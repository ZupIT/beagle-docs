[{"body":" What is Beagle? Beagle is an open source framework of cross-platform development based on the implementation paradigm of Server-Driven UI.\nThe main gain Beagle gives you is to allow teams to make layout and data changes directly in native mobile or web applications by changing the code on backend.  In this way, it‚Äôs possible to create, test and quickly update native application‚Äôs components without need to approve this changes on the store (App Store or Play Store).\nVersioning Beagle‚Äôs version follow the semantic versioning concept. The documentation is versioned according to the major Beagle version, meaning the main version. Between platforms, the features compatibility is by the minor version. For example, it is possible to use 1.0.0 in the backend with 1.0.1 on Android, 1.0.2 on iOS and 1.0.3 on the web react.\nBeagle‚Äôs current releases version are:\n Android: iOS: WEB:  Angular: React:   Backend   Some definitions on this documentation exists only only in some specific minors or patches. See the captions used to denote these cases:\n x.y.z: an exclusive definition of the version x.y.z; \u003e=x.y.z: existing definition from x.y.z version; \u003c=x.y.z: existing definition until the x.y.z version.  How does Beagle works? The tool works as a facilitator of BFF (Backend For Frontend). This means that Beagle, from a library of components defined in the Design System of the Android, iOS or Web application, makes the visual and behavioral change of them by returning a JSON file that indicates what and where each component should be rendered and which the action they are going to perform.\nThe reason Beagle is able to make this change from the frontend from the backend is because its architecture is structured in Server-Driven UI, where BFF constructs the data, components and actions present on the screen declaratively and forwards them in JSON format , while the front deserializes it, renders the visual components natively in addition to executing and assigning the actions present in each of them.\nBeagle‚Äôs Pillars Considering that it‚Äôs a tool based on Server-Driven, the JSON objects configured to run your application can be organized in 3 basic pillars:\n Content Visual Structure Flow (or Actions)  After defining in the frontend and backend how the visual structure of the application will be with the customized components and actions, as well as how they can be changed, the BFF will be able to communicate with the front.\nIn this way, new features, flows, customizations and combinations of visual components can be tested without the need to publish updates to the application, optimizing type A / B tests.\nWhy use Beagle? Beagle was created to optimize time and resources for development‚Äôs, design‚Äôs and business' teams to publish and keep updated their applications without need to approve it on App Store or Play Store and, also, respecting the application‚Äôs design system.  The main advantages of using Beagle on your project are:\n More flexibility at work, specially among developers and UI/UX designers when it‚Äôs necessary to make pontual changes. Easy app maintenance which enables to make constant tests to improve your application. Minor risks of duplicate code because all consumption of APIs, flows and rules will be in one place, BFF.  Another fundamental gain is that Beagle allows you to reduce user‚Äôs feedback time, once that the changes are quickly done, tested and validated.\n","excerpt":" What is Beagle? Beagle is an open source framework of cross-platform ‚Ä¶","ref":"/docs-beagle/","title":"Overview"},{"body":" What is Beagle? Beagle is an open source framework of cross-platform development based on the implementation paradigm of Server-Driven UI.\nThe main gain Beagle gives you is to allow teams to make layout and data changes directly in native mobile or web applications by changing the code on backend.  In this way, it‚Äôs possible to create, test and quickly update native application‚Äôs components without need to approve this changes on the store (App Store or Play Store).\nVersioning Beagle‚Äôs version follow the semantic versioning concept. The documentation is versioned according to the major Beagle version, meaning the main version. Between platforms, the features compatibility is by the minor version. For example, it is possible to use 1.0.0 in the backend with 1.0.1 on Android, 1.0.2 on iOS and 1.0.3 on the web react.\nBeagle‚Äôs current releases version are:\n Android: iOS: WEB:  Angular: React:   Backend   Some definitions on this documentation exists only only in some specific minors or patches. See the captions used to denote these cases:\n x.y.z: an exclusive definition of the version x.y.z; \u003e=x.y.z: existing definition from x.y.z version; \u003c=x.y.z: existing definition until the x.y.z version.  How does Beagle works? The tool works as a facilitator of BFF (Backend For Frontend). This means that Beagle, from a library of components defined in the Design System of the Android, iOS or Web application, makes the visual and behavioral change of them by returning a JSON file that indicates what and where each component should be rendered and which the action they are going to perform.\nThe reason Beagle is able to make this change from the frontend from the backend is because its architecture is structured in Server-Driven UI, where BFF constructs the data, components and actions present on the screen declaratively and forwards them in JSON format , while the front deserializes it, renders the visual components natively in addition to executing and assigning the actions present in each of them.\nBeagle‚Äôs Pillars Considering that it‚Äôs a tool based on Server-Driven, the JSON objects configured to run your application can be organized in 3 basic pillars:\n Content Visual Structure Flow (or Actions)  After defining in the frontend and backend how the visual structure of the application will be with the customized components and actions, as well as how they can be changed, the BFF will be able to communicate with the front.\nIn this way, new features, flows, customizations and combinations of visual components can be tested without the need to publish updates to the application, optimizing type A / B tests.\nWhy use Beagle? Beagle was created to optimize time and resources for development‚Äôs, design‚Äôs and business' teams to publish and keep updated their applications without need to approve it on App Store or Play Store and, also, respecting the application‚Äôs design system.  The main advantages of using Beagle on your project are:\n More flexibility at work, specially among developers and UI/UX designers when it‚Äôs necessary to make pontual changes. Easy app maintenance which enables to make constant tests to improve your application. Minor risks of duplicate code because all consumption of APIs, flows and rules will be in one place, BFF.  Another fundamental gain is that Beagle allows you to reduce user‚Äôs feedback time, once that the changes are quickly done, tested and validated.\n","excerpt":" What is Beagle? Beagle is an open source framework of cross-platform ‚Ä¶","ref":"/docs-beagle/docs/overview/","title":"Overview"},{"body":" O que √© o Beagle? O Beagle √© um framework open source de desenvolvimento cross-platform pautado no paradigma de implementa√ß√£o de Server-Driven UI.\nO principal ganho da ferramenta √© permitir que as equipes fa√ßam altera√ß√µes de layout e de dados direto em aplica√ß√µes nativas mobile e/ou web modificando apenas o c√≥digo no backend.  Dessa forma, √© poss√≠vel criar, testar e atualizar rapidamente os componentes de aplica√ß√µes nativas sem a necessidade de passar pela loja (App Store ou Play Store).\nVersionamento  As vers√µes do Beagle seguem o conceito de versionamento sem√¢ntico. A documenta√ß√£o, em si, √© versionada de acordo com a vers√£o major (maior) do Beagle, ou seja, com a vers√£o principal. Entre as plataformas, a compatibilidade de features √© pela vers√£o minor. Por exemplo, √© poss√≠vel usar a 1.0.0 no backend com a 1.0.1 no Android, a 1.0.2 no iOS e a 1.0.3 no web react.\nAs vers√µes de release atuais do Beagle s√£o:\n Android: iOS: WEB:  Angular: React:   Backend:   Algumas defini√ß√µes nessa documenta√ß√£o existem apenas em algumas minors ou patches espec√≠ficas. Segue a legenda usada para denotar esses casos:\n x.y.z: designa uma defini√ß√£o exclusiva da vers√£o x.y.z; \u003e=x.y.z: designa uma defini√ß√£o existente a partir da vers√£o x.y.z; \u003c=x.y.z: designa uma defini√ß√£o existente at√© a vers√£o x.y.z.  Como funciona o Beagle? A ferramenta atua como um facilitador do BFF (Backend For Frontend). Isso significa que o Beagle, a partir de uma biblioteca de componentes definidos no Design System da aplica√ß√£o Android, iOS ou Web, faz a altera√ß√£o visual e comportamental delas ao retornar um arquivo JSON que indica o que e onde deve ser renderizado cada componente e qual a a√ß√£o que v√£o executar.\nO motivo pelo qual o Beagle consegue fazer essa altera√ß√£o do frontend a partir do backend √© porque sua arquitetura est√° estruturada em Server-Driven UI, onde o BFF constr√≥i os dados, componentes e a√ß√µes presentes na tela de forma declarativa e os encaminha no formato JSON, enquanto o front o desserializa, renderiza os componentes visuais de forma nativa al√©m de executar e atribuir as a√ß√µes presentes em cada um deles.\nPilares do Beagle Por se tratar de uma ferramenta pautada em Server-Driven UI, os objetos JSON configurados para rodar na sua aplica√ß√£o podem ser divididos em 3 pilares b√°sicos:\n Conte√∫do Estrutura Visual Flow (ou A√ß√µes)  Depois de definido no frontend e no backend como ser√° a estrutura visual da aplica√ß√£o com os componentes e a√ß√µes customizados, bem como como eles poder√£o ser alterados, o BFF estar√° apto a se comunicar com o front.\nDessa forma, novas features, fluxos, customiza√ß√µes e combina√ß√µes de componentes visuais podem ser testados sem a necessidade de publicar atualiza√ß√µes no aplicativo, otimizando testes de tipo A/B.\nPor que usar o Beagle? O Beagle foi criado com objetivo de otimizar tempo e recurso das equipes de desenvolvimento, design e neg√≥cios para publicar e manter atualizados seus aplicativos sem a necessidade de passar por App Store ou Play Store e, ainda assim, respeitar o Design System da aplica√ß√£o.  Sendo assim, as principais vantagens que o Beagle traz para seu projeto s√£o:\n Maior flexibilidade de trabalho entre desenvolvedores frontend, backend e UI/UX designers no momento de realizar altera√ß√µes pontuais. Facilidade de manuten√ß√£o do app, al√©m de possibilitar a realiza√ß√£o constante de testes para melhoria da sua aplica√ß√£o. Menos duplica√ß√£o de c√≥digos, pois todo o consumo das APIs, fluxos e regras estar√£o em um √∫nico lugar, o BFF.  Outro ganho fundamental que o Beagle traz, √© a possibilidade de reduzir o tempo de feedback do usu√°rio, j√° que as mudan√ßas s√£o rapidamente testadas e validadas.\n","excerpt":" O que √© o Beagle? O Beagle √© um framework open source de ‚Ä¶","ref":"/docs-beagle/pt/","title":"Vis√£o geral"},{"body":" O que √© o Beagle? O Beagle √© um framework open source de desenvolvimento cross-platform pautado no paradigma de implementa√ß√£o de Server-Driven UI.\nO principal ganho da ferramenta √© permitir que as equipes fa√ßam altera√ß√µes de layout e de dados direto em aplica√ß√µes nativas mobile e/ou web modificando apenas o c√≥digo no backend.  Dessa forma, √© poss√≠vel criar, testar e atualizar rapidamente os componentes de aplica√ß√µes nativas sem a necessidade de passar pela loja (App Store ou Play Store).\nVersionamento  As vers√µes do Beagle seguem o conceito de versionamento sem√¢ntico. A documenta√ß√£o, em si, √© versionada de acordo com a vers√£o major (maior) do Beagle, ou seja, com a vers√£o principal. Entre as plataformas, a compatibilidade de features √© pela vers√£o minor. Por exemplo, √© poss√≠vel usar a 1.0.0 no backend com a 1.0.1 no Android, a 1.0.2 no iOS e a 1.0.3 no web react.\nAs vers√µes de release atuais do Beagle s√£o:\n Android: iOS: WEB:  Angular: React:   Backend   Algumas defini√ß√µes nessa documenta√ß√£o existem apenas em algumas minors ou patches espec√≠ficas. Segue a legenda usada para denotar esses casos:\n x.y.z: designa uma defini√ß√£o exclusiva da vers√£o x.y.z; \u003e=x.y.z: designa uma defini√ß√£o existente a partir da vers√£o x.y.z; \u003c=x.y.z: designa uma defini√ß√£o existente at√© a vers√£o x.y.z.  Como funciona o Beagle? A ferramenta atua como um facilitador do BFF (Backend For Frontend) Isso significa que o Beagle, a partir de uma biblioteca de componentes definidos no Design System da aplica√ß√£o Android, iOS ou Web, faz a altera√ß√£o visual e comportamental delas ao retornar um arquivo JSON que indica o que e onde deve ser renderizado cada componente e qual a a√ß√£o que v√£o executar.\nO motivo pelo qual o Beagle consegue fazer essa altera√ß√£o do frontend a partir do backend √© porque sua arquitetura est√° estruturada em Server-Driven UI, onde o BFF constr√≥i os dados, componentes e a√ß√µes presentes na tela de forma declarativa e os encaminha no formato JSON, enquanto o front o desserializa, renderiza os componentes visuais de forma nativa al√©m de executar e atribuir as a√ß√µes presentes em cada um deles.\nPilares do Beagle Por se tratar de uma ferramenta pautada em Server-Driven UI, os objetos JSON configurados para rodar na sua aplica√ß√£o podem ser divididos em 3 pilares b√°sicos:\n Conte√∫do Estrutura Visual Flow (ou A√ß√µes)  Depois de definido no frontend e no backend como ser√° a estrutura visual da aplica√ß√£o com os componentes e a√ß√µes customizados, bem como como eles poder√£o ser alterados, o BFF estar√° apto a se comunicar com o front.\nDessa forma, novas features, fluxos, customiza√ß√µes e combina√ß√µes de componentes visuais podem ser testados sem a necessidade de publicar atualiza√ß√µes no aplicativo, otimizando testes de tipo A/B.\nPor que usar o Beagle? O Beagle foi criado com objetivo de otimizar tempo e recurso das equipes de desenvolvimento, design e neg√≥cios para publicar e manter atualizados seus aplicativos sem a necessidade de passar por App Store ou Play Store e, ainda assim, respeitar o Design System da aplica√ß√£o.  Sendo assim, as principais vantagens que o Beagle traz para seu projeto s√£o:\n Maior flexibilidade de trabalho entre desenvolvedores frontend, backend e UI/UX designers no momento de realizar altera√ß√µes pontuais. Facilidade de manuten√ß√£o do app, al√©m de possibilitar a realiza√ß√£o constante de testes para melhoria da sua aplica√ß√£o. Menos duplica√ß√£o de c√≥digos, pois todo o consumo das APIs, fluxos e regras estar√£o em um √∫nico lugar, o BFF.  Outro ganho fundamental que o Beagle traz, √© a possibilidade de reduzir o tempo de feedback do usu√°rio, j√° que as mudan√ßas s√£o rapidamente testadas e validadas.\n","excerpt":" O que √© o Beagle? O Beagle √© um framework open source de ‚Ä¶","ref":"/docs-beagle/pt/docs/vis%C3%A3o-geral/","title":"Vis√£o geral"},{"body":" Backend For Frontend Also known as BFF, it is the server that makes it possible to send JSON objects to be rendered and, consequently, viewed on the frontend. This component allows screens and business rules to be written only once and then to be rendered natively on each platform where Beagle is present. The consumption of the APIs that provide the data for the application before executed by the fronts, is now the responsibility of BFF.\nDeclarative Views Paradigm in which layouts are built in a simplified way, since, the focus is on what the layout should be, letting Beagle solve its configuration. These declarative layouts are built using widgets both on BFF and Android written in Kotlin and on iOS in Swift.\nDesign System It is the structure that contains all the standard components and properties for a product or service. In development, it is essential that the Design System repository keep component styles, resources and themes of that application in one place.\nIn order for Beagle to work with the Design System of your application, it is necessary to have all of these styles implemented so that they can be viewed the moment the files are rendered.\nLayout Engine Tool that takes care of rendering the native visual elements of an application. When Beagle deserializes the information contained in JSON, the layout engine comes into play by rendering the components generated based on the Design System of the application. Beagle uses Yoga Layout to natively render components on Android and iOS platforms and build their respective layouts using Flexbox concepts.\nServer-Driven UI It is the concept in which a specific backend (BFF) consumes the application data and supplies it to the frontend together with their respective visual structures through one or more JSONs, that is, it not only informs the content of the screen, but also its structure , in addition to the flow of these pages if any.\n","excerpt":" Backend For Frontend Also known as BFF, it is the server that makes ‚Ä¶","ref":"/docs-beagle/docs/key-concepts/","title":"Key concepts"},{"body":" Backend For Frontend Conhecido tamb√©m como BFF, √© o servidor que possibilita enviar objetos JSON para serem renderizados e, consequentemente, visualizados no frontend. Este componente permite que telas e regras de neg√≥cio sejam escritas uma √∫nica vez para, em seguida, serem renderizadas de forma nativa em cada plataforma onde o Beagle est√° presente. O consumo das APIs que proveem os dados para a aplica√ß√£o antes executado pelos fronts, agora √© de responsabilidade do BFF.\nDeclarative Views Paradigma no qual os layouts s√£o constru√≠dos de forma simplificada, uma vez que, o foco est√° no qu√™ o layout deve ser, deixando o Beagle resolver sua configura√ß√£o. Esses layouts declarativos s√£o constru√≠dos usando widgets tanto no BFF e Android escritos em Kotlin e no iOS em Swift.\nDesign System √â a estrutura que cont√©m todos os componentes e propriedades padr√£o para um produto ou servi√ßo. No desenvolvimento, √© essencial que o reposit√≥rio Design System mantenha em um s√≥ lugar estilos de componentes, resources e temas daquela aplica√ß√£o.\nPara que o Beagle possa trabalhar com o design system da sua aplica√ß√£o, √© necess√°rio ter todos esses estilos implementados para que eles possam ser visualizados no momento em que os arquivos forem renderizados.\nLayout Engine Ferramenta que cuida da renderiza√ß√£o dos elementos visuais nativos de uma aplica√ß√£o. Quando o Beagle desserializa as informa√ß√µes contidas no JSON, o layout engine entra em a√ß√£o renderizando os componentes gerados com base no Design System da aplica√ß√£o. O Beagle usa oYoga Layout para renderizar nativamente os componentes nas plataformas Android e iOS e construir seus respectivos layouts atrav√©s dos conceitos do Flexbox.\nServer-Driven UI √â o conceito no qual um backend espec√≠fico (BFF) consome os dados da aplica√ß√£o e os fornece ao frontend junto com suas respectivas estruturas visuais atrav√©s de um ou mais JSONs, ou seja, ele n√£o s√≥ informa o conte√∫do da tela, mas tamb√©m sua estrutura, al√©m do fluxo dessas p√°ginas se houver.\n","excerpt":" Backend For Frontend Conhecido tamb√©m como BFF, √© o servidor que ‚Ä¶","ref":"/docs-beagle/pt/docs/principais-conceitos/","title":"Principais conceitos"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/","title":"Docs"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/","title":"Docs"},{"body":" Para iniciar as configura√ß√µes do Beagle na sua m√°quina, siga os passos para cada sistema operacional. Aqui tamb√©m listamos as configura√ß√µes do backend, que ser√° o BFF:\n","excerpt":" Para iniciar as configura√ß√µes do Beagle na sua m√°quina, siga os ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/","title":"Instalando o Beagle"},{"body":" To start the Beagle‚Äôs configuration on your machine, follow the steps to each operational system. Here we also list the settings of the backend, which will be the BFF:\n","excerpt":" To start the Beagle‚Äôs configuration on your machine, follow the steps ‚Ä¶","ref":"/docs-beagle/docs/get-started/installing-beagle/","title":"Installing Beagle"},{"body":" Requirements Before you start to configure Beagle for your Android system, it‚Äôs important to check out if you have installed all the current versions of the following programs: ‚Äå\n JDK 8 language Android API level: at least 19 or higher Kotlin 1.3+  Step 1: Dependencies' configuration You have to adjust your repository‚Äôs dependencies to receive Beagle. To do so, use the following configurations to download library.\n// Add it in your root build.gradle at the end of repositories: allprojects { repositories { google() jcenter() // \u003c 1.1.0  maven { url 'https://dl.bintray.com/zupit/repo'  } // \u003e= 1.1.0  mavenCentral() } }  The above configuration must be added toallprojects{}  Step 2: Include plugins Once you made the first configuration, now you have to include the kapt and Beagle‚Äôs plugin as dependencies on your dependency manager.\nThe current release version of Beagle is\n// Add in your plugins apply plugin: 'kotlin-kapt'‚Äã android { kotlinOptions { jvmTarget = JavaVersion.VERSION_1_8 } } // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" Insert the Beagle‚Äôs release version on the place of${beagle.version}, in other words, put the Beagle‚Äôs version highlighted in blue badge above without the v character.\nFor example: undefined-ext.beagle.version = \"0.2.8\"\nRemember to always check if you‚Äôre using the latest version of Beagle. To see this information, you just have to pass your mouse above the version number. After that, sync your machine.  Next Steps On this section, you made Beagle‚Äôs initial installation on your application!\nTo keep configuring Beagle:\nüëâGo toinitial configurations to enable the use of Beagle on your Android project.\nüëâ If you want to go straight to practice, access our tutorial to create a project from zero.\n","excerpt":" Requirements Before you start to configure Beagle for your Android ‚Ä¶","ref":"/docs-beagle/docs/get-started/installing-beagle/android/","title":"Android"},{"body":" Requisitos Antes de configurar o Beagle para o seu sistema Android, √© importante que voc√™ confirme as vers√µes dos programas que est√£o instalados na sua m√°quina. Para a ferramenta funcionar, √© necess√°rio ter as seguintes vers√µes: ‚Äå\n JDK 8 language Android API level: pelo menos a 19 ou superior Kotlin 1.3+  Passo 1: Configurar as depend√™ncias Voc√™ precisa ajustar as depend√™ncias do seu reposit√≥rio para receber o Beagle. Para isso, utilize as configura√ß√µes abaixo para fazer o download da biblioteca.\n// Add it in your root build.gradle at the end of repositories: allprojects { repositories { google() jcenter() // \u003c 1.1.0  maven { url 'https://dl.bintray.com/zupit/repo'  } // \u003e= 1.1.0  mavenCentral() } }  A configura√ß√£o acima deve ser adicionada emallprojects{}  Passo 2: Incluir os plugins Uma vez feita a primeira configura√ß√£o, agora voc√™ precisa incluir o plugin do kapt e do Beagle como depend√™ncias dentro do seu gerenciador de depend√™ncias.\nA vers√£o atual do Beagle\n// Add in your plugins apply plugin: 'kotlin-kapt' android { kotlinOptions { jvmTarget = JavaVersion.VERSION_1_8 } } // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" } Insira a vers√£o de release do Beagle no lugar de ${beagle.version}, ou seja, coloque a vers√£o do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os n√∫meros de vers√£o.\nPor exemplo: undefined-ext.beagle.version = \"0.2.8\"\nLembre de sempre verificar se voc√™ est√° usando a vers√£o mais recente do Beagle. Para saber disso, basta passar o mouse por cima do n√∫mero da vers√£o. Depois disso, sincronize com sua m√°quina.  Pr√≥ximos Passos Nesta se√ß√£o, voc√™ fez a instala√ß√£o inicial do Beagle na sua aplica√ß√£o!\nPara continuar a configurar o Beagle:\nüëâV√° para as configura√ß√µes iniciais para habilitar uso do Beagle no seu projeto Android\nüëâ Se quiser ir direto para pr√°tica, acesse nosso tutorial para criar um projeto do zero\n","excerpt":" Requisitos Antes de configurar o Beagle para o seu sistema Android, √© ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/android/","title":"Android"},{"body":" Requirements Before you start to configure Beagle for your iOS system, it‚Äôs important to check out if you have installed all the current versions of the following programs: ‚Äå\n iOS 10.0+ Xcode 11.0+ Swift 5.0+  Dependencies' Management Currently, Beagle is available for integrations through Carthage and CocoaPods.\nRemember to always check if you‚Äôre using the latest version of Beagle and, mostly, check if the different platforms you‚Äôre using are integrated to the same Beagle‚Äôs version. In this way, you ensure that all the tools are correctly communicating with each other.  Installation with CocoaPods To integrate Beagle with your application through CocoaPods, you have to add the framework as a dependency of your Podfile.\nCurrent Beagle‚Äôs version**:**\nThis process must be done in the following way:\npod 'Beagle' pod 'YogaKit', :git =\u003e 'https://github.com/ZupIT/YogaKit'  In the case of YogaKit, you must use our fork because some changes are not merged yer at Facebook‚Äôs repository.  Installation with Carthage Step 1: Integrate with your application To integrate Beagle with your application through Carthage, you have to add the framework as a dependency on your Cartfile.\nThis process must be done in the following way:\ngithub \"ZupIT/beagle\" ~\u003e 1.0.1  After an important release, we‚Äôll probably lauch versions with specific bug fixes for iOS, in which will have a version tag followed the sufix ‚Äú-iOS‚Äù (e.g: ‚Äú1.0.1-iOS‚Äù).  Step 2: Build on dependencies After the integration, you must follow the normal process of building with Carthage on your dependencies. The expected is that you receive some .framework files.\nIn Beagle‚Äôs case, the mandatory files to make you application work are:\n Beagle.framework BeagleSchema.framework YogaKit.framework  Other frameworks can be used only in more specific scenarios.\nNext Steps On this section, you made Beagle‚Äôs initial installation on your application!\nTo keep configuring Beagle:\nüëâTo keep knowing Beagle and test if everything worked with the installation, go to initial configurations and create your first Hello World!\nüëâ If you want to go straight to practice, access our tutorial to create a project from zero.\n","excerpt":" Requirements Before you start to configure Beagle for your iOS ‚Ä¶","ref":"/docs-beagle/docs/get-started/installing-beagle/ios/","title":"IOS"},{"body":" Requisitos Antes de configurar o Beagle para o seu sistema iOS, √© importante que voc√™ confirme as vers√µes dos programas que est√£o instalados na sua m√°quina. Para o Beagle funcionar, √© necess√°rio ter as seguintes vers√µes:\n iOS 10.0+ Xcode 11.0+ Swift 5.0+  Gerenciamento de depend√™ncias Hoje o Beagle est√° dispon√≠vel para integra√ß√£o atrav√©s do Carthage e CocoaPods\nLembre de sempre usar a vers√£o mais recente do Beagle e, principalmente, de checar se as diferentes plataformas est√£o integradas √† essa mesma vers√£o. Dessa forma, voc√™ garante que todas as ferramentas est√£o se comunicando corretamente.  Instala√ß√£o com CocoaPods Para integrar o Beagle √† sua aplica√ß√£o atrav√©s do CocoaPods voc√™ precisa adicionar o framework como depend√™ncia no seu Podfile.\nVers√£o atual do Beagle:\nEste processo pode ser feito da seguinte maneira:\npod 'Beagle' pod 'YogaKit', :git =\u003e 'https://github.com/ZupIT/YogaKit'  No caso do YogaKit, voc√™ precisa utilizar o nosso fork porque algumas modifica√ß√µes ainda n√£o foram mergeadas no reposit√≥rio do Facebook.  Instala√ß√£o com Carthage Passo 1: Integrar com sua aplica√ß√£o Para integrar o Beagle √† sua aplica√ß√£o atrav√©s do Carthage voc√™ precisa adicinar o framework como depend√™ncia no seu Cartfile.\nO processo pode ser feito da seguinte maneira:\ngithub \"ZupIT/beagle\" ~\u003e 1.0.1-iOS  Depois de uma release importante, podemos lan√ßar algumas vers√µes com bug fixes espec√≠ficas para o iOS, as quais estar√£o com a tag da vers√£o seguida com o sufixo ‚Äú-iOS‚Äù (e.g: ‚Äú1.0.1-iOS‚Äù).  Passo 2: Build nas depend√™ncias Depois de integrado, voc√™ deve seguir com o processo normal de build do Carthage nas suas depend√™ncias. O esperado √© que voc√™ receba alguns arquivos .framework como resultado.\nNo caso do Beagle, os arquivos obrigat√≥rios para que a sua aplica√ß√£o funcione s√£o:\n Beagle.framework BeagleSchema.framework YogaKit.framework  Outros frameworks s√£o utilizados apenas em cen√°rios de uso mais espec√≠ficos.\nPr√≥ximos Passos Nesta se√ß√£o, voc√™ fez a instala√ß√£o inicial do Beagle na sua aplica√ß√£o!\nPara continuar a configurar o Beagle:\nüëâPara continuar conhecendo o Beagle, e testar se deu tudo certo com a instala√ß√£o, v√° para as configura√ß√µes iniciais e crie seu primeiro Hello Beagle!\nüëâ Se quiser ir direto para pr√°tica, acesse nossotutorial para criar um projeto do zero\n","excerpt":" Requisitos Antes de configurar o Beagle para o seu sistema iOS, √© ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/ios/","title":"IOS"},{"body":" Introduction Unlike mobile application‚Äôs configurations, to install Beagle for Web does not demand previous requirements. You just have to follow the steps of Beagle‚Äôs framework installation according to the framework you use on your projects:\n Angular  React   Angular Beagle Angular‚Äôs current**:**\nStep 1: Install Beagle‚Äôs library To follow the installation process, navigate to the root of your angular project and run one of the commands below according to the package manager of your preference.\nIf you useYarn:\nyarn add @zup-it/beagle-angular If you use npm:\nnpm install --save @zup-it/beagle-angular Step 2: Verify the installation To confirm if the process worked, you simply have to use one of the commands below:\nyarn beagle help npx beagle help If the Beagle‚Äôs commands were listed as in the image below, that means that the installation worked correctly.\nWell done! Your library was installed. Now, you can see more of how to use Beagle on Angular.  React Beagle React‚Äôs current version**:**\nStep 1: Install Beagle‚Äôs library To follow the installation process, navigate to the root of your react project and run one of the commands below according to the package manager of your preference.\nIf you useYarn:\nyarn add @zup-it/beagle-react If you use npm:\nnpm install --save @zup-it/beagle-react  Well done! Your library was installed. Now, you can see more of how to use Beagle on React.  Next Steps On this section, you made Beagle‚Äôs initial installation on your application!\nTo keep configuring Beagle:\nüëâGo to initial configurations to enable the use of Beagle on your Web project.\nüëâ If you want to go straight to practice, access our tutorial to create a projeto from zero.\n","excerpt":" Introduction Unlike mobile application‚Äôs configurations, to install ‚Ä¶","ref":"/docs-beagle/docs/get-started/installing-beagle/web/","title":"WEB"},{"body":" Introdu√ß√£o Ao contr√°rio das configura√ß√µes para aplica√ß√µes mobile, o Beagle para Web n√£o exige requisitos pr√©vios. Basta apenas seguir com os procedimentos de instala√ß√£o de acordo com o framework que estiver utilizando:\n Angular  React   Angular Vers√£o atual do Beagle Angular:\nPasso 1: Instalar a biblioteca Beagle Para seguir com o processo de instala√ß√£o, navegue at√© a raiz do seu projeto angular e execute um dos comandos abaixo de acordo com o gerenciador de pacotes de sua prefer√™ncia.\nCaso utilize oYarn:\nyarn add @zup-it/beagle-angular Caso utilize o npm:\nnpm install --save @zup-it/beagle-angular Passo 2: Verificar a instala√ß√£o Para confirmar se o processo funcionou, basta executar um dos comandos abaixo:\nyarn beagle help npx beagle help Se os comandos do Beagle forem listados como na imagem abaixo, isso significa que a instala√ß√£o ocorreu corretamente.\nParab√©ns, a sua biblioteca est√° instalada! Veja agora como usar o Beagle no Angular  React Vers√£o atual do Beagle React:\nPasso 1: Instalando a biblioteca Beagle Para seguir com o processo de instala√ß√£o, navegue at√© a raiz do seu projeto e execute um dos comandos abaixo de acordo com o gerenciador de pacotes de sua prefer√™ncia.\nCaso utilize oYarn:\nyarn add @zup-it/beagle-react Caso utilize o npm:\nnpm install --save @zup-it/beagle-react  Parab√©ns, a sua biblioteca est√° instalada! Veja agora como usar Beagle no React.  Pr√≥ximos Passos Nesta se√ß√£o, voc√™ fez a instala√ß√£o inicial do Beagle na sua aplica√ß√£o!\nPara continuar a configurar o Beagle:\nüëâV√° para as configura√ß√µes iniciais para habilitar uso do Beagle no seu projeto Web\nüëâ Se quiser ir direto para pr√°tica, acesse nossotutorial para criar um projeto do zero\n","excerpt":" Introdu√ß√£o Ao contr√°rio das configura√ß√µes para aplica√ß√µes mobile, o ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/web/","title":"WEB"},{"body":" Before you get started, you must know that the steps below are for JVM languages.\nFor other languages, your server needs to serve JSON following our API. Also, check out our cache and platform specification mechanisms, which you may wish to implement as the clients already support them.\n Requirements Before you integrate Beagle to your application to run it on the backend, it‚Äôs important to check out if you have installed all the current versions of the following programs:\n JDK 8+ language (Kotlin 1.3+ is recommended) Maven 3+ Jackson 2+  If you already have updated all the programs above, then just go to the following instructions.\nInstallation Step 1: Create a micro-service When you create a micro-service, we recommend using your team‚Äôs established mechanisms. If that‚Äôs not your case, you can just follow the configurations below.\nIf your team works with micro-services using a framework other than Spring or Micronaut, see Beagle Framework instead.  For a simple setup, you can choose between 2 frameworks to create your BFF:\nMicronaut  A modern, JVM-based, full-stack framework for building modular, easily testable micro-service and serverless applications.\n Spring  Spring makes programming Java quicker, easier, and safer for everybody. Spring‚Äôs focus on speed, simplicity, and productivity has made it the world‚Äôs most popular Java framework.\n Once you choose the framework you‚Äôll work with, proceed with the configurations below:\nMicronaut Spring Creating a micro-service Micronaut \u003c= 1.3 As described on Micronaut‚Äôs quick start, create your application through a CLI tool with this command:\n$ mn create app bff --build maven --lang kotlin This will create an executable Micronaut project using Kotlin and Maven in a directory called bff. Open this project on the chosen IDE and follow the following steps to set the dependencies.\nMicronaut \u003e= 2.0 If you want to use Micronaut 2.0, you can use the new website, very similar to Spring.\n Click on the link below to download a zip file of the project with the image‚Äôs option below: Micronaut Launch para Beagle Micronaut Starter.   This configuration uses:  Kotlin with Maven forJava 8 (compatible with this version); Junit like the unit tests library.   Unzip the file and open the extracted folder in your IDE.   Create a micro-service Use Spring‚Äôs Initializr to create a project for your micro-service. Click the following link, Spring Initializr for Beagle Spring Starter, to get recommended settings.\n These settings are:  Maven dependency manager; Kotlin with JAR packaging and Java 8+ compatibility; Spring Boot Actuator dependency.   Click GENERATE to download a zip file containing your project. Unzip the file and open the extracted folder in your IDE.   Step 2: Configure dependencies (\u003c 1.1.0) Once you created and configured the micro-services, you have to add the address of our nexus. To do so, add the following to your pom.xml, found in the root of the generated project:\n\u003crepositories\u003e \u003crepository\u003e \u003cid\u003ebintray-zupit-repo\u003c/id\u003e \u003curl\u003ehttps://dl.bintray.com/zupit/repo\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e Step 3: Include starter dependency Lastly, you have to add the dependency for the Beagle starter to your backend. In that case, the framework you chose will define the dependency‚Äôs name (artifactId) should be done.\nClick on the tab of the framework you‚Äôre using and follow the steps to continue the configuration.\nMicronaut Starter Spring Starter Additional Requirements: This starter also configures version 1.3.3 of**micronaut-runtime**module in your BFF\n To follow this requirement, you just have to add the dependency below to your pom.xml.\n The current release version of Beagle is:   \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003ebeagle-micronaut-starter\u003c/artifactId\u003e \u003cversion\u003e${beagle.version}\u003c/version\u003e \u003c/dependency\u003e  Additional Requirements: This starter also configures version 2.2.5 of**spring-boot-starter-web**module in your BFF\n To follow this requirement, you just have to add the dependency below to your pom.xml.\n To check which Beagle‚Äôs version is:  \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003ebeagle-spring-starter\u003c/artifactId\u003e \u003cversion\u003e${beagle_version}\u003c/version\u003e \u003c/dependency\u003e Insert the Beagle‚Äôs release version on the place of${beagle.version}, in other words, put the Beagle‚Äôs version highlighted in blue badge above without the v character.\nFor example:\n-ext.beagle.version = \"0.2.8\"\nRemember to always check if you‚Äôre using the latest version of Beagle. To see this information, you just have to pass your mouse above the version number. After that, sync your machine.\n Well done, your initial configuration is ready to be used!\nYou can check a screen or server-driven componentto test the BFF.\nSpring Boot has a known problem involving WebMvcConfigurationSupport. Its presence replaces other configurations, including the ones in Beagle‚Äôs Spring Starter.\nIn case you face a similar problem, we suggest you replace it forWebMvcConfigurer.\nTo see more about it, access this issue on Github.\nThe annotation@EnableWebMvccauses the same problem, which means that you should replace it.\n  Well done, your initial configuration is ready to be used!  You can see more of how to use Beagle on the backend or how to test a BFF with server-driven components.\nNext Steps On this section, you made Beagle‚Äôs initial installation on your application!\nTo keep configuring Beagle:\nüëâGo to initial configurations to enable the use of Beagle on your Web project.\nüëâ If you want to go straight to practice, access our tutorial to create a projeto from zero.\n","excerpt":" Before you get started, you must know that the steps below are for ‚Ä¶","ref":"/docs-beagle/docs/get-started/installing-beagle/backend/","title":"Backend"},{"body":" Antes de iniciar a instala√ß√£o, √© importante voc√™ saber que as etapas abaixo s√£o para linguagens da JVM.\nPara outras linguagens, seu servidor precisa servir o JSON seguindo nossa API. D√™ uma olhada tamb√©m na nossa implementa√ß√£o de cache e em mecanismos espec√≠ficos de cada linguagem\n Requisitos Antes de integrar o Beagle √† sua aplica√ß√£o para rod√°-lo no backend, √© importante validar se sua m√°quina est√° com as vers√µes corretas instaladas dos seguintes softwares:\n JDK 8+ language (Kotlin 1.3+ √© recomendado) Maven 3+ Jackson 2+  Se voc√™ j√° tiver atualizado todos estes programas, basta seguir as instru√ß√µes abaixo.\nInstala√ß√£o Passo 1: Criar um microsservi√ßo No momento de criar o microsservi√ßo, recomendamos que voc√™ utilize os mesmos mecanismos estabelecidos. Caso este n√£o seja o seu caso, ent√£o basta seguir as configura√ß√µes abaixo.\nSe o seu time trabalha com microsservi√ßos usando outros frameworks, acesse o framework do Beagle.  Para uma configura√ß√£o simples, voc√™ pode escolher entre 2 modelos de frameworks para criar seu BFF:\nMicronaut   √â um framework full-stack moderno baseado em JVM para constru√ß√£o modular. F√°cil de testar em microsservi√ßos e com aplica√ß√µes sem servidor (serverless).\n Spring  √â um framework que permite programa√ß√£o em Java mais r√°pida, f√°cil e segura para todos. √â focada em velocidade, simplicidade e produtividade, o que o tornou o framework Java mais popular.\n Depois de selecionar com qual framework deseja seguir, prossiga com as configura√ß√µes abaixo:\nMicronaut Spring Criando um microsservi√ßo Micronaut \u003c= 1.3 Conforme descrito no quickstart do Micronaut, crie seu aplicativo atrav√©s da ferramenta de CLI com o seguinte comando:\n$ mn create-app bff --build maven --lang kotlin Isso criar√° um projeto Micronaut execut√°vel usando Kotlin e Mavenem um diret√≥rio chamado bff. Abra este projeto na IDE que escolher e siga o passo 2 para configurar as depend√™ncias.\nMicronaut \u003e= 2.0 Caso queira adotar o Micronaut 2.0, pode usar o novo site de constru√ß√£o de projeto, semelhante ao do Spring.\n Clique no link a seguir para baixar um zip do projeto com as op√ß√µes da imagem abaixo: Micronaut Launch para Beagle Micronaut Starter.   Essa configura√ß√£o inicial utiliza:  Kotlin com Maven paraJava 8 (compat√≠vel com essa vers√£o); Junit como biblioteca de testes unit√°rios.   Descompacte o arquivo na pasta que escolher para conter seu projeto BFF e abra o seu projeto na IDE de sua prefer√™ncia.   Criando um microsservi√ßo Neste caso, usaremos o site do Spring para gerar um projeto com o microsservi√ßo j√° criado:\n Clique no link a seguir e voc√™ ver√° a p√°gina abaixo: Spring Initializer for Beagle Spring Starter   Essa configura√ß√£o inicial utiliza:  Kotlin com Maven; A ultima vers√£o do Spring Boot Actuator dependency; Empacotamento JAR e Java 8 (compat√≠vel com essa vers√£o).   Clique em GENERATE para fazer o download de um arquivo zip que cont√©m o projeto Spring Boot. Descompacte o arquivo na pasta que escolher para conter seu projeto BFF e abra o seu projeto na IDE de sua prefer√™ncia.   Passo 2: Configurar as depend√™ncias (\u003c 1.1.0) Uma vez criado e configurado os microsservi√ßos, voc√™ precisa adicionar o endere√ßo do nosso nexus. Para isso, basta adicionar o c√≥digo abaixo no seu arquivo pom.xml:\n\u003crepositories\u003e \u003crepository\u003e \u003cid\u003ebintray-zupit-repo\u003c/id\u003e \u003curl\u003ehttps://dl.bintray.com/zupit/repo\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e Passo 3: Incluir requerimentos adicionais Por √∫ltimo, voc√™ precisa complementar algumas configura√ß√µes em nosso backend. Neste caso, o framework que voc√™ tiver escolhido √© que ir√° definir como deve ser feita a implementa√ß√£o.\nClique na op√ß√£o de Framework que voc√™ escolheu anteriormente e siga os passos para continuar a configura√ß√£o.\nMicronaut Starter Spring Starter Requerimentos adicionais: Este starter configura a vers√£o do m√≥dulo micronaut-runtime com ele e utiliza a vers√£o Micronaut 2.0.0.\n Para seguir com esse requerimento, basta adicionar arquivo pom √† sua depend√™ncia.\n Vers√£o atual do Beagle:  \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003ebeagle-micronaut-starter\u003c/artifactId\u003e \u003cversion\u003e${beagle.version}\u003c/version\u003e \u003c/dependency\u003e Insira a vers√£o de release do Beagle no lugar de ${beagle.version}. Ou seja, coloque a vers√£o do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os n√∫meros de vers√£o.\nPor exemplo: undefined-ext.beagle.version = \"0.2.8\"\nLembre de sempre verificar se voc√™ est√° usando a vers√£o mais recente do Beagle. Para saber disso, basta passar o mouse por cima do n√∫mero da vers√£o. Depois disso, sincronize com sua m√°quina.\n  Requerimentos adicionais: Este starter configura a vers√£o do m√≥dulo spring-boot-starter-web com ele e utiliza a vers√£o Spring Boot 2.3.1.\n Para seguir com esse requerimento, basta adicionar o arquivo pom √† sua depend√™ncia.\n Vers√£o atual do Beagle:  \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003ebeagle-spring-starter\u003c/artifactId\u003e \u003cversion\u003e${beagle_version}\u003c/version\u003e \u003c/dependency\u003e Insira a vers√£o de release do Beagle no lugar de ${beagle.version}. Ou seja, coloque a vers√£o do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os n√∫meros de vers√£o.\nPor exemplo:-ext.beagle.version = \"1.0.0\"\nLembre de sempre verificar se voc√™ est√° usando a vers√£o mais recente do Beagle. Para saber disso, basta passar o mouse por cima do n√∫mero da vers√£o. Depois disso, sincronize com sua m√°quina.\n Parab√©ns, a configura√ß√£o inicial est√° pronta para uso!\nVoc√™ pode conferir um exemplo pr√°tico de tela ou componente Server-Driven para testar o BFF\nO Spring Boot tem um problema conhecido envolvendo seu WebMvcConfigurationSupport. Sua presen√ßa substitui outras configura√ß√µes do Jackson, incluindo a do Spring Starter.\nCaso haja algum em seu projeto, sugerimos substitu√≠-lo porWebMvcConfigurer.\nPara mais detalhes, consulte esta issue no Github\nA anota√ß√£o @EnableWebMvc causa o mesmo problema, o que requer que ela tamb√©m seja removida.\n  Pronto, a configura√ß√£o inicial est√° pronta para uso!  Voc√™ pode conferir um exemplo pr√°tico de como testar o Beagle no Backend ou componente Server-Driven para testar o BFF.\nPr√≥ximos Passos Nesta se√ß√£o, voc√™ fez a instala√ß√£o inicial do Beagle na sua aplica√ß√£o!\nPara continuar a configurar o Beagle:\nüëâV√° para as configura√ß√µes iniciais para habilitar uso do Beagle no seu projeto Backend\nüëâ Se quiser ir direto para pr√°tica, acesse nosso tutorial para criar um projeto do zero\n","excerpt":" Antes de iniciar a instala√ß√£o, √© importante voc√™ saber que as etapas ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/backend/","title":"Backend"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/get-started/","title":"Get Started"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/primeiros-passos/","title":"Primeiros Passos"},{"body":" Depois de fazer a instala√ß√£o do Beagle, √© necess√°rio realizar as configura√ß√µes de uso para habilitar a ferramenta no seu projeto.\nVoc√™ pode configurar de acordo com a plataforma que estiver utilizando:\n","excerpt":" Depois de fazer a instala√ß√£o do Beagle, √© necess√°rio realizar as ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/","title":"Usando o Beagle"},{"body":" After you done Beagle‚Äôs installation, you have to make usage configuration to enable the tool on your project.\nYou can make this configuration based on the platform you wanna use:\n","excerpt":" After you done Beagle‚Äôs installation, you have to make usage ‚Ä¶","ref":"/docs-beagle/docs/get-started/using-beagle/","title":"Using Beagle"},{"body":" Usage configurations Once you have finished Beagle‚Äôs installation, you have to make now our tool‚Äôs usage configuration. To make this process easier, we‚Äôll use an example of how to render a ‚ÄúHello Beagle! screen with a small description.\nStep 1: Update Android Manifest In this step, you have to update your AndroidManifest and add two lines on this file:\n INTERNET‚Äôs permission so your application will be able to access internet. The attributeandroid:usesCleartextTraffic=\"true\" inside the \u003capplication\u003e tag for the local BFF communication.  For this example we will not be using a BFF, therefore this step is not necessary. However, for any and all tests that are done using Beagle Android with a BFF, this step is essential.  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication ... android:usesCleartextTraffic=\"true\" ...   The usesCleartextTraffic: Indicates with the app intends to use cleartext network traffic, HTTP. The default value for apps that target API level 27 or lower is ‚Äútrue‚Äù. Apps that target API level 28 or higher default to ‚Äúfalse‚Äù. The attribute android:usesCleartextTraffic=\"true\" inside \u003capplication\u003etag is used to communicate with the local BFF. If you intent to debug the project using a local BFF you can use this as an easy configuration step. Although, if you plan to turn this example into a release application, we recomend you using the networkSecurityConfig which you can configure using the android developers page instructions.   Step 2: Create a BeagleConfig class After the update, you have to create a BeagleConfig class and configure your attributes, as you can see on the example below:\n@BeagleComponent class AppBeagleConfig : BeagleConfig { override val environment: Environment get() = Environment.DEBUG override val baseUrl: String get() = \"https://myapp.server.com/\" override val isLoggingEnabled: Boolean = true override val cache: Cache = Cache( enabled = false, maxAge = 300, size = 15 ) }    Attribute Type Definition     isLoggingEnabled Boolean Attribute that enables or disables all logs that Beagle generates.   baseUrl String Informs the base URL used in Beagle in the application.\nIf you are using the emulator, check here to define this attribute.\n   environment Environment Attribute responsible for informing Beagle about the current build status of the application.   cache Cache Object responsible for managing the cache of Beagle requests.    Make sure to note your class configuration withBeagleComponent, because Beagle expect them to have empty constructors.  Step 3: BeagleActivitiy Beagle offers a default Activity to manage all activities that have been generated through server-driven. However, you can create one or more Activities that inherit from BeagleActivity with @BeagleComponent and are customized according to server-driven flows of your application.\nYou can create BeagleActivity now, but at his moment it is possible to proceed to the next step without configuring it. For more information about it, see Custom Beagle Activity.  Step 4: Initiate the Beagle and the Design System Now it‚Äôs the moment to initiate Beagle in your application‚Äôs class. However, before you start check out if the minimum version of your SDK is above 19, as in the example:\ndefaultConfig { minSdkVersion 19 //or higher }  You can set a Design System now, at this point it is not necessary, just proceed without configuring. But, if you wanna know more about it, check this section about Design System for Android.  Step 5: Create a BeagleSetup Now you have to initialize your Application ,so Beagle can generate other configurations file that you need. When you initialize Beagle for the first time, a BeagleSetup class will be automatically created as you can see in the image below:\nStep 6: Create the Application class At this moment, you should create a Kotlin class that extends to Application class. For this example, we‚Äôll name as AppApplication.\nThis class should be named as BeagleSetup().init(this) on onCreate method, according to the list below:\nclass AppApplication: Application() { companion object { var APPLICATION: Application? = null } override fun onCreate() { super.onCreate() APPLICATION = this BeagleSetup().init(APPLICATION!!) } }  When you create this class, press CTRL + F9 so Beagle‚Äôs generated classes are created.  Step 7: Update your Android Manifest.xml Finally, you must update again your AndroidManifest.xml and define the AppApplication we created as an application‚Äôs initialization file, as you can see in the example below:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication android:name=\".AppApplication\" .. Step 8: Manage logs You will create a class that implements BeagleLogger interface. This protocol must be defiened to ease the error management generated in the server-driven context of your application. And you must implement the methods the best way for your application. See the following example:\nprivate const val BEAGLE_TAG = \"BeagleSDK\" @BeagleComponent class BeagleLoggerDefault : BeagleLogger { override fun warning(message: String) { Log.w(BEAGLE_TAG, message) } override fun error(message: String) { Log.e(BEAGLE_TAG, message) } override fun error(message: String, throwable: Throwable) { Log.e(BEAGLE_TAG, message, throwable) } override fun info(message: String) { Log.i(BEAGLE_TAG, message) } } Step 9: Manage caches Here you will implement StoreHandler, it is a protocol that allows you to customize the way the cache is handled in the database and memory.\nFor that, you have to create two classes that will implement the LocalStore interface. This interface allows you to map the actions save, restore, delete and get all. See an example below:\ninternal object MemoryLocalStore : LocalStore { private val cache = mutableMapOf\u003cString, String\u003e() override fun save(key: String, value: String) { cache[key] = value } override fun restore(key: String): String? { return cache[key] } override fun delete(key: String) { cache.remove(key) } override fun getAll(): Map\u003cString, String\u003e { return cache.toMap() } } Now, you have to create a second class which depends on the StoreHandler creation, that it is a DatabaseLocalStore. See, this same file were declared some adjacent classes that work to this DatabaseLocalStore class, but it could be in different files, if you want. See the example:\ninternal object ScreenEntry : BaseColumns { const val TABLE_NAME = \"KeyValueCache\" const val KEY_COLUMN_NAME = \"key\" const val VALUE_COLUMN_NAME = \"value\" } internal class DatabaseLocalStore( private val contentValuesFactory: ContentValuesFactory = ContentValuesFactory(), private val database: SQLiteDatabase = BeagleDatabaseManager.getDatabase( BeagleUiSampleApplication.APPLICATION!!) ) : LocalStore { override fun save(key: String, value: String) { val values = contentValuesFactory.make().apply { put(ScreenEntry.KEY_COLUMN_NAME, key) put(ScreenEntry.VALUE_COLUMN_NAME, value) } val newRowId = database.insertWithOnConflict(ScreenEntry.TABLE_NAME, null, values, SQLiteDatabase.CONFLICT_REPLACE) if (newRowId == -1L) { BeagleMessageLogs.logDataNotInsertedOnDatabase(key, value) } } override fun restore(key: String): String? { return executeRestoreQueryForKey(key).use { cursor -\u003e if (cursor.count \u003e 0) { cursor.moveToFirst() cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.VALUE_COLUMN_NAME)) } else { null } } } override fun delete(key: String) { database.delete(ScreenEntry.TABLE_NAME, \"${ScreenEntry.KEY_COLUMN_NAME}=?\", arrayOf(key)) } override fun getAll(): Map\u003cString, String\u003e { val columnsToReturn = arrayOf(ScreenEntry.KEY_COLUMN_NAME, ScreenEntry.VALUE_COLUMN_NAME) val columnsForWhereClause = \"\" val valuesForWhereClause = arrayOf\u003cString\u003e() val cursor = database.query( ScreenEntry.TABLE_NAME, columnsToReturn, columnsForWhereClause, valuesForWhereClause, null, null, null ) val returnMap = mutableMapOf\u003cString, String\u003e() if (cursor.count \u003e 0) { cursor.moveToFirst() while (!cursor.isAfterLast) { returnMap[cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.KEY_COLUMN_NAME))] = cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.VALUE_COLUMN_NAME)) cursor.moveToNext() } } cursor.close() return returnMap } private fun executeRestoreQueryForKey(key: String): Cursor { val columnsToReturn = arrayOf(ScreenEntry.VALUE_COLUMN_NAME) val columnsForWhereClause = \"${ScreenEntry.KEY_COLUMN_NAME}=?\" val valuesForWhereClause = arrayOf(key) return database.query( ScreenEntry.TABLE_NAME, columnsToReturn, columnsForWhereClause, valuesForWhereClause, null, null, null ) } } internal class ContentValuesFactory { fun make(): ContentValues = ContentValues() } internal object BeagleDatabaseManager { private const val DATABASE_NAME = \"BeagleDefaultStore.db\" private const val DATABASE_VERSION = 2 private lateinit var database: SQLiteDatabase fun getDatabase(context: Context): SQLiteDatabase { if (!::database.isInitialized) { database = BeagleSQLiteDatabase( context, DATABASE_NAME, DATABASE_VERSION ).writableDatabase } return database } } internal open class BeagleSQLiteDatabase( context: Context, databaseName: String, databaseVersion: Int ) : SQLiteOpenHelper( context, databaseName, null, databaseVersion ) { override fun onCreate(db: SQLiteDatabase?) { val createTableQuery = \"CREATE TABLE ${ScreenEntry.TABLE_NAME}(\" + \"${BaseColumns._ID}INTEGER PRIMARY KEY,\" + \"${ScreenEntry.KEY_COLUMN_NAME}TEXT NOT NULL UNIQUE,\" + \"${ScreenEntry.VALUE_COLUMN_NAME}TEXT NOT NULL\" + \")\" db?.execSQL(createTableQuery) } override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) { val deleteTableQuery = \"DROP TABLE IF EXISTS ${ScreenEntry.TABLE_NAME}\" db?.execSQL(deleteTableQuery) onCreate(db) } } internal object BeagleMessageLogs { fun logDataNotInsertedOnDatabase(key: String, value: String) { BeagleLoggerDefault().warning( \"Error when trying to insert key=$keywith value=$valueon Beagle default database.\" ) } } The file above has some SQL Lite configuration and definition on how the cache manipulation actions will work, in case of a cache persistence on the database.\nAfter the MemoryLocalStore and DatabaseLocalStore classes definition, you can define StoreHandler. See the example below:\nimport br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.store.StoreHandler import br.com.zup.beagle.android.store.StoreType @BeagleComponent internal class StoreHandler( private val memoryLocalStore: MemoryLocalStore = MemoryLocalStore, private val databaseLocalStore: DatabaseLocalStore = DatabaseLocalStore() ) : StoreHandler { override fun save(storeType: StoreType, data: Map\u003cString, String\u003e) { data.forEach { if (storeType == StoreType.DATABASE) { databaseLocalStore.save(it.key, it.value) } else { memoryLocalStore.save(it.key, it.value) } } } override fun restore(storeType: StoreType, vararg keys: String): Map\u003cString, String?\u003e { val values = mutableMapOf\u003cString, String?\u003e() keys.forEach { val value = if (storeType == StoreType.DATABASE) { databaseLocalStore.restore(it) } else { memoryLocalStore.restore(it) } values[it] = value } return values } override fun delete(storeType: StoreType, key: String) { if (storeType == StoreType.DATABASE) { databaseLocalStore.delete(key) } else { memoryLocalStore.delete(key) } } override fun getAll(storeType: StoreType): Map\u003cString, String\u003e { return if (storeType == StoreType.DATABASE) { databaseLocalStore.getAll() } else { memoryLocalStore.getAll() } } } Now you‚Äôre ready to start using Beagle! To verify if the configuration is correct, we can simulate a Server-Driven screen to make the following test.\nUse Example How to display a Server-Driven screen Once you have already configured Beagle, every server-driven screen you build on your application‚Äôs backend will be sent to frontend through JSON.\nTo test our application, we‚Äôll make a simulation of a server-driven screen creating a JSON that represents a screen of tour Android application.\nFollow these steps to make this exhibition:\n Open the file MainActivity.kt; State the line below onOnCreate function; Add the a command line test_content.addView(testScreen().toView(this)) Notice that doesn‚Äôt exist the test_content, because we will still name this reference.  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) test_content.addView(testScreen().toView(this)) }  To access the view test_content as the example above, it is necessary to install the plugin:\nplugins { id 'kotlin-android-extensions' }   Open the .xml layout file of Main Activity and create a Frame layout.  As a default, Android usually creates .xml files with constraint layout. You don‚Äôt need to remove it, just add a layout frame inside it and check out if the configurations are similar to the example below:\nactivity_main.xml \u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/test_content\" /\u003e Now, you just have to return to MainActivity.kt page and state the function below. It‚Äôs responsible to list JSON to test the screen.  MainActivity.kt private fun testScreen() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle!\" ).applyStyle( Style(margin = EdgeValue(top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides usage of the \" + \"Server-Driven UI concept, natively in iOS, Android and Web applications. \" + \"By using Beagle, your team could easily change application's layout and\" + \" data by just changing backend code.\" ).applyStyle( Style(margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) The function above creates a JSON structure below, that will be interpreted by Beagle:\n{ \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello Beagle!\", \"style\" : { \"margin\" : { \"top\" : { \"value\" : 16.0, \"type\" : \"REAL\" } }, \"flex\" : { \"alignSelf\" : \"CENTER\" } } }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Beagle is a cross-platform framework which provides usage of the Server-Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code.\", \"style\" : { \"margin\" : { \"left\" : { \"value\" : 16.0, \"type\" : \"REAL\" }, \"top\" : { \"value\" : 20.0, \"type\" : \"REAL\" }, \"right\" : { \"value\" : 16.0, \"type\" : \"REAL\" } } } } ] } } Click on Run app and check the emulator screen!\nYou will see this screen:  Well done, you created your first screen with Beagle!  This tutorial focused in a simple screen configuration, so you could understand the process and without worrying about screens' hierarchy.\nAdditional Information Before you use Beagle, stay tuned about: the release build configuration and ProGuard.\nEven though it‚Äôs not necessary at this moment, it‚Äôs good to have in mind that you‚Äôll have to configure the ProGuard to activate the obfuscate code when you publish releases.\nThe annotated classes like BeagleComponent and RegisterValidator can‚Äôt implement parameters in your constructors because, on Beagle, these constructors must be empty.  ","excerpt":" Usage configurations Once you have finished Beagle‚Äôs installation, ‚Ä¶","ref":"/docs-beagle/docs/get-started/using-beagle/android/","title":"Android"},{"body":" Configura√ß√£o de uso Depois que voc√™ terminar a instala√ß√£o, √© preciso configurar o Beagle para o uso. Para facilitar a nossa explica√ß√£o, vamos usar um exemplo de como renderizar uma tela com um t√≠tulo ‚ÄúHello Beagle!‚Äù e uma pequena descri√ß√£o.\nPasso 1: Atualizar Android Manifest Nesse passo voc√™ deve atualizar oAndroidManifest e adicionar duas linhas a este arquivo:\n A permiss√£o de INTERNET para que sua aplica√ß√£o seja capaz de acessar a internet. O atributoandroid:usesCleartextTraffic=\"true\" dentro da tag \u003capplication\u003e para comunica√ß√£o com o BFF local.  Para este exemplo n√£o iremos utilizar um BFF, consequentemente essa configura√ß√£o n√£o √© necess√°ria. Por√©m, para todo e qualquer teste que seja feito usando o Beagle Android com um BFF, esse passo √© necess√°rio.  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication ... android:usesCleartextTraffic=\"true\" ...    OusesCleartextTraffic: indica que o aplicativo pretende usar o tr√°fego de rede de texto n√£o criptografado, HTTP. O valor padr√£o para aplicativos que visam o n√≠vel de API 27 ou inferior √© true. Os aplicativos que t√™m como alvo o n√≠vel de API 28 ou superior s√£o padronizados como false.\n  O atributo android: usesCleartextTraffic = \"true\" dentro da tag\u003capplication\u003e\n√© usado para se comunicar com o BFF local. Se voc√™ pretende depurar o projeto usando um BFF local, voc√™ pode usar essa configura√ß√£o como uma etapa de configura√ß√£o r√°pida.\n  No entanto, se voc√™ planeja transformar este exemplo em um aplicativo para release, recomendamos que voc√™ use o networkSecurityConfig, que voc√™ pode configurar usando as instru√ß√µes na p√°gina de desenvolvedores do Android.\n   Passo 2: Criar uma classe BeagleConfig Feita a atualiza√ß√£o, voc√™ precisa criar uma classe BeagleConfig e configurar seus todos os atributos, como mostra o exemplo abaixo:\n@BeagleComponent class AppBeagleConfig : BeagleConfig { override val environment: Environment get() = Environment.DEBUG override val baseUrl: String get() = \"https://myapp.server.com/\" override val isLoggingEnabled: Boolean = true override val cache: Cache = Cache( enabled = false, maxAge = 300, size = 15 ) }    Atributos Tipo Defini√ß√£o     environment Environment Atributo respons√°vel por informar ao Beagle qual o estado de build atual da aplica√ß√£o.   baseUrl String Informa a url base usada no Beagle na aplica√ß√£o. Se estiver usando emulador, consulte essa p√°gina para definir esse atributo.   isLoggingEnabled Boolean Atributo que habilita ou desabilita todos os logs que o Beagle gera.   cache Cache Objeto respons√°vel por gerenciar o cache das requisi√ß√µes do Beagle.    Fa√ßa a configura√ß√£o das classes com bastante aten√ß√£o, pois se voc√™ anot√°-las comBeagleComponent, o Beagle espera que elas tenham construtores vazios.  Passo 3: BeagleActivity O Beagle fornece uma Activity default para gerenciar as Activities geradas via server-driven. Por√©m voc√™ pode criar uma ou maisActivities que herdem de BeagleActivity com @BeagleComponent personalizadas de acordo com os fluxos server-driven da sua aplica√ß√£o.\nVoc√™ pode criar o BeagleActivity agora, mas neste momento √© poss√≠vel prosseguir com os pr√≥ximos passos sem configur√°-la. Para saber mais, confira a se√ß√£o sobreBeagle Activity Customizada.  Passo 4: Iniciar o Beagle e o Design System Agora √© o momento de iniciar o Beagle na classe da sua aplica√ß√£o. Por√©m, antes confira se a vers√£o m√≠nima da sua aplica√ß√£o em SKD est√° 19 ou superior, como indicado abaixo:\ndefaultConfig { minSdkVersion 19 //or higher }  Voc√™ pode criar o Design System agora, mas neste momento √© poss√≠vel prosseguir com os pr√≥ximos passos sem configur√°-lo. Para saber mais, confira a se√ß√£o sobre Design System com Beagle para Android.  Passo 5: Criar o BeagleSetup Agora voc√™ deve inicializar sua Application para que o Beagle gere os outros arquivos de configura√ß√£o que necessita. Ao ser iniciado pela primeira vez o Beagle ir√° criar automaticamente uma classe de BeagleSetup class, como mostra a figura abaixo:\nPasso 6: Criar a classe Application Neste momento, voc√™ deve criar uma classe Kotlin que estenda a classe Application que, para este exemplo, nomeamos como AppApplication.\nEsta classe deve chamar o BeagleSetup().init(this) no m√©todo onCreate, conforme listado abaixo:\nclass AppApplication: Application() { companion object { var APPLICATION: Application? = null } override fun onCreate() { super.onCreate() APPLICATION = this BeagleSetup().init(APPLICATION!!) } }  Assim que voc√™ criar essa classe, aperte CTRL + F9 para que as classes autogeradas do Beagle sejam criadas.  Passo 7: Atualizar seu Android Manifest.xml Por fim, voc√™ deve atualizar novamente o seu AndroidManifest.xml e definir a AppApplication que foi criada como o arquivo de inicializa√ß√£o da aplica√ß√£o, como no exemplo abaixo:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication android:name=\".AppApplication\" .. Passo 8: Gerenciar os Logs Voc√™ precisa criar uma classe que implementa a interface BeagleLogger. Esse protocolo dever√° ser definido para facilitar o monitoramento dos erros gerados no contexto server driven de sua aplica√ß√£o. E voc√™ deve implementar os m√©todos da forma mais apropriada para sua necessidade. Veja um exemplo:\nprivate const val BEAGLE_TAG = \"BeagleSDK\" @BeagleComponent class BeagleLoggerDefault : BeagleLogger { override fun warning(message: String) { Log.w(BEAGLE_TAG, message) } override fun error(message: String) { Log.e(BEAGLE_TAG, message) } override fun error(message: String, throwable: Throwable) { Log.e(BEAGLE_TAG, message, throwable) } override fun info(message: String) { Log.i(BEAGLE_TAG, message) } } Passo 9: Gerenciar os caches Aqui, voc√™ deve implementar o StoreHandler, um protocolo que permite personalizar a forma como o cache √© manipulado no banco de dados e na mem√≥ria.\nPara isso, √© preciso criar duas classes que implementar√£o a interface LocalStore. Essa interface permite mapear as a√ß√µes de salvar, restaurar, deletar e pegar tudo. Veja o exemplo abaixo:\ninternal object MemoryLocalStore : LocalStore { private val cache = mutableMapOf\u003cString, String\u003e() override fun save(key: String, value: String) { cache[key] = value } override fun restore(key: String): String? { return cache[key] } override fun delete(key: String) { cache.remove(key) } override fun getAll(): Map\u003cString, String\u003e { return cache.toMap() } } Agora criaremos uma segunda classe a qual dependeremos para cria√ß√£o do StoreHandler, que √© a DatabaseLocalStore. Note que neste mesmo arquivo foram declaradas algumas classes adjacentes que servem a essa classe DatabaseLocalStore mas poderiam estar em arquivos diferentes, caso prefira. Veja um exemplo:\ninternal object ScreenEntry : BaseColumns { const val TABLE_NAME = \"KeyValueCache\" const val KEY_COLUMN_NAME = \"key\" const val VALUE_COLUMN_NAME = \"value\" } internal class DatabaseLocalStore( private val contentValuesFactory: ContentValuesFactory = ContentValuesFactory(), private val database: SQLiteDatabase = BeagleDatabaseManager.getDatabase( BeagleUiSampleApplication.APPLICATION!!) ) : LocalStore { override fun save(key: String, value: String) { val values = contentValuesFactory.make().apply { put(ScreenEntry.KEY_COLUMN_NAME, key) put(ScreenEntry.VALUE_COLUMN_NAME, value) } val newRowId = database.insertWithOnConflict(ScreenEntry.TABLE_NAME, null, values, SQLiteDatabase.CONFLICT_REPLACE) if (newRowId == -1L) { BeagleMessageLogs.logDataNotInsertedOnDatabase(key, value) } } override fun restore(key: String): String? { return executeRestoreQueryForKey(key).use { cursor -\u003e if (cursor.count \u003e 0) { cursor.moveToFirst() cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.VALUE_COLUMN_NAME)) } else { null } } } override fun delete(key: String) { database.delete(ScreenEntry.TABLE_NAME, \"${ScreenEntry.KEY_COLUMN_NAME}=?\", arrayOf(key)) } override fun getAll(): Map\u003cString, String\u003e { val columnsToReturn = arrayOf(ScreenEntry.KEY_COLUMN_NAME, ScreenEntry.VALUE_COLUMN_NAME) val columnsForWhereClause = \"\" val valuesForWhereClause = arrayOf\u003cString\u003e() val cursor = database.query( ScreenEntry.TABLE_NAME, columnsToReturn, columnsForWhereClause, valuesForWhereClause, null, null, null ) val returnMap = mutableMapOf\u003cString, String\u003e() if (cursor.count \u003e 0) { cursor.moveToFirst() while (!cursor.isAfterLast) { returnMap[cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.KEY_COLUMN_NAME))] = cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.VALUE_COLUMN_NAME)) cursor.moveToNext() } } cursor.close() return returnMap } private fun executeRestoreQueryForKey(key: String): Cursor { val columnsToReturn = arrayOf(ScreenEntry.VALUE_COLUMN_NAME) val columnsForWhereClause = \"${ScreenEntry.KEY_COLUMN_NAME}=?\" val valuesForWhereClause = arrayOf(key) return database.query( ScreenEntry.TABLE_NAME, columnsToReturn, columnsForWhereClause, valuesForWhereClause, null, null, null ) } } internal class ContentValuesFactory { fun make(): ContentValues = ContentValues() } internal object BeagleDatabaseManager { private const val DATABASE_NAME = \"BeagleDefaultStore.db\" private const val DATABASE_VERSION = 2 private lateinit var database: SQLiteDatabase fun getDatabase(context: Context): SQLiteDatabase { if (!::database.isInitialized) { database = BeagleSQLiteDatabase( context, DATABASE_NAME, DATABASE_VERSION ).writableDatabase } return database } } internal open class BeagleSQLiteDatabase( context: Context, databaseName: String, databaseVersion: Int ) : SQLiteOpenHelper( context, databaseName, null, databaseVersion ) { override fun onCreate(db: SQLiteDatabase?) { val createTableQuery = \"CREATE TABLE ${ScreenEntry.TABLE_NAME}(\" + \"${BaseColumns._ID}INTEGER PRIMARY KEY,\" + \"${ScreenEntry.KEY_COLUMN_NAME}TEXT NOT NULL UNIQUE,\" + \"${ScreenEntry.VALUE_COLUMN_NAME}TEXT NOT NULL\" + \")\" db?.execSQL(createTableQuery) } override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) { val deleteTableQuery = \"DROP TABLE IF EXISTS ${ScreenEntry.TABLE_NAME}\" db?.execSQL(deleteTableQuery) onCreate(db) } } internal object BeagleMessageLogs { fun logDataNotInsertedOnDatabase(key: String, value: String) { BeagleLoggerDefault().warning( \"Error when trying to insert key=$keywith value=$valueon Beagle default database.\" ) } } O arquivo acima possui as configura√ß√µes para o SQL Lite e tamb√©m as defini√ß√µes de como as a√ß√µes de manipula√ß√£o de cache funcionar√£o, no caso da persist√™ncia do cache no banco de dados.\nAp√≥s a defini√ß√£o das classes MemoryLocalStore e DatabaseLocalStore voc√™ pode definir a StoreHandler. Veja o exemplo abaixo:\nimport br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.store.StoreHandler import br.com.zup.beagle.android.store.StoreType @BeagleComponent internal class StoreHandler( private val memoryLocalStore: MemoryLocalStore = MemoryLocalStore, private val databaseLocalStore: DatabaseLocalStore = DatabaseLocalStore() ) : StoreHandler { override fun save(storeType: StoreType, data: Map\u003cString, String\u003e) { data.forEach { if (storeType == StoreType.DATABASE) { databaseLocalStore.save(it.key, it.value) } else { memoryLocalStore.save(it.key, it.value) } } } override fun restore(storeType: StoreType, vararg keys: String): Map\u003cString, String?\u003e { val values = mutableMapOf\u003cString, String?\u003e() keys.forEach { val value = if (storeType == StoreType.DATABASE) { databaseLocalStore.restore(it) } else { memoryLocalStore.restore(it) } values[it] = value } return values } override fun delete(storeType: StoreType, key: String) { if (storeType == StoreType.DATABASE) { databaseLocalStore.delete(key) } else { memoryLocalStore.delete(key) } } override fun getAll(storeType: StoreType): Map\u003cString, String\u003e { return if (storeType == StoreType.DATABASE) { databaseLocalStore.getAll() } else { memoryLocalStore.getAll() } } } Agora voc√™ est√° pronto para come√ßar a usar o Beagle! E para verificar se a configura√ß√£o est√° correta simule uma tela Server-Driven fazendo o teste a seguir.\nExemplo pr√°tico Como exibir uma tela Server-Driven Para voc√™ testar nossa aplica√ß√£o, vamos simular uma tela server-driven criando um JSON que represente uma tela na sua aplica√ß√£o Android.\nSiga os passos abaixo para fazer a exibi√ß√£o:\n Abra o arquivo MainActivity.kt; Declare a linha abaixo na fun√ß√£o onCreate; Adicione a linha de comando test_content.addView(testScreen().toView(this)) Perceba que o test_content ainda n√£o existe, pois ainda vamos nomear esta refer√™ncia.  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) test_content.addView(testScreen().toView(this)) }  Para acessar a view test_content como no exemplo acima, √© necess√°rio a instalar o plugin:\nplugins { id 'kotlin-android-extensions' }   Abra o arquivo de layout .xml da Main Activity e crie um frame layout.  Por padr√£o, o Android costuma criar os arquivos .xml com o constraint layout. Voc√™ n√£o precisa remov√™-lo, apenas adicione o frame layout dentro dele e confira se as configura√ß√µes est√£o como no exemplo abaixo:\n\u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/test_content\" /\u003e Agora, √© s√≥ retornar a p√°gina MainActivity.kt e declarar a fun√ß√£o abaixo. Ela √© a respons√°vel por listar o JSON para testarmos a tela.  private fun testScreen() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle!\" ).applyStyle( Style(margin = EdgeValue(top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides usage of the \" + \"Server-Driven UI concept, natively in iOS, Android and Web applications. \" + \"By using Beagle, your team could easily change application's layout and\" + \" data by just changing backend code.\" ).applyStyle( Style(margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) A fun√ß√£o acima cria a estrutura JSON abaixo, que vai ser interpretada pelo Beagle:\n{ \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello Beagle!\", \"style\" : { \"margin\" : { \"top\" : { \"value\" : 16.0, \"type\" : \"REAL\" } }, \"flex\" : { \"alignSelf\" : \"CENTER\" } } }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Beagle is a cross-platform framework which provides usage of the Server-Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code.\", \"style\" : { \"margin\" : { \"left\" : { \"value\" : 16.0, \"type\" : \"REAL\" }, \"top\" : { \"value\" : 20.0, \"type\" : \"REAL\" }, \"right\" : { \"value\" : 16.0, \"type\" : \"REAL\" } } } } ] } } Clique em Run app e cheque a tela do emulador!\nVoc√™ ver√° a tela a seguir:  Parab√©ns, voc√™ criou sua primeira tela com Beagle!  Neste tutorial, focamos em uma configura√ß√£o de tela simples para voc√™ entender o processo, na pr√°tica, sem se preocupar com uma hierarquia de telas complexas. Mas, claro, voc√™ pode fazer bem mais no seu projeto com o Beagle!\nInforma√ß√£o adicional Antes de usar o Beagle, fique atento a configura√ß√£o da build de release e o ProGuard.\nMesmo n√£o sendo necess√°rio neste momento, √© bom ter em mente que voc√™ precisar√° configurar o ProGuard para ativar o ofuscamento do seu c√≥digo quando estiver publicando releases.\nAs classes anotadas como BeagleComponent e RegisterValidatorn√£o podem implementar par√¢metros nos seus construtores, pois no caso do Beagle esses construtores precisam estar vazios.  ","excerpt":" Configura√ß√£o de uso Depois que voc√™ terminar a instala√ß√£o, √© preciso ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/android/","title":"Android"},{"body":" How to display a ‚ÄúHello Beagle!‚Äù screen After you installed Beagle on your project, we‚Äôll show how to render a screen and display your first ‚ÄúHello Beagle!\".\nCheck out how to install Beagle in case you haven‚Äôt finished this step.  Currently, there are two types of approaches to render screens with Beagle: remote and declarative.\nRemote Renderization  Main approach used on Beagle because it‚Äôs based on server-driven UI concept. It allows you to build layouts dynamically, consuming the informations provided by a BFF through a remote URL.\n Declarative Renderization  Even if it‚Äôs an alternative not based on server-driven UI, this renderization is a way you can locally state componentes with Swift language. With this, you can use a local component directly or through a JSON that represents it, simulating a response from BFF.\n For this example, you will render a screen with declarative way, which means that all the processes will be done locally because, on this way, you‚Äôll know a little bit about Beagle and, in a few steps, test if your installation worked.\nStep 1: Create a class (MyBeagleScreen) Create a class and name it as you wish. Here, we‚Äôll call it MyBeagleScreen.\nThe class will have only one method responsible to build a Screen.\nimport Beagle import Foundation class BeagleConfig { static func config() { let dependencies = BeagleDependencies() dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"Server base URL\") ) Beagle.dependencies = dependencies } }  Notice that the Screen is being build using**Flex**. To understand better these components and your proprieties, go to the section **component‚Äôs layout**.  Step 2: Instantiate BeagleScreenViewController Now it‚Äôs time to display your first screen built using Beagle, and to do so you must:\nInstantiate a**BeagleScreenViewController** with**declarative** type that will receive a**MyBeagleScreen**.\nlet beagleViewController = Beagle.screen( .declarative( MyBeagleScreen.make() ) )  In case you want to use the **remote**type, check out how to display a server-driven screen.  Once you made it, you just have to present it as you wish.\npresent(beagleViewController, animated: true, completion: nil)  Don‚Äôt forget to add**import Beagle**.  Step 3: Run the application Now, run your application and, if everything works well, you will see a screen like this:\nCongratulations, you have created you first screen with Beagle üéâ  Next steps On this section, you saw how to create your first declarative screen using Beagle, on your simplest way, without entering on the server-driven UI concept.\nüëâTo understand more about how to configure Beagle and use it applying server-driven UI, check out how to create an iOS project from scratch.\n","excerpt":" How to display a ‚ÄúHello Beagle!‚Äù screen After you installed Beagle on ‚Ä¶","ref":"/docs-beagle/docs/get-started/using-beagle/ios/","title":"IOS"},{"body":" Como exibir uma tela ‚ÄúHello Beagle!‚Äù Depois de ter o Beagle instalado em seu projeto, vamos te mostrar como renderizar uma tela e exibir seu primeiro ‚ÄúHello Beagle!\".\nVeja como instalar o Beagle caso ainda n√£o tenha conclu√≠do esta etapa.  Atualmente, existem dois tipos de abordagens para a renderiza√ß√£o de telas com o Beagle: remota e declarativa.\nRenderiza√ß√£o Remota  Principal abordagem usada no Beagle por ser fundamentada no conceito de server-driven UI. Ela permite que voc√™ construa layouts dinamicamente, consumindo as informa√ß√µes fornecidas por um BFF, por meio de uma URL remota.\n Renderiza√ß√£o Declarativa  Apesar de ser uma alternativa n√£o pautada em server-driven UI, √© uma forma de renderiza√ß√£o que permite voc√™ declarar localmente componentes pela linguagem Swift. Com isso, voc√™ pode utilizar um componente local diretamente ou passando um JSON que o representa, simulando assim a resposta de um BFF.\n Para este exemplo, voc√™ ir√° renderizar uma tela de forma declarativa, ou seja, tudo ser√° feito localmente. Desta forma, voc√™ ir√° conhecer um pouco do Beagle e, em poucos passos, testar se sua instala√ß√£o funcionou.\nPasso 1: Crie uma classe (MyBeagleScreen) Crie uma classe e a nomeie como preferir. Aqui, iremos cham√°-la de MyBeagleScreen.\nA classe ir√° conter apenas um m√©todo, respons√°vel por construir uma Screen.\nimport Beagle import BeagleSchema class MyBeagleScreen { static func make() -\u003e Screen { return Screen( child: Container( children: [ Text(\"Hello Beagle!\") ] ).applyFlex( Flex( justifyContent: .center, alignItems: .center, grow: 1 ) ) ) } }  Note que a Screen est√° sendo constru√≠da utilizando Flex. Para entender melhor esses componentes e suas propriedades, v√° para a se√ß√£o posicionamento de componentes.  Passo 2: Instanciar o BeagleScreenViewController Agora, para conseguir visualizar a sua primeira tela constru√≠da utilizando o Beagle, tudo que voc√™ precisa fazer √©:\nInstanciar uma BeagleScreenViewController do tipo declarative que receber√° a**MyBeagleScreen**.\nlet beagleViewController = Beagle.screen( .declarative( MyBeagleScreen.make() ) )  Caso queira utilizar o tipo**remote**, veja como exibir uma tela Server-Driven UI.  Feito isso, basta apresent√°-la onde preferir.\npresent(beagleViewController, animated: true, completion: nil)  N√£o esque√ßa de adicionar**import Beagle**.  Passo 3: Executar a aplica√ß√£o Por fim, execute a sua aplica√ß√£o e, se tudo estiver certo, voc√™ dever√° ver uma tela como esta:\nParab√©ns, voc√™ criou sua primeira tela com Beagleüéâ  Pr√≥ximos passos Nesta se√ß√£o, voc√™ viu como criar sua primeira tela declarativa utilizando o Beagle, em sua forma mais simples, sem entrar no conceito de server-driven UI.\nüëâPara entender melhor como configurar o Beagle e utiliz√°-lo aplicando o conceito de server-driven UI, veja como criar um projeto iOS do zero.\n","excerpt":" Como exibir uma tela ‚ÄúHello Beagle!‚Äù Depois de ter o Beagle instalado ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/ios/","title":"IOS"},{"body":" Once you have finished Beagle‚Äôs installation, now you can make usage configuration according to the framework you‚Äôre using:\nIf you wanto to use a BFF, it‚Äôs necessary to have a configured CORS. See how to do this on use configurations for backend.  ","excerpt":" Once you have finished Beagle‚Äôs installation, now you can make usage ‚Ä¶","ref":"/docs-beagle/docs/get-started/using-beagle/web/","title":"WEB"},{"body":" No caso do Beagle para Web, √© necess√°rio fazer as configura√ß√µes de uso de acordo com o framework que estiver utilizando:\nCaso queira utilizar um BFF, √© necess√°rio ter um CORS configurado. Veja como fazer isso nas configura√ß√µes de uso para backend.  ","excerpt":" No caso do Beagle para Web, √© necess√°rio fazer as configura√ß√µes de ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/web/","title":"WEB"},{"body":" Usage configurations After you finished the installation, you need to make Beagle‚Äôs usage configuration for Angular‚Äôs framework. To do so, you just have to follow these steps:\nStep 1: Configure using an automatic configuration Type one of the commands below to generate the files that will be used on Beagle‚Äôs library. It‚Äôs possible to execute the command according to your package manager:\nyarn beagle init npx beagle init Once you made it, Beagle will return some questions. To answer them, follow the orientations below:\nQuestion 1: Would you like to use yarn or npm?\nIn this case, type the option that will be used as manager. In our example, we will use yarn, so type yarnand press enter.\nQuestion 2: Path to the beagle module (press enter to use default)\nIn this case, type the module path that will be used for Beagle. Considering we‚Äôre creating this project from zero e and there is no module, you just have to press enter without informing anything.\nQuestion 3: Path to the module with the components to use with beagle (press enter to use default)\nIn this case, type the module path that will be used for Beagle‚Äôs components. Considering we don‚Äôt have any module yet, you just have to press enter without informing anything.\nQuestion 4: What‚Äôs the base url of the backend providing your beagle JSONs? (press enter to use default)\nIn this case, type the backend‚Äôs basis URL that will be used to rescue JSON files. For our example, we‚Äôll use a JSON, so just type: http://localhost:4200/assets\nAt the end of this process, two files will be generate on your project:\n beagle-components.module.ts beagle.module.ts.  Open the file app.module.ts and, then, import Beagle‚Äôs module that was just generated:\n... import { Beagle } from './beagle.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, Beagle ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Step 2: Create a JSON to be rendered Now, you just have to create a JSON to render the components. Usually, this process would be made by an external server that would return de JSON, but for this example we‚Äôll create a local file to be accessed for the test.\nOn your angular project, navigate to the src/assets file and create a new file named payload.json. Open this new file you just created and copy the content below:\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\": \"Beagle is a cross-platform framework which provides usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] }  The Beagle‚Äôs library comes with many pre-defined components ready to be used in their project.\nThe code above creates a JSON with two os these components: container e text.\n After you created your JSON, open the file beagle.module.ts we generated in the previous step and add as a baseUrl the path: http://localhost:4200/assets\nimport { BeagleModule } from '@zup-it/beagle-angular' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, }) export class Beagle {} Well done, your configuration is ready! Now, we‚Äôll see how to render mapped components on JSON.\nStep 3: Use beagle-remote-view After creating the JSON, you need to tell Angular where to render the Beagle components. To do this, our lib provides the component \u003cbeagle-remote-view\u003e.\nOpen the file app.component.html and replace all the content with this code:\n\u003cbeagle-remote-view route=\"/payload.json\"\u003e\u003c/beagle-remote-view\u003e route in the code above states which route will be loaded. The URL specified here is relative to the baseUrl declared in the configuration.\nThe parameter route is only valid for versions 1.3 and above. For previous versions, you should use loadParams instead. loadParams is an object and the equivalent to this configuration would be { path: '/payload.json' }.  Example Testing the application Before we test if our configuration worked, you have to run one of the commands below to initialize the application.\nWhen you run the application, you can‚Äôt use use the ng serve command because it will initialize the application without Beagle. To make the Beagle‚Äôs initialization, it‚Äôs necessary to run one of the commands indicated for those who use npm or yarn.  If you use npm:\nnpm run serve If you use yarn:\nyarn serve  It‚Äôs important to clarify here that the command used to restart the application is fundamental make work the changes you intend to make in Beagle‚Äôs configurations files.\nThis process also must be done for any change made on @Input() proprieties of your mapped components. Beagle‚Äôs team is constantly developing solutions to improve this.\n After finished this commands, access the local: http://localhost:4200\nYou will see this screen:\nWell done, you created your first screen with Beagle!  ","excerpt":" Usage configurations After you finished the installation, you need to ‚Ä¶","ref":"/docs-beagle/docs/get-started/using-beagle/web/angular/","title":"Angular"},{"body":" Configura√ß√µes de uso Depois que voc√™ terminar a instala√ß√£o, √© preciso configurar o Beagle para o uso no framework do Angular. Para isso, basta realizar os seguintes passos:\nPasso 1: Configura√ß√£o autom√°tica Execute um dos comandos abaixo para gerar os arquivos que ser√£o usados pela biblioteca Beagle. √â poss√≠vel executar o comando de acordo com seu gerenciador de pacotes:\nyarn beagle init npx beagle init Feito isso, o Beagle ir√° retornar algumas perguntas. Para respond√™-las, siga as orienta√ß√µes abaixo:\nPergunta 1: Would you like to use yarn or npm?\nVoc√™ gostaria de usar yarn ou npm?\nNeste caso, digite a op√ß√£o que ir√° utilizar como gerenciador. No nosso exemplo, usaremos o yarn, logo digite yarne aperte enter.\nPergunta 2: Path to the beagle module (press enter to use default)\nCaminho para o modulo do Beagle (pressione enter para usar o default)\nNeste caso, digite qual o caminho do m√≥dulo que ser√° usado para o beagle. Como estamos criamos o projeto do zero e n√£o temos nenhum m√≥dulo, √© s√≥ dar enter sem informar nada.\nPergunta 3: Path to the module with the components to use with beagle (press enter to use default)\nCaminho para usar o m√≥dulo com componentes para usar o Beagle (pressione enter para usar default)\nNeste caso, digite qual o caminho do m√≥dulo que ser√° usado para os components do beagle. Como ainda n√£o temos nenhum m√≥dulo, √© s√≥ dar enter sem informar nada.\nPergunta 4: What‚Äôs the base url of the backend providing your beagle JSONs? (press enter to use default)\nQual a base url do backend que providencia o seu JSONs ao Beagle? (pressione enter para usar o default)\nNeste caso, digite qual ser√° a URL base do backend que ser√° utilizada para resgatar os arquivos JSON. Para o nosso exemplo, usaremos um JSON, logo √© s√≥ digitar: http://localhost:4200/assets\nAo final deste processo, ser√£o gerados dois novos arquivos em seu projeto:\n beagle-components.module.ts beagle.module.ts.  Abra o arquivo app.module.ts e, em seguida, importe o m√≥dulo Beagle que acabou de ser gerado:\n... import { Beagle } from './beagle.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, Beagle ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Passo 2: Cria√ß√£o do JSON de defini√ß√£o do layout Agora, voc√™ precisa criar um arquivo JSON que definir√° os componentes que ser√£o renderizados. Geralmente, esse arquivo seria obtido por um servidor externo, mas neste exemplo criaremos um arquivo local para ser acessado como teste.\nNo seu projeto angular, navegue at√© a pasta src/assets e crie um novo arquivo com o nome payload.json. Abra este novo arquivo que foi criado e copie o conte√∫do abaixo:\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle is a cross-platform framework which provides usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] }  A biblioteca Beagle j√° vem com diversos componentes pr√©-definidos e prontos para serem usados em seu projeto.\nO c√≥digo acima cria um JSON com dois desses componentes: container e text.\n Depois de criado o seu JSON, abra o arquivo beagle.module.ts gerado no passo anterior e adicione como baseUrl o caminho: http://localhost:4200/assets\nimport { BeagleModule } from '@zup-it/beagle-angular' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, }) export class Beagle {} Pronto, a configura√ß√£o est√° finalizada agora vamos aprender como renderizar os componentes mapeados no JSON.\nPasso 3: Usando o beagle-remote-view Depois de criado o JSON, voc√™ precisa especificar, dentro da aplica√ß√£o, o local em que os componentes ser√£o renderizados. Para realizar essa a√ß√£o, a biblioteca do Beagle fornece o componente \u003cbeagle-remote-view\u003e.\nAbra o arquivo app.component.html e substitua todo o conte√∫do pelo c√≥digo a seguir:\n\u003cbeagle-remote-view route=\"/payload.json\"\u003e\u003c/beagle-remote-view\u003e route no c√≥digo acima diz qual a rota ser√° carregada. A URL especificada aqui √© relativa √† baseUrl declarada na configura√ß√£o.\nO par√¢metro route √© v√°lido apenas para a vers√£o 1.3 ou superior. Para vers√µes anteriores, loadParams deve ser usado. loadParams√© um objeto e o valor equivalente ao desse exemplo seria{ path: '/payload.json' }.  Exemplo Testando a aplica√ß√£o Para testarmos se a nossa configura√ß√£o funcionou, voc√™ precisa rodar um dos comandos abaixo para inicializar a aplica√ß√£o.\nAo executar a aplica√ß√£o, voc√™ n√£o deve utilizar o comando ng serve porque ela ser√° iniciada sem compilar os arquivos do Beagle. Para que o Beagle seja inicializado corretamente, √© necess√°rio utilizar um dos comandos abaixo de acordo com seu gerenciador de pacotes.  Caso utilize npm:\nnpm run serve Caso utilize yarn:\nyarn serve  √â importante deixar claro que o comando para reiniciar a aplica√ß√£o √© fundamental para que as altera√ß√µes que voc√™ fez nos arquivos de configura√ß√£o do Beagle funcionem.\nEste processo tamb√©m deve ser feito para qualquer altera√ß√£o feita nas propriedades @Input() de seus componentes mapeados. A equipe Beagle est√° constantemente desenvolvendo solu√ß√µes para melhorar isso.\n Depois de finalizado o comando acesse a aplica√ß√£o em: http://localhost:4200\nVoc√™ dever√° ver a tela a seguir:\nParab√©ns, voc√™ criou sua primeira tela com Beagle!  ","excerpt":" Configura√ß√µes de uso Depois que voc√™ terminar a instala√ß√£o, √© preciso ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/web/angular/","title":"Angular"},{"body":" Usage configurations After you finished the installation, you need to make Beagle‚Äôs usage configuration for React‚Äôs framework. To do so, you just have to follow these steps:\nStep 1: Create a JSON to be rendered On your React project, on the public folder, create a file named payload.json and copy the code below. This file will map the components that will be rendered by Beagle. Generally, it would be returned by a external server, but on this example, we‚Äôll make a local JSON file to be rendered with Beagle‚Äôs library. .\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle is a cross-platform framework which provides usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] }  Beagle‚Äôs library comes with many pre-defined components ready to be used in their project.\nThe code above creates a JSON with two os these components: container e text.\n Step 2: Create a configuration file After you add the JSON on your project, create another file in the path /src, but this time with the name Beagle. Inside it, name a new file as beagle-service.ts.\nOnce you made it, your structure must be similar to the image below:\nNow open the beagle-service.ts file and copy this code:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} }) At this point of the configuration, you can add, for example, a path to Beagle‚Äôs external server. The most indicated is to let the baseUrl propriety without value because we‚Äôll use a local file (payload.json) for this example.\nIt‚Äôs important to reinforce that, for this example, we‚Äôre using typescript with the project. In case you don‚Äôt have this tool, we highly recommend you to install it, otherwise, please, ignore all the typing information.  Step 3: Using BeagleRemoteView Now you need to specify inside the application, the place where the components will be rendered. For that, open Beagle‚Äôs library that provides BeagleRemoteView and BeagleProvider. Open the component file where you want the JSON to be rendered and change it as in the example below:\nimport React from 'react'; import './App.css'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView route={'/payload.json'} /\u003e \u003c/BeagleProvider\u003e ); } export default App; When we make this note, we indicate to Beagle that our defined layout will be rendered on payload.json file. In this case, two components are provided on the library:\n \u003cBeagleProvider\u003e: Responsible to provide a valuepropriety as beagle-service created on the previous step and contains the initial configurations; \u003cBeagleRemoteView\u003e: Responsible to receive a path propriety, which is the path to our JSON file.  See that here we added ' / ‚Äò because this value will be associated to the definedbaseUrl on the file beagle-service.ts  route in the BeagleRemoteView is only valid for versions 1.3.0 and above. For earlier versions, please, use path instead.  Use Example Testing the project Before we test if our configuration worked, you have to run one of the commands below to initialize the application:\nyarn start npm run start After finished this commands, access the local: localhost:3000\nYou will see this screen:\nWell done, you created your first screen with Beagle!  ","excerpt":" Usage configurations After you finished the installation, you need to ‚Ä¶","ref":"/docs-beagle/docs/get-started/using-beagle/web/react/","title":"React"},{"body":" Configura√ß√µes de uso Depois que voc√™ terminar a instala√ß√£o, √© preciso configurar o Beagle para o uso no framework do React. Para isso, basta realizar os seguintes passos:\nPasso 1: Cria√ß√£o do JSON de defini√ß√£o do layout Dentro do seu projeto React na pasta public, crie um arquivo chamado payload.json com o c√≥digo abaixo. Este arquivo mapear√° os componentes que ser√£o renderizados pelo Beagle. Geralmente, ele seria retornado por um servidor externo, mas neste exemplo criaremos localmente no projeto.\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle is a cross-platform framework which provides usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] }  A biblioteca Beagle j√° vem com diversos componentes pr√©-definidos e prontos para serem usados em seu projeto.\nO c√≥digo acima cria um JSON com dois desses componentes: container e text.\n Passo 2: Configura√ß√£o do Beagle Service Depois de adicionar o arquivo payload.json no seu projeto, crie uma pasta no caminho /srccom nome beagle. Dentro dela, adicione um novo arquivo com o nome beagle-service.ts.\nFeito isso, a sua estrutura deve estar parecida com a imagem a seguir:\nAbra agora o arquivo criadobeagle-service.ts e insira o c√≥digo abaixo:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} }) Neste ponto da configura√ß√£o podemos definir a baseUrl do servidor externo do Beagle. Para este exemplo, deixaremos esta propriedade sem valor pois usaremos um arquivo local (payload.json).\n√â importante ressaltar que, para este exemplo, estamos usando otypescript junto ao projeto. Caso voc√™ n√£o tenha na sua m√°quina, ser√° preciso instalar.  Passo 3: Usando o BeagleRemoteView Agora voc√™ precisa especificar, dentro da aplica√ß√£o, o local em que os componentes ser√£o renderizados. Para isso, a biblioteca do Beagle fornece o BeagleRemoteView e o BeagleProvider. Abra o arquivo do componente que voc√™ deseja renderizar o layout e altere para ficar como o exemplo a seguir:\nimport React from 'react'; import './App.css'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView route={'/payload.json'} /\u003e \u003c/BeagleProvider\u003e ); } export default App;  \u003cBeagleProvider\u003e: Respons√°vel por prover para nossa aplica√ß√£o o beagle-service criado no passo anterior contendo as configura√ß√µes iniciais. Este √© especificado na propriedade value; \u003cBeagleRemoteView\u003e: Respons√°vel por renderizar o layout definido pelo JSON especificado pela propriedade route.  Note aqui que adicionamos ' / ‚Äò pois esse valor ser√° associado ao baseUrl definido no arquivo beagle-service.ts  route no BeagleRemoteView s√≥ √© v√°lido para as vers√µes 1.3 e superior. Para vers√µes anteriores, por favor, use path.  Exemplo pr√°tico Testando o projeto Para testarmos se a nossa configura√ß√£o funcionou, voc√™ precisa executar um dos comandos abaixo para inicializar a aplica√ß√£o:\nyarn start npm run start Depois de finalizar o comando, acesse: localhost:3000. Voc√™ dever√° ver a tela a seguir:\nParab√©ns, voc√™ criou sua primeira tela com Beagle!  ","excerpt":" Configura√ß√µes de uso Depois que voc√™ terminar a instala√ß√£o, √© preciso ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/web/react/","title":"React"},{"body":" Use configuration Once you have finishedBeagle‚Äôs installation, your BFF is fully configured for usage, with default settings.\nCORS Required configuration only to use your BFF with front-end web.  This process it is done according to your backend technology and, for that, we recommend you to check the tool‚Äôs documentation you have chosen.\nIf you are using one of our starters, check out the following links with both framework‚Äôs documentations about CORS:\n Micronaut Spring  We provided a constant BEAGLE_EXPOSED_HEADERS, that contains a list of headers names that Beagle needs to expose in your CORS configuration.\nA practical BFF example Step 1: Create a service Micronaut SpringBoot First, you should create a class to configure a Service . The process is pretty simple, you just have to:\n Create a class and name it as MyService; Note it with @Singleton, because this will be responsible to create your objects.  The example below, you can see the result that must appear on your screen:\nimport javax.inject.Singleton @Service class MyService { fun createAction(): Action = Alert( title = \"My Dialog\", message = \"This is a native popup!\", labelOk= \"Close\" ) fun createScreen(): Screen = Screen(child = this.createWidget()) fun createScreenBuilder(): ScreenBuilder = MyScreenBuilder(this.createWidget()) fun createWidget(): Widget = Text( text = \"Hello, world!\", alignment = TextAlignment.CENTER, textColor = \"#505050\" ) } private class MyScreenBuilder( private val component: ServerDrivenComponent ) : ScreenBuilder { override fun build() = Screen(child = this.component) }  To start, you should create a class to configure a Service . The process is pretty simple, you just have to:\n Create a class and name it as MyService; Note it with @Service , because this will be responsible to create your objects.  import javax.inject.Singleton @Service class MyService { fun createAction(): Action = Alert( title = \"My Dialog\", message = \"This is a native popup!\", labelOk= \"Close\" ) fun createScreen(): Screen = Screen(child = this.createWidget()) fun createScreenBuilder(): ScreenBuilder = MyScreenBuilder(this.createWidget()) fun createWidget(): Widget = Text( text = \"Hello, world!\", alignment = TextAlignment.CENTER, textColor = \"#505050\" ) } private class MyScreenBuilder( private val component: ServerDrivenComponent ) : ScreenBuilder { override fun build() = Screen(child = this.component) }  Step 2: Create a controller Micronaut SpringBoot The next step is to create a Controllerclass to expose our components through REST API. This class will be noted as @Controller.\nThis class receives a MyService through a primary constructor, so Micronaut can automatically make a dependency injection for you.\nThe endpoints are configured as notes according to HTTP method (for example, @Get to HTTP GET). They still receive a string that defines your path.\nTo configure your class, follow the example below. Remember to name the file asMyController so you can simply copy and paste this example.\nimport io.micronaut.http.annotation.Controller import io.micronaut.http.annotation.Get @Controller class MyController(private val myService: MyService) { @Get(\"/action\") fun getAction() = myService.createAction() @Get(\"/screen\") fun getScreen() = myService.createScreen() @Get(\"/builder\") fun getScreenBuilder() = myService.createScreenBuilder() @Get(\"/widget\") fun getWidget() = myService.createWidget() }  Once you made it, the next step is create a Controller class to expose our components through REST API. This class must be noted as@RestController\nThis class also must receive MyService through a primary constructor so Spring can automatically makes a dependency injection for you.\nThe endpoints are configured with notes according to HTTP method (for example @Get to HTTP GET). They receive a string that defines your path.\nTo configure this class, follow the example below. Remember to name the file asMyController so you can simply copy and paste this example.\nimport org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController @RestController class MyController(private val myService: MyService) { @GetMapping(\"/action\") fun getAction() = myService.createAction() @GetMapping(\"/screen\") fun getScreen() = myService.createScreen() @GetMapping(\"/builder\") fun getScreenBuilder() = myService.createScreenBuilder() @GetMapping(\"/widget\") fun getWidget() = myService.createWidget() }  Step 3: Configure your BFF You can configure cache and serialization using the lines below, by adding them to your application.properties.\nMicronaut SpringBoot The cache is configured to include /screen and /widget endpoints. The TTL for the /screen endpoint is configured to 50 seconds.\nbeagle.cache.endpoint.include=/screen,/widget beagle.cache.endpoint.ttl./screen=50s jackson.serializationInclusion=NON_NULL jackson.serialization.indentOutput=true  Cache is configured to exclude the /action endpoint\nbeagle.cache.endpoint.exclude=/action spring.jackson.default-property-inclusion=NON_NULL spring.jackson.serialization.indent-output=true  Serialization is configured to skip values that are not null and format the JSONs to make them easier to read.\nStep 4: Configure CORS Required configuration only to use your BFF with web front-end.  Micronaut SpringBoot You can configure CORS with the lines below, adding them in your application.properties.\nCORS is enabled here with default values to several details, and it will make them permissive. The cache header is exposed.\nmicronaut.server.cors.enabled=true micronaut.server.cors.configurations.beagle.exposedHeaders=beagle-hash  You can configure CORS with the classes below, that needs to implement Spring‚Äôs WebMvcConfigurerinterface, overlapping the addCorsMappings method.\nCORS is configured here to all endpoints with default values to several details, letting them very permissive. Our cache header is exposed using the constant.\nimport org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration open class CorsConfig : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(\"/**\").exposedHeaders(*BEAGLE_EXPOSED_HEADERS) } }  Use a permissive configuration like this one, only in local development environment. It eliminates CORS‚Äôs security benefits  We have an enabled CORS withmeusite.com.br like the permitted origin: GET, PUT, POST like the allowed methods Cache-control like an allowed header; and beagle-hash, x-meu1 like exposed header.\nMicronaut SpringBoot micronaut.server.cors.enabled=true micronaut.server.cors.configurations.meu.allowedOrigins=meusite.com.br micronaut.server.cors.configurations.meu.allowedMethods=GET,PUT,POST micronaut.server.cors.configurations.meu.allowedHeaders=Cache-Control micronaut.server.cors.configurations.meu.exposedHeaders=beagle-hash,x-meu1  import org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration open class CorsConfig : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(\"/**\") .allowedOrigins(\"meusite.com.br\") .allowedMethods(\"GET,PUT,POST\") .allowedHeaders(\"Cache-Control\") .exposedHeaders(*(BEAGLE_EXPOSED_HEADERS + \"x-meu1\")) } }  Step 5: Start your BFF After you have done the configuration above, you can start your BFF. Just run the command below in your project, a reminder, it needs to starts the server on port 8080 in your localhost.\nMicronaut SpringBoot $ mvn compile exec:exec  $ mvn spring-boot:run  Now that the BFF is running, to see the resulting JSON, insert the URL http://localhost:8080/action directly on your navigator. You should get the result below.\n{ \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"My Dialog\", \"message\" : \"This is a native popup!\", \"labelOk\" : \"Close\" } ","excerpt":" Use configuration Once you have finishedBeagle‚Äôs installation, your ‚Ä¶","ref":"/docs-beagle/docs/get-started/using-beagle/backend/","title":"Backend"},{"body":" Configura√ß√µes de uso Quando voc√™ finalizar a instala√ß√£o do Beagle, seu BFF estar√° com a configura√ß√£o padr√£o de uso.\nCORS Configura√ß√£o obrigat√≥ria apenas para usar seu BFF com front-end web.  Este processo √© feito de acordo com sua tecnologia de backend e, por isso, recomendamos que voc√™ cheque a documenta√ß√£o da ferramenta escolhida para ver que diz a respeito disso.\nSe voc√™ estiver usando um de nossos starters, segue os links das documenta√ß√µes dos frameworks sobre o CORS:\n Micronaut Spring  Disponibilizamos uma constante, BEAGLE_EXPOSED_HEADERS, contendo uma lista dos nomes das headers que o pr√≥prio Beagle precisa para poder expor na sua configura√ß√£o de CORS.\nUm exemplo pr√°tico de BFF Passo 1: Criar um servi√ßo Micronaut SpringBoot Para come√ßar, voc√™ deve criar uma classe para configurar um servi√ßo. O processo √© bem simples basta:\n Criar uma classe e nome√°-la como MyService Anot√°-la com o @Singleton  No exemplo abaixo, voc√™ confere o resultado que deve aparecer na sua tela:\nimport javax.inject.Singleton @Singleton class MyService { fun createAction(): Action = Alert( title = \"My Dialog\", message = \"This is a native popup!\", labelOk= \"Close\" ) fun createScreen(): Screen = Screen(child = this.createWidget()) fun createScreenBuilder(): ScreenBuilder = MyScreenBuilder(this.createWidget()) fun createWidget(): Widget = Text( text = \"Hello, world!\", alignment = TextAlignment.CENTER, textColor = \"#505050\" ) } private class MyScreenBuilder( private val component: ServerDrivenComponent ) : ScreenBuilder { override fun build() = Screen(child = this.component) }  Para come√ßar, voc√™ deve criar uma classe para configurar um servi√ßo. O processo √© bem simples basta:\n Criar uma classe e nome√°-la como MyService Anot√°-la com o @Service  No exemplo abaixo, voc√™ confere o resultado que deve aparecer na sua tela:\nimport javax.inject.Singleton @Service class MyService { fun createAction(): Action = Alert( title = \"My Dialog\", message = \"This is a native popup!\", labelOk= \"Close\" ) fun createScreen(): Screen = Screen(child = this.createWidget()) fun createScreenBuilder(): ScreenBuilder = MyScreenBuilder(this.createWidget()) fun createWidget(): Widget = Text( text = \"Hello, world!\", alignment = TextAlignment.CENTER, textColor = \"#505050\" ) } private class MyScreenBuilder( private val component: ServerDrivenComponent ) : ScreenBuilder { override fun build() = Screen(child = this.component) }  Passo 2: Criar um Controller Micronaut SpringBoot O pr√≥ximo passo √© criar uma classe Controller para expor nossos componentes via REST API. Esta classe ser anotada com @Controller.\nAl√©m disso, a classe tamb√©m deve receber um MyService via construtor prim√°rio para que o Micronaut fa√ßa automaticamente a inje√ß√£o da depend√™ncia para voc√™.\nOs endpoints s√£o configurados com anota√ß√µes seguindo o m√©todo HTTP (por exemplo, @Get para HTTP GET). Eles recebem ainda uma string que define o seu path.\nPara configurar sua classe, siga o exemplo abaixo. Lembre de nomear o arquivo como MyController para que voc√™ possa simplesmente copiar e colar este exemplo.\n{% code title=\"\" %}}\nimport io.micronaut.http.annotation.Controller import io.micronaut.http.annotation.Get @Controller class MyController(private val myService: MyService) { @Get(\"/action\") fun getAction() = myService.createAction() @Get(\"/screen\") fun getScreen() = myService.createScreen() @Get(\"/builder\") fun getScreenBuilder() = myService.createScreenBuilder() @Get(\"/widget\") fun getWidget() = myService.createWidget() }  Feito isso, o pr√≥ximo passo √© criar uma classe Controller para expor nossos componentes via REST API. Esta classe ser anotada com @RestController.\nAl√©m disso, ela tamb√©m deve receber MyService via um construtor prim√°rio para que o Spring automaticamente fa√ßa a inje√ß√£o de depend√™ncia para voc√™.\nOs endpoints s√£o configurados com anota√ß√µes seguindo o m√©todo HTTP (por exemplo @Get para HTTP GET). Eles recebem uma string que define o seu path.\nPara configurar sua classe, siga o exemplo abaixo. Lembre de nomear o arquivo como MyController para que voc√™ possa simplesmente copiar e colar este exemplo:\nimport org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController @RestController class MyController(private val myService: MyService) { @GetMapping(\"/action\") fun getAction() = myService.createAction() @GetMapping(\"/screen\") fun getScreen() = myService.createScreen() @GetMapping(\"/builder\") fun getScreenBuilder() = myService.createScreenBuilder() @GetMapping(\"/widget\") fun getWidget() = myService.createWidget() }  Passo 3: Configurar o BFF Voc√™ pode configurar cache e serializa√ß√£o com as linhas abaixo, adicionando elas no seu application.properties.\nMicronaut SpringBoot O cache √© configurado para incluir os endpoints /screen e /widget. O TTL para o endpoint /screen √© configurado para 50 segundos.\nbeagle.cache.endpoint.include=/screen,/widget beagle.cache.endpoint.ttl./screen=50s jackson.serializationInclusion=NON_NULL jackson.serialization.indentOutput=true  O cache √© configurado para excluir o endpoint /action.\nbeagle.cache.endpoint.exclude=/action spring.jackson.default-property-inclusion=NON_NULL spring.jackson.serialization.indent-output=true  A serializa√ß√£o √© configurada para ignorar valores que s√£o null e formatar o JSON para facilitar leitura.\nPasso 4: Configurar o CORS Configura√ß√£o obrigat√≥ria apenas para usar o BFF com frontend web  Micronaut SpringBoot Voc√™ pode configurar CORS com as linhas abaixo, adicionando elas no seu application.properties.\nAqui CORS √© habilitado com valores padr√µes para v√°rios detalhes, deixando-os muito permissivos. Nossa header de cache √© exposta.\nmicronaut.server.cors.enabled=true micronaut.server.cors.configurations.beagle.exposedHeaders=beagle-hash  Voc√™ pode configurar CORS com as classes abaixo, que precisam implementar a interface WebMvcConfigurer do Spring, sobrepondo o m√©todo addCorsMappings.\nAqui CORS √© configurado para todos os endpoints com valores padr√µes para v√°rios detalhes, deixando-os muito permissivos. Nossa header de cache √© exposta usando a constante.\nimport org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration open class CorsConfig : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(\"/**\").exposedHeaders(*BEAGLE_EXPOSED_HEADERS) } }  Use uma configura√ß√£o permissiva como essa apenas em ambiente local de desenvolvimento. Ela elimina todos os benef√≠cios de seguran√ßa do CORS.  Configurando mais granularmente, temos aqui CORS habilitado com meusite.com.br como origem permitida; GET, PUT, POST como m√©todos permitidos; Cache-control como header permitida; e beagle-hash, x-meu1 como header expostas.\nMicronaut SpringBoot micronaut.server.cors.enabled=true micronaut.server.cors.configurations.meu.allowedOrigins=meusite.com.br micronaut.server.cors.configurations.meu.allowedMethods=GET,PUT,POST micronaut.server.cors.configurations.meu.allowedHeaders=Cache-Control micronaut.server.cors.configurations.meu.exposedHeaders=beagle-hash,x-meu1  import org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration open class CorsConfig : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(\"/**\") .allowedOrigins(\"mywebsite.com\") .allowedMethods(\"GET,PUT,POST\") .allowedHeaders(\"Cache-Control\") .exposedHeaders(*(BEAGLE_EXPOSED_HEADERS + \"x-meu1\")) } }  Passo 5: Iniciar o BFF Depois de realizar as configura√ß√µes acima, voc√™ j√° pode iniciar seu BFF. Para isso, basta usar o comando abaixo em seu projeto, lembrando que ele deve come√ßar o servidor na porta 8080 em seu localhost.\nMicronaut SpringBoot $ mvn compile exec:exec  $ mvn spring-boot:run  Agora que seu BFF est√° executando, para ver o JSON resultante, insira a URL http://localhost:8080/action direto no seu navegador e deve obter o resultado abaixo.\n{ \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"My Dialog\", \"message\" : \"This is a native popup!\", \"labelOk\" : \"Close\" } ","excerpt":" Configura√ß√µes de uso Quando voc√™ finalizar a instala√ß√£o do Beagle, ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/backend/","title":"Backend"},{"body":" You can see blow some practical cases to you use Beagle on your project:\n","excerpt":" You can see blow some practical cases to you use Beagle on your ‚Ä¶","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/","title":"Creating a project from scratch"},{"body":" Confira abaixo quais cases pr√°ticos voc√™ pode usar no seu projeto com Beagle:\n","excerpt":" Confira abaixo quais cases pr√°ticos voc√™ pode usar no seu projeto com ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/","title":"Criando um projeto do zero"},{"body":" Starting an Android project For this practical example, we‚Äôll use Android Studio IDE. In case you still don‚Äôt have it installed, just access on official Android website and follow the instructions.\nAfter you installed the program, follow the steps below:\nStep 1: Open Android Studio and click on Start a new Android Studio project.\nStep 2: Choose the Empty Activity option and click on next.\nStep 3Ô∏è: On this page, we should list some important informations:\n Inform your project‚Äôs name. On this example, we‚Äôll call BeagleApp. Choose which language you‚Äôll use. For Beagle, we should go withKotlin. Choose SDK minimum 19, because a lower SDK won‚Äôt be compatible. Define a package and a Save location according to your preference. Click on Next.  Step 4Ô∏è: After you made the previous configurations, Android will take some time to build the project because it will be synchronizing all the initials dependencies to initialize the project\nOnce the initialization is done, you will see this page:\nWell done, your project was created on Android! Now, you will need to configure Beagle following the next steps.  Configuring Beagle Step 1: Define the dependencies To start, you have to configure Beagle‚Äôs dependencies on your repository. This can be done using the configurations below and downloading Beagle‚Äôs library.\n Open your project on Android Studio. Search for Graddle scripts file on the project. On this file, there are two files gradle name. Open the first one named.build.graddle(project:Beagle). Search for allprojects code block and configure Maven credentials as you see in the list below:  // Add it in your root build.gradle at the end of repositories: allprojects { repositories { google() jcenter() // \u003c 1.1.0  maven { url 'https://dl.bintray.com/zupit/repo'  } // \u003e= 1.1.0  mavenCentral() } }  Close build.graddle(project:Beagle) file.  Once you made it, we should include kapt plugin and Beagle as dependencies on dependency manager. To do so, follow these instructions:\n Open thebuild.graddle(Module:app) file  Notice that some plugins are already listed on the file‚Äôs beginning arquivo as it shows the image below:\n Then, add the line_apply plugin: 'kotlin-kapt'_  After that, you need to add some dependencies:\n Search for this file that is moving in dependencies { }code block. Add a ext.beagle_version variable on the top (in this case, out of) the dependencies scope  The current release version of Beagle is:    Copy and paste the lines below inside your dependencies:\n implementation ‚Äúbr.com.zup.beagle:android:$beagle_version‚Äù kapt ‚Äúbr.com.zup.beagle:android-processor:$beagle_version‚Äù  // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" }  Insert the Beagle‚Äôs release version on the place of${beagle.version}, in other words, put the Beagle‚Äôs version highlighted in blue badge above without the v caracter.\nFor example: undefined-ext.beagle.version = \"0.2.8\"\n At the end of these configurations, your file must be like this:\nStep 2: Configure the Android Manifest file The next step is to update your Android Manifest project by adding a few lines to the file:\n INTERNET‚Äôs permission so your application can be able to access internet. \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e  If you find difficulties to find this or another file, just use Android Studios search bar.\nTo enable it, press**SHIFT**button twice and the search interface will appear. Once you made it, just just have to type AndroidManifest and Android Studio will find it.\n \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication ... android:usesCleartextTraffic=\"true\" ... Let this file open because we‚Äôll use it again in another moment.\n The usesCleartextTraffic: Indicates with the app intends to use cleartext network traffic, HTTP. The default value for apps that target API level 27 or lower is ‚Äútrue‚Äù. Apps that target API level 28 or higher default to ‚Äúfalse‚Äù. The attribute android:usesCleartextTraffic=\"true\" inside \u003capplication\u003etag is used to communicate with the local BFF. Them if you intent to debug the project using a local BFF you can use this as an easy configuration step. Although, if you plan to turn this example into a release application, we recomend you using the networkSecurityConfig which you can configure using android developers page instructions.   Passo 3: Create an AppBeagleConfig For the next steps, you should create a AppBeagleConfig class, that is part of Beagle‚Äôs installation and it‚Äôs responsible to register some important configurations.\nWhen you create the call, we should guarantee that it‚Äôs configured in this way:\n Noted with @BeagleComponent And extending BeagleConfigclass.  To create AppBeagleConfig, follow these steps:\n First, we create a package with all configurations' files. Then, click with the right button on the main package of your project and click on new \u003e package __like in the image below:  Even though you can name the file as you want to, we‚Äôll recommend for this tutorial that you use the namebeagle.\n3. Click with the right button on beagle's package and click on **new\u0026gt;Kotlin File/Class**  __4. __Name it as AppBeagleConfig and then press ENTER\nCopy and paste the configurations below on AppBeagleConfig file you just created. Notice that it will implement two attributes: baseUrl and environment.   The baseUrl returns the basis URL of your environment. The**environment** returns the _current build state_ of your application. **isLoggingEnabled**returns the application‚Äôs log view The cache manager configuration.  import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.setup.BeagleConfig import br.com.zup.beagle.android.setup.Cache import br.com.zup.beagle.android.setup.Environment @BeagleComponent class AppBeagleConfig : BeagleConfig { override val baseUrl: String get() = \"http://10.0.2.2:8080\" // return the base url based on your environment  override val environment: Environment get() = Environment.DEBUG // return the current build state of your app  override val isLoggingEnabled: Boolean = true override val cache: Cache get() = Cache( enabled = true, // If true, we will cache data on disk and memory.  maxAge = 300, // Time in seconds that memory cache will live.  memoryMaximumCapacity = 15 // Memory LRU cache size. It represents number of screens that will be in memory.  ) // Cache management configuration }  At this tutorial point, we will test our Server-Driven screens on local host because it‚Äôs important that our baseURL be local.\nNow, Beagle expects that your@BeagleComponent classes must have only empty constructors.\n Step 4: Create AppBeagleActivity You will have to deal with the activities that will be generated through server-driven. That‚Äôs the reason why it‚Äôs necessary to implement an Activity to manage them. For this example, we‚Äôll name it asAppBeagleActivity.\nThis file is part of Beagle‚Äôs usage configuration and must be implemented, at least once, so Beagle can normally work.\nWhen you create AppBeagleActivity, remember to note it as BeagleComponent and to extend it toBeagleActivity class.\nIt‚Äôs very important to ensure that this activity is registered on Android Manifest. Make it right after you create the activity.  Follow the steps below to create AppBeagleActivity, including .xml file:\n Click with the right button on Beagle‚Äôs package and click on New\u003eActivity\u003eEmpty Activity  Name it as AppBeagleActivity for the Activity and click on finish.  From now on, Beagle will use this activity every time to load the screen‚Äôs informations received from backend on your application‚Äôs frontend.  We left a configuration example below so you just copy and paste.\n First, find this activity layout. It‚Äôs probably onRES \u003e LAYOUT \u003e with the name of activity_app_beagle.xml Copy and paste the .xml content below removing any previous content:  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/custom_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cFrameLayout android:id=\"@+id/server_driven_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_gravity=\"center\" android:visibility=\"gone\"/\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e  Now open AppBeagleActitivity.kt file and configure as it shows below:  @BeagleComponent class AppBeagleActivity : BeagleActivity() { private val progressBar: ProgressBar by lazy { findViewById\u003cProgressBar\u003e(R.id.progress_bar) } private val mToolbar: Toolbar by lazy { findViewById\u003cToolbar\u003e(R.id.custom_toolbar) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_app_beagle) } override fun getServerDrivenContainerId(): Int = R.id.server_driven_container override fun getToolbar(): Toolbar = mToolbar override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { when (state) { is ServerDrivenState.Started -\u003e { progressBar.visibility = View.VISIBLE } is ServerDrivenState.Finished -\u003e { progressBar.visibility = View.GONE } is ServerDrivenState.Error -\u003e { Toast.makeText(this, \"Error\", Toast.LENGTH_LONG).show() } } } }  At this point, it‚Äôs essential that you remove theActionBar pattern of this activity because, from now on, Beagle will manage the ActionBar/Toolbar.  To make this configuration, you must change your BeagleActivity‚Äôs theme. Go to Resources folder on your Android Studio‚Äôs application and open theSTYLE file. Then, just change your AppTheme like the example below:\n\u003cresources\u003e \u003c!-- Beagle Activity theme. --\u003e \u003cstyle name=\"MyTheme\" parent=\"Theme.AppCompat.NoActionBar\"\u003e Step 5: Initialize Beagle and the Design System What is Design System?\nFor more information, see section Design System with Beagle Android.\n √â o design system que guarda os registros dos componentes de estilo criados no frontend e √© assim que sua aplica√ß√£o Android ‚Äúsaber√°‚Äù qual componente de estilo deve aplicar a cada elemento de uma tela Server-Driven. √â na tela server driven que os elementos visuais (views) s√£o utilizados na constru√ß√£o da sua tela.\nEmbora voc√™ possa cri√°-lo agora se quiser, n√£o √© necess√°rio para as configura√ß√µes iniciais, para que voc√™ possa testar logo o Beagle! Voc√™ pode prosseguir sem configur√°-lo. Para mais informa√ß√µes sobre Design System no Beagle para Android.\n Now , you must initialize your Application so Beagle can manage the other configuration‚Äôs files. To do so, just click onMake project (HAMMER symbol) or use the command CTRL + F9.\nWhen it‚Äôs initialized, Beagle will automatically create a BeagleSetup file that will be in the folder with the generated files, like in the image below:\nStep 6: Create an AppApplication class On this step, you need to create aKOTLIN class that extends to the Applicationclass. For this example, we‚Äôll name it asAppApplication.\nIt‚Äôs necessary to make some configurations on this folder so it can BeagleSetup().init(this) function on your onCreate method. Follow these steps:\n Click with the right button on your project‚Äôs main package (beagleapp) and choose:  new \u003e Kotlin file/class Name the file as AppApplication and press enter Configure the file as in the example below:    class AppApplication: Application() { override fun onCreate() { super.onCreate() BeagleSetup().init(this) } } To finish this configuration, you must state the class on the AndroidManifest we created in the beginning.  The name of yourapplication now it‚Äôs the same of the class you created. Update the Android Manifest as it‚Äôs indicated below:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication android:name=\".AppApplication\" ...  Well done, your Android application is configured and ready to use Beagle!  All you have to do now is set up a backend to answer your application‚Äôs requests. Once you made this configuration, start your application and you‚Äôll see your first server-driven screen!\nStep 7: Display your Server-Driven Screen It‚Äôs very simple to show a Server-Driven screen. Now that all Beagle‚Äôs configuration is done, you just have to follow these steps:\n Open the file MainActivity.kt State the intent as listed below. It will define the address of screen‚Äôs informations on the backend you configured. Copy and paste the intent listed below on onCreate method.  val intent = this.newServerDrivenIntent\u003cAppBeagleActivity\u003e(ScreenRequest(\"/screen\")) startActivity(intent) finish()  YourMainActivity.kt must be like this:  Now you just have to click on Run app and check out your emulator‚Äôs screen!\nYou will see this screen:\nWell done, you created your first screen with Beagle! üéâ  ","excerpt":" Starting an Android project For this practical example, we‚Äôll use ‚Ä¶","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/android/","title":"Android"},{"body":" Iniciando um projeto Android Para este exemplo pr√°tico, utilizaremos o Android Studio IDE. Caso voc√™ ainda n√£o o tenha instalado, basta acessar no site oficial do Android e seguir as instru√ß√µes.\nDepois de ter instalado o programa, siga os passos abaixo:\nPasso 1: Abra o Android Studio e clique em Start a new Android Studio project.\nPasso 2: Selecione a op√ß√£o Empty Activity e clique em next.\nPasso 3Ô∏è: Nesta p√°gina, devemos listar algumas informa√ß√µes importantes:\n Informe o nome do seu projeto. Neste exemplo, chamaremos de BeagleApp. Selecione qual linguagem utilizar√°. Para o Beagle, devemos utilizar oKotlin. Selecione o SDK m√≠nimo 19, j√° que qualquer SDK menor que este n√£o ser√° compat√≠vel. Defina o package e a Save location de acordo com sua prefer√™ncia. Clique em Next.  Passo 4Ô∏è: Feitas as configura√ß√µes anteriores, o Android levar√° um tempo pra construir o projeto porque estar√° sincronizando todas as depend√™ncias inicias para inicializar o projeto\nQuando a inicializa√ß√£o for conclu√≠da, voc√™ ver√° esta p√°gina:\nParab√©ns, seu projeto foi criado no Android! Agora, voc√™ precisar√° configurar o Beagle, de acordo com os passos a seguir.  Configurando o Beagle Passo 1: Definir as depend√™ncias Para come√ßar, voc√™ precisa configurar as depend√™ncias do Beagle no seu reposit√≥rio. Isso pode ser feito utilizando as configura√ß√µes abaixo e fazendo o download da biblioteca do Beagle.\n Abra o seu projeto no Android Studio. Localize o arquivo Graddle scripts no projeto. Nele existem dois arquivos do com o nome gradle. Abra o primeiro cujo nome √© build.graddle(project:Beagle) Procure o bloco de c√≥digo allprojects e configure as credenciais do Maven como listadas abaixo.  // Add it in your root build.gradle at the end of repositories: allprojects { repositories { google() jcenter() // \u003c 1.1.0  maven { url 'https://dl.bintray.com/zupit/repo'  } // \u003e= 1.1.0  mavenCentral() } }  Feche o arquivo build.graddle(project:Beagle)  Feito isso, devemos incluir o kapt plugin e o Beagle como depend√™ncias no dependency manager. Para isso, siga estas instru√ß√µes:\n Abra o arquivo build.graddle(Module:app)  Perceba que alguns plugins j√° est√£o listados no come√ßo desse arquivo como mostrado na figura abaixo\n Em seguida, adicione a linha_apply plugin: 'kotlin-kapt'_  Depois disso, voc√™ precisa adicionar algumas depend√™ncias. Para isso:\n Procure neste arquivo que est√° mexendo o bloco de c√≥digo dependencies { }: Adicione a vari√°vel ext.beagle_version logo acima (no caso, fora) do escopo das depend√™ncias  Vers√£o atual do Beagle    Copie e cole as linhas abaixo dentro das depend√™ncias :\n implementation ‚Äúbr.com.zup.beagle:android:$beagle_version‚Äù kapt ‚Äúbr.com.zup.beagle:android-processor:$beagle_version‚Äù  // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" }  Insira a vers√£o de release do Beagle no lugar de ${beagle.version}, ou seja, coloque a vers√£o do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os n√∫meros de vers√£o.\nPor exemplo: undefined-ext.beagle.version = \"0.2.8\"\n Ao final destas configura√ß√µes, o seu arquivo dever√° estar assim:\n Passo 2: Configurar o Android Manifest O pr√≥ximo passo √© atualizar o seu projeto no Android Manifest adicionando algumas linhas a este arquivo:\n A permiss√£o de INTERNET para que sua aplica√ß√£o seja capaz de acessar a internet. \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e  Se voc√™ tiver dificuldade para encontrar este ou qualquer arquivo, basta usar a ferramenta de busca do Android Studio.\nPara habilit√°-la, aperte o bot√£o**SHIFT**do seu teclado duas vezes e a interface de busca aparecer√° . Feito isso, √© s√≥ digitar AndroidManifest e o Android Studio o localizar√°.\n \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication ... android:usesCleartextTraffic=\"true\" ... Uma dica √© deixar este arquivo aberto porque vamos us√°-lo de novo em outro momento.\n O**usesCleartextTraffic:** indica que o aplicativo pretende usar o tr√°fego de rede de texto n√£o criptografado, HTTP. O valor padr√£o para aplicativos que visam o n√≠vel de API 27 ou inferior √© **true**. Os aplicativos que t√™m como alvo o n√≠vel de API 28 ou superior s√£o padronizados como **false**. O atributo android: usesCleartextTraffic = \"true\" dentro da tag \u003capplication\u003e √© usado para se comunicar com o BFF local. Se voc√™ pretende depurar o projeto usando um BFF local, voc√™ pode usar essa configura√ß√£o como uma etapa de configura√ß√£o r√°pida. No entanto, se voc√™ planeja transformar este exemplo em um aplicativo para release, recomendamos que voc√™ use o networkSecurityConfig, que voc√™ pode configurar usando as instru√ß√µes na p√°gina de desenvolvedores do Android.   Passo 3: Criar o AppBeagleConfig Em um pr√≥ximo passos, voc√™ deve criar uma classe chamada AppBeagleConfig. Ela faz parte das configura√ß√µes iniciais do Beagle e √© nela que vamos registrar algumas configura√ß√µes importantes.\nAo cri√°-la, devemos garantir que ela esteja configurada da seguinte forma:\n Anotada com o @BeagleComponent E deve estender (extend) da classeBeagleConfig  Para criar o AppBeagleConfig, siga estes passos:\n Primeiro vamos criar o pacote que conter√° nossos arquivos de configura√ß√£o. Clique com bot√£o direito do mouse no pacote principal do seu projeto e click em new \u003e package __conforme a figura abaixo:  Embora voc√™ possa nome√°-lo como preferir, sugerimos que para este tutorial voc√™ use o nomebeagle\n3. Clique com o bot√£o direito do mouse no pacote beagle e clique em **new\u0026gt;Kotlin File/Class**  __4. __Nomeie como AppBeagleConfig e pressione ENTER\nCopie e cole as configura√ß√µes abaixo no arquivo AppBeagleConfig que acabou de criar. Perceba que ele implementar√° os atributos: baseUrl, environment, isLoggingEnabled, cache.   O baseUrl retorna a URL base do seu ambiente. O**environment** retorna o _current build state_ da sua aplica√ß√£o. O **isLoggingEnabled**retorna a visualiza√ß√£o de log da aplica√ß√£o. O cache configura√ß√£o de gerenciamento de cache.  import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.setup.BeagleConfig import br.com.zup.beagle.android.setup.Cache import br.com.zup.beagle.android.setup.Environment @BeagleComponent class AppBeagleConfig : BeagleConfig { override val baseUrl: String get() = \"http://10.0.2.2:8080\" // return the base url based on your environment  override val environment: Environment get() = Environment.DEBUG // return the current build state of your app  override val isLoggingEnabled: Boolean = true override val cache: Cache get() = Cache( enabled = true, // If true, we will cache data on disk and memory.  maxAge = 300, // Time in seconds that memory cache will live.  memoryMaximumCapacity = 15 // Memory LRU cache size. It represents number of screens that will be in memory.  ) // Cache management configuration }  A partir deste ponto do tutorial, iremos testar nossas telas Server-Driven usando o local host. Por isso, √© importante que nossa**baseURL** seja o seu local host.\nOutro ponto de aten√ß√£o √© que, neste momento, o Beagle espera que classes anotadas com @BeagleComponent tenham seus construtores vazios.\n Passo 4: Criar o AppBeagleActivity Voc√™ precisar√° lidar com as activities que ser√£o geradas via server-driven. Por isso, √© necess√°rio implementar uma Activity para gerenci√°-las. Para este exemplo, vamos nome√°-la AppBeagleActivity.\nEste arquivo faz parte da configura√ß√£o de uso do Beagle e deve ser implementado pelo menos uma vez para que ela opere normalmente.\nQuando for criar o AppBeagleActivity, lembre-se de anot√°-la com BeagleComponent e estend√™-la para classeBeagleActivity.\nVale lembrar que √© muito importante garantir que essa activity esteja registrada no Android Manifest. Fa√ßa isso assim que cri√°-la.  Siga os passos abaixo para criar o AppBeagleActivity, incluindo o arquivo .xml:\n Clique com o bot√£o direito do mouse no pacote Beagle e clique em New\u003eActivity\u003eEmpty Activity  D√™ o nome de AppBeagleActivity para a Activity e clique em finish.  A partir da√≠, o Beagle ir√° utilizar esta activity sempre que carregar as informa√ß√µes das tela recebidas do backend no frontend da sua aplica√ß√£o.  Deixamos um exemplo abaixo j√° configurado para voc√™ copiar e colar.\n Primeiro localize o layout dessa activity. Ela provavelmente estar√° emRES \u003e LAYOUT \u003e com o nome de activity_app_beagle.xml Copie e cole o conte√∫do abaixo .xml removendo qualquer conte√∫do anterior:  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/custom_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cFrameLayout android:id=\"@+id/server_driven_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_gravity=\"center\" android:visibility=\"gone\"/\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e  Agora abra o arquivo AppBeagleActitivity.kt e configure como definido abaixo:  @BeagleComponent class AppBeagleActivity : BeagleActivity() { private val progressBar: ProgressBar by lazy { findViewById\u003cProgressBar\u003e(R.id.progress_bar) } private val mToolbar: Toolbar by lazy { findViewById\u003cToolbar\u003e(R.id.custom_toolbar) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_app_beagle) } override fun getServerDrivenContainerId(): Int = R.id.server_driven_container override fun getToolbar(): Toolbar = mToolbar override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { when (state) { is ServerDrivenState.Started -\u003e { progressBar.visibility = View.VISIBLE } is ServerDrivenState.Finished -\u003e { progressBar.visibility = View.GONE } is ServerDrivenState.Error -\u003e { Toast.makeText(this, \"Error\", Toast.LENGTH_LONG).show() } } } }  Neste ponto do tutorial, √© essencial que voc√™ remova aActionBar padr√£o dessa activity porque, a partir deste momento, ser√° o Beagle que ir√° gerenciar ActionBar/Toolbar.  Para realizar esta configura√ß√£o, voc√™ deve mudar o seu BeagleActivity's theme. V√° at√© a pasta Resources na sua aplica√ß√£o do Android Studio e abra o arquivo STYLE . Depois, √© s√≥ Modificar o seu AppTheme como no exemplo abaixo:\n\u003cresources\u003e \u003c!-- Beagle Activity theme. --\u003e \u003cstyle name=\"MyTheme\" parent=\"Theme.AppCompat.NoActionBar\"\u003e Passo 5: Inicializar o Beagle e o Design System Importante! O que √© o Design System?\n√â o design system que guarda os registros dos componentes de estilo criados no frontend e √© assim que sua aplica√ß√£o Android ‚Äúsaber√°‚Äù qual componente de estilo deve aplicar a cada elemento de uma tela Server-Driven. √â na tela server driven que os elementos visuais (views) s√£o utilizados na constru√ß√£o da sua tela.\nEmbora voc√™ possa cri√°-lo agora se quiser, n√£o √© necess√°rio para as configura√ß√µes iniciais, para que voc√™ possa testar logo o Beagle! Voc√™ pode prosseguir sem configur√°-lo. Mas saiba que o Design System √© o pulm√£o da aplica√ß√£o server-driven!\nDesign System no Beagle para Android.\n Agora, voc√™ deve inicializar sua Application para que o Beagle gere os outros arquivos de configura√ß√£o que necessita. Para isso, basta clicar emMake project (s√≠mbolo de MARTELO) ou use o comando CTRL + F9.\nAo ser inicializado, o Beagle ir√° criar automaticamente o arquivo BeagleSetup, que estar√° na pasta de arquivos gerados como mostrado na figura abaixo:\nPasso 6: Criar a classe AppApplication Nesta etapa, voc√™ precisa criar uma classeKOTLIN que estenda da classe Application. Neste exemplo, vamos nome√°-la de AppApplication.\n√â preciso realizar algumas configura√ß√µes para que a pasta cumpra seu papel de chamar a fun√ß√£o BeagleSetup().init(this) em seu m√©todo onCreate. Siga os passos abaixo:\n Clique com o bot√£o direito do mouse no pacote principal do seu projeto (beagleapp) e selecione:  new \u003e Kotlin file/class Nomeie o arquivo como AppApplication e aperte enter Configure-a como no exemplo abaixo:    class AppApplication: Application() { override fun onCreate() { super.onCreate() BeagleSetup().init(this) } } Para finalizar a implementa√ß√£o, voc√™ deve declarar a classe no Android Manifest que criamos no come√ßo e que j√° est√° aberto.  O nome da suaapplication agora √© o nome desta classe que voc√™ criou. Fa√ßa o update do Android Manifest como indicado abaixo:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication android:name=\".beagle.AppApplication\" ...  Pronto, a sua aplica√ß√£o Android est√° configurada e preparada para usar o Beagle!  Tudo o que voc√™ precisa agora √© configurar um backend para responder as requisi√ß√µes da sua aplica√ß√£o. Feita esta configura√ß√£o, inicie a sua aplica√ß√£o e voc√™ ver√° sua primeira tela server-driven!\nPasso 7: Exibir sua Tela Server-Driven √â muito simples exibir uma tela Server-Driven. Agora que toda a configura√ß√£o do Beagle est√° pronta, voc√™ precisa seguir estes passos:\n Abra o arquivo MainActivity.kt Declare o intent como listado abaixo. Ele vai definir o endere√ßo que tem as informa√ß√µes da sua tela no backend que voc√™ configurou. Copie e cole o intent listado abaixo no m√©todo onCreate.  val intent = this.newServerDrivenIntent\u003cAppBeagleActivity\u003e(ScreenRequest(\"/screen\")) startActivity(intent) finish()  SuaMainActivity.kt deve ficar assim:  Agora basta somente clicar em Run app e checar sua tela no emulador!\nVoc√™ ver√° esta tela:\nParab√©ns, voc√™ criou sua primeira tela com Beagle! üéâ  ","excerpt":" Iniciando um projeto Android Para este exemplo pr√°tico, utilizaremos ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-android/","title":"Case Android"},{"body":" Criando um Design System No exemplo pr√°tico da p√°gina ‚ÄúCriando um projeto com Beagle para Android‚Äù, voc√™ pode conferir como fazer a implementa√ß√£o do Beagle para criar uma tela server-driven simples, com apenas 2 textos: 1 t√≠tulo e 1 par√°grafo.\nNeste tutorial, a ideia √© avan√ßar a partir do projeto anterior para criar um Design System na sua biblioteca do Beagle. Os exemplos que ilustrar√£o o passo a passo est√£o nestes sample codes que voc√™ encontra no nosso reposit√≥rio.\nO Design System que iremos configurar vai permitir que voc√™ customize alguns componentes do Beagle, como por exemplo:\n Text Button Toolbar TabBar Entre outros.  Al√©m disso, ser√° poss√≠vel customizar os 2 componentes de textos que criamos na primeira tela feita no tutorial anterior.\nContexto Com o Design System deste tutorial, voc√™ poder√° registrar estilos (styles) como fontes, cores, tamanhos de fonte e componentes customizados.\nDe modo geral, define-se o design system de uma aplica√ß√£o ao criar uma classe que implemente a sua interface. A partir dela, implementa-se todos os m√©todos que sobrescrevem as fun√ß√µes respons√°vel por aplicar ‚Äúestilos‚Äù aos componentes. √â poss√≠vel declarar, dentro de uma fun√ß√£o, N estilos ou mesmo nenhum (salvo algumas exce√ß√µes).\nNo caso do Beagle, cada estilo deve ser referenciado de forma que cada um tenha um nome para ser facilmente identificado.\nExemplo No exemplo abaixo, temos o m√©todo image que est√° registrando v√°rias imagens que est√£o sendo utilizadas para construir uma p√°gina a partir do backend.\nPerceba que nela utilizamos um operador when para designar os estilos, ou seja, o primeiro valor √© listado como uma string que identifica o componente de estilo no Beagle (semelhante a uma rela√ß√£o de chave/valor) e com umaArrow Function -\u003e listamos o estilo do componente (id do estilo no Android). A l√≥gica aqui se assemelha a um par ‚Äúchave/valor‚Äù.\nCom a fun√ß√£o estabelecida desta forma, o operador else conter√° um estilo ‚Äúdefault‚Äù, como demonstrado no c√≥digo abaixo.\nO trecho em amarelo mostra o ‚Äúnome do estilo‚Äù declarado no backend e recuperado no front end (Android). J√° o trecho em laranja mostra o estilo criado no Android que ser√° executado quando ‚ÄúNome do estilo‚Äù for lido no JSON informado pelo backend\nCome√ßando Vamos √† parte pr√°tica! Primeiro, voc√™ deve localizar a pasta de estilos ‚ÄúStyle‚Äù em sua IDE Android . Para fazer isso no Android Studio, clique em res \u003e values \u003e styles.\nFeito essa parte, abra o arquivo de estilos (styles) e voc√™ ver√° uma tela semelhante a abaixo. √â neste arquivo que listaremos os estilos que ser√£o aplicados nos componentes Android.\nSugerimos manter este arquivo aberto, pois vamos utiliz√°-lo mais √† frente.\nDividimos a cria√ß√£o do design system em 3 passos que ser√£o vistos a seguir:\nPasso 1: Configurar o Design System no Android O primeiro passo na cria√ß√£o de um design system √© criar uma classe para represent√°-lo.\nVale refor√ßar que o design system que criaremos faz parte do projeto que mencionamos no in√≠cio do tutorial.  Com o projeto aberto, clique na pasta beagle com o bot√£o direito do mouse e clique em new \u003e kotlin file/class. Feito isso, siga as instru√ß√µes abaixo:\n D√™ o nome de AppDesignSystem ao arquivo (ou outro nome que voc√™ preferir). Indique que esta classe deve estender de uma open class do Beagle chamada DesignSystem. Use a anota√ß√£o @BeagleComponent acima do nome da classe AppDesignSystem.  Ao fazer estes passos, j√° podemos chamar m√©todos em que vamos registrar componentes que s√£o criados no BFF. Cada m√©todo √© respons√°vel por aplicar ‚Äúestilos‚Äù aos componentes.\nNeste exemplo, vamos chamar o m√©todo textStyle.\n@BeagleComponent class AppDesignSystem: DesignSystem() { override fun textStyle(id: String): Int? { return super.textStyle(id) } } Desta forma, o open classeDesignSystem tem ao menos seis m√©todos, onde cada um deles representa um tipo de componente. Cada m√©todo dever√° ent√£o aplicar estilos aos componentes visuais que ser√£o ali registrados.\nDemonstraremos mais adiante como esses componentes e seus estilos s√£o listados e organizados dentro desses m√©todos. Por ora, vamos entender o que cada m√©todo faz:\n O m√©todo buttonStyle √© respons√°vel por aplicar estilo a componentes do tipo Bot√£o (Button). O m√©todo image √© respons√°vel registrar uma imagem para que ela possa ser referenciada em um tela server-driven. O m√©todo tabBarStyle √© respons√°vel por aplicar estilos nos componentes do tipo TabBar. O m√©todo textStyle aplica estilos nos componentes do tipo Text‚Ä¶ (perceba que usamos o plural ao falar de componentes‚Ä¶ logo logo voc√™ saber√° o porqu√™). E o m√©todo toolbarStyle respons√°vel por aplicar estilo no componenteToolbar. O m√©todo inputTextStyle responsavel por aplicar estilo no componente InputText.  Passo 2: Customizar o componente Este momento √© o ponto em que o ocorre o BFF, quando frontend se conecta ao backend.\nPara isso, voc√™ ter√° de configurar o frontend do Android e o backend do Intellij. Caso n√£o o tenha pronto, √© s√≥ baixar o exemplo de configura√ß√£o do backend e rod√°-lo.\nPara o nosso backend aqui, criamos uma pagina server-driven com 2 textos, sendo um t√≠tulo e um par√°grafo. Ela deve ficar assim quando for renderizada no frontend:\nPerceba que nossa tela √© praticamente a estrutura e conte√∫do somente. O tamanho do texto √© padr√£o e a forma carece de um estilo.\nPara atribuir um estilo a esses textos vamos recorrer a nossa tela configurada l√° no BFF:\n Abra o projeto de BFF e localize o arquivo FirstScreenBeagleBuilder.  Esse √© o arquivo que cont√©m o c√≥digo da sua primeira tela server driven, que deve estar configurada como na imagem logo abaixo.\nNela voc√™ deve perceber que constru√≠mos uma hierarquia de componentes com uma SCREEN e dois componentes do tipo TEXT.\nPara este momento do tutorial, preocupe-se apenas no que deve ser feito para que possamos aplicar um estilo aos nossos componentes.  Para adicionar um estilo a um elemento de texto, voc√™ deve listar o nome do estilo dentro do componente texto, conforme mostrado baixo. N√£o se esque√ßa de separar os componentes por uma v√≠rgula.\nSegure o bot√£o Ctrl e coloque o mouse sobre o componente Text e voc√™ ver√° a lista de atributos que esse componente pode receber aqui no back-end. Por ora, utilizaremos apenas o Style\n 2. Coloque uma virgula ap√≥s o atributo text = \"Hello Beagle\", e escreva o outro atributo que quer definir, que √© o `styleId` 3. Digite a string `‚ÄúTitle.Text.Orange‚Äù` e pronto! O estilo est√° definido para esse componente de texto.  Text( text = \"Hello Beagle\", styleId = \"Title.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( top = 16.unitReal() ), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Por enquanto, n√£o se preocupe com os outros elementos, como .applyStyle e demais configura√ß√µes. Apenas garanta que nada mais seja modificado no exemplo e procure mant√™-lo como mostramos agora.\nRepita este processo para o outro componente Text que √© um paragrafo, com a diferen√ßa de que, aqui, nomeie-o como ‚ÄúDescription.Text.Orange‚Äù  Isto √© tudo que faremos no back-end nesse momento. Voc√™ pode rodar sua aplica√ß√£o backend para que o servi√ßo fique dispon√≠vel e, em breve, voc√™ ver√° sua tela com estilo no Android.\nCaso tenha algum problema, recomendamos que fa√ßa o tutorial para implementar a instala√ß√£o desse backend.   4. Primeiro, vamos registrar tr√™s cores no arquivo color no android.   Acesse o pacote res \u003e values \u003e colors Adicione as 3 cores dentro da Tag \u003cresources\u003e\u003c/resources\u003e da seguinte forma. Digite o c√≥digo abaixo, assim criando as cores branca, preta e laranja na sua paleta de cores.  \u003ccolor name=\"colorWhite\"\u003e#FFFFFF\u003c/color\u003e \u003ccolor name=\"colorBlack\"\u003e#000000\u003c/color\u003e \u003ccolor name=\"colorOrange\"\u003e#FFA500\u003c/color\u003e Para encerrar esta etapa, crie no Android os estilos com os nomes que acabamos de atribuir aos textos l√° na tela server-driven. acesse arquivo de estilos no pacote res \u003e values \u003e styles\nVoc√™ pode fazer isso adicionando a configura√ß√£o de estilo dentro da tag \u003cresources\u003e\u003c/resources\u003e como listado abaixo. Perceba que voc√™ j√° tem alguns elementos de estilo definidos e deve adicionar mais esse. Copie e cole o c√≥digo abaixo para o texto que queremos que seja o T√≠tulo.\n\u003cstyle name=\"Title.Text.Orange\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorOrange\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"textAllCaps\"\u003etrue\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e Repare que voc√™ pode definir muito mais aspectos dentro do estilo. Isso porque todas as op√ß√µes que o Android permite podem ser configuradas nele.\n A primeira linha, define o nome do estilo como ‚ÄúTitle.Text.Orange‚Äù A segunda define a cor laranja para o texto, como listado acima A terceira define o tamanho do texto como: 20 sp A quarta define que o texto deve ser exibe todo em letras mai√∫sculas A quinta linha define que o texto ser√° em negrito  Devemos fazer o mesmo processo com o texto do par√°grafo. Para ele, criaremos o seguinte estilo: Description.Text.Orange\n\u003cstyle name=\"Description.Text.Orange\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorOrange\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e16sp\u003c/item\u003e \u003citem name=\"textAllCaps\"\u003etrue\u003c/item\u003e \u003c/style\u003e  √â uma boa pr√°tica definirmos um estilo default. No caso deste tutorial, vamos definir um para ser aplicado a textos normais.\nO objetivo √© que este valor seja aplicado no texto que chegar do backend que n√£o tiver nenhum estilo pr√©-definido.\n \u003cstyle name=\"Design.System.Text.Default\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e12sp\u003c/item\u003e \u003c/style\u003e E pronto! Nossos componentes est√£o customizados! Agora vamos √† etapa final.\nPasso 3: Registrar o componente no Design System Uma vez que voc√™ j√° tem todos os estilos criados, √© o momento de registr√°-los na nossa classe AppDesignSystem, pois √© l√° onde Beagle aplica os estilos definidos no Android Studio nas telas server-driven que voc√™ receber do backend.\nPara isso, siga estes passos:\n Abra a classeAppDesignSystem e v√° ao m√©todotextStyle. Dentro deste m√©todo, crie um operador when. Dentro dele, vamos listar todos os estilos de texto que queremos utilizar agora e depois.  Em caso de d√∫vida, veja aqui como utilizar o When.   Informe os nomes dos \"styles\" que referenciamos no backend (BFF) e o estilo criado no Android, ligando-os programaticamente.\n  No else , devemos listar o estilo o default que criamos. Siga o exemplo do codigo abaixo:\n  override fun textStyle(id: String): Int? { return when (id) { \"Title.Text.Orange\" -\u003e R.style.Title_Text_Orange \"Description.Text.Orange\" -\u003e R.style.Description_Text_Orange else -\u003e R.style.Design_System_Text_Default } } Perceba que o m√©todo textAppearance recebe uma string como par√¢metro name, que vem da nossa tela server-driven.\nNo primeiro registro, listamos o nome criado para o estilo do t√≠tulo que foi:\n ‚ÄúTitle.Text.Orange‚Äù Com uma arrow function -\u003e listamos o endere√ßo do estilo no Android, ou seja, a ID do estilo criado como normalmente fazemos no Android Studio, que √© : R.style.Title_Text_Orange.  Fa√ßa o mesmo processo no segundo registro, pois agora estamos registrando o estilo que queremos usar para par√°grafos com a descri√ß√£o que criamos na nossa p√°gina server-driven. O segundo registro deve ser:\n ‚ÄúDescription.Text.Orange‚Äù -\u003e R.style.Description_Text_Orange.  E, por fim, no par√¢metro else de nosso operador when, devemos informar o valor default que criamos para o texto. Isso significa que qualquer requisi√ß√£o de estilo por uma p√°gina server-driven que n√£o tenha um estilo definido aqui, ter√° o estilo default aplicado sobre si.\n Nestes casos, o par√¢metro else deve retornar -\u003e R.style.Design_System_Text_Default.  Com os elementos listados desta forma, voc√™ pode preparar um Design System com diversas op√ß√µes de tamanhos de textos, cores, margens. Lembrando que estes estilos podem ser criados para usar agora ou em outro momento.\nParab√©ns, o seu DesignSystem est√° pronto!\nAgora, basta executar sua aplica√ß√£o Android e sua tela apresentar√° a os estilos customizados que definimos.\n O que fazer depois de pronto? Agora que voc√™ j√° criou o seu Design System, √© poss√≠vel alterar o tamanho, cor ou testar os estilos que preferir.\nUma das grandes vantagens em utilizar uma p√°gina server-driven √© poder trabalhar com um design system maduro. Ou seja, se voc√™ altera o modo como os componentes est√£o posicionados no backend, √© poss√≠vel ‚Äúmudar sua tela‚Äù da maneira que quiser, tudo por meio do backend.\nNeste exemplo, utilizamos elementos simples de estilo para explicar o Design system, mas perceba o n√∫mero de fun√ß√µes nesta classe e, a partir da√≠, veja o qu√£o amplo um design system pode ser.\n","excerpt":" Criando um Design System No exemplo pr√°tico da p√°gina ‚ÄúCriando um ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-android/design-system-com-beagle-android/","title":"Design System com Beagle Android"},{"body":" Creating a Design System On the use example of the page creating an Android project with Beagle , you saw how to implement Beagle to create a simple server-driven screen with only 2 texts: 1 title and 1 paragraph.\nIn this tutorial, the idea is to get deeper from the previous project to create a Design System on Beagle‚Äôs library. To better illustrate the explanation, we‚Äôll use these sample codes that you can find out in our repository.\nThe Design System we will configure, it will allow you to customize some Beagle‚Äôs components, such as:\n Text Button Toolbar TabBar  Besides, it will be possible to customize the other 2 text components we created on the screen from the previous tutorial.\nContext With this Design System, you‚Äôll be able to register stylesas fonts, colors, font size and customized components.\nGenerally, we define as an application‚Äôs design system a class that implements your interface. From her, we can implement all the methods that overwrite the responsible functions to apply ‚Äústyles‚Äù on the components. Inside a function, it‚Äôs possible to state N styles or even none (except in some cases).\nOn Beagle, each style must be referenced in a way that each one has a name to be easily identified.\nExample On the example below, we have a image method that‚Äôs registering many images that are been used to build a page from backend.\nNotice that, on her, we can use the when operator to design styles, that is the first value is listed as a string that identifies Beagle‚Äôs component syle (on a similar relation key/value) and with aArrow Function -\u003e where we list the component‚Äôs style (id style on Android). Again, the logic here is similar to a pair ‚Äúkey/value‚Äù.\nWith the function already stablished, the else operator will contain a ‚Äúdefault‚Äù style, like we demonstrate on the code below:\nThe yellow highlight shows the ‚Äústyle name‚Äù stated on backend and rescued on frontend (Android) while the orange highlight shows the style created on Android and that will be executed when the JSON from backend reads the ‚ÄúStyle name‚Äù.\nGetting start Let‚Äôs go to practice! First, you have to look for a style folder named ‚ÄúStyle‚Äù on your IDE Android. To do so on Android Studio, just click on res \u003e values \u003e styles.\nOnce you made this part, open the style‚Äôs file (styles) and you‚Äôll see a screen similar to the example below. This is the file where we‚Äôll list all the styles we‚Äôre intending to apply on Android‚Äôs components.\nWe suggest you to keep this file open, because we‚Äôll use it some steps ahead.\nWe divided the design system creation in 4 steps, as we‚Äôll see now.\nStep 1: Configure the Design System for Android The first step on design system creation is to create a class to represent it.\nJust remember that the design system we‚Äôre about to create is part of the project we mentioned in the beginning.  With the project opened, click on beagle‚Äôs folder and, with the right button, click on new \u003e kotlin file/class. Once you made it, follow these instructions:\n Name your file as AppDesignSystem (or another name of your preference). Indicate that this class should extends a Beagle‚Äôs interface called DesignSystem. Use the @BeagleComponent note above the AppDesignSystemclass name.  When you follow these steps, Android will request that some functions must be implemented to be responsible to apply ‚Äústyles‚Äù to the components. After you agree to implement these methods, your screen must be like the example below:\nWith this way, the AppDesignSystem will overwrite, at least, six methods in which each one represents one component‚Äôs type. Each method will apply styles to visual components that will be registered.\nWe‚Äôll demonstrate further how these components and their styles are listed and organized inside these methods. For now, let‚Äôs understand what each method does:\n The theme method applies a theme that can be similar to the native platform. It‚Äôs the only mandatory method when we create a design system class. The buttonStyle method is responsible to apply style to Button components. The image method is responsible to register a image so that can be referenced on a server-driven screen. The tabBarStyle method is responsible to apply styles to TabBar components. The textAppearance method applies to Text components. And the toolbarStyle method responsible to apply style to Toolbar components.  When you create a Design System class, it‚Äôs necessary to have, at least, one theme method stated. The other methods can be left without implementation, as you can see in the image above.\nStep 2: Create a theme The next step is create a theme component so our Beagle‚Äôs application can use when renders our server-driven screens.\n First, let‚Äôs register three colors on the color file on Android.   Access the package res \u003e values \u003e colors Addd three colors inside the \u003cresources\u003e\u003c/resources\u003e tag. Type the code below so you can create the white, black and orange colors on your color palette.  \u003ccolor name=\"colorWhite\"\u003e#FFFFFF\u003c/color\u003e \u003ccolor name=\"colorBlack\"\u003e#000000\u003c/color\u003e \u003ccolor name=\"colorOrange\"\u003e#FFA500\u003c/color\u003e Then, let‚Äôs access the style file, like we saw before.  In case you have closed the file, you can find it inside the values package. You‚Äôll have to access the package because we‚Äôre going to create a style to our server-driven theme. To do so, click on _res \u003e values \u003e styles. _  Copy and paste the code below using the \u003cresources\u003e\u003c/resources\u003e tag.\n\u003cstyle name=\"AppThemeServerDriven\" parent=\"Theme.AppCompat.NoActionBar\"\u003e \u003c!-- Customize your theme here. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAcent\u003c/item\u003e \u003citem name=\"android:windowBackground\"\u003e@color/colorWhite\u003c/item\u003e \u003c/style\u003e Two important changes happen to this file:\nChange 1: A new theme style was created with the name AppThemeServerDriven.\nNotice that in this style , the parent must be Theme.AppCompat.NoAction bar. This detail is very important because Beagle particularly treats an action bar and controls its behavior with other method on the design system called toolbarStyle.\n__Change 2: New colors were listed inside the new esteem.\nNotice how they correspond to the items colorPrimary, colorPrimaryDark normally referenced in this way on the Android‚Äôs application pattern theme. We‚Äôre suggesting here a similar theme, but you can define how you want to. For now, let‚Äôs just keep this way.\nNow, we need to access the AppDesignSystem class, that we recently created, to register the Design System style. Considering we only have one theme, you can follow these instructions:\n Copy and paste the line and replace the theme function onAppDesignSystem class and we‚Äôre done. Your theme is configured and registered on Beagle.  override fun theme(): Int = R.style.AppThemeServerDriven Step 3: Customize a component This is the moment that occurs the BFF, when frontend connects to backend.\nTo do so, you‚Äôll have to configure Android‚Äôs frontend and Intellij‚Äôs backend. In case you haven‚Äôt this configuration done, just follow the backend‚Äôs configuration and run it.\nFor our backend here, we created a server-driven page with 2 texts: 1 title and 1 paragraph. It should be like this when rendered on frontend:\nNotice that our screen is basically structure and content. The text is on standard size and the layout doesn‚Äôt have a style.\nTo attribute a style to these texts, we‚Äôll recorrer a nossa tela configurada l√° no BFF:\n Open the BFF project and look for the FirstScreenBeagleBuilderfile.  This is the file that contains the code of your server-driven screen, that has to be configured as it shows in the image below.\nOn that image, you‚Äôll see that we built a component‚Äôs hierarchy with one SCREEN and two types of TEXT component.\nFor this point on the tutorial, just focus on what must be done to apply one style to our components.  To add a style and a text element, you should list the style‚Äôs name inside the text component, as indicated in the image below. Don‚Äôt forget to separate the components by one comma.\nHold the Ctrl button and put your mouse on the Text component so you‚Äôll see the attribute‚Äôs list that this component can receive from backend. For now, we‚Äôll only use the Style\n 2. Put a comma after the text attribute = \"Hello Beagle\", and write the another attribute you want to define, which in this case is the `style` 3. Type a `‚ÄúHelloBeagle.Text.Title‚Äù` string e we're done! The style was defined to this text component.  Text( text = \"Hello Beagle\", style = ‚ÄúHelloBeagle.Text.Title‚Äù ).applyFlex( Flex( margin = EdgeValue( top = 16.unitRal(Real) ), alignSelf = Alignment.CENTER ) ), For now, don‚Äôt worry about the other elements, like .applyFlex, and other configurations. Just make sure that there‚Äôs nothing else to be changed on the example, let‚Äôs keep it this way now.\nRepeat this process to the other Text component - the paragraph -, with the difference that, here, you will name it as ‚ÄúDesign.System.Text.Description‚Äù  This all we‚Äôre gonna do on the backend for now. You can run your backend‚Äôs application so the service be available and, soon, you‚Äôll see your styled screen on Android.\nIn case you have any problem, we recommend you to follow this tutorial to implement the backend.   2. Return to Android Studio and access again the style's file on the package **res \u0026gt; values \u0026gt; styles**.  To finish this stage, you have to create on Android the styles and names we just attributed to the texts on the server-driven screen.\nYou can do this by adding the style‚Äôs configuration inside the \u003cresources\u003e\u003c/resources\u003e tag, as its listed below. Notice that you already have some defined styles' elements and must add this one more. Copy and paste the code below with the text that we want to be our Title.\n\u003cstyle name=\"Design.System.Text.Title\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorOrange\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"textAllCaps\"\u003eTrue\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e Notice that you can define many more aspects inside the style because all the options available on Android can be configured on it.\n The first line defines the style‚Äôs name like ‚ÄúHelloBealge.Text.Title‚Äù The second defines the text‚Äôs orange color, as listed above. The third defines the text‚Äôs size, like 20 sp. The fourth defines that the text must be exhibited on caps lock. The fifth linha defines that the text will be on bold.  We should make the same process with the paragraph text. In this case, we‚Äôll create this style: Design.System.Text.Description\nIt‚Äôs a good practice to define a default style. For this tutorial, we‚Äôll define one to be applied on normal texts.\nThe objective is that this value be applied on a text that came from backend without a predefined style.\n And done! Our components are customized! Now let‚Äôs get to the final stage.\nStep 4: Register a component on Design System Once you have already all the styles created, it‚Äôs the moment to register them in our AppDesignSystem class because it‚Äôs there where Beagle applies all the defined styles on Android Studio on server-driven screens that came from backend.\nTo do so, follow these steps:\n Open the AppDesignSystem class and go to the textAppearance method. Inside this method, create a when operator. Inside it, we‚Äôll list all the text styles that we want to use now and later.  If you have any trouble on making this configuration, check out how to use When.   Infor the \"styles\" names we referenced on backend (BFF) and the style created on Android, programmatically connecting them.\n  On else , we should list the default style we created. Follow the example on the image below:\n  Notice that the textAppearance method receives a string as a nameparameter, that comes from our server-driven screen.\nOn the first register, we list the name created for the title style:\n ‚ÄúHelloBeagle.Text.Title‚Äù With a arrow function -\u003e we listed the address of the Android‚Äôs style, that is the style ID created in the same way we do on Android Studio: R.style.Design_System_Text_Title.  Repeat the same process for the second register because now we‚Äôre registering the style we want to use for the paragraphs with a description we created on our server-driven page. The second register must be:\n ‚ÄúBeagle.Text.Description‚Äù -\u003e R.style.Design_System_Text_Description.  And, finally, the else parameter of our when operator, we should inform the default we created for the text. That means that any style request for a server-driven page that doesn‚Äôt come with a predefined style, the default style will be automatically applied.\n In these cases, the else parameter must return -\u003e R.style.Design_System_Text_Default.  With the elements listed on this way, you can prepare a Design System with many options of text sizes, colors and margins. Just remember that these styles can be created to use now or in another moment.\nWell done, your Design System is ready!\nNow, you just have to execute your Android application and your screen will show the customized styles we just defined.\n What‚Äôs next? Now that you already created your Design System, it‚Äôs possible to change the size, color or even test the styles as you wish.\nOne of the biggest advantages on using a server-driven page is that you can work on a mature design system. That means if you can change the way components are positioned on the backend, it‚Äôs possible to ‚Äúchange your screen‚Äù in the way you want to, all through backend.\nOn this example, we used simple elements to explain design system, but as you could see on the number of functions on this class, the design system can be very broad.\n","excerpt":" Creating a Design System On the use example of the page creating an ‚Ä¶","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/android/design-system-with-beagle-android/","title":"Design System with Beagle Android"},{"body":" Iniciando um projeto iOS Para criar um projeto iOS no Beagle, voc√™ primeiro precisa ter o Xcode instalado. Caso ainda n√£o o tenha instalado ainda, fa√ßa o download na Mac App Store.\nAntes de come√ßar, voc√™ primeiro precisar criar um projeto no Xcode. Para isso, basta abrir o programa e nomear o seu projeto. Para este exemplo, colocaremos como Beagle Sample.\nAp√≥s criar o seu projeto, precisaremos adicionar as depend√™ncias. Para isso, usaremos o gerenciador CocoaPods.\nSe voc√™ tem alguma d√∫vida sobre como usar este gerenciador, sugerimos checar a documenta√ß√£o oficial do Cocoa Pods.  Passo 1: Configurar o Cocoa Pods Voc√™ usar√° o terminal para instalar o CocoaPods, para isto abra o terminal e digite sudo gem install cocoapods\nsudo gem install cocoapods Para configur√°-lo, navegue at√© sua pasta pelo terminal e digite o comando: pod init\npod init Depois, abra o folder do projeto usando o comando: open .\nopen . Feito isso, voc√™ deve selecionar o arquivo podfile assim como apresentado na imagem abaixo:\nAbra o arquivo e adicione as seguintes depend√™ncias:\ntarget 'Beagle Sample' do pod 'Beagle' pod 'YogaKit', :git =\u003e 'https://github.com/ZupIT/YogaKit' end Abra novamente o terminal e digite o comando: pod install para que as depend√™ncias sejam instaladas.\npod install Depois da instala√ß√£o, voc√™ deve abrir o arquivo que possui a extens√£o workspace. Neste exemplo, n√≥s o chamaremos de Beagle Sample.workspace\nPasso 2: Configurar o Beagle Agora que seu projeto est√° criado, voc√™ deve fazer as configura√ß√µes do Beagle. Para isso, siga os passos abaixo:\n Crie uma classe chamadaBeagleConfig .  Esta classe ser√° respons√°vel por conter parte da configura√ß√£o inicial do Beagle. Nela, implementaremos uma fun√ß√£o est√°tica config para aplicar essas configura√ß√µes.\n2. Nesta fun√ß√£o crie uma constante chamada **`dependency`** que deve ser do tipo**`BeagleDependencies`**.  A esta constante ser√£o atribu√≠das algumas configura√ß√µes do projeto, como por exemplo, listar a URL base que lista oJSON a ser utilizado na constru√ß√£o de uma tela server-driven. Para configurar esta constante, use o exemplo abaixo:\nimport Beagle import Foundation class BeagleConfig { static func config() { let dependencies = BeagleDependencies() dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"http://localhost\") ) Beagle.dependencies = dependencies } } Agora, vamos configurar a classe**SceneDelegate** para que possamos inicializar nossa aplica√ß√£o com o Beagle a partir de uma tela via BFF:\n Crie a constante beagleScreen, que ir√° receber a tela server-driven. O argumento init URL deve conter o endere√ßo da URL relativa que ser√° criada no backend (BFF). No nosso exemplo a chamaremos de ‚Äú/screen‚Äù  Siga o exemplo abaixo:\nlet beagleScreen = Beagle.screen(.remote(.init(url: \"/screen\"))) window = UIWindow(frame: UIScreen.main.bounds) window?.windowScene = windowScene window?.rootViewController = beagleScreen window?.makeKeyAndVisible() Ao final, a classe**SceneDelegate** deve ficar assim:\nPasso 3: Configurar o Xcode Inicialmente, as propriedades do Xcode est√£o configuradas para que sua aplica√ß√£o seja iniciada via main.storyboard. No entanto, agora quem deve iniciar a aplica√ß√£o √© o Beagle e, para que isso ocorra, devemos mudar essas propriedades apagando as refer√™ncias ligadas ao main.storyboard.\nEstas refer√™ncias est√£o no main project file, na**Info tab**, e est√£o assim organizadas:\nA primeira fica na sess√£o:\nCustom iOS Target Properties \u003e\nMain storyboard file base name\nA segunda fica na sess√£o:\nApplication Scene Manifest\u003e\nScene Configuration\u003e\nApplication Session Role \u003e\nItem 0 (Default Configuration)\u003e\nStoryboard name.\nNo GIF abaixo, voc√™ v√™ melhor como remover as refer√™ncias:\nFeito! O Beagle est√° configurado na sua aplica√ß√£o iOS. Agora, tudo o que voc√™ precisa √© configurar um backend para responder as requisi√ß√µes do seu aplicativo server-driven.\nFeita essa configura√ß√£o, inicie a sua aplica√ß√£o e voc√™ ter√° sua primeira tela server-driven!\nVoc√™ ver√° a tela a seguir:\n","excerpt":" Iniciando um projeto iOS Para criar um projeto iOS no Beagle, voc√™ ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-ios/","title":"Case ios"},{"body":" Starting an iOS project To create an iOS project for Beagle, you will need a Macbook with Xcode installed. In case you don‚Äôt have it yet, download Xcode on the Apple Store.\nBefore you start, first it‚Äôs necessary to create a project on Xcode. To do so, your just have to open the program and name a project. For this example, we‚Äôll call as Beagle Sample.\nAfter you created the project, we‚Äôll need to add the dependencies and, for that, we‚Äôll use CocoaPods' manager.\nIf you wanna know more about how to use Cocoa Pods, check out their documentation.  Step 1: Configure Cocoa Pods You‚Äôll use the terminal to install CocoaPods, so open your terminal and type sudo gem install cocoapods\nsudo gem install cocoapods To configure it, go to your folder through the terminal and type: pod init\npod init Then, open your project‚Äôs folder using the open command.\nopen . Once you made it, you must choose the podfile file the same way as it‚Äôs shown in the image:\nOpen the file and add the following dependencies:\ntarget 'Beagle Sample' do pod 'BeagleUI' pod 'YogaKit', :git =\u003e 'https://github.com/ZupIT/YogaKit' end Open the terminal again and type the pod install command so your dependencies can be installed.\npod install After the installation, you should open a file with a**workspace.** extension. For this example, we‚Äôll name it asBeagle Sample.workspace\nStep 2: Configure Beagle Now that your project was created, you must make Beagle‚Äôs configuration. To do so, follow the steps below:\n Create a class calledBeagleConfig .  This class will be responsible to contain part of Beagle‚Äôs initial configuration. On her, we‚Äôll implement a config static function to apply these configurations.\n2. On this function, create a constant called **`dependency`** that must be**`BeagleDependencies`**type.  We‚Äôll attribute to this constant some project‚Äôs configurations like, for example, the list of basis URL that lists the JSON that will be used to build the the server-driven screen. To configure this constant, use the example below:\nimport Beagle import Foundation class BeagleConfig { static func config() { let dependencies = BeagleDependencies() dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"http://localhost\") ) Beagle.dependencies = dependencies } } Now, we‚Äôll configure the**SceneDelegate** class so it can be used to initialize our application with Beagle from a screen through BFF:\n Create a**beagleScreen** constant, that will receive the server-driven screen. The init URL argument must contain the relative URL address that will be created on backend (BFF). For this example, we‚Äôll call it ‚Äú/screen‚Äù  Follow the example below:\nlet beagleScreen = Beagle.screen(.remote(.init(url: \"/screen\"))) window = UIWindow(frame: UIScreen.main.bounds) window?.windowScene = windowScene window?.rootViewController = beagleScreen window?.makeKeyAndVisible() At the end of this process, the**SceneDelegate** class should be like this:\nStep 3: Configure Xcode Usually, the Xcode‚Äôs proprieties are configured so your application can be initialized through main.storyboard. Now that will be done by Beagle and, for this configuration works, we must change the proprieties deleting the references related to main.storyboard.\nThese references are in the main project file, on**Info tab**, and are organized like this:\nThe first stays in the session:\nCustom iOS Target Properties \u003e\nMain storyboard file base name\nThe second stays in the session:\nApplication Scene Manifest\u003e\nScene Configuration\u003e\nApplication Session Role \u003e\nItem 0 (Default Configuration)\u003e\nStoryboard name.\nOn the GIF below, you can see better how to remove these references:\nWell done, now Beagle is configured for your iOS application! All you have to do is set up a backend to answer to your server-driven applications‚Äôs requests.\nOnce you finished the configuration, start your application and you‚Äôll have your first server-driven screen!\nYou will see this screen:\n","excerpt":" Starting an iOS project To create an iOS project for Beagle, you will ‚Ä¶","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/ios/","title":"IOS"},{"body":" Criando estilos para o Beagle iOS No exemplo pr√°tico da p√°gina ‚ÄúCriando um projeto com Beagle para iOS‚Äù, voc√™ pode conferir como fazer a implementa√ß√£o do Beagle e criar sua primeira tela server-driven.\nNeste tutorial, a ideia √© avan√ßar a partir do projeto anterior para criar um Design System na sua biblioteca do Beagle. Os exemplos que ilustrar√£o o passo a passo est√£o nestessample codes que voc√™ encontra no nosso reposit√≥rio.\nA ideia aqui √© configurar alguns estilos no iOS para que voc√™ possa customizar componentes como:\n Text. Button. Navigation Bar Tab View Entre outros.  Al√©m disso, vamos aplicar estilos de texto nos 2 componentes textuais.\nPara tal, criaremos uma esp√©cie de Design System, ou seja, um arquivo para reunir um conjunto desses estilos guardando os registros dos componentes de estilo criados no frontend.\n√â dessa forma que sua aplica√ß√£o iOS ‚Äúsaber√°‚Äù qual componente de estilo dever√° renderizar ao receber uma tela server-driven. Vale lembrar que, no caso da tela server-driven, estar√£o relacionados os elementos visuais (views) utilizados na constru√ß√£o da sua tela.\nPasso 1: Criar um arquivo Swift Crie um arquivo Swift. No nosso exemplo, vamos chamar de Styles. Nele, voc√™ deve importar o UIKit e o BeagleUI e criar uma Struct com nome Stylesassim como fizemos no exemplo abaixo:\nimport UIKit import Beagle struct Styles { } Essa struct ir√° conter todos os estilos que ser√£o acessados pelo Beagle. Aqui, estar√° listada a l√≥gica que permite ao Beagle aplicar os estilos definidos no iOS a uma tela server-driven.\nPasso 2: Criar um estilo para um texto Uma vez que voc√™ gerou seu arquivo, voc√™ deve agora criar fun√ß√£o est√°tica para definir e retornar um estilo de texto. Como, no caso deste exemplo, teremos um estilo para t√≠tulo e outro para par√°grafo, criaremos duas fun√ß√µes.\nO retorno desta fun√ß√£o ir√° utilizar a classe BeagleStyle,que √© uma classe interna do Beagle que fica acess√≠vel quando voc√™ importa a classe beagleUI.\n√â neste retorno que estar√° definido o estilo criado para o componente text . Siga o passo abaixo para criar cada fun√ß√£o:\nO estilo do t√≠tulo ir√° retornar a fonte Courier com tamanho 20 e com a cor laranja. Implemente-o como no exemplo abaixo.\nstatic func titleTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 20) ?? UIFont.systemFont(ofSize: 20), color: .orange ) }  Caso a fonte n√£o seja encontrada, o Beagle ir√° definir como default a fonte do sistema com tamanho 20.  Realize o mesmo processo para criar o estilo do nosso par√°grafo. Exemplo abaixo:\nstatic func descriptionTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 15) ?? UIFont.systemFont(ofSize: 15), color: .orange ) } Depois de implementar estes dois estilos, o seu arquivo Styles dever√° estar assim:\nimport UIKit import Beagle struct Styles { static func titleTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 20) ?? UIFont.systemFont(ofSize: 20), color: .orange ) } static func descriptionTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 15) ?? UIFont.systemFont(ofSize: 15), color: .orange ) } } Passo 3: Registrar o estilo no Beagle Config Agora √© necess√°rio registrar os estilo no Beagle, √© importante para que ele seja capaz de aplicar esses estilos nas telas server-driven.\n Abra o arquivo BeagleConfig . Registre uma constante com o nome theme √â na constante theme que ser√° listado todos os estilos. Essa constante ir√° receber o AppTheme que √© onde os estilos s√£o registrados. Crie o bloco de informa√ß√µes abaixo dentro da fun√ß√£o static func config Crie o bloco de informa√ß√µes abaixo dentro da fun√ß√£o static func config  let theme = AppTheme(styles: []) Para registrar, liste o nome do estilo, declarado no backend, e indique a qual estilo deve ser aplicado. Cada estilo dever√° ser registrado assim:  \"Title.Text.Orange\": Styles.titleTextStyle  \"Title.Text.Organge\" √© o nome do estilo definido para o componente text na tela server-driven.  Styles.titleTextStyle √© a fun√ß√£o criada logo no in√≠cio desse tutorial. Ela retorna o estilo que est√° definido nela para que o Beagle Config saiba renderizar o estilo correto em cada componente visual, nesse caso o text que ser√° o t√≠tulo.  A constante theme com os dois estilos registrados deve estar assim:\nlet theme = AppTheme(styles: [ \"Title.Text.Orange\": Styles.titleTextStyle, \"Description.Text.Orange\": Styles.descriptionTextStyle ]) Ainda no BeagleConfig devemos referenciar o theme que criamos no BeagleDependencies.\nSiga o exemplo abaixo e finalize a configura√ß√£o do BeagleConfig como mostrado abaixo:\nimport Beagle import Foundation class BeagleConfig { static func config() { let theme = AppTheme(styles: [ \"Title.Text.Orange\": Styles.titleTextStyle, \"Description.Text.Orange\": Styles.descriptionTextStyle ]) let dependencies = BeagleDependencies() dependencies.theme = theme dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"http://localhost:8080\") ) Beagle.dependencies = dependencies } } Assim, o front-end est√° configurado e os estilos definidos.\nPasso 4: Definir estilos no backend No tutorial de configura√ß√£o do backend, uma pagina server driven foi criada com 2 textos, um t√≠tulo e um par√°grafo.\nA p√°gina era assim quando renderizada no frontend:\nPara atribuir um estilo a esses textos siga as instru√ß√µes:\n Abra o projeto de backend (BFF) e localize o arquivo FirstScreenBeagleBuilder. Esse √© o arquivo que cont√©m o c√≥digo da sua primeira tela server driven. Ela deve estar configurada como na foto abaixo. Nela voc√™ deve perceber que foi constru√≠da uma hierarquia de componentes com uma screen (tela) e dois componentes do tipo text.  class FirstScreenBuilder : ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle\", styleId = \"Title.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( top = 16.unitReal() ), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides \" + \"usage of the Server-Driven UI concept, natively in \" + \"iOS, Android and Web applications. By using Beagle, \" + \"your team could easily change application's layout \" + \"and data by just changing backend code.\", styleId = \"Description.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) Para adicionar um estilo a um elemento de texto, voc√™ deve listar o nome do estilo dentro do componente texto, conforme mostrado baixo. N√£o se esque√ßa de separar os componentes por uma v√≠rgula. Segure o bot√£o Ctrl e coloque o mouse sobre o componente Text e voc√™ ver√° a lista de atributos que esse componente pode receber aqui no backend. Por hora, utilizaremos apenas o Style\n 1. Coloque uma virgula ap√≥s o atributo text = \"Hello Beagle\", e escreva o outro atributo que quer definir, que √© o `styleId` 2. Digite a string `‚ÄúTitle.Text.Orange‚Äù` e pronto! O estilo est√° definido para esse componente de texto.  Text( text = \"Hello Beagle\" styleId = \"Title.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), E pronto, isso √© tudo que faremos no backend nesse momento.\n Fa√ßa o mesmo para o outro componente Text que √© um par√°grafo, mas nomeie-o como ‚ÄúDescription.Text.Orange‚Äù  Voc√™ pode rodar sua aplica√ß√£o backend para que o servi√ßo fique dispon√≠vel.\nCaso tenha algum problema, recomendamos que fa√ßa o tutorial para implementa√ß√£o desse backend.  O que fazer depois de pronto? Depois de executar o backend, agora execute o Xcode.\nE o resultado ser√° esse:\nAgora que est√° pronto, teste um pouco, mude os tamanhos, mude as cores, e teste os estilos que quiser!\nNeste exemplo foi utilizado elementos de estilo simples para explicar o Design system, mas o n√∫mero de fun√ß√µes nessa classe mostra como ela pode ser ampla. Voc√™ pode desenvolver toolBars diferentes, bot√µes e todo o tipo de componentes, inclusive componentes customizados (que abordaremos em outro codeLab) e utiliz√°-los no Beagle.\n","excerpt":" Criando estilos para o Beagle iOS No exemplo pr√°tico da p√°gina ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-ios/definindo-os-estilos-no-beagle-ios/","title":"Definindo os estilos no Beagle ios"},{"body":" Creating styles for Beagle iOS On the first use example, you saw how to implement Beagle and create your first server-driven screen.\nIn this tutorial, the idea is to get deeper from the previous project to create a Design System on Beagle‚Äôs library. To better illustrate the explanation, we‚Äôll use these sample codes that you can find out in our repository.\nThe idea is to configure some styles on iOS to allow you to customize some components, such as:\n Text. Button. Navigation Bar Tab View Entre outros.  Besides, we‚Äôll apply text styles to 2 texts' components.\nTo do so, we‚Äôll create a kind of Design System, which is a file with a set of styles in where we‚Äôll keep the styles' components registers created on frontend.\nThis way, your iOS application ‚Äúwill know‚Äù which style component must be rendered in a server-driven screen. Just remember that the server-driven screen case, the visual components (views) will be related and it will be used to build the screen.\nStep 1: Create a Swift file Create a Swift file. On our example, let‚Äôs call it Styles. On this file, you must import the UIKit and the BeagleUI and also create a Struct with the name Styles, just like the image below:\nimport UIKit import Beagle struct Styles { } This struct will contain all the styles Beagle will access. Here, it will be listed the logic that allows Beagle to apply defined styles on iOS into a server-driven screen.\nStep 2: Create a text style Once you have created your file, now you must create a static function to define and return a text style. For this example, we‚Äôll have one style for a title and another one for the paragraph, so we‚Äôll create two different functions.\nThis function return will use the BeagleStyle class, which is a Beagle‚Äôs intern class that‚Äôs available when you import the beagleUI class.\nIt‚Äôs on these return that‚Äôs defined the style created for the text component. Follow the instructions below to create each function:\nThe title text style will return Courier font with size 20 and orange color. Implement it like in the example below:\nstatic func titleTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 20) ?? UIFont.systemFont(ofSize: 20), color: .orange ) }  If you can‚Äôt find the text font, Beagle will define a system default font with size 20.  Repeat the same process to create our paragraph style, like in the example below:\nstatic func descriptionTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 15) ?? UIFont.systemFont(ofSize: 15), color: .orange ) } After you implement both styles, your Styles file must be like this:\nimport UIKit import Beagle struct Styles { static func titleTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 20) ?? UIFont.systemFont(ofSize: 20), color: .orange ) } static func descriptionTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 15) ?? UIFont.systemFont(ofSize: 15), color: .orange ) } } Step 3: Register a style on Beagle Config Now it‚Äôs necessary to register Beagle‚Äôs styles, which is important so Beagle can be able to apply these styles in server-driven screens.\n  Open the BeagleConfig file. Register a constante called theme\n  It‚Äôs on the theme constant where the styles will be listed.\n  This constant will receive the AppTheme , which is where the styles are registered.\n  Create the information block below inside the**static func config** function.\n  Create the information block below inside the**static func config** function.\nlet theme = AppTheme(styles: []) To register, list the style name stated on backend and, then, indicate which style must be applied. Each style must be registered like this:    \"Title.Text.Orange\": Styles.titleTextStyle  \"Title.Text.Organge\" is the defined style name text component on the server-driven screen.  Styles.titleTextStyle is the function created in the beginning of this tutorial. She returns the defined style so Beagle Config can be able to render the correct style of each visual component, in our case is the text that must be rendered as a title.  The theme constant with two registered styles must be like this:\nlet theme = AppTheme(styles: [ \"Title.Text.Orange\": Styles.titleTextStyle, \"Description.Text.Orange\": Styles.descriptionTextStyle ]) Still on BeagleConfig, we should refer the theme we created on BeagleDependencies.\nFollow the example below and finish the BeagleConfig‚Äôs setup as the example below shows:\nimport Beagle import Foundation class BeagleConfig { static func config() { let theme = AppTheme(styles: [ \"Title.Text.Orange\": Styles.titleTextStyle, \"Description.Text.Orange\": Styles.descriptionTextStyle ]) let dependencies = BeagleDependencies() dependencies.theme = theme dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"http://localhost:8080\") ) Beagle.dependencies = dependencies } } In this way, the frontend is configured and the styles are defined.\nStep 4: Define styles on backend On the backend‚Äôs configuration tutorial, we created a server-driven page with 2 texts: 1 title and 1 paragraph.\nThis page was like that when rendered on frontend:\nTo attribute a style to these texts, follow these instructions:\n Open the backend project (BFF) and look for the FirstScreenBeagleBuilderfile. This is the file that contains the code of your first server-driven screen. She must be configured like in the image below. On her, you will notice that it was built a hierarchy‚Äôs screen components and two text types components.  class FirstScreenBuilder : ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle\", styleId = \"Title.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( top = 16.unitReal() ), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides \" + \"usage of the Server-Driven UI concept, natively in \" + \"iOS, Android and Web applications. By using Beagle, \" + \"your team could easily change application's layout \" + \"and data by just changing backend code.\", styleId = \"Description.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) To add a style to a text element, you must list the style name within the text component, as shown below. Don‚Äôt forget to separate the components with a comma. Hold the Ctrl button and place the mouse over the Text component and will see the list of attributes that this component can receive here on the backend. For now, we will only use Style.\n 1. Put a comma after the text attribute = \"Hello Beagle\", and write another attribute you want to define, in our case it's `styleId` 2. Type a `‚ÄúTitle.Text.Orange‚Äù` string and done! Your style is defined for this text component.  Text( text = \"Hello Beagle\", styleId = ‚ÄúTille.Text.Organge‚Äù ).applyFlex( Flex( margin = EdgeValue( top = 16.unitRal(Real) ), alignSelf = Alignment.CENTER ) ), And done, that‚Äôs all we‚Äôre gonna do on our backend so far.\n Repeat the same process with the otherText component - the paragraph -, but name it as ‚ÄúDescription.Text.Orange‚Äù  You can run your backend‚Äôs application so the service can be available.\nIn case you have any problem, we recommend you to make our backend‚Äôs implementation tutorial.  What‚Äôs next? After you execute the backend, you now have to execute the Xcode.\nThis should be your result:\nNow that is ready, test a little more, try to change sizes, colors and whatever style you want to!\nFor this example, we used simple style‚Äôs elements to explain Design System, but the number of functions is quite big. That means you can develop different toolBars, buttons and all kinds of components, including customized components to use on Beagle.\n","excerpt":" Creating styles for Beagle iOS On the first use example, you saw how ‚Ä¶","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/ios/defining-styles-on-beagle-ios/","title":"Defining styles on Beagle ios"},{"body":" Iniciando um projeto Web Pr√©-Requisitos Para criar um projeto com Beagle para Web, confirme se voc√™ tem instalado os seguintes programas:\n Angular CLI Node 10.16 + Yarn ou npm  Para iniciar o projeto √© preciso utilizar o Visual Studio Code. Caso ainda n√£o o tenha instalado, voc√™ pode baix√°-lo no site oficial da ferramenta.\nAp√≥s a instala√ß√£o, siga os passos de acordo com o framework escolhido:\nAngular React Passo 1: abra o terminal e use o comando abaixo:\nng new caseAngular Aguarde o CLI terminar a cria√ß√£o do projeto.\nPasso 2: entre na pasta do projeto gerado cd caseAngular, adicione o Beagle Angular ao seu reposit√≥rio com um dos comandos abaixo de acordo com seu gerenciador de pacotes:\nnpm install --save @zup-it/beagle-angular yarn add @zup-it/beagle-angular Agora, aguarde a instala√ß√£o.\nPasso 3: digite um desses comandos e aperte o enter:\nyarn beagle init npx beagle init  Na pergunta ‚ÄòWould you like to use yarn or npm?' Digite a op√ß√£o que voc√™ escolheu para usar como gerenciador, no exemplo ser√° o yarn, portanto digite yarne aperte enter. Na pergunta ‚ÄòPath to the beagle module (press enter to use default)‚Äô - digite qual o caminho do m√≥dulo que ser√° usado para o Beagle, como o projeto foi criado agora, n√£o h√° m√≥dulos ainda, portanto aperte enter sem informar nada. Na pergunta ‚ÄòPath to the module with the components to use with beagle (press enter to use default)‚Äô - digite qual o caminho do m√≥dulo que ser√° usado para o Beagle, como o projeto foi criado agora, n√£o h√° m√≥dulos ainda, portanto aperte enter sem informar nada. Na pergunta ‚ÄòWhat‚Äôs the base url of the backend providing your beagle JSONs? (press enter to use default)‚Äô - digite qual ser√° a URL base do backend que ser√° utilizada para resgatar os JSONs, aqui ser√° usada o mockyio, ent√£o digite https://www.mocky.io/v2/e aperte enter. Aguarde a configura√ß√£o terminar:   Foram criados dois arquivos em seu projeto beagle-components.module.ts e beagle.module.ts.   Passo 1: abra o terminal e digite um dos comandos abaixo:\nnpx create-react-app case-react --template typescript ou\nyarn create react-app case-react --template typescript Passo 2: acesse a pasta do projeto cd case-react e adicione o Beagle React ao seu reposit√≥rio. No terminal digite:\nnpm install --save @zup-it/beagle-react ou\nyarn add @zup-it/beagle-react e aguarde a instala√ß√£o finalizar.\n Configura√ß√£o Agora √© hora de configurar os arquivos do Beagle dentro da sua aplica√ß√£o, siga as instru√ß√µes:\nAngular React Abra o arquivo app.module.ts e importe o m√≥dulo Beagle que acabou de ser gerado:\n... import { Beagle } from './beagle.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, Beagle ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Abra o arquivo beagle.module.ts e coloque o caminho baseUrl\nimport { BeagleModule } from '@zup-it/beagle-angular' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, }) export class Beagle {}  No caminho /src crie uma outra pasta com o nome beagle e dentro dela um novo arquivo chamado beagle-service.tsSua estrutura deve estar parecida com a imagem a seguir:\nAgora, abra o arquivo criado beagle-service.ts e copie o c√≥digo:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} })  Criando o JSON para ser renderizado Agora √© preciso um JSON para renderizar os componentes, normalmente a chamada seria feita para um servidor externo que retornaria o JSON, mas neste exemplo um arquivo local ser√° criado para ser acessado como teste:\nAngular React No seu projeto angular navegue at√© a pasta src/assets e crie um novo arquivo com o nome payload.json. Insira neste arquivo o conte√∫do do JSON abaixo.\n No seu projeto react navegue at√© a pasta /publice crie um novo arquivo com o nome payload.json. Insira neste arquivo o conte√∫do do JSON abaixo:\n { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle is a cross-platform framework which provides usage of the server Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] } Renderizando os componentes Agora √© necess√°rio adicionar na aplica√ß√£o o local onde os componentes ser√£o renderizados via JSON. A biblioteca Beagle fornece um componente com essa funcionalidade o Beagle remote view, siga os passos para configurar:\nAngular React Abra o arquivo app.component.html e substitua todo o conte√∫do pelo c√≥digo a seguir:\n\u003cbeagle-remote-view route=\"/payload.json\"\u003e\u003c/beagle-remote-view\u003e route no c√≥digo acima diz qual a rota ser√° carregada. A URL especificada aqui √© relativa √† baseUrl declarada na configura√ß√£o.\nO par√¢metro route √© v√°lido apenas para a vers√£o 1.3 ou superior. Para vers√µes anteriores, loadParams deve ser usado. loadParams√© um objeto e o valor equivalente ao desse exemplo seria{ path: ‚Äò/payload.json‚Äô }.\n  Abra o arquivo App.tsx onde o JSON ser√° renderizado e altere para ficar como o exemplo a seguir:\nimport React from 'react'; import './App.css'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView route={'/payload.json'} /\u003e \u003c/BeagleProvider\u003e ); } export default App; Neste passo apontamos onde queremos renderizar nosso layout definidos no arquivo payload.json. Temos aqui dois componentes fornecidos pela biblioteca beagle:\n\u003cBeagleProvider\u003e Recebe uma propriedade value com o beagle-service criado no passo anterior que cont√©m as configura√ß√µes iniciais\n\u003cBeagleRemoteView\u003e Recebe uma propriedade route que √© o caminho do nosso arquivo JSON, note aqui que adicionamos ' / ‚Äò pois esse valor ser√° concatenado com o baseUrl definido no arquivo beagle-service.ts.\nroute no BeagleRemoteView s√≥ √© v√°lido para as vers√µes 1.3 e superior. Para vers√µes anteriores, por favor, use path.\n  Testando a aplica√ß√£o Depois de finalizar a configura√ß√£o b√°sica do projeto, agora √© preciso rodar um dos comandos abaixo para inicializar a aplica√ß√£o:\nAngular React Se voc√™ usa o npm:\nnpm run serve Se voc√™ usa o yarn:\nyarn serve  Se voc√™ usa o npm:\nnpm run start Se voc√™ usa o yarn:\nyarn start  Depois de finalizados os comando acesse no navegador o endere√ßo da sua aplica√ß√£o. Se uma tela com os componentes for renderizada tudo est√° funcionando corretamente.\n","excerpt":" Iniciando um projeto Web Pr√©-Requisitos Para criar um projeto com ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-web/","title":"Case Web"},{"body":" Starting a Web project Requirements To create a Beagle‚Äôs project for, check out if have installed the following programs:\n Angular CLI Node 10.16 + Yarn or npm  You must have Visual Studio Code to start your project. In case you don‚Äôt have installed it yet, you can find more information about it.\nAfter the installation, follow the steps according to framework you chose:\nAngular React Step 1: Open the terminal and use the command below:\nng new caseAngular Wait until the CLI finishes to create the project.\nStep 2: Go to the cd caseAngulargenerated project‚Äôs folder, add Beagle Angular to your repository with one of the commands below, according to your package manager:\nnpm install --save @zup-it/beagle-angular yarn add @zup-it/beagle-angular Now, wait for the installation.\nStep 3: Type one of these commands and press enter:\nyarn beagle init npx beagle init   On the question ‚ÄòWould you like to use yarn or npm?‚Äô, type the option you chose to use as a manager. For example, if you chose yarn, then type yarnand press enter.\n  On the question ‚ÄòPath to the beagle module (press enter to use default)', type which module path you‚Äôre using for Beagle. Considering the project was just created, and there aren‚Äôt any modules, press enter without informing anything.\n  On the question ‚ÄòPath to the module with the components to use with beagle (press enter to use default)', type which module path will be used for Beagle. Considering the project was just created, and there aren‚Äôt any modules, press enter without informing anything.\n  On the question ‚ÄòWhat‚Äôs the base url of the backend providing your beagle JSONs? (press enter to use default)', type which will be the backend‚Äôs basis URL that will be used to rescue the JSONs. Here, we‚Äôll use mockyio, so type https://www.mocky.io/v2/and press enter. Then wait until the configuration finishes:\n   At the end, two files were created on your project:beagle-components.module.ts andbeagle.module.ts.   Step 1: Open the terminal and use the command below:\nnpx create-react-app case-react --template typescript yarn create react-app case-react --template typescript Step 2: Acess the cd case-react project‚Äôs file and add Beagle React to your repository. On your terminal, type:\nnpm install --save @zup-it/beagle-react or\nyarn add @zup-it/beagle-react And wait until the installation finishes.\n Configuration Now it‚Äôs time to configure Beagle‚Äôs files inside your application, following these instructions:\nAngular React Open the app.module.ts file and import Beagle‚Äôs module that was just generated:\n... import { Beagle } from './beagle.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, Beagle ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Open the beagle.module.ts file and put the baseUrl path\nimport { BeagleModule } from '@zup-it/beagle-angular' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, }) export class Beagle {}  On the /src path, create another folder named beagle and, inside it, create a new file calledbeagle-service.ts. Its structure should be similar to the image below:\nNow, open the beagle-service.ts created file and copy this code:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} })  Creating a JSON to be rendered Now you need a JSON to render the components. Usually, this call is made by an external server that would return the JSON, but for this example we‚Äôll use a local file that will be created for this test:\nAngular React On your angular project, navigate to the src/assets folder and create a new file named payload.json. Insert this new file on the JSON content below.\n On your react project, navigate to the /public folder and create a new file named payload.json. Insert on the new file the JSON content below:\n { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle √≠s a cross-platform framework which provices usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] } Rendering components Now it‚Äôs necessary to add on your application the local where the components will be rendered through JSON. The Beagle‚Äôs library provides a component with this functionality: beagle remote view. To configure this component, follow these steps:\nAngular React Open the app.component.html file and replace all the content with this code:\n\u003cbeagle-remote-view route=\"/payload.json\"\u003e\u003c/beagle-remote-view\u003e route in the code above states which route will be loaded. The URL specified here is relative to the baseUrl declared in the configuration.\nThe parameter route is only valid for versions 1.3 and above. For previous versions, you should use loadParams instead. loadParams is an object and the equivalent to this configuration would be { path: ‚Äò/payload.json‚Äô }.\n  Open the App.tsx file where the JSON will be rendered and change it until it looks like the example below:\nimport React from 'react'; import './App.css'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView route={'/payload.json'} /\u003e \u003c/BeagleProvider\u003e ); } export default App; On this step, we point where our layout defined with payload.json file should be rendered. Here, we have two componentes provided by Beagle:\n\u003cBeagleProvider\u003e: Receives the value propriety as the beagle-service created on the previous step and that contains the initials configurations.\n\u003cBeagleRemoteView\u003e: Receives theroute propriety that‚Äôs the path for our JSON file. Notice here that we add ' / ‚Äò because this value will be associated to a definedbaseUrl onbeagle-service.ts file.\nroute in the BeagleRemoteView is only valid for versions 1.3.0 and above. For earlier versions, please, use path instead.\n  Testing your application Once you have finished the project‚Äôs basic configuration, now you have to run one of the commands below to initialize your application:\nIf you use npm:\nnpm run serve If you use yarn:\nyarn serve After you finish these commands, access your application‚Äôs address on your navigator. If a screen with components would be rendered, that means that‚Äôs correctly working.\n","excerpt":" Starting a Web project Requirements To create a Beagle‚Äôs project for, ‚Ä¶","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/web/","title":"WEB"},{"body":" Starting a Backend project In this tutorial, the Backend will be implemented with Beagle so that it can respond to requests from your server-driven application, be it on Android, iOS or WEB.\nRequirements To create a Beagle project for backend, it is necessary:\n IDE Intelij IDE Community  Step 1: Configure using Spring initializr The first step to configure your backend is to access Spring website.\nIt will create aMaven project that will help your project‚Äôs configuration.\nSpring configuration\n Choose Maven as your project option; Check kotlin as a language; Choose the initial version bigger than 2.1. Group is the name it will be used as a hierarchy in the beginning. For this example, it can be com.example; Artifact is the project‚Äôs name. You will name it BFF; Description contain a simple description of the project; Packaging must be checked as JAR; Java must be chosen as the java version of your system; Click on generate and it will download your project as.zip; Extract the file in your chosen folder.  Step 2: Import your project to Intellij Follow the steps below to import the project you have created. First, open intellij and click on Import project.\n Choose the file where you put yourSpring project and click ok. Click on Import projects from external model and choose Maven and then, click finish.  Configuring Beagle Step 1: Configure the project As a starting point, follow this step by step to install the backend\nStep 2: Define the structure The second step is to create some packages to better organize the project. They will be named: builder,service and controller\n Click src\u003e main\u003e kotlin until you find the name of your project. Right-click new\u003e package Name it builder and press enter. Repeat the process creating the other two packages, naming them service and controller After creating the packages, your screen should look like this:  Step 3: ‚Äå Create the application service The first class that we will create is the Builder. It is in this file that the Server-Driven screen must be structured:\n Right-click the builder package and click new\u003e Kotlin File / Class and name it ScreenBeagleBuilder This class must extend from ScreenBuilder (which is an internal Beagle class). Note that it will replace the build method and this is where the Server-Driven screen will be implemented. In this step, you can copy and paste the code below into your class:  import br.com.zup.beagle.core.Style import br.com.zup.beagle.ext.applyStyle import br.com.zup.beagle.ext.unitReal import br.com.zup.beagle.widget.Widget import br.com.zup.beagle.widget.action.Alert import br.com.zup.beagle.widget.core.AlignSelf import br.com.zup.beagle.widget.core.EdgeValue import br.com.zup.beagle.widget.core.Flex import br.com.zup.beagle.widget.core.TextAlignment import br.com.zup.beagle.widget.layout.Container import br.com.zup.beagle.widget.layout.Screen import br.com.zup.beagle.widget.layout.ScreenBuilder import br.com.zup.beagle.widget.ui.ImagePath import br.com.zup.beagle.widget.ui.Text object ScreenBeagleBuilder : ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle!\" ).applyStyle( Style(margin = EdgeValue(top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides usage of the \" + \"Server-Driven UI concept, natively in iOS, Android and Web applications. \" + \"By using Beagle, your team could easily change application's layout and\" + \" data by just changing backend code.\" ).applyStyle( Style(margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) } The next class we will create is**Service**:\n Right-click the service package and click New\u003e Kotlin File / Class. Name it ScreenBeagleService. This class must be annotated with @Service, which is a Spring annotation Implement a method called createScreenBeagle that returns the ScreenBeagleBuilder class:  import com.example.bff.builder.ScreenBeagleBuilder import org.springframework.stereotype.Service @Service class ScreenBeagleService { fun createScreenBeagle() = ScreenBeagleBuilder } And then the Controller class.\n In the controller package, create a class and name it ScreenController. It must be annotated with @RestController to expose its components through the Rest API. He will receive a ScreenBeagleService through his main builder, so Spring can inject it for you. Create your class as in the example below:  import com.example.bff.service.ScreenBeagleService import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController @RestController class ScreenController( private val screenBeagleService: ScreenBeagleService ) { @GetMapping(\"/screen\") fun getFirstScreen() = screenBeagleService.createScreenBeagle() }  The @RestController annotation defines this class as a controller class The screenBeagleService parameter must have its type defined as: ScreenBeagleService The getScreen method needs to annotate @ GetMapping (\"/ screen\") to create the \"/ screen\" path in the application‚Äôs URL and receive the result of the createScreenBeagle function  The backend is ready to serve as the BFF of your Server-Driven application.\nInitializing the application Now it‚Äôs time to start your application, follow the next steps:\nStep 1: Run the project Click on the green triangle named run, or press and hold SHIFT + F10 to run your back-end application.\nYour screen should look like this:\nStep 2: Make a request Open your browser and type: localhost: 8080 / screen\nA JSON structure must appear on your screen similar to the structure below:\n{ \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello Beagle!\", \"style\" : { \"margin\" : { \"top\" : { \"value\" : 16.0, \"type\" : \"REAL\" } }, \"flex\" : { \"alignSelf\" : \"CENTER\" } } }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Beagle is a cross-platform framework which provides usage of the Server-Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code.\", \"style\" : { \"margin\" : { \"left\" : { \"value\" : 16.0, \"type\" : \"REAL\" }, \"top\" : { \"value\" : 20.0, \"type\" : \"REAL\" }, \"right\" : { \"value\" : 16.0, \"type\" : \"REAL\" } } } } ] } } Step 3: Check the process If that is not the answer you had, it is necessary to check the configuration process again. Go back to the previous steps and start with the classes that have the biggest mistakes when configured for the first time.\nOr, if you prefer, take the finished project from our repository and compare it with yours. You can access the repository here. \nIn order to use the backend service, you must have the front end prepared for Beagle, whether Android, iOS or Web. Everything will work using a JSON from the Backend.  To learn more about configuring your frontend environment, see more at:\nüëâ Beagle implementation tutorial for Android.\nüëâBeagle implementation tutorial for iOS.\nüëâBeagle implementation tutorial for Web.\n","excerpt":" Starting a Backend project In this tutorial, the Backend will be ‚Ä¶","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/backend/","title":"Backend"},{"body":" Iniciando um projeto Backend Nesse tutorial ser√° implementado o Backend com o Beagle para que ele possa responder a requisi√ß√µes de sua aplica√ß√£o server-driven, seja ela em Android, iOS ou WEB.\nPr√©-requisitos Para criar um projeto com o Beagle para o backend, √© preciso:\n IDE Intelij IDE Community  Passo 1: Iniciar o projeto usando Spring initializr O primeiro passo para configurar seu backend √© acessar o site do Spring\nEle criar√° o projeto Maven que facilitar√° a configura√ß√£o do seu projeto.\nConfigura√ß√£o do Spring\n Escolha o Maven como o sua op√ß√£o de projeto; Marque kotlin como a linguagem; Marque a vers√£o de inicializa√ß√£o maior que 2.1. Group √© o nome que ser√° usado como a hierarquia do come√ßo. Para esse exemplo, voc√™ pode deixar como com.example; Artifact √© o nome do projeto. Voc√™ nome√°-lo como BFF; Description cont√©m a simples descri√ß√£o do projeto; Packaging deve ser marcado como JAR; Java deve ser marcado como a vers√£o java do seu sistema; Clique em generate e voc√™ ir√° fazer o download do seu projeto no formato .zip; Extraia o arquivo na pasta de sua preferencia.  Passo 2: Importar seu projeto para o Intelij Siga os passos abaixo para importar o projeto que voc√™ criou. Primeiro, abra o intellij e clique emImport project.\n  Escolha o arquivo onde voc√™ colocou o seuSpring project\ne clique em ok.\n  Clique em Import projects from external model e escolha Maven e depois, clique em finish.\n  Configurando o Beagle Passo 1: Configurar o projeto Como ponto de partida, siga nosso passo a passo para instalar o backend.\nPasso 2: Definir a Estrutura O segundo passo √© criar alguns pacotes para organizar melhor o projeto. Eles ser√£o nomeados: builder, service e controller\n Clique em src \u003e main \u003e kotlin at√© encontra o nome do seu projeto. Clique com o bot√£o direito do mouse em new \u003e package Nomeie builder e aperte enter. Repita o processo criando os dois outros pacotes, nomeando-os service e controller Ap√≥s a cria√ß√£o dos pacotes, a sua tela dever√° estar assim:  Passo 3:‚Äå Criar o servi√ßo da aplica√ß√£o A primeira classe que iremos criar √© a Builder . √â nesse arquivo que a tela Server-Driven deve ser estruturada:\n Clique no pacote builder com o bot√£o direito do mouse e clique em new \u003e Kotlin File / Class e coloque o nome como ScreenBeagleBuilder Essa classe deve estender de ScreenBuilder (que √© uma classe interna do Beagle). Observe que ele substituir√° o m√©todo de build e √© aqui que ser√° implementado a primeira tela Server-Driven. Nesta etapa, voc√™ pode copiar e colar o c√≥digo abaixo em sua classe.  import br.com.zup.beagle.core.Style import br.com.zup.beagle.ext.applyStyle import br.com.zup.beagle.ext.unitReal import br.com.zup.beagle.widget.Widget import br.com.zup.beagle.widget.action.Alert import br.com.zup.beagle.widget.core.AlignSelf import br.com.zup.beagle.widget.core.EdgeValue import br.com.zup.beagle.widget.core.Flex import br.com.zup.beagle.widget.core.TextAlignment import br.com.zup.beagle.widget.layout.Container import br.com.zup.beagle.widget.layout.Screen import br.com.zup.beagle.widget.layout.ScreenBuilder import br.com.zup.beagle.widget.ui.ImagePath import br.com.zup.beagle.widget.ui.Text object ScreenBeagleBuilder : ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle!\" ).applyStyle( Style(margin = EdgeValue(top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides usage of the \" + \"Server-Driven UI concept, natively in iOS, Android and Web applications. \" + \"By using Beagle, your team could easily change application's layout and\" + \" data by just changing backend code.\" ).applyStyle( Style(margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) } A pr√≥xima classe a ser criada √© a Service:\n Clique com o bot√£o direito do mouse no pacote service e clique em New\u003e Kotlin File / Class. Nomeie-a como ScreenBeagleService. Essa classe deve ser anotada com @Service que √© uma anota√ß√£o do Spring Implemente um m√©todo chamado de createScreenBeagleque tem como retorno a classe ScreenBeagleBuilder:  import com.example.bff.builder.ScreenBeagleBuilder import org.springframework.stereotype.Service @Service class ScreenBeagleService { fun createScreenBeagle() = ScreenBeagleBuilder } E por fim a classe Controller .\n No pacote controllercrie uma classe e nomeia como ScreenController . Ela deve ser anotada com @RestController para que assim exponha seus componentes por meio da API Rest. Ele receber√° um ScreenBeagleService por meio de seu construtor principal, para que o Spring possa injet√°-la para voc√™. Crie sua classe como no exemplo abaixo:  import com.example.bff.service.ScreenBeagleService import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController @RestController class ScreenController( private val screenBeagleService: ScreenBeagleService ) { @GetMapping(\"/screen\") fun getFirstScreen() = screenBeagleService.createScreenBeagle() }  A anota√ß√£o @RestController define esta classe como uma controller O par√¢metro screenBeagleService precisa ter seu tipo definido como :ScreenBeagleService O m√©todo getScreen precisa anotar@GetMapping(\"/screen\") para criar o caminho ‚Äú/screen‚Äù na URL da aplica√ß√£o e receber o resultado da fun√ß√£o createScreenBeagle  O backend est√° pronto para servir como BFF de sua aplica√ß√£o Server-Driven.\nInicializando a aplica√ß√£o Agora √© hora de inicializar a sua aplica√ß√£o, siga os passos:\nPasso 1: Rodar o projeto Clique no tri√¢ngulo verde chamado**run**, ou aperte e segure SHIFT + F10 para rodar sua aplica√ß√£o back-end.\nA sua tela estar√° assim:\nPasso 2: Fazer uma requisi√ß√£o Abra o seu browser e digite: localhost:8080/screen\nUma estrutura JSON tem que aparecer na sua tela similar a estrutura abaixo:\n{ \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello Beagle!\", \"style\" : { \"margin\" : { \"top\" : { \"value\" : 16.0, \"type\" : \"REAL\" } }, \"flex\" : { \"alignSelf\" : \"CENTER\" } } }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Beagle is a cross-platform framework which provides usage of the Server-Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code.\", \"style\" : { \"margin\" : { \"left\" : { \"value\" : 16.0, \"type\" : \"REAL\" }, \"top\" : { \"value\" : 20.0, \"type\" : \"REAL\" }, \"right\" : { \"value\" : 16.0, \"type\" : \"REAL\" } } } } ] } } Passo 3: Checar o processo Se essa n√£o for a resposta que voc√™ teve √© necess√°rio checar o processo de configura√ß√£o novamente. Volte os passos anteriores e comece pelas classes que s√£o as que apresentam maiores equ√≠vocos quando configuradas pela primeira vez.\nOu, se preferir, pegue o projeto pronto no nosso reposit√≥rio e compare com o seu. Voc√™ pode acessar o reposit√≥rio aqui. \nPara que o servi√ßo de backend seja consumido, voc√™ deve ter o front-end preparado para o Beagle, seja Android, iOS ou Web. Tudo ir√° funcionar usando o mesmo JSON do backend.  Para saber mais sobre como configurar o seu ambiente frontend, veja mais em:\nüëâ Tutorial do Beagle para Android.\nüëâTutorial do Beagle para iOS.\nüëâTutorial do Beagle para Web.\n","excerpt":" Iniciando um projeto Backend Nesse tutorial ser√° implementado o ‚Ä¶","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-backend/","title":"Case Backend"},{"body":" Currently, there are two cache labels on Beagle:\n A volatile layer. A persistent layer.  The volatile layer today depends on the persistent layer, meaning that only curly items on the persistent layer are candidates to the volatile cache.\nCache‚Äôs layers Volatile cache It‚Äôs the cache that lays on the frontend application‚Äôs memory and it‚Äôs used to reduce the number of backend‚Äôs calls.\nThe entries on this cache layer has time duration defined by cache general configurations of each client‚Äôs platform.\nYou can check out how to configure the cache according to your frontend‚Äôs platform on the following links:\n Configuring Cache  Persistent cache On this cache layer, there are two types of localization:\n On backend‚Äôs memory; On frontend‚Äôs storage.  This cache is used to optimize BFF‚Äôs response - in terms of time and size -, in cases where there is no changes. The entries of this cache lasts until the server redeploy or the client is reinstalled.\nThe premisse to this cache works is that it has to always return the same JSON to the same request. To guarantee that, it‚Äôs necessary that this cache is the same according to its endpoint and specific platform as we can see in component‚Äôs platform specification.\nIn other words, we say that an endpoint can return a static element because it can only work if it returns the same JSON, independently of any other specific platform.\nIt‚Äôs important to remember that cache‚Äôs mechanism must not be used with endpoints that does not meet this premisse.  The cache can be activated or disabled on BFF by endpoint or for an entire BFF. You can check out how to configure a cache. \nHow does the cache protocol works? The protocol acts in the beagle-hash header. BFF validates the received hashes and send a complete response or just the status HTTP 304 Not Modified (without the body).\nWhen BFF responds with the status 304, the application loads the element in cache. If this does not happen, it stores the hash and render the received elements.\nNext Steps üëâ See how to configure cache according to each platform (Android, iOS, Web e Backend).\nüëâCheck out how cache works according to its types (reliable and unreliable).\n","excerpt":" Currently, there are two cache labels on Beagle:\n A volatile layer. A ‚Ä¶","ref":"/docs-beagle/docs/resources/cache/","title":"Cache"},{"body":" Atualmente, existem duas camadas de cache no Beagle:\n Uma camada vol√°til Uma camada persistente.  A camada vol√°til hoje depende da camada persistente, no sentido que apenas itens cacheadas na camada persistente s√£o candidatos para o cache vol√°til.\nCamadas de cache Cache vol√°til √â o cache que fica na mem√≥ria da aplica√ß√£o frontend e que √© usado para reduzir a quantidade de chamadas ao backend.\nAs entradas nesta camada do cache t√™m dura√ß√£o por tempo, definida nas configura√ß√µes gerais de cache de cada plataforma de cliente.\nVoc√™ pode checar como configurar o cache de acordo com sua plataforma, no link abaixo:\n Configurando o cache  Cache persistente Nesta camada de cache, existem duas localiza√ß√µes. S√£o elas:\n Na mem√≥ria do backend; No armazenamento do frontend.  Este cache √© usado para otimizar a resposta do BFF - tanto em tempo quanto em tamanho -, em casos que n√£o h√° mudan√ßa. As entradas neste cache duram at√© o servidor refazer o deploy ou o cliente ser reinstalado.\nA premissa para que este cache funcione √© que ele deve sempre retornar o mesmo JSON para a mesma requisi√ß√£o. Para que uma requisi√ß√£o seja considerada igual, √© necess√°rio que tenha o mesmo endpoint e a mesma plataforma especificada como mostra nossa especifica√ß√£o de plataformas.\n√â importante destacar que o mecanismo de cache n√£o deve ser utilizado em endpoints que n√£o atendam a essa premissa. Ele pode ser ativado ou desativado no BFF por endpoint ou para o BFF inteiro.  Como o protocolo de cache funciona? O protocolo atua no cabe√ßalho beagle-hash. O BFF, por sua vez, valida os hashes recebidos e envia uma resposta completa ou apenas o status HTTP 304 Not Modified (sem um corpo).\nQuando o BFF responde com o status 304, o aplicativo carrega do elemento em cache. Caso isto n√£o aconte√ßa, ele armazena os dados recebidos (hash e JSON) e renderiza os elementos.\nPr√≥ximos passos üëâ Veja como fazer as configura√ß√µes de cache de acordo com cada plataforma (Android, iOS, Web e Backend).\nüëâConfira o funcionamento do cache de acordo com seus tipos (confi√°vel e n√£o confi√°vel)\n","excerpt":" Atualmente, existem duas camadas de cache no Beagle:\n Uma camada ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/cache/","title":"Cache"},{"body":" Como funciona o cache? O cache padr√£o √© controlado pelo backend com a tag cache-control e beagle-hash que s√£o informa√ß√µes que devem ser fornecidas atrav√©s do header das requisi√ß√µes, onde o beagle-hash √© respons√°vel por fornecer o hash referente a tela que est√° sendo baixada e o cache-controlo tempo de vida deste cache como sendo confi√°vel.\nCache confi√°vel Um cache √© dito confi√°vel quando o seu tempo de vida ainda n√£o expirou.\nNeste caso ao verificar que existe um cache no front e ele √© confi√°vel, a tela √© renderizada sem sequer confirmar com o servidor. Isso poupa tempo, banda e prov√™ uma experi√™ncia fluida para o usu√°rio.\nO cache confi√°vel fica salvo em mem√≥ria.\nCache n√£o confi√°vel J√° que temos o cache confi√°vel, tamb√©m temos o n√£o confi√°vel, isso quer dizer que o tempo de vida dele j√° expirou.\nUm cache ser n√£o confi√°vel significa que ao ser identificado ele precisa ser revalidado com o backend para aquela rota pelo seu hash.\nNeste momento ele deixa de estar salvo na mem√≥ria e fica salvo de maneira persistente no disco.\nTempo de vida O tempo de vida do cache pode ser parametrizado atrav√©s de configura√ß√£o pela aplica√ß√£o. Na implementa√ß√£o padr√£o do cache o tempo de vida √© de 300 segundos. Este tempo tamb√©m pode ser alterado caso o backend envie um tempo diferente atrav√©s do header cache-control, pois ele tem prioridade nesta configura√ß√£o.\nRevalida√ß√£o de cache Quando um cache n√£o confi√°vel √© encontrado ele precisa ser revalidado com o backend. Isso quer dizer que ao buscar uma tela ele envia no header da requisi√ß√£o o hash que possui.\nAo receber essa requisi√ß√£o o servidor entende que j√° existe uma vers√£o desta tela salva na aplica√ß√£o e compara o valor hash enviado com o valor atual salvo por ele (backend). Caso sejam iguais √© enviada uma resposta com status 304 e sem corpo algum, indicando que a tela permanece a mesma e que aquele cache √© confi√°vel novamente.\nCaso o hash enviado pelo front seja diferente daquele salvo no backend, ser√° enviada uma resposta normalmente com o novo valor do hash que dever√° ser atualizado na aplica√ß√£o.\nOcupa√ß√£o de mem√≥ria e disco Para evitar sobrecarga de mem√≥ria e disco ambos os caches aplicam uma pol√≠tica de substitui√ß√£o__Least Recently Used (LRU) onde a quantidade m√°xima de registros tamb√©m pode ser configurada atrav√©s da classe base de cache pela aplica√ß√£o. Os valores padr√µes para mem√≥ria e disco s√£o 15 e 150 respectivamente.\nConfigurando e customizando o cache Existem customiza√ß√µes permitidas pela classe padr√£o existente no cache como tempo de vida e quantidade m√°xima de registros em mem√≥ria e disco.\nCaso a abordagem padr√£o n√£o resolva o problema, a aplica√ß√£o tem total liberdade de substituir completamente a implementa√ß√£o padr√£o pela que melhor atender. Para isso, basta que a classe respons√°vel pelo gerenciamento do cache esteja em conformidade com o protocolo CacheManagerProtocol.\nCada plataforma tem especificidades para configurar o cache.\nAbaixo listamos a configura√ß√£o por plataforma:\nAndroid iOS Backend Web No Android, o cache √© configurado quando implementamos as configura√ß√µes iniciais do Beagle.\nEsta implementa√ß√£o acontece dentro da classe que nomeamos AppBeagleConfig, ou seja, dentro da classe de configura√ß√£o do Beagle.\nO cache, em si, √© uma class interna do Beagle na qual podemos definir 3 propriedades representadas pelos atributos:\n enable maxAge memoryMaximumCapacity  @BeagleComponent class AppBeagleConfig : BeagleConfig { override val isLoggingEnabled: Boolean = true override val baseUrl: String get() = \"https://myapp.server.com/\" override val environment: Environment get() = Environment.DEBUG override val cache: Cache = Cache( enabled = true, maxAge = 300, memoryMaximumCapacity = 15 ) } Atributos do cache    Atributo Defini√ß√£o     enable Valor booleanoque habilita ou desabilita o cache em mem√≥ria e disco   maxAge Valor inteirode tempo em segundos que o cache em mem√≥ria estar√° ativo   memoryMaximumCapacity Valor inteiro que representa o tamanho do cache de mem√≥ria LRU. Representa o n√∫mero de telas que v√£o estar na mem√≥ria. Por exemplo, se voc√™ definir o n√∫mero 15, significa que 15 p√°ginas ficar√£o em cache.     No iOS, o cache √© configurado quando implementamos as configura√ß√µes das depend√™ncias do Beagle.\n√â poss√≠vel mudar a configura√ß√£o default do cache criando uma inst√¢ncia da classe CacheManagerDefault. Nessa classe permitimos que voc√™ altere os valores de 3 propriedades:\n memoryMaximumCapacity diskMaximumCapacity cacheMaxAge  let dependencies = BeagleDependencies() let cacheManager = CacheManagerDefault( dependencies: dependencies, config: .init(memoryMaximumCapacity: 15, diskMaximumCapacity: 300, cacheMaxAge: 300)) dependencies.cacheManager = cacheManager Beagle.dependencies = dependencies Tamb√©m √© poss√≠vel criar a sua pr√≥pria classe de gerenciamento de cache e configur√°-la dentro da sua inst√¢ncia do BeagleDependencies se voc√™ conformar essa classe com o protocolo CacheManagerProtocol.\npublic protocol CacheManagerProtocol { func addToCache(_ reference: CacheReference) func getReference(identifiedBy id: String) -\u003e CacheReference? func isValid(reference: CacheReference) -\u003e Bool } Atributos do cache    Atributo Defini√ß√£o     memoryMaximumCapacity Valor inteiro que representa o tamanho do cache de mem√≥ria LRU. Representa o n√∫mero de telas que v√£o estar na mem√≥ria. Por exemplo. Se definirmos o n√∫mero 15 quer dizer que 15 p√°ginas ficar√£o em cache.   diskMaximumCapacity Valor inteiro que representa o tamanho do cache de disco LRU. Representa o n√∫mero de telas que v√£o estar no disco. Por exemplo. Se definirmos o n√∫mero 150 quer dizer que 150 p√°ginas ficar√£o em cache.   cacheMaxAge Valor inteirode tempo em segundos que o cache em mem√≥ria estar√° ativo     No backend, as configura√ß√µes desta funcionalidade s√£o suportadas apenas para quem utiliza a biblioteca starter.\nO cache √© criado para otimizar a resposta de uma requisi√ß√£o tanto em tamanho quanto em tempo do BFF quando o retorno √© igual ao anterior a ela. As entradas nesse cache duram at√© o servidor ser ‚Äúredeployado‚Äù ou o cliente ser reinstalado.‚Äå\nPara realizar a configura√ß√£o de cache:\n Dentro da pasta src/main/resources, procure pelo arquivo application.properties Caso n√£o tenha o arquivo, voc√™ pode cri√°-lo agora.  Se a chave n√£o estiver listada no seu arquivo, significa que a configura√ß√£o padr√£o ser√° aplicada automaticamente.\nbeagle.cache.endpoint.include=/image,/context/.* beagle.cache.enabled=false‚Äã #Micronuat beagle.cache.endpoint.ttl./endpoint1=10s beagle.cache.endpoint.ttl./endpoint2=1m #Spring (precisa de [] para escapar os /) beagle.cache.endpoint.ttl.[/endpoint1]=10s beagle.cache.endpoint.ttl.[/endpoint2]=1m Na lista abaixo, voc√™ confere quais s√£o as propriedades dispon√≠veis e as configura√ß√µes que podem ser alteradas.\n   Chave Descri√ß√£o Valor Padr√£o     beagle.cache.enabled  Flag indicando se o mecanismo de cache est√° habilitado (ou n√£o). true    beagle.cache.endpoint.include  Lista de endpoints a serem cacheados. Aceita express√µes regulares conforme java.util.regex.Pattern por meio do kotlin.text.Regex. Todos (\u003c=1.0.2)\nNenhum (\u003e=1.1.0)\n   beagle.cache.endpoint.exclude  Lista de endpoints a n√£o serem cacheados. Aceita express√µes regulares conforme java.util.regex.Pattern por meio do kotlin.text.Regex. A exclus√£o √© prioridade em cima da inclus√£o. Nenhum   beagle.cache.endpoint.ttl (\u003e=1.1.0)\n Pares de chave valor, onde a chave √© um endpoint como String e o valor √© uma dura√ß√£o.\n\nA dura√ß√£o √© um n√∫mero seguido da unidade abreviada (s, m, h, etc.) para popular o valor da headerCache-control: max-age para esse endpoint.\n\nO endpoint precisa estar inclu√≠do. Endpoints inclusos t√™m dura√ß√£o de 30s por padr√£o. Dura√ß√µes menores que um segundo viram zero, pela defini√ß√£o do Cache-control: max-age.\n Nenhum     Na web, o cache √© configurado quando definimos as configura√ß√µes iniciais do Beagle Web no par√¢metro strategy, que √© um dos par√¢metros do BeagleModule (se voc√™ estiver usando Angular) ou createBeagleUIService(se voc√™ estiver usando React).\nPor padr√£o, o cache vem habilitado com a estrat√©gia**beagle-with-fallback-to-cache**, por√©m a estrat√©giabeagle-cache-only tamb√©m pode ser utilizada para implementar oprotocolo de cache do Beagle.\nLembre de deixar o CORS habilitado no backend sempre que for utilizar a estrat√©gia de cache do Beagle para Web.\n Abaixo, exemplos de como foi alterado do beagle-with-fallback-to-cache, que √© o padr√£o, para o beagle-cache-only.\nExemplo de configura√ß√£o para o Angular:\n@BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, strategy: 'beagle-cache-only' }) export class Beagle { } Exemplo de configura√ß√£o para o React:\nexport default createBeagleUIService({ baseUrl: \"\", components: {}, strategy: 'beagle-cache-only' })  ","excerpt":" Como funciona o cache? O cache padr√£o √© controlado pelo backend com a ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/cache/configurando-o-cache/","title":"Configurando o cache"},{"body":" How does cache work? As in other platforms the pattern cache is controlled by the backend with the tag cache-control and beagle-hash, they are information that must be provided through request header, where beagle-hash is responsible for providing this hash related to the screen that has been downloaded and cache-control for the life time of this cache as reliable.\nReliable cache A reliable cache is when its life time has not expired yet.\nIn this case, when verifying if there is a cache in the front and it is reliable, the screen is rendered without confirming with the server. This saves time, bandwidth and provides a fluid experience to the user.\nReliable cache its saved in the memory.\nUnreliable cache We also have the unreliable cache, that means its life time has already expired.\nA unreliable cache means that when it is identified it needs to be validaded with a backend to the route with its hash.\nThis moment it stops being saved in the memory and it is saved in a persistent way in the disk.\nLife time The cache‚Äôs life time can have a parameter through the application‚Äôs configuration. In the standard cache implementation the life time is 300 seconds. This time can be altered if the backend sends a different time through the cache-control header, because it has priority in this configuration.\nCache re validation When an unreliable cache is found, it must be validated with the backend. That means when searching a screen, it sends a request in the header the hash it has.\nWhen receiving the request, the server understands that already has a version of this screen saved in the application and compares the hash value sent with the current one saved by the backend. In case they are the same, a response is sent with 304 status and without a body, indicating that the screen remains the same and that cache is reliable again.\nIf the hash sent by the front it is different from the one saved in the backend, a response will be sent normally with a new hash value that it must be updated in the application.\nMemory and disk occupation To avoid a memory and disk overload, both caches apply a replacement policity Least Recently Used (LRU) where the maximum quantity of the records can be also configured through the base cache class by the application. The standard values for memory and disk are 15 and 150, respectively.\nConfiguring and customizing the cache There are allowed customization allowed by pattern class that exists in the cache, like life time and maximum quantity of records in memory and disk.\nIn case the pattern approach does not solve the problem, the applicantion is free to replace the pattern implementation to another one that fits better. For that, the class responsible for the cache management needs to be in accordance with the CacheManagerProtocol protocol.\nEvery platform has different specifications to configure the cache.\nWe listed below, see:\nAndroid iOS Backend Web In Android, the cache is configured when you implement the first Beagle‚Äôs configuration.\nThis implementation happens inside the class named AppBeagleConfig, meaning that it is inside the Beagle‚Äôs configuration class.\nThe cache, is a Beagle‚Äôs internal class where we can define 3 properties, represented by the attributes below:\n enable maxAge memoryMaximumCapacity  @BeagleComponent class AppBeagleConfig : BeagleConfig { override val isLoggingEnabled: Boolean = true override val baseUrl: String get() = \"https://myapp.server.com/\" override val environment: Environment get() = Environment.DEBUG override val cache: Cache = Cache( enabled = true, maxAge = 300, memoryMaximumCapacity = 15 //  ) } Cache‚Äôs attributes    Attribute Definition     enable boolean value that enables or disables the cache in disk and memory.   maxAge int value of time in seconds that a memory cache will be active.   memoryMaximumCapacity Int value that represents the memory cache LRU size. It is the number of screens that will be in the memory, for example, if you define a number 15, it means 15 pages that will be in cache.     In iOS, the cache is configured when you first configure Beagle‚Äôs dependencies.\nWe allow you to change the default configuration of cache by creating a instance of a class named CacheManagerDefault. Inside this class you can define the value of 3 properties:\n memoryMaximumCapacity diskMaximumCapacity cacheMaxAge  let dependencies = BeagleDependencies() let cacheManager = CacheManagerDefault( dependencies: dependencies, config: .init(memoryMaximumCapacity: 15, diskMaximumCapacity: 300, cacheMaxAge: 300)) dependencies.cacheManager = cacheManager Beagle.dependencies = dependencies It is also possible to create your own cache manager and set it to BeagleDependencies if you conform to the protocol CacheManagerProtocol.\npublic protocol CacheManagerProtocol { func addToCache(_ reference: CacheReference) func getReference(identifiedBy id: String) -\u003e CacheReference? func isValid(reference: CacheReference) -\u003e Bool } Cache‚Äôs attributes    Attribute Definition     memoryMaximumCapacity whole value that represents the mamory cache LRU size. It is the number of screens that will be in memory. For example, if you define a number 15, it means 15 pages that will be in cache.   diskMaximumCapacity Whole value that represents the memory cache LRU size. It is the number of screens that will be in the memory. For example, if you define a number 15, it means 15 pages that will be in cache.   cacheMaxAge whole time value in seconds that the memory cache is active.     In the backend this functionality is only supported if you use the started library\nThe cache was created to optimize the response of a request in terms of size and BFF‚Äôs time, when the return is the same as the previous one. The input in this cache last until the server is redeployed or the client installed again.\nTo make this configuration:\n Search inside the ‚Äåsrc/main/resources folder for the fileapplication.properties If you don‚Äôt have it, you can install now.  In case the key is not listed in your file, it means that the standard configuration will be applied automatically.\nbeagle.cache.endpoint.exclude=/imagebeagle.cache.enabled=false‚Äã In the list below, you will find what are the available properties and which configuration can be altered.\n   Key Description Default     beagle.cache.enabled  Flag indicating if the cache mechanism is enabled or not. true    beagle.cache.endpoint.include  Endpoints list to be cached. It accepts regular expressions according to java.util.regex.Pattern throughkotlin.text.Regex. All (\u003c=1.0.2)\nNone (\u003e=1.1.0)\n   beagle.cache.endpoint.exclude  Endpoints list to not be cached. It accepts regular expressions according tojava.util.regex.Pattern. through kotlin.text.Regex. The exclusion is a priority. None   beagle.cache.endpoint.ttl (\u003e=1.1.0)\n Key values pair, where the key is an endpoint like a string and a value is the duration.\n\nThe duration is a number following the abbreviated unit (s, m, h, etc) to populate the header valueCache-control: max-age to this endpoint.\n\nThe endpoint needs to be included. Included enpoints have a 30s duration by default.\nDurations shorter than a second will be zero, by the\nCache-control: max-age definition.\n None     On web, the cache is configured when it‚Äôs defined the initials configurations of Beagle Web on the strategy parameter, which is one of BeagleModule parametes (if you‚Äôre using Angular) orcreateBeagleUIService(if you‚Äôre using React).\nBy default, the cache comes enabled with**beagle-with-fallback-to-cache** strategy, however the beagle-cache-only strategy can also be used to implement Beagle‚Äôs cache protocol.\nRemember to set CORS enabled for backend when you want to use cache‚Äôs strategy for Beagle on Web.\n Below, you can see examples on how to changebeagle-with-fallback-to-cache, which is default forbeagle-cache-only.\nExample of configuration for Angular:\n@BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, strategy: 'beagle-cache-only' }) export class Beagle { } Example of configuration for React:\nexport default createBeagleUIService({ baseUrl: \"\", components: {}, strategy: 'beagle-cache-only' })  ","excerpt":" How does cache work? As in other platforms the pattern cache is ‚Ä¶","ref":"/docs-beagle/docs/resources/cache/how-to-configure-cache/","title":"How to configure cache"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/recursos/","title":"Recursos"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/resources/","title":"Resources"},{"body":" Availability: Beagle 1.0+  Introduction Beagle will use a dependency called Yoga Layout to position components on your application screen. To do this, Yoga calculates the position the elements are, and after that, it does its rendering.\nAbout Yoga Layout Yoga is framework developed by Facebook to position views using the Flexbox concept in Android and iOS applications.\nFlexbox is a CSS concept that organizes elements in containers dynamically so that, regardless of your application dimensions, you can maintain a flexible layout.\nHere follows some key concepts about Flexbox:\n Main Axis Cross Axis Main Size  For Main Size, it is possible to set 3 types of dimensions:\n Cross Size: The size of a cross axis. Main Start and Main The Start and End point in a main axis. Cross Start and Cross End: Start and end in a cross axis.  ‚ÄåThese axis values will depend on what is defined at the Flex-direction property.\nIf it is defined as:\n row ou row-reverse: The main axis will be horizontal and the cross axis will be vertical.   column ou column-reverse: The main axis will be vertical and the cross axis will be horizontal.  Important! The default orientation on Beagle will be a column, meaning the the elements are displayed in a column.  Properties The following atributes willl define specific properties that the Yoga Layout sets.\nUnitValue The Basis, Size, Margin, Padding and Position attributes described above receive a UnitValue that expects a Double value and a UnitType, which is an enum with the following options:\n   UnitType Definition     REAL Apply a Doublevalue   PERCENT Apply a Double value as percentage of the parent size   AUTO Follows the parent‚Äôs value. Except when it has its own size    For the attributes listed below, on the Web, the default isUnitType.AUTO.\nThe UnitType.AUTO can be used on iOS, Android and Web fronts according to the table below:\n   Attributes  iOS\n  Android\n  Web\n     Basis  ‚úî ‚úî ‚úî   Size    ‚úî   Margin    ‚úî   Padding    ‚úî   Position    ‚úî    ","excerpt":" Availability: Beagle 1.0+  Introduction Beagle will use a dependency ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/","title":"Component's Positioning"},{"body":" Disponibilidade: Beagle 1.0+  Introdu√ß√£o No Beagle, voc√™ ter√° de usar uma depend√™ncia chamadaYoga Layout para posicionar os componentes na tela da sua aplica√ß√£o.\nPara fazer isso, o Yoga faz os c√°lculos necess√°rios para posicionar os elementos e, depois disso, faz a sua renderiza√ß√£o.\nSobre o Yoga Layout O Yoga √© um framework Android e iOS desenvolvido pelo Facebook para posicionar views usando o conceito do Flexbox.\nO Flexbox organiza os elementos dentro de containers de forma din√¢mica para que, independente das dimens√µes da sua aplica√ß√£o, voc√™ possa manter um layout flex√≠vel.\nAlguns conceitos chave para entender o Flexbox s√£o:\n Main Axis: eixo horizontal Cross Axis: eixo vertical Main Size: tamanho da dimens√£o dos eixos.  No caso do Main Size, √© poss√≠vel ter 3 tipos diferentes de dimens√µes:\n Cross Size: Tamanho da dimens√£o cross axis. Main Start and Main End: Come√ßo e o fim do main axis. Cross Start and Cross End: Come√ßo e o fim do cross axis.  ‚ÄåEstes eixos dependem do valor atribu√≠do √† propriedade flex-direction para definir a orienta√ß√£o dos elementos em tela.\nSe esta propriedade receber o valor:\n row ou row-reverse: o main axis do container ser√° o horizontal e o cross axis ser√° vertical.   column ou column-reverse: o main axis do container ser√° vertical e o cross axis ser√° horizontal.  Importante ressaltar que o default do Beagle √© o valor columnou seja, os elementos ser√£o dispostos em colunas por padr√£o.  Propriedades dispon√≠veis A partir do Yoga Layout, voc√™ pode utilizar as seguintes propriedades para inserir, alterar ou eliminar componentes em tela:\nUnitValue As propriedades Basis, Size, Margin, Padding e Position descritas acima recebem um UnitValue que espera um valorDoublee um UnitType, que √© um enumcom as seguintes op√ß√µes:\n   UnitType Defini√ß√£o     REAL Aplica o valor Double   PERCENT Aplica o valor Double em forma de percentual do tamanho do pai   AUTO Segue o valor do pai. Exceto quando possui tamanho pr√≥prio    Para as propriedades listadas abaixo, na Web, o default √© UnitType.AUTO.\nO UnitType.AUTO pode ser usado nas frentes iOS, Android e Web de acordo com a tabela abaixo:\n   Propriedade  iOS\n  Android\n  Web\n     Basis  ‚úî ‚úî ‚úî   Size    ‚úî   Margin    ‚úî   Padding    ‚úî   Position    ‚úî    ","excerpt":" Disponibilidade: Beagle 1.0+  Introdu√ß√£o No Beagle, voc√™ ter√° de usar ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/","title":"Posicionamento de componentes"},{"body":" Flex Direction The flex-direction property is applied to a container and defines the display axis / flow in which the elements will be organized. This property has the following attributes:row, row-reverse, column, column-reverse.\nThe examples where the function createText was used, returned a text component with an applied style. But this configuration is not required.  See below the components' behaviour examples for each attribute:\nRow Items are organized in a line form from left to right:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Row Reverse Items are organized in a line form from right to left:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.rowReverse) ) ) ) }  Column (Default) Items are organized from top to bottom:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) ) ) ) }  Column Reverse Items are organized from bottom to top:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.columnReverse) ) ) ) }  For more information about PositionType, check out the Yoga Layout documentation\n","excerpt":" Flex Direction The flex-direction property is applied to a container ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/flex-direction/","title":"Flex Direction"},{"body":" Flex Direction A propriedade flex-direction √© aplicada a um container e define o eixo/fluxo de exibi√ß√£o em que os elementos ser√£o organizados. Essa propriedade tem os seguintes atributos: row, row-reverse, column, column-reverse.\nNos exemplos abaixo, foi utilizada fun√ß√£o createText com intuito de retornar um componente de texto com um estilo aplicado. Mas essa configura√ß√£o n√£o √© obrigat√≥ria.  Confira abaixo os exemplos de comportamento dos elementos para cada atributo:\nRow Os itens s√£o organizados em forma de linha exibindo seus elementos da esquerda para a direita:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Row Reverse Os itens s√£o organizados em forma de linha, exibindo seus elementos da direita para a esquerda:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.rowReverse) ) ) ) }  Column (Padr√£o) Os itens s√£o organizados em forma de colunas e s√£o posicionados de cima para baixo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) ) ) ) }  Column Reverse Os itens s√£o organizados em forma de colunas e s√£o posicionados de baixo para cima:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.columnReverse) ) ) ) }  Para saber o Flex Direction, acesse a documenta√ß√£o no Yoga Layout  ","excerpt":" Flex Direction A propriedade flex-direction √© aplicada a um container ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/flex-direction/","title":"Flex Direction"},{"body":" Grow This property defines the proportion that an item should grow when necessary. Its value is 0 by default and that indicates that the item should not grow. This attribute accepts only Double positive values\nExample 1 The grow applied has value 0 and the container size did not change\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyStyle( Style( backgroundColor = \"#000000\", flex = Flex(grow = 0.0) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) ) ) ) }  Example 2 Grow 1.0 has been applied and the container size has grown until it meets the screen limits:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyStyle( Style( backgroundColor = \"#000000\", flex = Flex(grow = 1.0) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) ) ) ) }  For more information about Grow, check out the Yoga Layout documentation.\n","excerpt":" Grow This property defines the proportion that an item should grow ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/grow/","title":"Grow"},{"body":" Grow Esta propriedade define a propor√ß√£o que um item deve crescer, quando necess√°rio. Seu valor √© 0, por padr√£o e o que indica que o item n√£o deve crescer. Esse atributo aceita apenas valores num√©ricos Doublepositivo.\nExemplo 1 O grow foi aplicado com valor 0, e o container ficou do mesmo tamanho do conte√∫do:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyStyle( Style( backgroundColor = \"#000000\", flex = Flex(grow = 0.0) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) ) ) ) }  Exemplo 2 O grow = 1.0 foi aplicado e o container ficou com o tamanho da tela:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyStyle( Style( backgroundColor = \"#000000\", flex = Flex(grow = 1.0) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) ) ) ) }  Para saber o Grow, acesse a documenta√ß√£o no Yoga Layout  ","excerpt":" Grow Esta propriedade define a propor√ß√£o que um item deve crescer, ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/grow/","title":"Grow"},{"body":" Justify Content Justify-content defines the alignment of items along the main axis (horizontally) and has the following attributes:flex-start, flex-end, center, space-between, space-around e space-Evenly.\nThe size of a container can interfere on this property behaviour. The elements when are positioned, they can be set in a column instead a line, like the example below. If the container does not have enough height to contain all the stacked elements, this property won‚Äôt be able to show the element in a column,  Flex Start (Default) Items are aligned at the beginning of the main axis; lined up at the screen top\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.flexStart) ) ) ) }  Flex End Items are aligned from the end of the main axis; aligned at screen the bottom\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.flexEnd) ) ) ) }  Center Items are aligned at the center of the main axis; in the center of the screen:\nKotlin Swift {% code title=\"\" %}}\nprivate fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.center) ) ) ) }  Space Between The first item is moved to main axis start, the last is moved to the main axis end and the rest are evenly distributed making the space between them is equal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_BETWEEN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceBetween) ) ) ) }  Space Around Items are evenly distributed along the main axis. Equal margins are assigned at main axis start and endd (or left and right, depending on the direction of the main axis). For this reason, the first and last items are not sticked at the edges.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_AROUND ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceAround) ) ) ) }  Space Evenly Items are evenly distributed along the main axis:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceEvenly) ) ) ) }  For more information about Justify Content, check out the Yoga Layout documentation\n","excerpt":" Justify Content Justify-content defines the alignment of items along ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/justify-content/","title":"Justify Content"},{"body":" Justify Content O justify-content define o alinhamento dos itens ao longo do eixo principal do container (horizontalmente) e tem os seguintes atributos: flex-start, flex-end, center, space-between, space-around e space-Evenly.\nO tamanho do container pode interferir no comportamento dessa propriedade. Isso significa que, quando os elementos s√£o posicionados, podem ser dispostos em uma coluna em vez de uma linha, como no exemplo abaixo.\nNesse momento, se o container n√£o possuir uma altura suficiente para conter os elementos empilhados, essa propriedade n√£o conseguir√° mostrar os elementos em uma coluna.\n Flex Start (padr√£o) Os itens s√£o alinhados a partir do in√≠cio do eixo principal; alinhados em cima, no come√ßo da tela:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.flexStart) ) ) ) }  Flex End Os itens s√£o alinhados a partir do fim do eixo principal; alinhados em baixo, no fim da tela:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.flexEnd) ) ) ) }  Center Os itens s√£o alinhados ao centro do eixo principal; no centro da tela:\nKotlin Swift {% code title=\"\" %}}\nprivate fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.center) ) ) ) }  Space Between O primeiro item √© deslocado para o in√≠cio do eixo principal, o √∫ltimo √© deslocado para o fim do eixo principal e os demais s√£o distribu√≠dos uniformemente; o espa√ßo entre eles √© igual:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_BETWEEN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceBetween) ) ) ) }  Space Around Os itens s√£o uniformemente distribu√≠dos ao longo do eixo principal. Aqui, s√£o atribu√≠das margens iguais acima e abaixo (ou √† esquerda e √† direita, dependendo da dire√ß√£o do eixo principal). Por isso o primeiro e o √∫ltimo item n√£o ficam ‚Äúcolados‚Äù nas bordas do container:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_AROUND ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceAround) ) ) ) }  Space Evenly Os itens s√£o uniformemente distribu√≠dos ao longo do eixo principal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceEvenly) ) ) ) }  Para saber o Justify Content, acesse a documenta√ß√£o no Yoga Layout  ","excerpt":" Justify Content O justify-content define o alinhamento dos itens ao ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/justify-content/","title":"Justify Content"},{"body":" Align Content This property defines how the lines are distributed along the cross axis (vertical)and has the following attributes:flex-start, flex-end, center, space-between, space-around e stretch.\nStretch Lines are evenly distributed along the cross axis and take up all the available space:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.STRETCH ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.stretch) ) ) ) }  Flex Start (default) Lines are distributed at the beginning of the cross axis:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.flexStart) ) ) ) }  Flex End Lines are distributed at the end of the cross axis\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.flexEnd) ) ) ) }  Center Lines are kept in center of the cross axis:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.center) ) ) ) }  Space Between The first line is moved to the beginning of the cross axis, and the last one to the end. The rest are evenly distributed between:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.SPACE_BETWEEN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.spaceBetween) ) ) ) }  Space Around Lines are evenly distributed along the cross axis. Margins are assigned equally to the left and right (or above and below, depending on the direction of the cross axis). That is why the first and last lines are not sticked to the edges\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.SPACE_AROUND ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.spaceAround) ) ) ) }  For more information about Align Content, check out the Yoga Layout documentation.\n","excerpt":" Align Content This property defines how the lines are distributed ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/align-content/","title":"Align Content"},{"body":" Align Content Essa propriedade define como as linhas s√£o distribu√≠das ao longo do eixo transversal (vertical) do container e tem os seguintes atributos: flex-start, flex-end, center, space-between, space-around e stretch.\nStretch As linhas s√£o distribu√≠das uniformemente ao longo do eixo transversal e ocupa todo o espa√ßo dispon√≠vel:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.STRETCH ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.stretch) ) ) ) }  Flex Start (padr√£o) As linhas s√£o distribu√≠das no in√≠cio do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.flexStart) ) ) ) }  Flex End As linhas s√£o distribu√≠das no fim do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.flexEnd) ) ) ) }  Center As linhas s√£o mantidas no centro do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.center) ) ) ) }  Space Between A primeira linha √© deslocada para o in√≠cio do eixo transversal, a √∫ltima para o final e as demais s√£o distribu√≠das uniformemente entre eles:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.SPACE_BETWEEN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.spaceBetween) ) ) ) }  Space Around As linhas s√£o uniformemente distribu√≠das ao longo do eixo transversal. As margens s√£o atribu√≠das igualmente √† esquerda e √† direita (ou acima e abaixo, dependendo da dire√ß√£o do eixo transversal). Por isso a primeira e a √∫ltima linha n√£o ficam ‚Äúcoladas‚Äù nas bordas do container:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.SPACE_AROUND ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.spaceAround) ) ) ) }  Para saber o Align Content, acesse a documenta√ß√£o no Yoga Layout.  ","excerpt":" Align Content Essa propriedade define como as linhas s√£o distribu√≠das ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/align-content/","title":"Align Content"},{"body":" Align Items This property defines how items are distributed along the container‚Äôs transversal axis and has the following attributes:flex-start, flex-end, center, baseline e stretch.\nStretch Items will be expanded to fill the entire dimension of the cross axis (height or width).\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.STRETCH ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.stretch) ) ) ) }  Flex Start Items are shifted to the cross axis start:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.flexStart) ) ) ) }  Flex End Items are shifted to the cross axis end:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.flexEnd) ) ) ) }  Center Items are centered on the cross axis:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  Baseline Items are aligned acording to the firt text line in each element.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.BASELINE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(70).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(40).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(100).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .grow(1) .justifyContent(.spaceEvenly) .alignItems(.baseline) ) ) ) }  For more information about Align Itens, check out the Yoga Layout documentation.\n","excerpt":" Align Items This property defines how items are distributed along the ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/align-items/","title":"Align Items"},{"body":" Align Items Essa propriedade define como os itens s√£o distribu√≠dos ao longo do eixo transversal do container e tem os seguintes atributos: flex-start, flex-end, center, baseline e stretch.\nStretch Os itens ser√£o expandidos para preencher toda a dimens√£o do eixo transversal (altura ou largura) da tela:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.STRETCH ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.stretch) ) ) ) }  Flex Start Os itens s√£o deslocadas para o in√≠cio do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.flexStart) ) ) ) }  Flex End Os itens s√£o deslocadas para o final do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.flexEnd) ) ) ) }  Center Os itens s√£o centralizados no eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  Baseline Os itens s√£o alinhados a partir da base da primeira linha de texto de cada um:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.BASELINE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(70).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(40).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(100).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .grow(1) .justifyContent(.spaceEvenly) .alignItems(.baseline) ) ) ) }  Para saber mais sobre o Align Items, acesse a documenta√ß√£o no Yoga Layout.  ","excerpt":" Align Items Essa propriedade define como os itens s√£o distribu√≠dos ao ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/align-items/","title":"Align Items"},{"body":" Align Self This property will override the behavior defined by the align-items property. It has the following attributes:flex-start, flex-end, center, auto, baseline e stretch.\nAlign self is set to each component and not to a container.  Each number above represents one property:\n1 = auto: Will follow positioning set by the align-items property;\n2 = stretch: Items will streach until the fill the whole cross axis;\n3 = flex-start: Items displays at the cross axis begining;\n4 = flex-end: Items displays at the cross axis end;\n5 = center: Items displays at the cross axis center;\n6 = baseline: Items are aligned acording to the firt text line in each element..\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(alignSelf = AlignSelf.AUTO) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( flex = Flex(alignSelf = AlignSelf.STRETCH) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( flex = Flex(alignSelf = AlignSelf.FLEX_START) ), createText(backgroundColor = \"#dd7631\", text = \"4\").applyFlex( flex = Flex(alignSelf = AlignSelf.FLEX_END) ), createText(backgroundColor = \"#649d66\", text = \"5\").applyFlex( flex = Flex(alignSelf = AlignSelf.CENTER) ), createText(backgroundColor = \"#dd7631\", text = \"6\").applyFlex( flex = Flex(alignSelf = AlignSelf.BASELINE) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().alignSelf(.auto)), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().alignSelf(.stretch)), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().alignSelf(.flexStart)), createText(backgroundColor: \"#142850\",text: \"4\").applyFlex( Flex().alignSelf(.flexEnd)), createText(backgroundColor: \"#dd7631\",text: \"5\").applyFlex( Flex().alignSelf(.center)), createText(backgroundColor: \"#649d66\",text: \"6\").applyFlex( Flex().alignSelf(.baseline)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .grow(1) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  For more information about Align Self, check out the Yoga Layout documentation\n","excerpt":" Align Self This property will override the behavior defined by the ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/align-self/","title":"Align Self"},{"body":" Align Self Permite que o item sobrescreva o comportamento definido pela propriedade align-items. Ela tem os seguintes atributos:flex-start, flex-end, center, auto, baseline e stretch.\nO align self √© aplicado em cada componente e n√£o no container.  Cada um dos n√∫meros acima representa um atributo:\n1 = auto: Respeita o comportamento definido no container por meio do align-items;\n2 = stretch: O item ser√° esticado para preencher toda a dimens√£o do eixo transversal (altura ou largura);\n3 = flex-start: O item √© deslocado para o in√≠cio do eixo transversal;\n4 = flex-end: O item √© deslocado para o final do eixo transversal;\n5 = center: O item √© centralizado no eixo transversal;\n6 = baseline: O item √© alinhado a partir da base da primeira linha de texto dos demais.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(alignSelf = AlignSelf.AUTO) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( flex = Flex(alignSelf = AlignSelf.STRETCH) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( flex = Flex(alignSelf = AlignSelf.FLEX_START) ), createText(backgroundColor = \"#dd7631\", text = \"4\").applyFlex( flex = Flex(alignSelf = AlignSelf.FLEX_END) ), createText(backgroundColor = \"#649d66\", text = \"5\").applyFlex( flex = Flex(alignSelf = AlignSelf.CENTER) ), createText(backgroundColor = \"#dd7631\", text = \"6\").applyFlex( flex = Flex(alignSelf = AlignSelf.BASELINE) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().alignSelf(.auto)), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().alignSelf(.stretch)), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().alignSelf(.flexStart)), createText(backgroundColor: \"#142850\",text: \"4\").applyFlex( Flex().alignSelf(.flexEnd)), createText(backgroundColor: \"#dd7631\",text: \"5\").applyFlex( Flex().alignSelf(.center)), createText(backgroundColor: \"#649d66\",text: \"6\").applyFlex( Flex().alignSelf(.baseline)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .grow(1) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  Para saber mais sobre o align self, acesse a documenta√ß√£o no Yoga Layout.  ","excerpt":" Align Self Permite que o item sobrescreva o comportamento definido ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/align-self/","title":"Align Self"},{"body":" Flex Wrap By default, items in a container will try to fit in a single line, but this will only happen when their original width can be adjusted.\nThe flex-wrap property changes this behavior and ‚Äúwraps‚Äù items. It has the following attributes: nowrap, wrap, wrap-reverse.\nNo Wrap (default) Items displays in one single line:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.NO_WRAP ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.noWrap) ) ) ) }  Wrap A break line will occur and the rightmost items will drop one line:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.wrap) ) ) ) }  Wrap Reverse The break line will upline the rightmost items:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.wrapReverse) ) ) ) }  For more information about Flex Wrap, check out the Yoga Layout documentation.\n","excerpt":" Flex Wrap By default, items in a container will try to fit in a ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/flex-wrap/","title":"Flex Wrap"},{"body":" Flex Wrap Por padr√£o os itens do container tentar√£o se ajustar em uma √∫nica linha dentro do container, mas para que isso ocorra a sua largura original pode ser ajustada. A propriedade flex-wrap altera esse comportamento e faz a ‚Äúquebra de linha‚Äù nos itens, e ela tem os seguintes atributos: nowrap, wrap, wrap-reverse.\nNo Wrap (padr√£o) Todos os itens ser√£o dispostos em uma linha:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.NO_WRAP ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.noWrap) ) ) ) }  Wrap A quebra de linha ir√° acontecer e os itens mais √† direita ser√£o deslocados para a linha de baixo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.wrap) ) ) ) }  Wrap Reverse A quebra de linha ir√° acontecer e os itens mais √† direita ser√£o deslocados para a linha acima:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.wrapReverse) ) ) ) }  Para saber mais sobre o Flex wrap, acesse a documenta√ß√£o no Yoga Layout.  ","excerpt":" Flex Wrap Por padr√£o os itens do container tentar√£o se ajustar em uma ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/flex-wrap/","title":"Flex Wrap"},{"body":" Margin Margin will apply some space outboarding the elements: all, bottom, end, horizontal, left, right, start, top, vertical\nAtributes All Defines some space around the element in all directions:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(all = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().margin(EdgeValue().all(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Bottom Defines some space at the element bottom:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(bottom = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().bottom(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) .justifyContent(.flexStart) .grow(1) ) ) ) }  Left Defines some space at the element left side:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(left = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().left(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Right Defines some space at the element right side:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(right = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().right(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Top Defines some space at the element top:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(top = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().top(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Horizontal Defines some horizontal space at the element sides:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(horizontal = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().horizontal(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Vertical Defines some vertical space at the element top and botton sides:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(vertical = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().vertical(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) .justifyContent(.flexStart) .grow(1) ) ) ) }  For more information about Margin, check out theYoga Layout documentation\n","excerpt":" Margin Margin will apply some space outboarding the elements: all, ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/margin/","title":"Margin"},{"body":" Margin Margin aplica um espa√ßamento no elemento filho, e tem os seguintes atributos: all, bottom, end, horizontal, left, right, start, top, vertical\nPropriedades All Define um espa√ßamento em todos os lados do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(all = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().margin(EdgeValue().all(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Bottom Define um espa√ßamento na parte inferior do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(bottom = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().bottom(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) .justifyContent(.flexStart) .grow(1) ) ) ) }  Left Define um espa√ßamento no lado esquerdo do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(left = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().left(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Right Define um espa√ßamento no lado direito do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(right = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().right(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Top Define um espa√ßamento na parte superior do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(top = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().top(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Horizontal Define um espa√ßamento no eixo horizontal do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(horizontal = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().horizontal(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Vertical Define um espa√ßamento no eixo vertical do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(vertical = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().vertical(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) .justifyContent(.flexStart) .grow(1) ) ) ) }  Para saber mais, acesse Margin ou uma se√ß√£o completa na documenta√ß√£o do Yoga Layout.  ","excerpt":" Margin Margin aplica um espa√ßamento no elemento filho, e tem os ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/margin/","title":"Margin"},{"body":" Padding This property allows spacing inside an element. Within Padding, you will also find the following atributes:\nall, bottom, end, horizontal, left, right, start, top, vertical\nAtributes All Defines some space inside the element in all directions:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(all = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().all(20) flex: Flex().flexDirection(.row) ) ) ) ) }   Bottom Defines some space at the bottom inside a element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) )applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(bottom = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().bottom(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Left Defines some space inside the element, at the left side:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(left = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().left(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Right Defines some space inside the element, at the right side:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(right = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().right(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Top Defines some space inside the element, at the top:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(top = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().top(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Horizontal Defines some horizontal space inside the element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(horizontal = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().horizontal(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Vertical Defines some vertical space inside the element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(vertical = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().vertical(20) flex: Flex().flexDirection(.row) ) ) ) ) }  For more information about Padding, check out the Yoga Layout documentation\n","excerpt":" Padding This property allows spacing inside an element. Within ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/padding/","title":"Padding"},{"body":" Padding Esta propriedade permite aplicar um espa√ßamento no elemento pai. Dessa forma, todo elemento filho que for criado depois dessa configura√ß√£o j√° vir√° com espa√ßamento pr√©-definido.\nDentro do Padding, voc√™ encontra ainda as seguintes propriedades:\nall, bottom, end, horizontal, left, right, start, top, vertical\nPropriedades All √â ele quem define um espa√ßamento em todos os lados do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(all = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().all(20) flex: Flex().flexDirection(.row) ) ) ) ) }   Bottom √â ele quem define um espa√ßamento na parte inferior do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) )applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(bottom = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().bottom(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Left √â ele quem define um espa√ßamento no lado esquerdo do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(left = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().left(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Right √â ele quem define um espa√ßamento no lado direito do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(right = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().right(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Top √â ele quem define um espa√ßamento na parte superior do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(top = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().top(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Horizontal √â ele quem define um espa√ßamento no eixo horizontal do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(horizontal = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().horizontal(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Vertical √â ele quem define um espa√ßamento no eixo vertical do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(vertical = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().vertical(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Para saber mais sobre Padding, acesse a documenta√ß√£o do Yoga Layout  ","excerpt":" Padding Esta propriedade permite aplicar um espa√ßamento no elemento ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/padding/","title":"Padding"},{"body":" Position This property defines an elements position on screen and its values are: top, right, bottom,left\nThey behave according to the Position Type (defined after this one ) of this element. The element inside the Position can have 2 types of positioning\n Relative: Elements move in a specific direction respecting each other bondaries. Absolute: The elements move in the same direction defined by the parent element.  It will be more clear when we address this property ahead.  Propriedades All It sets the same value for all positions:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(all = 50.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().all(50))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Bottom It sets a spacing at the bottom of an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(bottom = 50.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().bottom(50))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Left It defines a spacing on the left side of an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(left = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().left(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Right It defines a spacing on the right side of an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(right = 100.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().right(100))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Top It defines a spacing on the top of an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(top = 100.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().top(100))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Horizontal It defines horizontal spacing at an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(horizontal = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().horizontal(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Vertical It defines vertical spacing at an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(vertical = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().vertical(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  For more information about Position, check out the Yoga Layout documentation\n","excerpt":" Position This property defines an elements position on screen and its ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/position/","title":"Position"},{"body":" Position Esta propriedade determina a posi√ß√£o de um assume em tela e os seus valores top, right, bottom, left se comportam de acordo com o Position Type deste elemento.\nO elemento dentro do Position pode ter diferentes tipos de deslocamento se forem:\n Relative: os elementos se deslocam em uma dire√ß√£o espec√≠fica Absolute: os elementos se deslocam na mesma dire√ß√£o definida para o elemento pai.  Propriedades All √â ele quem define o mesmo valor para todas posi√ß√µes. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(all = 50.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().all(50))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Bottom √â ele quem define um espa√ßamento na parte inferior do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(bottom = 50.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().bottom(50))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Left √â ele quem define um espa√ßamento no lado esquerdo do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(left = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().left(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Right √â ele quem define um espa√ßamento no lado direito do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(right = 100.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().right(100))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Top √â ele quem define o posicionamento do top. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(top = 100.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().top(100))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Horizontal √â ele quem define um valor horizontal adicionando valor no left e right. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(horizontal = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().horizontal(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Vertical √â ele quem define um valor vertical adicionando valor no top e bottom. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(vertical = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().vertical(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Para saber mais sobre Position, acesse a documenta√ß√£o do Yoga Layout.  ","excerpt":" Position Esta propriedade determina a posi√ß√£o de um assume em tela e ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/position/","title":"Position"},{"body":" PositionType This property defines the position of an element within the parent and whether it should be used as Relative or Absolute\nRelative (default) This property positions the element in relation to the other elements in the same flow, causing them to move respecting the limits on their sibling elements.\nThis is how it displays\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 130.unitReal(),height = 130.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 100.unitReal(),height = 100.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),height = 70.unitReal())) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().height(130).width(130))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().height(100).width(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().height(70).width(70))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Absolute This element when you wish that an element ‚Äúescape‚Äù the normal flow on the layout. He will ignore other elements and displays acording to its father parent.\nCheck how it works:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 130.unitReal(),height = 130.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 100.unitReal(),height = 100.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),height = 70.unitReal()), positionType = FlexPositionType.ABSOLUTE) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().height(130).width(130))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().height(100).width(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .positionType(.absolute) .size(Size().height(70).width(70))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  For more information about PositionType, check out the Yoga Layout documentation.\n","excerpt":" PositionType This property defines the position of an element within ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/positiontype/","title":"Positiontype"},{"body":" PositionType √â a propriedade que define qual a posi√ß√£o do elemento dentro do pai e ainda se ele deve ser usado como Relativo ou Absoluto.\nRelativo (Padr√£o) Por padr√£o, esta propriedade posiciona o elemento em rela√ß√£o aos demais elementos no mesmo fluxo, fazendo com que eles se desloquem respeitando os limites de seus elementos irm√£os.\nVeja como funciona neste exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 130.unitReal(),height = 130.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 100.unitReal(),height = 100.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),height = 70.unitReal())) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().height(130).width(130))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().height(100).width(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().height(70).width(70))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Absoluto Por padr√£o, voc√™ usa este elemento quando quiser que um elemento n√£o participe do fluxo normal do layout. Em vez disso, ele √© apresentado independentemente de seus irm√£os.\nVeja como funciona neste exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 130.unitReal(),height = 130.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 100.unitReal(),height = 100.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),height = 70.unitReal()), positionType = FlexPositionType.ABSOLUTE) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().height(130).width(130))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().height(100).width(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .positionType(.absolute) .size(Size().height(70).width(70))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Para saber mais sobre Position Type, acesse a documenta√ß√£o do Yoga Layout.  ","excerpt":" PositionType √â a propriedade que define qual a posi√ß√£o do elemento ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/positiontype/","title":"Positiontype"},{"body":" Basis This property defines the standard size of an item along the main axis. It could change according to the element caracteristics, which means that:\n If the father element has a Flex value set as: FlexDirection: row.The basis will define the screen width; If the father element has a Flex Value set as: FlexDirection: column.The basis defines the screen height.  How is it used FlexDirection: row Here the flexDirection: row is used to set the screen width size:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( Text(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ), Text(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ), Text(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#dd7631\",text: \"2\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#649d66\",text: \"3\") .applyFlex(Flex().basis(100)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  FlexDirection Column Here the flexDirection: column is used to set the screen height size\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = 100.unitReal() ) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = 100.unitReal() ) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = 100.unitReal() ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#dd7631\",text: \"2\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#649d66\",text: \"3\") .applyFlex(Flex().basis(100)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) ) ) ) }  Basis with UnitType.AUTO It is also possible to put UnitValue (0.0, UnitType.AUTO) when using the basis. In this case, the value 0.0 is not relevant, because using UnitType.AUTO the main axis will be adjusted according to the size of the content. Unless a size fix value is also set for the component in the same direction as the main axis.\nKotlin  private fun screen() :Widget{ return Container( children = listOf( Text(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ), Text(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ), Text(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  For more information about Basis, check out the Yoga Layout documentation.  ","excerpt":" Basis This property defines the standard size of an item along the ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/basis/","title":"Basis"},{"body":" Basis Esta propriedade define o tamanho padr√£o de um item ao longo do eixo principal. √â poss√≠vel que ele mude de acordo com o elemento, o que significa dizer que:\n Se o pai tiver o valor flexDirection: row o basis define o valor da largura (width); Se o pai tiver o cont√™iner flexDirection: column, basis define o valor da altura (height).  Exemplos de uso FlexDirection: Row Neste exemplo, voc√™ v√™ como a aplica√ß√£o usando o flexDirection: row para manipular o tamanho da largura da tela.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( Text(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ), Text(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ), Text(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#dd7631\",text: \"2\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#649d66\",text: \"3\") .applyFlex(Flex().basis(100)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }   FlexDirection Column J√° neste exemplo, voc√™ v√™ como fica a aplica√ß√£o usando o flexDirection: column para manipular o tamanho da altura da tela.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = 100.unitReal() ) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = 100.unitReal() ) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = 100.unitReal() ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#dd7631\",text: \"2\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#649d66\",text: \"3\") .applyFlex(Flex().basis(100)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) ) ) ) }  Basis com UnitType.AUTO √â poss√≠vel tamb√©m passar UnitValue(0.0, UnitType.AUTO) quando utilizar basis. Neste caso o valor 0.0 n√£o √© relevante, pois usando UnitType.AUTO o eixo principal ser√° ajustado de acordo com tamanho do conte√∫do. Exceto se um valor de sizefixo tamb√©m for definido para o componente no mesmo sentido do eixo principal.\nKotlin  private fun screen() :Widget{ return Container( children = listOf( Text(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ), Text(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ), Text(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  Para saber mais sobre Basis, acesse a documenta√ß√£o do Yoga Layout.  ","excerpt":" Basis Esta propriedade define o tamanho padr√£o de um item ao longo do ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/basis/","title":"Basis"},{"body":" Shrink This atribute defines an item‚Äôs ability to shrink, reducing child elements along the main axis. The reduction of the elements is done in a way that the total size of all the shrunk children does not exceed the size of the main container.\nWith Shrink, the element receives a double value, which will decrease the element according to the space at the container:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal()), shrink = 3.0) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, size = Size(width = 300.unitReal(),height = 300.unitReal()) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(150).height(150))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(150).height(150))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .size(Size().width(150).height(150)) .shrink(0.3) ), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .size(Size().width(300).height(300)) ) ) ) }  For more information about Shrink, check out the Yoga Layout documentation.\n","excerpt":" Shrink This atribute defines an item‚Äôs ability to shrink, reducing ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/shrink/","title":"Shrink"},{"body":" Shrink Esta propriedade define a capacidade de um item encolher, reduzindo os elementos filhos ao longo do eixo principal.\nA diminui√ß√£o dos elementos √© feita de uma forma que o tamanho total de todos os filhos encolhidos n√£o ultrapasse o tamanho do container principal.\nCom o Shrink, o elemento recebe um valor double, que ir√° diminuir o elemento de acordo com espa√ßo do container. Veja no exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal()), shrink = 3.0) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, size = Size(width = 300.unitReal(),height = 300.unitReal()) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(150).height(150))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(150).height(150))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .size(Size().width(150).height(150)) .shrink(0.3) ), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .size(Size().width(300).height(300)) ) ) ) }  Para saber mais sobre Shrink, acesse a documenta√ß√£o do Yoga Layout.  ","excerpt":" Shrink Esta propriedade define a capacidade de um item encolher, ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/shrink/","title":"Shrink"},{"body":" Size These atributes handles the item‚Äôs sizes on screen.\nSize has the following atributes: width, heigth, maxWidth,maxHeight, minWidth, minHeigh, aspectRatio\nAtributos: Width Defines the item width\nHeight Defines the item height\nMaxWidth Defines a maximum width an item can fill up to.\nMaxHeight Defines a maximum height an item can fill up to.\nMinWidth Defines a minimum width an item can shrink down to.\nMinHeight Defines a minimum heght an item can shrink down to.\nAspectRatio This property created by Yoga Layout defines the width ratio according to the item‚Äôs height, following a logic of a double\u003e 0 value.\nFor example, if you apply a height of 100dp to a component and the aspectRatio of 2, the width will be 2 times the height where it will have the value of 200dp.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 50.unitReal(),height = 50.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(maxWidth = 70.unitReal(),maxHeight = 70.unitReal(), minWidth = 30.unitReal(),minHeight = 30.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),aspectRatio = 2.0)) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size() .width(50).height(50))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size() .maxWidth(70).maxHeight(70) .minWidth(30).minHeight(30))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .size(Size().width(70).aspectRatio(2.0)) ), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  For more information about Size, check out the Yoga Layout documentation.\n","excerpt":" Size These atributes handles the item‚Äôs sizes on screen.\nSize has the ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/size/","title":"Size"},{"body":" Size Esta propriedade manipula toda parte de tamanho do item em tela. O Size conta com os seguintes atributos:\nwidth, heigth, maxWidth,maxHeight, minWidth, minHeigh, aspectRatio\nAtributos: Width Define o tamanho da largura do item\nHeight Define o tamanho da altura do item.\nMaxWidth Define uma largura m√°xima.\nMaxHeight Define uma altura m√°xima.\nMinWidth Define uma largura m√≠nima.\nMinHeight Define uma altura m√≠nima.\nAspectRatio √â uma propriedade criada pelo Yoga Layout que define a propor√ß√£o de largura de acordo com altura do item, seguindo uma l√≥gica de valor double \u003e 0.\nIsso significa dizer que, por exemplo, se voc√™ aplicar uma altura de 100dp em um componente e o aspectRatio de 2, a largura ser√° 2 vezes a altura onde ter√° o valor de 200dp.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 50.unitReal(),height = 50.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(maxWidth = 70.unitReal(),maxHeight = 70.unitReal(), minWidth = 30.unitReal(),minHeight = 30.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),aspectRatio = 2.0)) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size() .width(50).height(50))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size() .maxWidth(70).maxHeight(70) .minWidth(30).minHeight(30))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .size(Size().width(70).aspectRatio(2.0)) ), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  Para saber mais sobre Size, acesse a documenta√ß√£o do Yoga Layout.  ","excerpt":" Size Esta propriedade manipula toda parte de tamanho do item em tela. ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/size/","title":"Size"},{"body":" Display This property defines how this component displays.That allows a container to be flexible or blocked according to the value defined. The Display also provides a flexible context for all of its direct child elements.\nIn this property, we have two attributes:\n Flex None  Flex When this value is set the elements inside this container turns into Flexbox elements.\nNone When this value is set, the elements won‚Äôt shown on the screen, thus having their height and width 0.\n Kotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(display = FlexDisplay.NONE) ), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW, alignItems = AlignItems.CENTER, justifyContent = JustifyContent.CENTER, grow = 1.0 ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().display(.none)), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) .alignItems(.center) ) ) ) }  For more information about Display Margin, check out the Yoga Layout documentation.\n","excerpt":" Display This property defines how this component displays.That allows ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/display/","title":"Display"},{"body":" Display Esta propriedade define o tipo de exibi√ß√£o deste componente, o que permite um container ser flex√≠vel ou bloqueado de acordo com o valor passado.\nO Display possibilita ainda um contexto flex√≠vel para todos os seus elementos filhos diretos. Nesta propriedade, temos dois atributos:\n Flex None  Flex Quando esse valor for definido permite que os elementos ficam flex√≠vel.\nNone Quando esse valor for definido permite que os elementos n√£o sejam mostrado na tela, assim tendo sua altura e largura com valor 0.\n Kotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(display = FlexDisplay.NONE) ), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW, alignItems = AlignItems.CENTER, justifyContent = JustifyContent.CENTER, grow = 1.0 ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().display(.none)), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) .alignItems(.center) ) ) ) }  ","excerpt":" Display Esta propriedade define o tipo de exibi√ß√£o deste componente, ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/display/","title":"Display"},{"body":" Flex This property defines how items will be filled according to the space available along the main axis. Flex sets values ‚Äã‚Äãapplied to each child‚Äôs property.\nThus, it takes the values ‚Äã‚Äãof all the child elements and makes the following calculation: they add and then divide by each value of the flex property applied to the child. The result should be the child‚Äôs filled space in the container.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex(Flex(flex = 1.0)), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex(Flex(flex = 2.0)), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex(Flex(flex = 3.0)) ) ).applyFlex( Flex( grow = 1.0 ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().flex(1)), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().flex(2)), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().flex(3)) ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) ) ) ) }  For more information about Flex Margin, check out the Yoga Layout documentation.\n","excerpt":" Flex This property defines how items will be filled according to the ‚Ä¶","ref":"/docs-beagle/docs/resources/components-positioning/flex/","title":"Flex"},{"body":" Flex Esta propriedade define como os itens do container ser√£o preenchidos de acordo com o espa√ßo dispon√≠vel ao longo do eixo principal.\nPara isso, o Flex estabelece os valores aplicados na propriedade de cada filho. Assim, ele pega os valores de todos os elementos filhos e fazem o seguinte c√°lculo: somam e depois divide por cada valor da propriedade flex aplicado no filho. O resultado deve ser o espa√ßo preenchido do filho no container.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex(Flex(flex = 1.0)), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex(Flex(flex = 2.0)), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex(Flex(flex = 3.0)) ) ).applyFlex( Flex( grow = 1.0 ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().flex(1)), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().flex(2)), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().flex(3)) ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) ) ) ) }  ","excerpt":" Flex Esta propriedade define como os itens do container ser√£o ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/flex/","title":"Flex"},{"body":" Confira abaixo quais configura√ß√µes √© poss√≠vel fazer com os componentes do Beagle:\n","excerpt":" Confira abaixo quais configura√ß√µes √© poss√≠vel fazer com os ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/componentes/","title":"Componentes"},{"body":" ","excerpt":" ","ref":"/docs-beagle/docs/resources/components/","title":"Components"},{"body":" O ContextComponent √© uma interface precisa ser implementada em componentes que usam o Contexto, porque √© onde est√° o atributo context.\nComponentes do Beagle com contexto:  Container SimpleForm PageView ScrollView TabView  Componente customizado com contexto Segue abaixo um exemplo de componente customizado com o contexto:\nAndroid BFF iOS @RegisterWidget data class CustomComponent( val otherAttribute: String override val context: ContextData? = null ): WidgetView(), ContextComponent  @RegisterWidget data class CustomComponent( val otherAttribute: String override val context: ContextData? = null ): Widget(), ContextComponent  public struct CustomComponent: RawComponent, HasContext { public var context: Context? public var otherAttribute: String }  Se voc√™ quiser criar componentes customizados no iOS, √© necess√°rio registr√°-lo! Veja como registrar aqui.  ","excerpt":" O ContextComponent √© uma interface precisa ser implementada em ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/componentes/componente-com-contexto/","title":"Componente com contexto"},{"body":" Availability: Beagle1.0+ ComposedComponent helps with organization, maintenance and code reuse.\nclass MyScreenComponent : ComposeComponent { override fun build(): ServerDrivenComponent { //todo  } }  ComposedComponent doesn‚Äôt have a functionality, it is a backend exclusive resource.  Use case If you have, for example, a component structure that repeats constantly , just like the image below:\nIn this case, if you build a layout using DSL, the code would be like this:\nval style = Style( size = Size( width = UnitValue( 33.0, type = UnitType.PERCENT ) ) ) Screen( navigationBar = NavigationBar( title = \"Title\", showBackButton = true ), child = Container( children = listOf( // 1  Text(\"Nome:\").applyStyle(style = style), Text(\"Maria\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 2  Text(\"Idade:\").applyStyle(style = style), Text(\"10\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 3  Text(\"Cidade\").applyStyle(style = style), Text(\"Uberl√¢ndia\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 4  Text(\"Pa√≠s:\").applyStyle(style = style), Text(\"Brasil\").applyStyle(style = style), Text(\"Desatualizado\").applyStyle(style = style) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP ) ) ) As you can see, there is code repetition, to solve this problem you can use ComposedComponent. See below how it‚Äôs possible:\nEncapsulate this code in this single component like this:\nclass MyComposeComponent( private val field: String, private val value: String, private val status: String ): ComposeComponent { private val style = Style( size = Size( width = UnitValue( 33.0, type = UnitType.PERCENT ) ) ) override fun build() = Container( children = listOf( createText(field), createText(value), createText(status) ) ) private fun createText(text: String) = Text(text).applyStyle(style = style) } Now you can use it this way:\nScreen( navigationBar = NavigationBar( title = \"Title\", showBackButton = true ), child = Container( children = listOf( MyComposeComponent( field = \"Nome:\", value = \"Maria\", status = \"Atualizado\" ), MyComposeComponent( field = \"Idade:\", value = \"10\", status = \"Atualizado\" ), MyComposeComponent( field = \"Cidade:\", value = \"Uberl√¢ndia\", status = \"Atualizado\" ), MyComposeComponent( field = \"Pa√≠s:\", value = \"Brasil\", status = \"Desatualizado\" ) ) ).applyFlex(Flex(flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP)) The code is clearer and makes the code maintenance easier.\nTo build this component, it was not necessary to create a new one or a behaviour in the frontend.\n","excerpt":" Availability: Beagle1.0+ ComposedComponent helps with organization, ‚Ä¶","ref":"/docs-beagle/docs/resources/components/composedcomponent/","title":"Composedcomponent"},{"body":" O ComposedComponent facilita a organiza√ß√£o, manuten√ß√£o e reaproveitamento de c√≥digo. Ele n√£o tem funcionalidade pr√≥pria e √© exclusivo do backend.\nclass MyScreenComponent : ComposeComponent { override fun build(): ServerDrivenComponent { //todo  } } Caso de uso Se voc√™ tem, por exemplo, uma estrutura de componentes que se repete constantemente, como na imagem abaixo:\nNeste caso, se voc√™ construir este layout utilizando o DSL, o c√≥digo ficaria da seguinte forma:\nval style = Style( size = Size( width = UnitValue( 33.0, type = UnitType.PERCENT ) ) ) Screen( navigationBar = NavigationBar( title = \"Title\", showBackButton = true ), child = Container( children = listOf( // 1  Text(\"Nome:\").applyStyle(style = style), Text(\"Maria\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 2  Text(\"Idade:\").applyStyle(style = style), Text(\"10\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 3  Text(\"Cidade\").applyStyle(style = style), Text(\"Uberl√¢ndia\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 4  Text(\"Pa√≠s:\").applyStyle(style = style), Text(\"Brasil\").applyStyle(style = style), Text(\"Desatualizado\").applyStyle(style = style) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP ) ) ) Existe muita repeti√ß√£o de c√≥digo, o que dificulta sua manuten√ß√£o. Para resolver este problema, voc√™ pode utilizar o ComposedComponent.\nVeja abaixo como isso √© poss√≠vel:\n Encapsule este c√≥digo em um componente √∫nico como abaixo:  class MyComposeComponent( private val field: String, private val value: String, private val status: String ): ComposeComponent { private val style = Style( size = Size( width = UnitValue( 33.0, type = UnitType.PERCENT ) ) ) override fun build() = Container( children = listOf( createText(field), createText(value), createText(status) ) ) private fun createText(text: String) = Text(text).applyStyle(style = style) }  2. Agora voc√™ pode us√°-lo assim:  Screen( navigationBar = NavigationBar( title = \"Title\", showBackButton = true ), child = Container( children = listOf( MyComposeComponent( field = \"Nome:\", value = \"Maria\", status = \"Atualizado\" ), MyComposeComponent( field = \"Idade:\", value = \"10\", status = \"Atualizado\" ), MyComposeComponent( field = \"Cidade:\", value = \"Uberl√¢ndia\", status = \"Atualizado\" ), MyComposeComponent( field = \"Pa√≠s:\", value = \"Brasil\", status = \"Desatualizado\" ) ) ).applyFlex(Flex(flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP)) O c√≥digo fica bem mais claro e facilita a manuten√ß√£o!\nPara a constru√ß√£o deste componente, n√£o foi necess√°rio a cria√ß√£o de nenhum outro novo ou comportamento no frontend.\n","excerpt":" O ComposedComponent facilita a organiza√ß√£o, manuten√ß√£o e ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/componentes/componente-composto/","title":"Componente Composto"},{"body":" ContextComponent is an interface that it is necessary to be implemented in components that use Context, because it contains the context attribute.\nBeagle‚Äôs components with context:  Container SimpleForm PageView ScrollView TabView  Customized components with context See below an example with customized components with context:\nAndroid BFF iOS @RegisterWidget data class CustomComponent( val otherAttribute: String override val context: ContextData? = null ): WidgetView(), ContextComponent  @RegisterWidget data class CustomComponent( val otherAttribute: String override val context: ContextData? = null ): Widget(), ContextComponent  public struct CustomComponent: RawComponent, HasContext { public var context: Context? public var otherAttribute: String }  If you want to create customized components on iOS, it is necessary to register it. See how to do it here  ","excerpt":" ContextComponent is an interface that it is necessary to be ‚Ä¶","ref":"/docs-beagle/docs/resources/components/components-with-context/","title":"Components with context"},{"body":" Alguns elementos fornecidos pelo Beagle podem ser mais direcionados √† uma plataforma e, talvez, n√£o fazer tanto sentido para outra. Por exemplo, o uso do ScrollView funciona melhor na plataforma Mobile, mas n√£o √© necess√°rio na Web.\nIsso acontece porque o Beagle possui a funcionalidade de Especifica√ß√£o de Plataforma, que te permite ter controle de quais elementos s√£o enviados pelo BFF e quais plataformas ser√£o usadas.\nComo funciona? O Beagle faz uso de um cabe√ßalho personalizado, beagle-platform, com os poss√≠veis valores:\n ALL; MOBILE; ANDROID; IOS; WEB;  Dessa forma, a resposta do BFF √© interceptada e os elementos filtrados de acordo com a plataforma para qual ela est√° sendo enviada.\nComo acessar? Voc√™ pode acessar esse controle de duas maneiras:\n Por meio de estruturas de controle de fluxo em seu c√≥digo, que verifica qual plataforma seu cliente usou para realizar uma requisi√ß√£o.  Veja no exemplo a seguir:\nfun createComponentPlatformDependent(beaglePlatform: BeaglePlatform) = when { this.beaglePlatform.isMobilePlatform() -\u003e { ScrollView( children = listOf( Text(\"Mobile platform\") ) ) } this.beaglePlatform == BeaglePlatform.WEB -\u003e { Text(\"Web platform\") } else -\u003e { ScrollView( children = listOf( Text(\"Mobile platform\"), Text(\"Web platform\") ) ) } } Especificando a plataforma para qual o elemento √© destinado e, com isso, o Beagle faz a filtragem dos elementos corretos.  Veja no exemplo a seguir:\nButton(text = \"mobile only text\").forPlatform(BeaglePlatform.MOBILE), Button(text = \"web only text\").forPlatform(BeaglePlatform.WEB), Button(text = \"ios only text\").forPlatform(BeaglePlatform.IOS), Button(text = \"android only text\").forPlatform(BeaglePlatform.ANDROID), Button(text = \"text free for all\") Se quiser saber como configurar esta funcionalidade, veja na se√ß√£o de customiza√ß√£o do Beagle.\nCaso utilize um dos Beagle starters, n√£o √© necess√°rio realizar a configura√ß√£o da funcionalidade manualmente, pois ela j√° vem pr√©-configurada.  ","excerpt":" Alguns elementos fornecidos pelo Beagle podem ser mais direcionados √† ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/componentes/especifica%C3%A7%C3%A3o-de-componentes-por-plataforma/","title":"Especifica√ß√£o de componentes por plataforma"},{"body":" Some elements provided by Beagle can be better used in some platforms than other, for example, ScrollView works better in mobile and it is not needed for web.\nBeagle has a platform specification functionality, so it is able to control which elements are sent by BFF and which platforms will be used.\nHow does it work? Beagle uses a customized header beagle-platform with the possible values:\n ALL; MOBILE; ANDROID; IOS; WEB;  This way, the BFF response is intercepted according to the platform which it is being sent.\nHow can you access it? There are two way you can access this control:\n Through flow control structure in your code that verifies which platform your client used to make a request:  fun createComponentPlatformDependent(beaglePlatform: BeaglePlatform) = when { this.beaglePlatform.isMobilePlatform() -\u003e { ScrollView( children = listOf( Text(\"Mobile platform\") ) ) } this.beaglePlatform == BeaglePlatform.WEB -\u003e { Text(\"Web platform\") } else -\u003e { ScrollView( children = listOf( Text(\"Mobile platform\"), Text(\"Web platform\") ) ) } } You can specify which platform the element will use and then Beagle will filter the correct elements:  Button(text = \"mobile only text\").forPlatform(BeaglePlatform.MOBILE), Button(text = \"web only text\").forPlatform(BeaglePlatform.WEB), Button(text = \"ios only text\").forPlatform(BeaglePlatform.IOS), Button(text = \"android only text\").forPlatform(BeaglePlatform.ANDROID), Button(text = \"text free for all\") You can check how to configure this functionality here.\nIf you use Beagle starters, it is not necessary to configure this functionality manually, because it is already configured.  ","excerpt":" Some elements provided by Beagle can be better used in some platforms ‚Ä¶","ref":"/docs-beagle/docs/resources/components/platform-sorting/","title":"Platform sorting"},{"body":" Beagle has in its library some customization. You can check the process of each one in the links below:\n","excerpt":" Beagle has in its library some customization. You can check the ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/","title":"Customization"},{"body":" O Beagle disponibiliza na sua biblioteca algumas customiza√ß√µes. Voc√™ pode conhecer melhor o processo para cada biblioteca nas pr√≥ximas p√°ginas:\n","excerpt":" O Beagle disponibiliza na sua biblioteca algumas customiza√ß√µes. Voc√™ ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/","title":"Customiza√ß√£o"},{"body":" These are Beagle for Android classes:\n","excerpt":" These are Beagle for Android classes:\n","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/","title":"Beagle for Android"},{"body":" O Beagle para Android possui estas principais classes:\n","excerpt":" O Beagle para Android possui estas principais classes:\n","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/","title":"Beagle para Android"},{"body":" Introdu√ß√£o Uma a√ß√£o (Action) √© um componente do Beagle que pode ser chamado por meio de eventos que s√£o disparados por outros componentes (inclusive outras a√ß√µes).\nO Beagle j√° possui algumas a√ß√µes pr√©-definidas, no entanto √© poss√≠vel criar novas a√ß√µes personalizadas.\n√â obrigat√≥ria a adi√ß√£o da tag @Transient para todos os atributos presentes nas classes que representar√£o as a√ß√µes para que n√£o sejam levados em conta na serializa√ß√£o e desserializa√ß√£o do componente.  ","excerpt":" Introdu√ß√£o Uma a√ß√£o (Action) √© um componente do Beagle que pode ser ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/a%C3%A7%C3%B5es-customizadas/","title":"A√ß√µes customizadas"},{"body":" Introduction CustomAction is a Beagle‚Äôs component that can be called through events triggered by other components, including actions.\nBeagle already has some predefined actions, however it is possible to create custom actions.\nIt is mandatory to add the @Transient tag for all attributes present in the classes that will represent the actions so that they are not taken into account in the component serialization and deserialization.  ","excerpt":" Introduction CustomAction is a Beagle‚Äôs component that can be called ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-action/","title":"Custom Action"},{"body":" Para criar sua a√ß√£o personalizada siga os seguintes os passos:\n Criar uma classe anotada com @RegisterAction que implemente a interface Action; Depois disso, a interface solicitar√° que o m√©todo execute seja implementado; Agora, declare o resultado da action.  O atributo value √© um exemplo de par√¢metro que pode ser declarado no construtor dessa classe, voc√™ pode usar quantos precisar. O exemplo a seguir mostra uma a√ß√£o com Toast recebendo um texto como par√¢metro:\n@RegisterAction data class CustomActionAndroid( val value: String ) : Action { override fun execute(rootView: RootView) { Toast.makeText( rootView.getContext(), value, Toast.LENGTH_SHORT ).show() } } Veja abaixo um exemplo de Action em um componente do tipo Bot√£o:\nButton( text = text, styleId = styleId, onPress = listOf( CustomActionAndroid(\"Sou uma a√ß√£o customizada\") ) ) ","excerpt":" Para criar sua a√ß√£o personalizada siga os seguintes os passos:\n Criar ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/a%C3%A7%C3%B5es-customizadas/a%C3%A7%C3%A3o-customizada-simples/","title":"A√ß√£o Customizada Simples"},{"body":" To create your custom action, follow the next steps:\n Create an annotated class with @RegisterAction that implements an Action interface; After that, the interface will request to implement the execute method; Now, declare the action result.  The value attribute is a parameter example that can be declared in this class constructor. The following example shows an action with Toast receiving a text with a parameter:\n@RegisterAction data class CustomActionAndroid( val value: String ) : Action { override fun execute(rootView: RootView) { Toast.makeText( rootView.getContext(), value, Toast.LENGTH_LONG).show() } }  See below an action example in a button type component:  Button( text = text, styleId = styleId, onPress = listOf(CustomActionAndroid(\"I'm a customized action\")) ) ","excerpt":" To create your custom action, follow the next steps:\n Create an ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-action/simple-custom-action/","title":"Simple Custom Action"},{"body":" To create a custom action in Beagle whose execution is asynchronous such as consuming an API or accessing a database, just create an action as usual as the previous example detailed and implement the AsyncAction interface.\nWith the action created, just link the AsyncAction interface and delegate its implementation to the AsyncActionImpl class that Beagle already provides.\nWe recommend using this class, as it implements the onActionStarted and onActionFinished exposing its state in a reactive and standardized way in the framework.  @RegisterAction data class CustomActionAndroid( val value: String ) : Action, AsyncAction by AsyncActionImpl() { override fun execute(rootView: RootView) { // Do asynchronous work  } } Now, with the action ready to execute asynchronously, we have to MANDATORILY notify when its execution is finished through the onActionFinished method.\n@RegisterAction data class CustomActionAndroid( val value: String ) : Action, AsyncAction by AsyncActionImpl() { override fun execute(rootView: RootView) { // Do asynchronous work  onActionFinished() } } It‚Äôs done! Your action is now configured to run any job asynchronously!\nIt is mandatory to implement the AsyncAction interface for any custom action that is inserted within the ListView component.  ","excerpt":" To create a custom action in Beagle whose execution is asynchronous ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-action/async-custom-action/","title":"Async Custom Action"},{"body":" Para criar uma a√ß√£o customizada no Beagle cuja execu√ß√£o seja ass√≠ncrona como o consumo de uma API ou acesso a um banco de dados, basta criar uma action normalmente como o exemplo anterior detalhou e implementar a interface AsyncAction.\nCom a action criada, basta vincular a interface AsyncAction e delegar sua implementa√ß√£o para a classe AsyncActionImpl que o Beagle j√° fornece.\nRecomendamos o uso dessa classe, pois ela implementa os onActionStarted e onActionFinished expondo seu estado de forma reativa e padronizado no framework.  @RegisterAction data class CustomActionAndroid( val value: String ) : Action, AsyncAction by AsyncActionImpl() { override fun execute(rootView: RootView) { // Do asynchronous work  } } Agora, com a action pronta para executar de forma assincrona, temos que OBRIGATORIAMENTE notificar quando sua execu√ß√£o est√° conclu√≠da atrav√©s do m√©todo onActionFinished.\n@RegisterAction data class CustomActionAndroid( val value: String ) : Action, AsyncAction by AsyncActionImpl() { override fun execute(rootView: RootView) { // Do asynchronous work  onActionFinished() } } Pronto! Sua action agora est√° configurada para executar qualquer trabalho de forma ass√≠ncrona!\n√â obrigat√≥ria a implementa√ß√£o da interface AsyncAction para toda a√ß√£o customizada que for inserida dentro do componente ListView.  ","excerpt":" Para criar uma a√ß√£o customizada no Beagle cuja execu√ß√£o seja ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/a%C3%A7%C3%B5es-customizadas/a%C3%A7%C3%A3o-customizada-ass%C3%ADncrona/","title":"A√ß√£o Customizada Ass√≠ncrona"},{"body":" Introdu√ß√£o No Beagle, a ferramenta de navega√ß√£o entre telas permite que voc√™ configure a√ß√µes como navegar para uma nova tela ou fechar uma tela.\nA quest√£o √© que, al√©m de realizar estas configura√ß√µes, voc√™ pode tamb√©m customizar a navega√ß√£o da sua aplica√ß√£o.\nDe modo geral, existem duas op√ß√µes de customiza√ß√£o:\n De acordo com as anima√ß√µes padr√µes do Android A partir de transi√ß√£o de fragmentos fornecidas pelo pr√≥prio Beagle e que, neste caso, podem ser customizadas de acordo com a sua prefer√™ncia e design system. S√£o elas:   PushView PopView PopToView  Protocolo e customiza√ß√£o O protocolo padr√£o do Beagle para casos de customiza√ß√£o √© utilizar a ferramenta nativa do Android para fazer transi√ß√£o de fragmentos para customizar sua anima√ß√£o.\nPara entender melhor como este processo funciona, leia mais na se√ß√£o setCustomAnimations do Android.  A outra maneira de customizar uma anima√ß√£o de transi√ß√£o √© por meio da implementa√ß√£o da classe BeagleActivity, na qual o Beagle utiliza o m√©todo getFragmentTransitionAnimation().\nCaso este m√©todo n√£o seja implementado e customizado, as transi√ß√µes seguir√£o a anima√ß√£o padr√£o Beagle. O c√≥digo abaixo mostra o m√©todo da BeagleActivity, que pode ser sobrescrito dessa forma:\nopen fun getFragmentTransitionAnimation() = FragmentTransitionAnimation( enter = R.anim.slide_from_right, exit = R.anim.none_animation, popEnter = R.anim.none_animation, popExit = R.anim.slide_to_right ) \u0000A anima√ß√µes padr√£o usada pelo Beagle s√£o:\n Transi√ß√£o de entrada (enter) √† nova tela surge da direta do aplicativo. Anima√ß√£o de sa√≠da da pilha (popExit), em que a tela tamb√©m vai para a direita.  Como visto no c√≥digo acima, para sobrescrever o m√©todo de customiza√ß√£o voc√™ s√≥ precisa enviar como resultado uma inst√¢ncia da data class FragmentTransitionAnimation, como descrito abaixo:\ndata class FragmentTransitionAnimation( @AnimatorRes @AnimRes val enter: Int, @AnimatorRes @AnimRes val exit: Int, @AnimatorRes @AnimRes val popEnter: Int, @AnimatorRes @AnimRes val popExit: Int )  Vale contextualizar que esta classe possui quatro atributos, sendo eles:\n enter exit popEnter popExit  E todas elas descritas na documenta√ß√£o nativa do setCustomAnimations\n Depois que voc√™ sobrescrever o m√©todo getFragmentTransitionAnimation() na implementa√ß√£o da BeagleActivity, as transi√ß√µes de suas telas e fragmentos Beagle ir√£o agora seguir sua pr√≥pria anima√ß√£o.\nExemplo O exemplo de uso a seguir √© para caso de telas que entram e saem com uma anima√ß√£o vertical. Para fazer esta configura√ß√£o, siga os passos abaixo:\nPasso 1: Crie uma pasta com o nome anim no arquivo res da sua aplica√ß√£o Android. Este ser√° o local onde as anima√ß√µes ser√£o armazenadas.\n\u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003ctranslate android:duration=\"@android:integer/config_longAnimTime\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:fromYDelta=\"100%\" android:toYDelta=\"0%\"/\u003e \u003c/set\u003e Se seguir o c√≥digo acima, voc√™ indicar√° ao Beagle de que a anima√ß√£o dever√° subir do ponto m√≠nimo vertical para o ponto m√°ximo, completando toda a tela do aplicativo. Esta anima√ß√£o ser√° usada nas transi√ß√µes de entrada.\nPasso 2: √â hora de configurar a anima√ß√£o de sa√≠da. Nela, voc√™ far√° uma configura√ß√£o para que ela se comporte como o oposto da anima√ß√£o de entrada, descendo toda a tela\u0000. Para fazer isso, basta copiar o c√≥digo abaixo:\n\u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003ctranslate android:duration=\"@android:integer/config_longAnimTime\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:fromYDelta=\"0%\" android:toYDelta=\"100%\"/\u003e \u003c/set\u003e Passo 3: Depois de criar as anima√ß√µes, voc√™ pode utiliz√°-las sobrescritas ao m√©todo getFragmentTransition() na sua implementa√ß√£o da BeagleActivity, que ficar√° como no exemplo abaixo:\noverride fun getFragmentTransitionAnimation() = FragmentTransitionAnimation( enter = R.anim.slide_from_bottom, exit = R.anim.slide_to_bottom, popEnter = R.anim.slide_from_bottom, popExit = R.anim.slide_to_bottom )  \u0000Pronto, o Beagle agora j√° consegue usar as novas anima√ß√µes de transi√ß√£o!  Vale ressaltar que, para este exemplo, apenas duas anima√ß√µes foram criadas, sendo uma delas usada para animar as transi√ß√µes de enter e popEnter e a outra para exit e popExit. Por√©m, nada impede de voc√™ criar uma para cada ou uma para todos.\n","excerpt":" Introdu√ß√£o No Beagle, a ferramenta de navega√ß√£o entre telas permite ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/anima%C3%A7%C3%B5es-de-navega%C3%A7%C3%A3o/","title":"Anima√ß√µes de navega√ß√£o"},{"body":" Introduction BeagleActivity is a class that helps you manage where your server-driven components will be placed. Its structure works like an Android activity.\nIn order to Beagle understand that you‚Äôre working with an BeagleAcitivity‚Äôs class, it‚Äôs necessary to use @RegisterController annotation and implement their respective methods.\nWhat is customizable? When it comes to Beagle Activity, there are some custom components:\n Layout xml Toolbar Handling error ProgressBar  Check out the example below of how to custom an Beagle Activity:\n@RegisterController class SampleServerDrivenActivity : BeagleActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_server_driven) } override fun getToolbar(): Toolbar { TODO(\"Not yet implemented\") } override fun getServerDrivenContainerId(): Int { TODO(\"Not yet implemented\") } override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { TODO(\"Not yet implemented\") } } 1. Layout xml A xml layout file is where you host the screen component‚Äôs structure, likely you do with Android Activity. Even if you‚Äôre using Beagle to send your screen structure through server-driven, it‚Äôs still important to create this xml file to receive this content.\nSee below an example of an activity xml layout:\n\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cFrameLayout android:id=\"@+id/server_driven_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_gravity=\"center\" android:visibility=\"gone\"/\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e For the server-driven content, the xml layout needs a frame layout to load this content.\nIn the getServerDrivenContainerId()method, you must return the frame layout id.\noverride fun getServerDrivenContainerId(): Int = R.id.server_driven_container 2. Toolbar You can create a Toolbar and apply in your activity using the getToolbar() . In this method, you must return your Toolbar.\noverride fun getToolbar(): Toolbar = findViewById\u003cToolbar\u003e(R.id.toolbar) 3. Handling error You can watch the state and treat the errors from onServerDrivenContainerStateChanged()\noverride fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { if (state is ServerDrivenState.Error) { //Your error's treatment  } } 4. ProgressBar The same way that happens with error, you can handle if the server-driven container status is loading.\noverride fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { if (state is ServerDrivenState.Loading) { progressBar.visibility = if (state.loading) View.VISIBLE else View.GONE } }  You can register many activities as you wish, but you must define a default BeagleActivity using the annotation @RegisterController(id = \"ACTIVITY_IDENTIFIER\").\nThis id identify what activity the BFF will use.  ","excerpt":" Introduction BeagleActivity is a class that helps you manage where ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-beagle-activity/","title":"Custom Beagle Activity"},{"body":" Introdu√ß√£o O Beagle fornece uma Activity default para gerenciar as Activities geradas via server-driven. Por√©m voc√™ pode criar uma ou maisActivities que herdem de BeagleActivity com @BeagleComponent personalizadas de acordo com os fluxos server-driven da sua aplica√ß√£o. Sua estrutura funciona parecida com o Android Activity.\nPara que o Beagle interprete essa classe como uma BeagleActivity, √© necess√°rio usar a anota√ß√£o @BeagleComponent e implementar seus respectivos m√©todos.\nO que √© customiz√°vel? Quando se trata do Beagle Activity, √© poss√≠vel customizar alguns componentes:\n Layout xml Toolbar Tratamento de erros ProgressBar  Confira abaixo um exemplo de c√≥digo para uma Custom Beagle Activity:\n@RegisterController class SampleServerDrivenActivity : BeagleActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_server_driven) } override fun getToolbar(): Toolbar { TODO(\"Not yet implemented\") } override fun getServerDrivenContainerId(): Int { TODO(\"Not yet implemented\") } override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { TODO(\"Not yet implemented\") } } 1. Layout xml O arquivo xml √© o local onde voc√™ armazena o pacote de componentes da tela, de forma semelhante ao que voc√™ faz com o Android Activity.\nMesmo usando o Beagle para enviar a estrutura da tela pelo server-driven, √© importante criar este arquivo xml para receber o conte√∫do.\nSegue abaixo um exemplo de um layout xml:\n\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cFrameLayout android:id=\"@+id/server_driven_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_gravity=\"center\" android:visibility=\"gone\"/\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e Para o conte√∫do server-driven ser exibido √© necess√°rio um frame layout. Sendo assim, o m√©todo getServerDrivenContainerId() precisa retornar o id do frame layout.\n2. Toolbar Voc√™ pode criar uma Toolbar e us√°-la em sua activity atrav√©s do m√©todogetToolbar() . Isso permite retornar a Toolbar desejada.\noverride fun getToolbar(): Toolbar = findViewById\u003cToolbar\u003e(R.id.toolbar) 3. Tratamento de erros Voc√™ pode observar os estados e tratar os erros a partir do onServerDrivenContainerStateChanged()``\noverride fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { if (state is ServerDrivenState.Error) { //Your error's treatment  } } 4. ProgressBar Da mesma forma que os erros, voc√™ consegue observar se o estado do container server-driven est√° em loading pelo ProgressBar. Veja como no trecho de c√≥digo a seguir:\noverride fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { if (state is ServerDrivenState.Loading) { progressBar.visibility = if (state.loading) View.VISIBLE else View.GONE } }  √â poss√≠vel registrar quantas activities voc√™ precisar, por√©m voc√™ deve defini-las usando a anota√ß√£o@RegisterController(id = \"ACTIVITY_IDENTIFIER\").\nEsse id √© o que o BFF ir√° usar pra identificar qual activity usar.  ","excerpt":" Introdu√ß√£o O Beagle fornece uma Activity default para gerenciar as ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/beagle-activity-customizada/","title":"Beagle Activity customizada"},{"body":" This component does not work on 1.1.0 version and it will be removed in the future version. Use SimpleForm instead.  Introduction A validator component is used when it is necessary to validate some form information. It validates through isValidmethod that is requested when a FormSubmit or a notifyChanges() are implemented. This validator is listed as component that receives data in a form named FormInput.\nValidator context The Form component capture data informed by the user and validates and send them to BFF. This validation can happen when the user activates FormSubmit or when notifies its status to InputWidget(FormInput).\nValidator receives two generic parameters and it has only on isValid method that returns a boolean value.\ninterface Validator\u003cin I, in W\u003e { fun isValid(input: I, widget: W): Boolean }  input: represents the value inputWidget sends as data to be validated. widget: refers to InputWidget that sent the data.  Implementing a validator To implement a validator, you have to have a form that enables FormSubmit when FormInput is not empty, in this case it will receive a string with the data and then it will be validated if it is empty or not.\n The class that will validate the data is annotated as @RegisterValidator This annotation register this validator on Beagle and identify it by the name listed in parentheses.  @RegisterValidator(\"text-is-not-blank\") class TextNotBlankValidator : Validator\u003cString, ServerDrivenComponent\u003e { override fun isValid(input: String, widget: ServerDrivenComponent): Boolean { return !input.isBlank() } }  To send to InputWidget this validation, it is necessary to refer the given name to the annotation above \"text-is-not-blank\"in the component. Follow the example below:  FormInput( name = \"required-field\", required = true, validator = \"text-is-not-blank\", child = SampleTextField(placeholder = \"placeholder\") ) The follow example, the InputWidget implementation will run the Validator calling the notifyChanges() method.\n@RegisterWidget class SampleTextField(private val placeholder: String) : InputWidget() { @Transient private lateinit var textFieldView: EditText override fun getValue() = textFieldView.text.toString() override fun onErrorMessage(message: String) { textFieldView.error = message } override fun toView(context: Context) = EditText(context).apply { textFieldView = this textFieldView.hint = placeholder textFieldView.isSingleLine = true doOnTextChanged { _, _, _, _ -\u003e notifyChanges() } } }  If you want to validate the information as the user types it, the suggestion is to call the functionnotifyChanges()inside the other function doOnTextChange{}.  ","excerpt":" This component does not work on 1.1.0 version and it will be removed ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-validator/","title":"Custom Validator"},{"body":" Introdu√ß√£o A classe HTTPClient define como as solicita√ß√µes de servi√ßos s√£o configuradas. Para us√°-la, voc√™ precisa criar uma classe que implemente uma interface do tipo HttpClient.\nAqui, voc√™ pode adicionar cabe√ßalhos √†s suas requisi√ß√µes, definir os m√©todos request, body response, data response, executar criptografia, etc.\nCriando a classe HttpClient Para criar essa classe, siga os seguintes passos:\nPasso 1: Adicionar as depend√™ncias Localize o arquivo build.gradle(Module:app) , abra-o e role a p√°gina para baixo at√© encontrar o bloco de c√≥digo dependencies { }.\n  Copie e cole a linha abaixo dentro das depend√™ncias:\n implementation ‚Äòcom.squareup.okhttp3:okhttp:4.5.0‚Äô  __\n  Aperte Sync now para sincronizar o Gradle novamente.\n  Essa depend√™ncia √© necess√°ria, pois a classe que implementa HttpClient vai importar algumas configura√ß√µes dela.\n  Se a sua aplica√ß√£o utilizar servi√ßos do tipo Retrofit √© poss√≠vel que aconte√ßa algum conflito, porque esse servi√ßo define a depend√™ncia okhttp internamente e com isso ela ir√° conflitar com a depend√™ncia do HttpClient.\n  Substitua a linha:\nimplementation ‚Äòcom.squareup.okhttp3:okhttp:4.5.0‚Äô\n  Por essas duas outras linhas:\nimplementation ‚Äòcom.squareup.retrofit2:retrofit:2.7.2‚Äô\nimplementation ‚Äòcom.squareup.retrofit2:converter-gson:2.7.2\n   Passo 2: Criar a classe  Crie a classe e escolha o nome que voc√™ desejar. Nesse exemplo, foi dado o nome de HttpClientDefault. Se o Android reclamar dos imports, √© s√≥ checar se as depend√™ncias n√£o est√£o conflitantes. Essa configura√ß√£o √© bem extensa, a sugest√£o √© que voc√™ copie e cole a classe abaixo e modifique como achar necess√°rio:  import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.exception.BeagleApiException import br.com.zup.beagle.android.networking.HttpClient import br.com.zup.beagle.android.networking.HttpMethod import br.com.zup.beagle.android.networking.RequestCall import br.com.zup.beagle.android.networking.RequestData import br.com.zup.beagle.android.networking.ResponseData import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Job import kotlinx.coroutines.cancel import kotlinx.coroutines.launch import java.io.EOFException import java.net.HttpURLConnection typealias OnSuccess = (responseData: ResponseData) -\u003e Unit typealias OnError = (responseData: ResponseData) -\u003e Unit @BeagleComponent class HttpClientDefault : HttpClient, CoroutineScope { private val job = Job() override val coroutineContext = job + CoroutineDispatchers.IO override fun execute( request: RequestData, onSuccess: OnSuccess, onError: OnError ): RequestCall { if (getOrDeleteOrHeadHasData(request)) { onError(ResponseData(-1, data = byteArrayOf())) return createRequestCall() } launch { try { val responseData = doHttpRequest(request) onSuccess(responseData) } catch (ex: BeagleApiException) { onError(ex.responseData) } } return createRequestCall() } private fun getOrDeleteOrHeadHasData(request: RequestData): Boolean { return (request.method == HttpMethod.GET || request.method == HttpMethod.DELETE || request.method == HttpMethod.HEAD) \u0026\u0026 request.body != null } @Throws(BeagleApiException::class) private fun doHttpRequest( request: RequestData ): ResponseData { val urlConnection: HttpURLConnection try { urlConnection = request.uri.toURL().openConnection() as HttpURLConnection } catch (e: Exception) { throw BeagleApiException(ResponseData(-1, data = byteArrayOf()), request) } request.headers.forEach { urlConnection.setRequestProperty(it.key, it.value) } addRequestMethod(urlConnection, request.method) if (request.body != null) { setRequestBody(urlConnection, request) } try { return createResponseData(urlConnection) } catch (e: Exception) { throw tryFormatException(urlConnection, request) } finally { urlConnection.disconnect() } } private fun tryFormatException(urlConnection: HttpURLConnection, request: RequestData): BeagleApiException { val response = urlConnection.getSafeError() ?: byteArrayOf() val statusCode = urlConnection.getSafeResponseCode() val statusText = urlConnection.getSafeResponseMessage() val responseData = ResponseData(statusCode = statusCode, data = response, statusText = statusText) return BeagleApiException(responseData, request) } private fun addRequestMethod(urlConnection: HttpURLConnection, method: HttpMethod) { val methodValue = method.toString() if (method == HttpMethod.PATCH || method == HttpMethod.HEAD) { urlConnection.setRequestProperty(\"X-HTTP-Method-Override\", methodValue) urlConnection.requestMethod = \"POST\" } else { urlConnection.requestMethod = methodValue } } private fun setRequestBody(urlConnection: HttpURLConnection, request: RequestData) { urlConnection.setRequestProperty(\"Content-Length\", request.body?.length.toString()) try { urlConnection.outputStream.write(request.body?.toByteArray()) } catch (e: Exception) { throw BeagleApiException(ResponseData(-1, data = byteArrayOf()), request) } } private fun createResponseData(urlConnection: HttpURLConnection): ResponseData { return ResponseData( statusCode = urlConnection.responseCode, statusText = urlConnection.responseMessage, headers = urlConnection.headerFields.filter { it.key != null }.map { val headerValue = it.value.toString() .replace(\"[\", \"\") .replace(\"]\", \"\") it.key to headerValue }.toMap(), data = try { urlConnection.inputStream.readBytes() } catch (e: EOFException) { byteArrayOf() } ) } private fun createRequestCall() = object : RequestCall { override fun cancel() { this@HttpClientDefault.cancel() } } } ","excerpt":" Introdu√ß√£o A classe HTTPClient define como as solicita√ß√µes de ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/camada-de-rede/","title":"Camada de rede"},{"body":" Introduction Beagle already has basic widgets that you can use to create components interface of your server-driven application.\nHowever, your application may need more customized components (Custom Views), and to make them ‚Äòvisible‚Äô to Beagle, you have to create a customized widget. You can create many new components you want, since it makes your application‚Äôs Views, ‚Äòvisible‚Äô to Beagle.\nIt is mandatory to add the @Transient tag for all attributes present in the classes that will represent the widgets so that they are not taken into account in the component serialization and deserialization.  ","excerpt":" Introduction Beagle already has basic widgets that you can use to ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-widget/","title":"Custom Widget"},{"body":" Introdu√ß√£o √â poss√≠vel observar o estado atual da tela durante as requisi√ß√µes server-driven em uma BeagleActivity, inclusive estados de erro.\nExemplo Ao exibir uma tela server-driven , √© poss√≠vel sobrescrever o m√©todo onServerDrivenContainerStateChange() para implementar suas tratativas para cada estado da tela.\nAbaixo segue um exemplo de uma BeagleActivity com o m√©todo onServerDrivenContainerStateChange()sobrescrito:\n@BeagleComponent class AppBeagleActivity : BeagleActivity() { private val progressBar: ProgressBar by lazy { findViewById\u003cProgressBar\u003e(R.id.progress_bar) } private val mToolbar: Toolbar by lazy { findViewById\u003cToolbar\u003e(R.id.custom_toolbar) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_app_beagle) } override fun getServerDrivenContainerId(): Int = R.id.server_driven_container override fun getToolbar(): Toolbar = mToolbar override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { when (state) { is ServerDrivenState.Started -\u003e { progressBar.visibility = View.VISIBLE } is ServerDrivenState.Finished -\u003e { progressBar.visibility = View.GONE } is ServerDrivenState.Error -\u003e { Toast.makeText(this, \"Error\", Toast.LENGTH_LONG).show() } } } } A partir destes estados, como mostra o exemplo anterior de implementa√ß√£o do loadView, √© poss√≠vel definir quando mostrar ou esconder o Load e definir tamb√©m outras a√ß√µes pertinentes aos estados ServerDrivenState: Started, Success , Finished e Error.\nsealed class ServerDrivenState { object Started : ServerDrivenState() object Finished : ServerDrivenState() object Success : ServerDrivenState() open class Error( val throwable: Throwable, val retry: BeagleRetry ) : ServerDrivenState() } Veja mais detalhes de cada estado:\n Started: Indica que uma busca de componente server-driven foi iniciada. Finished: Indica que uma busca de componente server-driven foi conclu√≠da. Success: Indica um estado de sucesso ao buscar um componente server-driven. Error: Indica um estado de erro ao buscar um componente server-driven.  ","excerpt":" Introdu√ß√£o √â poss√≠vel observar o estado atual da tela durante as ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/carregamento-e-tratamento-de-erros/","title":"Carregamento e tratamento de erros"},{"body":" How to create components (custom views) and widgets? The example below shows how a custom widget will be implemented and which component it will register. It will have a text and two buttons inside a linear layout. The buttons in this component will be responsible to increase and decrease the text‚Äôs size and the screen will be like the image:\nYou can do this using @RegisterWidget annotation and extending the WidgetView class.  Follow the next steps to create and customize a component and a widget:\nStep 1: Create widget  Create a class and name it\"CustomWidgetTitleIncrease\"; Apply the annotation@RegisterWidget ; Extend this class using WidgetView interface; This class now will request a toView method to be implemented. Change the class as listed below:  CustomWidgetTitleIncrease.kt @RegisterWidget class CustomWidgetTitleIncrease: WidgetView() { override fun buildView(rootView: RootView): View { TODO(\"not implemented\") } Step 2: Create and configure the component  Create a .XML configuration file and copy and paste the content below, it will create a layout:  title_increase_component_layout.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:orientation=\"vertical\"\u003e \u003cTextView android:id=\"@+id/tv_example_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:padding=\"20dp\" android:text=\"Example\" /\u003e \u003cLinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\"\u003e \u003cButton android:id=\"@+id/bt_increase\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:text=\"B1\" /\u003e \u003cButton android:id=\"@+id/bt_decrease\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:text=\"B2\" /\u003e \u003c/LinearLayout\u003e \u003c/LinearLayout\u003e Now, you have to create the component:\n Create a class and name it:TitleIncreaseComponent. This class will register how the component work and the business rule; Copy and paste the class below:  class TitleIncreaseComponent(context: Context) : LinearLayout(context) { init { View.inflate(context, R.layout.title_increase_component_layout, this) changeTitleSize() } fun setTitleText(title: String) { tvExampleTitle.text = title } fun setTitleButton1(titleButton:String){ btIncrease.text = titleButton } fun setTitleButton2(titleButton:String){ btDecrease.text = titleButton } private fun changeTitleSize(){ var size = tvExampleTitle.textSize tvExampleTitle.textSize = size Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() val textView = findViewById\u003cTextView\u003e(R.id.tvExampleTitle) val b1 = findViewById\u003cButton\u003e(R.id.btIncrease) val b2 = findViewById\u003cButton\u003e(R.id.btDecrease) b1.setOnClickListener { if(size \u003c 50){ size += 5f tvExampleTitle.textSize = size } Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() } b2.setOnClickListener { if(size \u003e 5){ size -= 5f tvExampleTitle.textSize = size } Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() } } } Step 3: Configure the widget The layout and the component are defined, it is necessary to finish the configuration of the customized widget.\n Check the function below and see that some text variables were added. This was chosen to demonstrate that it is possible to define the value of this variables by the widget, adding title and button names.  CustomWidgetTitleIncrease.kt @RegisterWidget class CustomWidgetTitleIncrease( private val title: String, private val buttonTitle1: String, private val buttonTitle2: String ) : WidgetView() { override fun buildView(rootView: RootView) = TitleIncreaseComponent(rootView.getContext()).apply { setTitleText(title) setTitleButton1(buttonTitle1) setTitleButton2(buttonTitle2) } } Step 4: Display the component The customized widget is now ready, the component can be displayed.\n To test the component, use the method below:  MainActivity.kt class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView( CustomWidgetTitleIncrease( \"Example Title\", \"Increase\", \"Decrease\" ).buildView(rootView = object : RootView { override fun getContext() = this@MainActivity override fun getLifecycleOwner() = this@MainActivity }) ) } } Run the aplication and your component will be displayed:  ","excerpt":" How to create components (custom views) and widgets? The example ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-widget/simple-custom-widget/","title":"Simple Custom Widget"},{"body":" Introdu√ß√£o Quando um m√©todo de ofusca√ß√£o √© usado, √© necess√°rio que algumas regras sejam implementadas para garantir que os nomes e os IDs usados internamente pelo Beagle, n√£o sejam ofuscados ou minificados.\nExemplo Para garantir isso, voc√™ deve adicionar as seguintes regras no arquivo android-rules.pro do ProGuard:\nproguard-rules.pro # Beagle uses coroutines in network requests -keep class kotlinx.coroutines.experimental.android.AndroidExceptionPreHandler { *; } # Beagle does reflection on generic parameters -keepattributes Signature, InnerClasses, EnclosingMethod # Beagle does reflection on method and parameter annotations -keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations -dontwarn org.jetbrains.annotations.** -keep class kotlin.Metadata { *; } # Yoga is a dependency used on Beagle -keep @com.facebook.proguard.annotations.DoNotStrip class * { *; } # Customized classes for Beagle -keep @br.com.zup.beagle.annotation.** class * { *; } -keep @br.com.zup.beagle.android.annotation.** class * { *; } -keep class * extends br.com.zup.beagle.android.widget.** # Core classes in Beagle -keep class br.com.zup.beagle.android.action.** { *; } -keep class br.com.zup.beagle.android.widget.** { *; } -keep class br.com.zup.beagle.android.components.** { *; } -keep class br.com.zup.beagle.android.context.** { *; } -keep class br.com.zup.beagle.widget.** { *; } -keep class br.com.zup.beagle.core.** { *; } -keep class br.com.zup.beagle.analytics.** { *; }  Aqui, voc√™ tamb√©m habilita o minifyEnable e shrinkResources no buildType declarando-os como true para testar a ofusca√ß√£o do ProGuard.  Para testar o ProGuard voc√™ deve ativ√°-lo na sua IDE, voc√™ pode usar o Android Studio, adicione a configura√ß√£o listada abaixo:\nbuildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' } } ","excerpt":" Introdu√ß√£o Quando um m√©todo de ofusca√ß√£o √© usado, √© necess√°rio que ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/configura%C3%A7%C3%A3o-do-proguard/","title":"Configura√ß√£o do Proguard"},{"body":" Currently in Beagle, the Container and ListView components have the behavior of executing a list of actions as soon as they are rendered. For this, they expose the onInit property, which receives the list of actions that will be triggered.\nTo create a custom widget with the behavior of triggering a list of actions as soon as it is rendered, Beagle provides an easy way to do it using the pattern delegate by implementing the OnInitiableComponent interface.\nFor this step-by-step we will focus on linking OnInitiableComponent to the customizable widget, since its creation in detail has already been shown in the previous example.  Step 1: Link OnInitiableComponent With the customizable widget created, add the OninitiableComponent interface.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int ): WidgetView(), OnInitiableComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 2: Implement onInit property After adding the OnInitiableComponent interface to the widget, override the onInit property.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 3: Delegate implementation In addition to the onInit property, the OnInitiableComponent interface needs the implementation of the handleOnInit and markToRerunOnInit methods. To facilitate and maintain the component‚Äôs behavior pattern, Beagle already provides a ready implementation and we recommend its use, just delegating OnInitiableComponentImpl.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent by OnInitiableComponentImpl(onInit) { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 4: Execute handleOnInit Finally, with all the configuration done in the widget, only the execution of the handleOnInit method is missing so that the list of onInit actions can be executed as soon as the view is rendered.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent by OnInitiableComponentImpl(onInit) { override fun buildView(rootView: RootView): View { handleOnInit(rootView, view) } } It‚Äôs done! Your component now performs a list of actions whenever it is rendered!\nIt is mandatory to implement the OnInitiableCompoent interface for every custom widget that is inserted into the ListView component.  ","excerpt":" Currently in Beagle, the Container and ListView components have the ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-widget/oninit-custom-widget/","title":"Oninit Custom Widget"},{"body":" Introdu√ß√£o O DeepLinkHandler √© uma interface que define como configurar a navega√ß√£o entre uma Server-Driven activity e uma activity nativa.\nExemplo Criando um DeepLinkHandler Para realizar essa configura√ß√£o, voc√™ deve criar uma classe que implemente a interface DeepLinkHandler e que fa√ßa a anota√ß√£o com @BeagleComponent, conforme listado abaixo:\n@BeagleComponent class AppDeepLinkHandler : DeepLinkHandler { override fun getDeepLinkIntent( rootView: RootView, path: String, data: Map\u003cString, String\u003e?, shouldResetApplication: Boolean ) = Intent(\"openThisActivity\") } Feito isso, √© necess√°rio modificar o arquivo de manifesto do Android:\n Passo 1: Voc√™ deve adicionar um intent-filter na Activity para a qual deseja navegar. Passo 2: Voc√™ deve adicionar uma Action que identificar√° essa Activity. O nome que usamos aqui foi ‚ÄúopenThisActivity‚Äù. Passo 3: Adicione uma tag category e a nomeie como \"android.intent.category.DEFAULT\", assim como no exemplo abaixo.  //AndroidManifest \u003cactivity android:name=\".activities.DeepLinkActivity\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"navigate.myview\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e Agora voc√™ s√≥ precisa chamar a Action Navigate com o m√©todo OpenNativeRoute como o exemplo abaixo:\n//Widget used to navigate to a native activity Button( text = \"Click to navigate!\", onPress = listOf( Navigate.OpenNativeRoute(\"openThisActivity\") ) ) ","excerpt":" Introdu√ß√£o O DeepLinkHandler √© uma interface que define como ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/deep-link-handler/","title":"Deep Link Handler"},{"body":" To create a custom widget that uses other Beagle components, just implement the SingleChildComponent interface when there is only one child component, or MultiChildComponent for the widget that uses several other components.\nA component must implement only one of these interfaces, or SingleChildComponent, or MultiChildComponent, never both at the same time.  SingleChildComponent Custom widgets that render a single Beagle component must implement the SingleChildComponent interface.\nStep 1: Link SingleChildComponent With the custom widget created, add the SingleChildComponent interface.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 2: Implement the child property After adding the SingleChildComponent interface to the widget, override the child property.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val child: ServerDrivenComponent ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 3: Use the component To use the view generated from the child component, just consider it as a ViewConvertable and call the buildView method.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val child: ServerDrivenComponent ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { val builtChild = (child as ViewConvertable).buildView(rootView) } } MultiChildComponent Custom widgets that render one or more Beagle components must implement the MultiChildComponent interface.\nStep 1: Link MultiChildComponent With the custom widget created, add the MultiChildComponent interface.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int ): WidgetView(), MultiChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 2: Implement the children property After adding the MultiChildComponent interface to the widget, override the children property.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val children: List\u003cServerDrivenComponent\u003e ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 3: Use the component To use the view generated from the children component, just consider each one as ViewConvertable and call their buildView method.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val children: List\u003cServerDrivenComponent\u003e ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { children.forEach { child -\u003e val builtChild = (child as ViewConvertable).buildView(rootView) } } } It‚Äôs done! Your component now uses other Beagle components!\nIt is mandatory to implement one of the two interfaces for any custom widget that uses Beagle components within the ListView component.  ","excerpt":" To create a custom widget that uses other Beagle components, just ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-widget/serverdrivencomponent-custom-widget/","title":"Serverdrivencomponent Custom Widget"},{"body":" Introdu√ß√£o Voc√™ pode registrar estilos como fontes, cor, tamanho da fonte e componentes customizados com design system, que foi adicionado ao Beagle 1.0.0\n√â com o design system que se armazena os componentes de estilo registrados, criado no frontend e ent√£o a sua aplica√ß√£o Android saber√° qual componente de estilo dever√° ser aplicado em cada tela server-drive. √â por meio dos elementos de elementos da view s√£o usados para criar sua tela.\nPara definir o design system da sua aplica√ß√£o, voc√™ deve criar a classe que estenda um Open class DesignSystem. Ela ir√° subscrever as fun√ß√µes que s√£o usadas para aplicar os estilos aos componentes, e dentro de cada fun√ß√£o, voc√™ pode declarar v√°rios estilos.\nCada estilo mostrado com o Beagle deve ser referenciado de uma forma que, cada um deles tenha um nome a ser identificado.\nExemplo O m√©todo da imagem registrada em uma s√©rie de imagens que ser√° usada para construir p√°ginas vindas do backend. O operador when √© usado para designar os estilos, o primeiro valor listado √© uma string que identifica o estilo do componente do Beagle (muito similiar a key/value) e o estilo do componente que foi listado com uma Arrow Function -\u003e.\nO operador desta fun√ß√£o else, ir√° conter o estilo padr√£o, como no c√≥digo abaixo:\n// This class is used by the RenderEngine in order to define the styles configured at the application. // It must extend DesignSystem. // These are the styles the AppDesignSystem implements: image, textStyle, inputTextStyle, buttonStyle, toolbarStyle and tabViewStyle  @BeagleComponent class AppDesignSystem : DesignSystem() { override fun image(id: String): Int? { return when (name) { \"delete\" -\u003e android.R.drawable.ic_delete \"logo\" -\u003e android.R.drawable.ic_logo \"banner\" -\u003e android.R.drawable.ic_banner else -\u003e android.R.drawable.ic_menu_help } } override fun textStyle(id: String): Int? { return when (name) { \"TextBlackBold\" -\u003e R.style.TextBlackBold else -\u003e R.style.TextBlackBold } } override fun inputTextStyle(id: String): Int? { return R.style.TextBlack } override fun buttonStyle(id: String): Int? = R.style.ButtonBlack override fun toolbarStyle(id: String): Int? = R.style.Toolbar override fun tabViewStyle(id: String): Int? { return R.style.CustomTab } }  Quando uma classe estende oOpen Class DesignSystem , √© poss√≠vel gerenciar estilos que ser√£o aplicados aos componentes server-driven. √â necess√°rio implementar a classe para registrar os estilos no Beagle, porque somente assim voc√™ poder√° ver os estilos e aplic√°-los.  Como um padr√£o Android, os estilos podem ser definidos no arquivo style e referenciados dentro da classe que entenda o Design System.\n\u003cresources\u003e \u003c!-- Base application theme. --\u003e \u003cstyle name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"\u003e \u003c!-- Customize your theme here. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAccent\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"TextBlackBold\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"TextBlack\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"ButtonBlack\" parent=\"Widget.AppCompat.Button\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e18sp\u003c/item\u003e \u003citem name=\"android:textAllCaps\"\u003efalse\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"Toolbar\" parent=\"Widget.AppCompat.Toolbar\"\u003e \u003citem name=\"android:background\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"navigationIcon\"\u003e?attr/homeAsUpIndicator\u003c/item\u003e \u003c/style\u003e \u003c/resources\u003e ","excerpt":" Introdu√ß√£o Voc√™ pode registrar estilos como fontes, cor, tamanho da ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/design-system/","title":"Design System"},{"body":" Introduction The DeepLinkHandler is an interface that sets how to configure the navigation between Server-Driven activities and native activities.\nExample Creating a DeepLinkHandler To make this configuration, you must create a class that implements the DeepLinkHandler interface, and that annotates it with @BeagleComponent, like listed below:\n@BeagleComponent class AppDeepLinkHandler : DeepLinkHandler { override fun getDeepLinkIntent( rootView: RootView, path: String, data: Map\u003cString, String\u003e?, shouldResetApplication: Boolean ) = Intent(\"openThisActivity\") } Once you made it, it‚Äôs necessary modify the Android manifest file:\n Step 1: You must add an intent filterat the activity you wish to navigate to. Step 2: You will add an action tag that will identify this activity. The id namewe used here is \"openThisActivity\" Step 3: Add an category tag and name it \"android.intent.category.DEFAULT\" , like the example below  //AndroidManifest \u003cactivity android:name=\".activities.DeepLinkActivity\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"openThisActivity\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e And that‚Äôs it. Now you just need to call the Navigate action with the method OpenNativeRoute like the example below:\n//Widget used to navigate to a native activity Button( text = \"Click to navigate!\", onPress = listOf( Navigate.OpenNativeRoute(\"openThisActivity\") ) ) ","excerpt":" Introduction The DeepLinkHandler is an interface that sets how to ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/deep-link-handler/","title":"Deep Link Handler"},{"body":"Serializador/Deserializador customizado Introdu√ß√£o O Beagle oferece um serializador/deserializador customizado por meio da Interface BeagleTypeAdapter. Com esse Adapter √© poss√≠vel mapear uma classe qualquer, inclusive as que representam tipos concretos, como um Integer.\nVeja abaixo o contrato definido da interface:\ninterface BeagleTypeAdapter\u003cT\u003e { fun fromJson(json: String) : T fun toJson(type: T) : String } Exemplo Neste exemplo cum adapter foi criado para a interface Person que √© extendida a partir da data class PersonImpl que possui somente um atributo name do tipo String.\nPara criar um adapter voc√™ deve:\n Criar uma classe que ser√° seu adapter e anot√°-la com @RegisterBeagleAdapter.Neste exemplo o nome dado foi PersonAdapter Declarar qual classe se quer mapear com esse adapter. Aqui mapeamos a interface Person que representa a data class PersomImpl. Estender a classe adapter (PersonAdapter) a partir da Interface BeagleTypeAdapter informando a classe que voc√™ quer mapear; Ao estender a interface voc√™ dever√° implementar os m√©todos fromJson e toJson, veja o exemplo abaixo:  interface Person data class PersonImpl(val name: String) : Person @RegisterBeagleAdapter class PersonAdapter : BeagleTypeAdapter\u003cPerson\u003e { override fun fromJson(json: String): Person { val rootObject = JSONObject(json) return PersonImpl(rootObject.getString(KEY)) } override fun toJson(type: Person): String { type as PersonImpl val rootObject = JSONObject() rootObject.put(KEY, type.name) return rootObject.toString() } } M√©todo fromJson Esse m√©todo recebe um JSONObject como string e retorna uma inst√¢ncia da classe mapeada (Person).\nM√©todo toJson Esse m√©todo recebe o tipo de dado mapeado (Person) e retorna um JSONObject como uma string.\n","excerpt":"Serializador/Deserializador customizado Introdu√ß√£o O Beagle oferece um ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/serializadordeserializador-customizado/","title":"Serializadordeserializador customizado"},{"body":" Introduction You can register styles as fonts, color, font size and customized components with design system, which was added on Beagle 1.0.0.\nIt is the design system that stores the style components registry created in the frontend and then your Android application will know which style component it must be applied in each server-driven screen. It is through it that views elements are used to create your screen.\nTo define a design system in your application, you have to create a class that extends an Open class DesignSystem. It will overwrite functions that are used to apply sytles to the components, inside each function you can declare several styles.\nEvery style displayed with Beagle must be referenced in a way each one of them has a name to be identified.\nExample The image method is registered in a series of images that will be used in the page construction coming from the backend. The operator when is used to designate the styles, the first listed value is a string that identifies the Beagle‚Äôs style component(very similiar to key/value) and the component‚Äôs style was listed with theArrow Function -\u003e.\nThis function‚Äôs operator else will contain a default style, like the code block below:\n// This class is used by the RenderEngine in order to define the styles configured at the application. // It must extend DesignSystem. // These are the styles the AppDesignSystem implements: image, textStyle, inputTextStyle, buttonStyle, toolbarStyle and tabViewStyle  @BeagleComponent class AppDesignSystem : DesignSystem() { override fun image(id: String): Int? { return when (name) { \"delete\" -\u003e android.R.drawable.ic_delete \"logo\" -\u003e android.R.drawable.ic_logo \"banner\" -\u003e android.R.drawable.ic_banner else -\u003e android.R.drawable.ic_menu_help } } override fun textStyle(id: String): Int? { return when (name) { \"TextBlackBold\" -\u003e R.style.TextBlackBold else -\u003e R.style.TextBlackBold } } override fun inputTextStyle(id: String): Int? { return R.style.TextBlack } override fun buttonStyle(id: String): Int? = R.style.ButtonBlack override fun toolbarStyle(id: String): Int? = R.style.Toolbar override fun tabViewStyle(id: String): Int? { return R.style.CustomTab } }  When a class extends theOpen Class DesignSystem it is able to manage styles that will be applied to the server driven components. It is necessary to implement a class to register the styles on Beagle, only this way it will be able to see the styles and apply them.  As an Android pattern, the styles can be defined in the style file and referenced inside a class that understands Design System.\n\u003cresources\u003e \u003c!-- Base application theme. --\u003e \u003cstyle name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"\u003e \u003c!-- Customize your theme here. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAccent\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"TextBlackBold\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"TextBlack\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"ButtonBlack\" parent=\"Widget.AppCompat.Button\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e18sp\u003c/item\u003e \u003citem name=\"android:textAllCaps\"\u003efalse\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"Toolbar\" parent=\"Widget.AppCompat.Toolbar\"\u003e \u003citem name=\"android:background\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"navigationIcon\"\u003e?attr/homeAsUpIndicator\u003c/item\u003e \u003c/style\u003e \u003c/resources\u003e ","excerpt":" Introduction You can register styles as fonts, color, font size and ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/design-system/","title":"Design System"},{"body":" Introdu√ß√£o O sistema de logs do Beagle permite que voc√™ investigue erros durante o desenvolvimento e problemas com o aplicativo em produ√ß√£o.\nAs mensagens de log fornecidas pelo Beagle Android podem ser acessadas pelo:\n Console do Android Studio Console da Aplica√ß√£o  Elas s√£o divididas em 3 categorias:\n Info: relacionada √† camada Rede, informa√ß√µes e respostas da comunica√ß√£o com o servidor. Warning: mensagens informativas de erros relacionados a componentes do Beagle. Error: exibe mensagens de erros relacionadas a parse, http e outras exce√ß√µes.  √â poss√≠vel desabilitar as mensagens de logs disparadas. Dessa forma, o Beagle n√£o ir√° mais chamar a API de Log, seja ela a padr√£o ou customizada. Voc√™ precisa passar o atributo isLoggingEnabled do AppBeagleConfig para false:\n@BeagleComponent class AppBeagleConfig : BeagleConfig { override val isLoggingEnabled: Boolean = false } Customiza√ß√£o Para deixar o ambiente do Beagle aberto a modifica√ß√µes, a API de Logs padr√£o pode ser substitu√≠da por qualquer outra.\nA configura√ß√£o dessa customiza√ß√£o √© feita com a cria√ß√£o de uma classe anotada com @BeagleComponent e que implemente a Interface BeagleLogger. Essa interface precisa da implementa√ß√£o dos m√©todos de logs, voc√™ pode seguir o exemplo abaixo:\n@BeagleComponent class CustomBeagleLog : BeagleLogger { override fun warning(message: String) { TODO(\"Not yet implemented\") } override fun error(message: String) { TODO(\"Not yet implemented\") } override fun error(message: String, throwable: Throwable) { TODO(\"Not yet implemented\") } override fun info(message: String) { TODO(\"Not yet implemented\") } } ","excerpt":" Introdu√ß√£o O sistema de logs do Beagle permite que voc√™ investigue ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/sistema-de-log/","title":"Sistema de Log"},{"body":" Introduction This class defines how the services requests are configured, to use it, you need to create a class that implements a HttpClient interface.\nYou can add headers to your requests, define method request, body response, data response, run cryptography, etc.\nCreating a HttpClient class To create this class, follow the next steps:\nStep 1: Add the dependencies Locate the file build.gradle(Module:app) , open it and scroll the page until you find the code block dependencies { }.\n  Copy and paste the line below inside the dependencies:\n implementation ‚Äòcom.squareup.okhttp3:okhttp:4.5.0‚Äô  __\n  Press Sync now to synchronize the Gradle again.\n  This dependency is necessary, because the class that implements HttpClient will import some of its configuration.\n  If your application uses Retrofit services, it is possible some conflict may occur, because it internally defines a okhttp dependency and then it will conflict with the HttpClient.\n  Replace this line:\nimplementation ‚Äòcom.squareup.okhttp3:okhttp:4.5.0‚Äô\n  For these two lines:\nimplementation ‚Äòcom.squareup.retrofit2:retrofit:2.7.2‚Äô\nimplementation ‚Äòcom.squareup.retrofit2:converter-gson:2.7.2\n   Step 2: Create a class  Create a class and choose a name for it. For the example,HttpClientDefault was chosen. If Android complain about imports, just check if the dependencies are not conflicting. This configuration is long, so copy and paste the class below. You may modify it later.  import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.exception.BeagleApiException import br.com.zup.beagle.android.networking.HttpClient import br.com.zup.beagle.android.networking.HttpMethod import br.com.zup.beagle.android.networking.RequestCall import br.com.zup.beagle.android.networking.RequestData import br.com.zup.beagle.android.networking.ResponseData import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Job import kotlinx.coroutines.cancel import kotlinx.coroutines.launch import java.io.EOFException import java.net.HttpURLConnection typealias OnSuccess = (responseData: ResponseData) -\u003e Unit typealias OnError = (responseData: ResponseData) -\u003e Unit @BeagleComponent class HttpClientDefault : HttpClient, CoroutineScope { private val job = Job() override val coroutineContext = job + CoroutineDispatchers.IO override fun execute( request: RequestData, onSuccess: OnSuccess, onError: OnError ): RequestCall { if (getOrDeleteOrHeadHasData(request)) { onError(ResponseData(-1, data = byteArrayOf())) return createRequestCall() } launch { try { val responseData = doHttpRequest(request) onSuccess(responseData) } catch (ex: BeagleApiException) { onError(ex.responseData) } } return createRequestCall() } private fun getOrDeleteOrHeadHasData(request: RequestData): Boolean { return (request.method == HttpMethod.GET || request.method == HttpMethod.DELETE || request.method == HttpMethod.HEAD) \u0026\u0026 request.body != null } @Throws(BeagleApiException::class) private fun doHttpRequest( request: RequestData ): ResponseData { val urlConnection: HttpURLConnection try { urlConnection = request.uri.toURL().openConnection() as HttpURLConnection } catch (e: Exception) { throw BeagleApiException(ResponseData(-1, data = byteArrayOf()), request) } request.headers.forEach { urlConnection.setRequestProperty(it.key, it.value) } addRequestMethod(urlConnection, request.method) if (request.body != null) { setRequestBody(urlConnection, request) } try { return createResponseData(urlConnection) } catch (e: Exception) { throw tryFormatException(urlConnection, request) } finally { urlConnection.disconnect() } } private fun tryFormatException(urlConnection: HttpURLConnection, request: RequestData): BeagleApiException { val response = urlConnection.getSafeError() ?: byteArrayOf() val statusCode = urlConnection.getSafeResponseCode() val statusText = urlConnection.getSafeResponseMessage() val responseData = ResponseData(statusCode = statusCode, data = response, statusText = statusText) return BeagleApiException(responseData, request) } private fun addRequestMethod(urlConnection: HttpURLConnection, method: HttpMethod) { val methodValue = method.toString() if (method == HttpMethod.PATCH || method == HttpMethod.HEAD) { urlConnection.setRequestProperty(\"X-HTTP-Method-Override\", methodValue) urlConnection.requestMethod = \"POST\" } else { urlConnection.requestMethod = methodValue } } private fun setRequestBody(urlConnection: HttpURLConnection, request: RequestData) { urlConnection.setRequestProperty(\"Content-Length\", request.body?.length.toString()) try { urlConnection.outputStream.write(request.body?.toByteArray()) } catch (e: Exception) { throw BeagleApiException(ResponseData(-1, data = byteArrayOf()), request) } } private fun createResponseData(urlConnection: HttpURLConnection): ResponseData { return ResponseData( statusCode = urlConnection.responseCode, statusText = urlConnection.responseMessage, headers = urlConnection.headerFields.filter { it.key != null }.map { val headerValue = it.value.toString() .replace(\"[\", \"\") .replace(\"]\", \"\") it.key to headerValue }.toMap(), data = try { urlConnection.inputStream.readBytes() } catch (e: EOFException) { byteArrayOf() } ) } private fun createRequestCall() = object : RequestCall { override fun cancel() { this@HttpClientDefault.cancel() } } } ","excerpt":" Introduction This class defines how the services requests are ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/network-client/","title":"Network Client"},{"body":" Este componente foi descontinuado na vers√£o 1.1.0 e ser√° removido em uma vers√£o futura. Use SimpleForm em seu lugar  Introdu√ß√£o Um componente do tipo Validator √© utilizado quando for necess√°rio validar alguma informa√ß√£o em um formul√°rio. Essa valida√ß√£o acontece atrav√©s do m√©todo isValid, que √© chamado sempre que s√£o executados umFormSubmit ou um notifyChanges().\nAl√©m disso, esse Validator √© listado no componente que recebe dados em um formul√°rio, ao qual chamamos deFormInput.\nContexto do validador No Beagle, √© poss√≠vel usar o componente Form para capturar dados informados pelo usu√°rio, valid√°-los e envi√°-los ao BFF.\nEssa valida√ß√£o pode tanto ocorrer quando o usu√°rio ativa o FormSubmit e/ou quando o usu√°rio notifica que o estado de seu InputWidget(FormInput) mudou, como por exemplo, quando ditamos um texto ou quando o campo perde o foco.\nO Validator recebe dois par√¢metros gen√©ricos e possui um √∫nico m√©todo isValid que retorna um valor booleano.\ninterface Validator\u003cin I, in W\u003e { fun isValid(input: I, widget: W): Boolean }  input: Representa o valor que o inputWidget envia como informa√ß√£o (data) a ser validada. widget: Widget que referencia o InputWidget que enviou a informa√ß√£o (data).  Implementando um validador √â poss√≠vel implementar um validador quando, por exemplo, voc√™ tem um formul√°rio que habilite o FormSubmit apenas nos casos em que o FormInput n√£o estiver vazio. Quando isso acontece, o Form deve receber uma String com a entrada de dados e ser√° validada se est√° vazia ou n√£o.\n A classe que validar√° a informa√ß√£o est√° anotada com um @RegisterValidator Essa anota√ß√£o registra esse validador no Beagle e o identifica pelo nome listado entre par√™nteses.  @RegisterValidator(\"text-is-not-blank\") class TextNotBlankValidator : Validator\u003cString, ServerDrivenComponent\u003e { override fun isValid(input: String, widget: ServerDrivenComponent): Boolean { return !input.isBlank() } }  Para enviar ao InputWidget essa valida√ß√£o, √© necess√°rio somente referenciar o nome dado na anota√ß√£o acima \"text-is-not-blank\"no componente.  Siga o exemplo abaixo:\nFormInput( name = \"required-field\", required = true, validator = \"text-is-not-blank\", child = SampleTextField(placeholder = \"placeholder\") ) J√° no exemplo a seguir, a implementa√ß√£o de um InputWidget ir√° executar o Validator chamando o m√©todo notifyChanges().\n@RegisterWidget class SampleTextField(private val placeholder: String) : InputWidget() { private lateinit var textFieldView: EditText override fun getValue() = textFieldView.text.toString() override fun onErrorMessage(message: String) { textFieldView.error = message } buildView(rootView: RootView) = EditText(rootView.getContext()).apply { textFieldView = this textFieldView.hint = placeholder textFieldView.isSingleLine = true doOnTextChanged { _, _, _, _ -\u003e notifyChanges() } } }  Se voc√™ deseja validar a informa√ß√£o conforme o usu√°rio a digita, a sugest√£o √© que voc√™ chame a fun√ß√£onotifyChanges() dentro da fun√ß√£o doOnTextChange{}.  ","excerpt":" Este componente foi descontinuado na vers√£o 1.1.0 e ser√° removido em ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/validador-customizado/","title":"Validador customizado"},{"body":" Introduction It is possible to watch the screen‚Äôs current state during server-driven requests in a BeagleActivity, including error states.\nExample To display a server-driven screen, it is possible to overwrite the onServerDrivenContainerStateChange() method to implement its handles to each screen state.\nSee below a BeagleActivity example with the overwritten onServerDrivenContainerStateChange() method:\n@BeagleComponent class AppBeagleActivity : BeagleActivity() { private val progressBar: ProgressBar by lazy { findViewById\u003cProgressBar\u003e(R.id.progress_bar) } private val mToolbar: Toolbar by lazy { findViewById\u003cToolbar\u003e(R.id.custom_toolbar) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_app_beagle) } override fun getServerDrivenContainerId(): Int = R.id.server_driven_container override fun getToolbar(): Toolbar = mToolbar override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { when (state) { is ServerDrivenState.Started -\u003e { progressBar.visibility = View.VISIBLE } is ServerDrivenState.Finished -\u003e { progressBar.visibility = View.GONE } is ServerDrivenState.Error -\u003e { Toast.makeText(this, \"Error\", Toast.LENGTH_LONG).show() } } } } On the loadView, you can also see that these states shows the loadView implementation, it is possible to define when to show or to hide Load. And you can also define other action to the states ServerDrivenState, that areStarted, Success , Finished and Error\nsealed class ServerDrivenState { object Started : ServerDrivenState() object Finished : ServerDrivenState() object Success : ServerDrivenState() open class Error( val throwable: Throwable, val retry: BeagleRetry ) : ServerDrivenState() } See more details about each state:\n Started: Indicates that a server-driven component fetch has begun. Finished: Indicates that a server-driven component fetch has finished. Success: Indicates a success state while fetching a server-driven component. Error: Indicates an error state while fetching a server-driven component.  ","excerpt":" Introduction It is possible to watch the screen‚Äôs current state ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/loading-and-errors-treatment/","title":"Loading and errors treatment"},{"body":" Introdu√ß√£o O Beagle j√° fornece alguns widgets b√°sicos prontos que voc√™ pode utilizar para criar a interface dos componentes de sua aplica√ß√£o server-driven.\nNo entanto, a sua aplica√ß√£o pode precisar de componentes mais especializados (Custom Views) e, para torn√°-los ‚Äúvis√≠veis‚Äù ao Beagle, voc√™ precisa criar um widget espec√≠fico para ele. Dessa forma, voc√™ pode criar quantos novos componentes desejar, desde que sempre torne as Views do seu aplicativo ‚Äúvis√≠veis‚Äù para o Beagle.\n√â obrigat√≥ria a adi√ß√£o da tag @Transient para todos os atributos presentes nas classes que representar√£o os widgets para que n√£o sejam levados em conta na serializa√ß√£o e desserializa√ß√£o do componente.  ","excerpt":" Introdu√ß√£o O Beagle j√° fornece alguns widgets b√°sicos prontos que ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/widgets-customizados/","title":"Widgets customizados"},{"body":" Introduction Beagle‚Äôs log system allows you to investigate errors during the development and problems that may happen with the application‚Äôs production.\nThe log messages given by Android Beagle can be accessed in the:\n Android Studio‚Äôs console Application‚Äôs console  They are divided in 3 categories:\n Info: related to the Network layer, information and communication‚Äôs response with the server. Warning: informational messages of errors related to Beagle‚Äôs component. Error: shows error messages related to parse, http and other exceptions.  It is possible to disable triggered log messages. Beagle will not call the Log‚Äôs API, even if it is a pattern or customized. You will need to change the attribute isLoggingEnabled ofAppBeagleConfig tofalse:\n@BeagleComponent class AppBeagleConfig : BeagleConfig { override val isLoggingEnabled: Boolean = false } Customization In order to let Beagle‚Äôs environment open to modifications, the API logs pattern can be replaced to any other.\nThe configuration of this customization it is done with the creation of an annotation class with @BeagleComponent and that implements the BeagleLogger Interface. This interface needs logs method implementation, you can follow the example below:\n@BeagleComponent class CustomBeagleLog : BeagleLogger { override fun warning(message: String) { TODO(\"Not yet implemented\") } override fun error(message: String) { TODO(\"Not yet implemented\") } override fun error(message: String, throwable: Throwable) { TODO(\"Not yet implemented\") } override fun info(message: String) { TODO(\"Not yet implemented\") } } ","excerpt":" Introduction Beagle‚Äôs log system allows you to investigate errors ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/log-system/","title":"Log System"},{"body":" Como criar componentes (custom views) e widgets? No exemplo abaixo, ser√° implementado um custom widget e o componente que ele registrar√°. Esse componente ser√° composto por um texto e dois bot√µes dentro de um layout linear.\nOs bot√µes neste componente ser√£o respons√°veis ‚Äã‚Äãpor aumentar e diminuir o tamanho do texto do t√≠tulo e a tela ser√° como a imagem a seguir:\nVoc√™ pode fazer isso usando a anota√ß√£o @RegisterWidget e estendendo a classe WidgetView .  Criando um componente e um widget Siga os passos abaixo para criar e customizar um componente e um widget:\nPasso 1: Criar o widget Para criar um widget:\n Crie uma classe e a nomeie\"CustomWidgetTitleIncrease\" Aplique a anota√ß√£o@RegisterWidget a esta classe; Estenda essa classe utilizando a interface WidgetView A classe agora requisitar√° que voc√™ implemente o m√©todo buildView . Nesse momento, deixe a classe como listada abaixo, pois a configura√ß√£o desse m√©todo ser√° finalizada depois.  CustomWidgetTitleIncrease.kt @RegisterWidget class CustomWidgetTitleIncrease: WidgetView() { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 2: Criar e configurar o componente Comece criando um arquivo de configura√ß√£o.XMLe copie e cole o conte√∫do abaixo, pois ela cria o layout que escolhemos para esse exemplo.\ntitle_increase_component_layout.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:orientation=\"vertical\"\u003e \u003cTextView android:id=\"@+id/tv_example_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:padding=\"20dp\" android:text=\"Example\" /\u003e \u003cLinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\"\u003e \u003cButton android:id=\"@+id/bt_increase\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:text=\"B1\" /\u003e \u003cButton android:id=\"@+id/bt_decrease\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:text=\"B2\" /\u003e \u003c/LinearLayout\u003e \u003c/LinearLayout\u003e Agora, √© hora de criar o componente:\n Crie uma classe e a nomeie: TitleIncreaseComponent. √â nessa classe que ficar√° registrado como o componente funciona e a regra de neg√≥cio dele. Lembrando que a regra de negocio desse componente √© unicamente aumentar e dimunir o tamanho do seu T√≠tulo. Copie e cole a classe abaixo:  class TitleIncreaseComponent(context: Context) : LinearLayout(context) { init { View.inflate(context, R.layout.title_increase_component_layout, this) changeTitleSize() } fun setTitleText(title: String) { tv_example_title.text = title } fun setTitleButton1(titleButton: String) { bt_increase.text = titleButton } fun setTitleButton2(titleButton: String) { bt_decrease.text = titleButton } private fun changeTitleSize() { var size = tv_example_title.textSize tv_example_title.textSize = size Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() bt_increase.setOnClickListener { if (size \u003c 50) { size += 5f tv_example_title.textSize = size } Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() } bt_decrease.setOnClickListener { if (size \u003e 5) { size -= 5f tv_example_title.textSize = size } Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() } } } Passo 3: Configurar o Widget O layout e o componente est√£o definidos, √© preciso terminar a configura√ß√£o do Widget customizado:\nAnalise a fun√ß√£o abaixo e observe que algumas vari√°veis de texto foram adicionadas. Essa pr√°tica foi escolhida para demonstrar que √© poss√≠vel definir o valor dessas vari√°veis pelo Widget, colocando o t√≠tulo e o nome dos bot√µes.\nCustomWidgetTitleIncrease.kt @RegisterWidget class CustomWidgetTitleIncrease( private val title: String, private val buttonTitle1: String, private val buttonTitle2: String ) : WidgetView() { override fun buildView(rootView: RootView) = TitleIncreaseComponent(rootView.getContext()).apply { setTitleText(title) setTitleButton1(buttonTitle1) setTitleButton2(buttonTitle2) } } Passo 4: Exibir o componente Agora o Widget customizado est√° pronto, o componente pode ser exibido.\nPara testar o componente, utilize o m√©todo abaixo:\n Perceba que o widget passa alguns par√¢metros para o componente, como o ‚ÄúT√≠tulo‚Äù do componente e o t√≠tulo dos bot√µes. O m√©todo buildView foi implementado dentro do widget que customizamos  MainActivity.kt import br.com.zup.beagle.android.utils.toView class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val customWidget = CustomWidgetTitleIncrease( \"Example Title\", \"Increase\", \"Decrease\" ) setContentView(customWidget.toView(this)) } }  Execute a aplica√ß√£o e seu componente customizado (nesse caso uma tela) ser√° exibido:  ","excerpt":" Como criar componentes (custom views) e widgets? No exemplo abaixo, ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/widgets-customizados/widget-customizado-simples/","title":"Widget Customizado Simples"},{"body":" Introduction Beagle has a screen navigation tool that allows you to configure actions like navigate to a new screen or close one.\nBesides these configuration, you can also customize the navigation of your application.\nThere are two customization options:\n According to Android‚Äôs animation pattern. Fragments transition provided by Beagle, that it can be customized according to your preference and design system. They are:   PushView PopView PopToView  Protocol and customized Beagle‚Äôs pattern protocol for customization is to use a native Android tool, to make fragment transition to customize your animation.\nFor more information on how this process works, check out the Android‚Äôs section setCustomAnimations.  The other way to customize an animation it is the transition through the BeagleActivity class implementation, which Beagle uses the getFragmentTransitionAnimation() method.\nIn case this method it isn‚Äôt implemented and customized, the transitions will follow the Beagle‚Äôs animation pattern. The code below shows the BeagleActivity method, that can be overwritten this way:\nopen fun getFragmentTransitionAnimation() = FragmentTransitionAnimation( enter = R.anim.slide_from_right, exit = R.anim.none_animation, popEnter = R.anim.none_animation, popExit = R.anim.slide_to_right ) \u0000Beagle‚Äôs animation pattern are:\n Enter transition (enter) to the new screen that appears on the right side of the application. Stack exit animation (popExit), the screen also go to the right side.  The code above showed that to overwrite the customization method you only need to send a data class instance FragmentTransitionAnimation as a result, like below:\ndata class FragmentTransitionAnimation( @AnimatorRes @AnimRes val enter: Int, @AnimatorRes @AnimRes val exit: Int, @AnimatorRes @AnimRes val popEnter: Int, @AnimatorRes @AnimRes val popExit: Int )  To contextualize this class has four attributes, they are:\n enter exit popEnter popExit  And all of them are described in the setCustomAnimations documentation.\n After you have overwritten the getFragmentTransitionAnimation() method in the BeagleActivity implementation, your screens transitions and Beagle‚Äôs fragments will follow its own animation.\nExample The example below is about screens that comes in and out with a vertical animation. To make this configuration, follow the steps:\nStep 1: Create a folder with anim name on the res file of your Android application. This will be the place where the animation will be stored.\n\u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003ctranslate android:duration=\"@android:integer/config_longAnimTime\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:fromYDelta=\"100%\" android:toYDelta=\"0%\"/\u003e \u003c/set\u003e If you follow the code bellow, you will indicate Beagle that the animation must rise from the minimum vertical point to the maximum point, completing the whole application screen. This animation will be used in the enter transitions.\nStep 2: It is time to configure the exit animation. You will make a configuration on it in order that it will behave like the opposite of the input animation, scrolling the whole screen. To make this, just copy this code below:\n\u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003ctranslate android:duration=\"@android:integer/config_longAnimTime\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:fromYDelta=\"0%\" android:toYDelta=\"100%\"/\u003e \u003c/set\u003e Step 3: After creating the animations, you can use the overwritten to thegetFragmentTransition() method on your BeagleActivity implementation, that will be like the example below:\noverride fun getFragmentTransitionAnimation() = FragmentTransitionAnimation( enter = R.anim.slide_from_bottom, exit = R.anim.slide_to_bottom, popEnter = R.anim.slide_from_bottom, popExit = R.anim.slide_to_bottom )  \u0000Done! Beagle now can use the new transition animation!  It is important to mention, only two animation were created, one of them used to animate the enter and popEnter transitions. However, you can create more, one for each or one for all.\n","excerpt":" Introduction Beagle has a screen navigation tool that allows you to ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/navigation-animation/","title":"Navigation Animation"},{"body":" Atualmente no Beagle, os componentes Container e ListView possuem o comportamento de executar uma lista de a√ß√µes assim que s√£o renderizados. Para isso, eles exp√µe a propriedade onInit, a qual recebe a lista de a√ß√µes que ser√£o disparadas.\nPara criar um widget customizado com o comportamento de disparar uma lista de a√ß√µes assim que for renderizado, o Beagle fornece uma forma f√°cil de fazer utilizando o pattern delegate atrav√©s da implementa√ß√£o da interface OnInitiableComponent.\nPara esse passo-a-passo vamos focar na vincula√ß√£o do OnInitiableComponent ao widget customiz√°vel, j√° que a cria√ß√£o dele em detalhes j√° foi mostrada no exemplo anterior.  Passo 1: Vincular OnInitiableComponent Com o widget customiz√°vel criado, adicione a interface OninitiableComponent.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int ): WidgetView(), OnInitiableComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 2: Implementar propriedade onInit Ap√≥s adicionar a interface OnInitiableComponent ao widget, sobrescreva a propriedade onInit.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 3: Delegar implementa√ß√£o Al√©m da propriedade onInit, a interface OnInitiableComponent precisa da implementa√ß√£o dos m√©todos handleOnInit e markToRerunOnInit. Para facilitar e manter o padr√£o de comportamento do componente, o Beagle j√° fornece uma implementa√ß√£o pronta e recomendamos o seu uso, bastando somente delegar OnInitiableComponentImpl.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent by OnInitiableComponentImpl(onInit) { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 4: Executar handleOnInit Por fim, com toda a configura√ß√£o feita no widget, falta somente a execu√ß√£o do m√©todo handleOnInit para que a lista de a√ß√µes onInit sejam executadas assim que a view for renderizada.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent by OnInitiableComponentImpl(onInit) { override fun buildView(rootView: RootView): View { handleOnInit(rootView, view) } } Pronto! Seu componente agora executa uma lista de a√ß√µes sempre que for renderizado!\n√â obrigat√≥rio a implementa√ß√£o da interface OnInitiableCompoent para todo widget customizado que for inserido dentro do componente ListView.  ","excerpt":" Atualmente no Beagle, os componentes Container e ListView possuem o ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/widgets-customizados/widget-customizado-com-oninit/","title":"Widget Customizado com Oninit"},{"body":"Serializer / Deserializer Introduction Beagle offers a customized serializer/deserializer set through a BeagleTypeAdapter interface. With this Adapter it is possible to map any class, including classes that represent concrete types, such as an Integer. Below, you can see our interface contract.\nSee below the defined interface contract:\ninterface BeagleTypeAdapter\u003cT\u003e { fun fromJson(json: String) : T fun toJson(type: T) : String } Example This example creates an adapter for the Person interface that is extended from the data class PersonImpl that has only a name attribute as a String type.\nIn order to create an adapter you must:\n Create a class that will be your adapter and annotate it with a@ RegisterBeagleAdapter. In this example we named this class as PersonAdapter ; Declare which class you want to map with this adapter. Here we implemented a PersonImpl data class as an example.; Extend the adapter (PersonAdapter) class from the BeagleTypeAdapter Interface, informing the class to be mapped on; When extending the interface you must implement the fromJson and toJson methods, see the example below:  interface Person data class PersonImpl(val name: String) : Person @RegisterBeagleAdapter class PersonAdapter : BeagleTypeAdapter\u003cPerson\u003e { override fun fromJson(json: String): Person { val rootObject = JSONObject(json) return PersonImpl(rootObject.getString(KEY)) } override fun toJson(type: Person): String { type as PersonImpl val rootObject = JSONObject() rootObject.put(KEY, type.name) return rootObject.toString() } } FromJson method This method takes a JSONObject as a string and returns an instance of the mapped class (Person).\nToJson method This method takes the mapped data type (Person) and returns a JSONObject as a string.\n","excerpt":"Serializer / Deserializer Introduction Beagle offers a customized ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/serializer-deserializer/","title":"Serializer  Deserializer"},{"body":" Para criar um widget customizado que utilize outros componentes do Beagle, basta implementar a interface SingleChildComponent quando houver somente um componente filho, ou MultiChildComponent para o widget que utilizar varios outros componentes.\nUm componente deve implementar somente uma dessas interfaces, ou SingleChildComponent, ou MultiChildComponent, nunca as duas ao mesmo tempo.  SingleChildComponent Widgets customizados que renderizem um unico componente do Beagle devem implementar a interface SingleChildComponent.\nPasso 1: Vincular SingleChildComponent Com o widget customizado criado, adicione a interface SingleChildComponent.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 2: Implementar a propriedade child Ap√≥s adicionar a interface SingleChildComponent ao widget, sobrescreva a propriedade child.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val child: ServerDrivenComponent ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 3: Utilize o componente Para usar a view gerada a partir do componente child, basta considera-lo como um ViewConvertable e chamar o m√©todo buildView.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val child: ServerDrivenComponent ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { val builtChild = (child as ViewConvertable).buildView(rootView) } } MultiChildComponent Widgets customizados que renderizem um ou mais componentes do Beagle devem implementar a interface MultiChildComponent.\nPasso 1: Vincular MultiChildComponent Com o widget customizado criado, adicione a interface MultiChildComponent.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int ): WidgetView(), MultiChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 2: Implementar a propriedade children Ap√≥s adicionar a interface MultiChildComponent ao widget, sobrescreva a propriedade children.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val children: List\u003cServerDrivenComponent\u003e ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 3: Utilize o componente Para usar a view gerada a partir do componente children, basta considerar cada um como ViewConvertable e chamar o m√©todo buildView de cada.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val children: List\u003cServerDrivenComponent\u003e ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { children.forEach { child -\u003e val builtChild = (child as ViewConvertable).buildView(rootView) } } } Pronto! Seu componente agora utiliza outros componentes do Beagle!\n√â obrigat√≥rio a implementa√ß√£o de uma das duas interfaces para todo widget customizado que utilizar componentes do Beagle dentro do componente ListView.  ","excerpt":" Para criar um widget customizado que utilize outros componentes do ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/widgets-customizados/widget-customizado-com-serverdrivencomponent/","title":"Widget Customizado com Serverdrivencomponent"},{"body":" Introduction When a obfuscation method is used, it is necessary that some rules are implemented to make sure the IDs internally used in Beagle are not obfuscated or minimized.\nExample To make sure it happes, you have to add the following rules to the Proguard file android-rules.pro.\nproguard-rules.pro # Beagle uses coroutines in network requests -keep class kotlinx.coroutines.experimental.android.AndroidExceptionPreHandler { *; } # Beagle does reflection on generic parameters -keepattributes Signature, InnerClasses, EnclosingMethod # Beagle does reflection on method and parameter annotations -keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations -dontwarn org.jetbrains.annotations.** -keep class kotlin.Metadata { *; } # Yoga is a dependency used on Beagle -keep @com.facebook.proguard.annotations.DoNotStrip class * { *; } # Customized classes for Beagle -keep @br.com.zup.beagle.annotation.** class * { *; } -keep @br.com.zup.beagle.android.annotation.** class * { *; } -keep class * extends br.com.zup.beagle.android.widget.** # Core classes in Beagle -keep class br.com.zup.beagle.android.action.** { *; } -keep class br.com.zup.beagle.android.widget.** { *; } -keep class br.com.zup.beagle.android.components.** { *; } -keep class br.com.zup.beagle.android.context.** { *; } -keep class br.com.zup.beagle.widget.** { *; } -keep class br.com.zup.beagle.core.** { *; } -keep class br.com.zup.beagle.analytics.** { *; }  You also have to enableminifyEnable andshrinkResources onbuildType declaring them as true to test the ProGuard obfuscation.  You must activate ProGuard in your IDE, to test it, you can use Android Studio, just add the listed configuration below:\nbuildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' } } ","excerpt":" Introduction When a obfuscation method is used, it is necessary that ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/proguard-configuration/","title":"Proguard configuration"},{"body":" These are Beagle for iOS classes:\n","excerpt":" These are Beagle for iOS classes:\n","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/","title":"Beagle for ios"},{"body":" O Beagle para iOS possui estas principais classes:\n","excerpt":" O Beagle para iOS possui estas principais classes:\n","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/","title":"Beagle para ios"},{"body":" Introdu√ß√£o Uma action √© um bloco de c√≥digo que pode ser executado quando definido em algum evento. O Beagle j√° possui algumas por padr√£o, mas √© poss√≠vel criar sua action personalizada.\nExemplo Como criar uma custom action? Para criar uma custom action, siga os seguintes passos:\n Crie uma classe que implemente a interface Action;  struct CustomAction: Action { func execute( controller: BeagleController, origin: UIView) { print(\"Custom action foi chamada!\") } }  Depois disso, a interface solicitar√° que o m√©todo execute seja implementado. √â nesse m√©todo que deve ser implementado o bloco de c√≥digo que sua a√ß√£o ir√° executar;\n  Agora, √© necess√°rio registrar essa nova a√ß√£o nas depend√™ncias do Beagle:\n  let dependencies = BeagleDependencies() dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\" ) Beagle.dependencies = dependencies Como usar? Veja abaixo um exemplo de como usar um bot√£o que executa a a√ß√£o customizada no evento de clique:\nButton( text: \"do request\", onPress: [ CustomAction() ] ) ","excerpt":" Introdu√ß√£o Uma action √© um bloco de c√≥digo que pode ser executado ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/a%C3%A7%C3%B5es-customizadas/","title":"A√ß√µes customizadas"},{"body":" Introduction Your application can change Beagle‚Äôs default behaviour with the properties customization of the Beagle.dependencies instantiation.\nThey have a specific role in Beagle‚Äôs capacity, this is the reason you have to deal Beagle.dependencies as the main focus on your customization, so that other parts of your application are able to see the changes you made in the dependencies.\nYou must trust in the pattern implementation, like the example below:\nclass BeagleDependencies: BeagleDependenciesProtocol { var urlBuilder: UrlBuilderProtocol var networkClient: NetworkClient var decoder: ComponentDecoding var appBundle: Bundle var theme: Theme var validatorProvider: ValidatorProvider? var deepLinkHandler: DeepLinkScreenManaging? var localFormHandler: LocalFormHandler? var repository: Repository var analytics: Analytics? var navigation: BeagleNavigation var preFetchHelper: BeaglePrefetchHelping var cacheManager: CacheManagerProtocol? var formDataStoreHandler: FormDataStoreHandling var windowManager: WindowManager var opener: URLOpener var globalContext: GlobalContext var isLoggingEnabled: Bool var logger: BeagleLoggerType } The Beagle‚Äôs dependencies must be register in the AppDelegate, see the example below:\n@UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool { let dependencies = BeagleDependencies() dependencies.theme = AppTheme.theme dependencies.urlBuilder = UrlBuilder(baseUrl: URL(string: .baseURL)) dependencies.navigation.defaultAnimation = .init( pushTransition: .init( type: .fade, subtype: .fromRight, duration: 0.1 ), modalPresentationStyle: .formSheet ) dependencies.isLoggingEnabled = true dependencies.decoder.register( component: CustomComponent.self, named: \"CustomComponent\" ) dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\") Beagle.dependencies = dependencies let rootViewController = MainScreen().screenController() window?.rootViewController = rootViewController return true } } UrlBuilder It configures the base URL to your application, it‚Äôs used when the navigation flow via Beagle are defined, you can use a relative URL.\nSee how to use it below:\ndependencies.urlBuilder = UrlBuilder(baseUrl: URL(string: \"YOUR BASE URL NetworkClient It can run network requests. Your application must be customized here, because every project has a specific network layer. For that, the pattern implementation cannot work on your project.\nDecoder It transforms a JSON into Beagle‚Äôs Component (Elements Section). It already has a logic to decode all the default components. If you have to work with customized components, you can register them in this instance.\nSee below how to register a component and a customized action:\nBeagle.dependencies.decoder.register( component: CustomWidget.self, named: \"CustomWidget\" ) Beagle.dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\" ) AppBundle You can provide a package for your application in a way Beagle can access your resources, for example, images, fonts, colors, etc.\nTheme It stores all your styles and it knows how to apply them in your components. Some widgets have a variable that allows you to define the style. Each name must be passed on the dependency of theme, so that style may be used in your component.\nTo configure the customized styles, follow the next steps:\nYou will use text as a widget that has UITextView as your UIKit view. After that, you will apply your style changes to this view which will have font and textColor customization.  Step 1: create a function that it will receive a UIKit widget representation of what you want to apply to the style.\nstatic func blackTextNormalStyle() -\u003e (UITextView?) -\u003e Void { return { $0?.font = .systemFont(ofSize: 16) $0?.textColor = .black } } Passo 2: create a concrete instance of AppTheme with the names of yout style and its functions.\nlet theme = AppTheme(styles: [ \"myStyleName\": blackTextNormalStyle ]) Passo 3: assign your Theme instance to Beagle‚Äôs dependencies.\nBeagle.dependencies.theme = theme Passo 4: now, you can use Text with your style properties and then configure the name your defined for your customized style.\nText(\"Some text\", style: \"myStyleName\") ValidatorProvider Validates the customization that it will be made when the Form widget will be used.\nDeepLinkHandler This handler is used for adeep link navigation action. The variable has a default value, you can add new screens or replace for other in the application.\nYou will find how to add a screen with a possible deep linking routing using a default value below:\nlet deepLinkHandler = DeeplinkScreenManager.shared deepLinkHandler[\"MyDeepLinkScreen\"] = MyDeepLinkScreenClass.self Beagle.dependenciesdeepLinkHandler = deepLinkHandler LocalFormHandler Your application can deal with form being send by the user using FormLocalAction.\nLocalFormHandler defined on Beagle‚Äôs dependencies will be used to run this.\nRepository It is responsible for three main operations on:\n fetchComponent: orchestrate the request to search widgets on the server. submitForm: submit forms on widget. fetchImage: search images for networkImage.  Analytics It is a protocol that can be implemented to track the appearence of the screen or its closing or a click event.\nSee the example below:\nclass AnalyticsSample: Analytics { func trackEventOnScreenAppeared(_ event: AnalyticsScreen) { print(\"Screen \\(event.screenName)appeared\") } func trackEventOnScreenDisappeared(_ event: AnalyticsScreen) { print(\"Screen \\(event.screenName)disappeared\") } func trackEventOnClick(_ event: AnalyticsClick) { print(\"Button touch with:\\ncategory = \\(event.category)\\nlabel = \\(event.label ?? \"empty\")\\nvalue = \\(event.value ?? \"empty\")\") } } Navigation navigation deals with the navigate types of action in your application. There is one implementation that it is used with default value, but that it can be replaced for a BeagleNavigation class.\nOn this same attribute is also possible to define a navigation animation.\npreFetchHelper This component is used to search BeagleScreenViewControllers and delivers a fluid experience to the user. It already has a value, it can be altered to fit what you need.\nThe pre search is used when there is a navigataion widget in a way you can download all the data possible in the next screen, avoiding navigation delays. This behaviour can be deactivated.\nCacheManager It is responsible to keep and manage the server-driven content cache of your application.\nFormDataStoreHandler It is a way to persist the form data.\nWindowManager It is responsible to manage a window.\nOpener It is a protocol that has a method and opens an URL in case you need to navigate through an external link.\nGlobalContext Variable that defines a global scope context.\nIsLoggingEnabled It is a boolean variable that enables or disable the logs, it comes already enabled by a pattern.\nLogger Logger is a variable type BeagleLoggerType that organizes the application‚Äôs logs. These logs follow a LogType protocol, which there are parameters:\n category: log‚Äôs matter; message: log‚Äôs message; level: ranks the critical level.  It is possible to create a customized logger, which it has the application‚Äôs specifics categories.  ","excerpt":" Introduction Your application can change Beagle‚Äôs default behaviour ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/beagles-dependencies/","title":"Beagle's dependencies"},{"body":" Introdu√ß√£o No protocolo BeagleNavigation temos uma vari√°vel defaultAnimation que permite que voc√™ mude as anima√ß√µes de transi√ß√£o da sua aplica√ß√£o, e tamb√©m outra fun√ß√£o que lida com os tipos de a√ß√µes navigate e define os seus comportamentos.\nSugerimos que voc√™ use a implementa√ß√£o default, mas se necess√°rio, √© permitido que essa implementa√ß√£o seja substitu√≠da por uma classe que est√° de acordo com o protocolo acima.\nProtocolo e customiza√ß√£o No protocolo da BeagleNavigation temos uma vari√°vel defaultAnimation que determina como a anima√ß√£o de uma tela acontece quando ela √© apresentada.\n√â permitido que as transi√ß√µes de Push e Pop de uma View Controller sejam alteradas usando as vari√°veis pushTransition e popTransition. √â poss√≠vel tamb√©m mudar o modalPresentationStyle e modalTransitionStyle de uma view usando as vari√°veis abaixo:\npublic struct BeagleNavigatorAnimation { var pushTransition: Transition? var popTransition: Transition? var modalPresentationStyle: UIModalPresentationStyle? var modalTransitionStyle: UIModalTransitionStyle } Na estrutura abaixo, proporcionamos os tipos de CATransition , onde voc√™ pode fazer uma transi√ß√£o de estados de uma layer criando e adicionando um objecto de CATransition.\npublic struct Transition { var type: CATransitionType var subtype: CATransitionSubtype? var duration: Double } Exemplo Veja o exemplo abaixo onde o default das transi√ß√µes de pushTransition e modalPresentationStyle foi modificado:\nlet animation = BeagleNavigatorAnimation( pushTransition: .init( type: .fade, subtype: .fromRight, duration: 1.0), modalPresentationStyle: .formSheet) let dependencies = BeagleDependencies() dependencies.navigation.defaultAnimation = animation  Esta configura√ß√£o se aplica a todas as navega√ß√µes da sua aplica√ß√£o.  ","excerpt":" Introdu√ß√£o No protocolo BeagleNavigation temos uma vari√°vel ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/anima%C3%A7%C3%B5es-de-navega%C3%A7%C3%A3o/","title":"Anima√ß√µes de navega√ß√£o"},{"body":" Introduction Beagle View is an UIView that must be used when it is necessary to add a Beagle‚Äôs component in a native screen that has other views and use AutoLayout.\nUsing a Beagle View Creating an AutoLayout Check out below a native layout that can be used as an example of AutoLayout use with Beagle:\nstruct AutoLayoutComponent: ServerDrivenComponent { var widgetProperties: WidgetProperties = WidgetProperties() func toView(renderer: BeagleRenderer) -\u003e UIView { return AutoLayoutWrapper(view: AutoLayoutSample()) } } class AutoLayoutSample: UIView { let constraintView: UIView let heightConstraint: NSLayoutConstraint override init(frame: CGRect) { let view = UIView() self.constraintView = view self.heightConstraint = view.heightAnchor.constraint(equalToConstant: 100) super.init(frame: frame) backgroundColor = .yellow layer.borderWidth = 1 layer.borderColor = UIColor.black.cgColor view.backgroundColor = .cyan addSubview(view) translatesAutoresizingMaskIntoConstraints = false let label = UILabel() label.text = \"AUTO\" addSubview(label) label.translatesAutoresizingMaskIntoConstraints = false label.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 5).isActive = true label.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -5).isActive = true label.topAnchor.constraint(equalTo: topAnchor, constant: 5).isActive = true view.translatesAutoresizingMaskIntoConstraints = false view.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 5).isActive = true view.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -5).isActive = true view.topAnchor.constraint(equalTo: label.bottomAnchor, constant: 5).isActive = true view.widthAnchor.constraint(equalToConstant: 50).isActive = true heightConstraint.isActive = true } required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } Creating a BeagleView A BeagleView can be created with like an UIView. Check out below an example of a ViewController with a container that has a text and a button:\nclass CustomViewController: UIViewController { private lazy var beagleView = BeagleView( Container( widgetProperties: WidgetProperties( id: \"container\", style: Style().backgroundColor(\"#D3D3D3\") .margin(EdgeValue(all: 5)) .padding(EdgeValue(all: 5)) .flex(Flex().flexWrap(.wrap))) ) { Text(\"YOGA\") Button( text: \"ADD\", onPress: [AddChildren(componentId: \"container\", value: [AutoLayoutComponent()])] ) AutoLayoutComponent() } ) override func viewDidLoad() { super.viewDidLoad() navigationItem.title = \"BeagleView\" setupView() } private func setupView() { view.backgroundColor = .white let margin = view.layoutMarginsGuide view.addSubview(beagleView) beagleView.translatesAutoresizingMaskIntoConstraints = false beagleView.topAnchor.constraint(equalTo: margin.topAnchor).isActive = true beagleView.leadingAnchor.constraint(equalTo: margin.leadingAnchor).isActive = true beagleView.trailingAnchor.constraint(lessThanOrEqualTo: margin.trailingAnchor).isActive = true beagleView.bottomAnchor.constraint(lessThanOrEqualTo: margin.bottomAnchor).isActive = true } } Notice that the onPress of the button is calls the AddChildren method that adds the native layout, which means that every time the button is pressed, it adds a view with native layout.\n","excerpt":" Introduction Beagle View is an UIView that must be used when it is ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/beagle-view/","title":"Beagle View"},{"body":" Introdu√ß√£o Beagle View √© uma UIView que deve ser usada quando √© necess√°rio adicionar um componente do Beagle em uma tela nativa que possui outras views e usam AutoLayout.\nUsando uma Beagle View Criando um AutoLayout Segue abaixo um layout nativo que ser√° usado para exemplificar o uso do AutoLayout junto com o Beagle:\nstruct AutoLayoutComponent: ServerDrivenComponent { var widgetProperties: WidgetProperties = WidgetProperties() func toView(renderer: BeagleRenderer) -\u003e UIView { return AutoLayoutWrapper(view: AutoLayoutSample()) } } class AutoLayoutSample: UIView { let constraintView: UIView let heightConstraint: NSLayoutConstraint override init(frame: CGRect) { let view = UIView() self.constraintView = view self.heightConstraint = view.heightAnchor.constraint(equalToConstant: 100) super.init(frame: frame) backgroundColor = .yellow layer.borderWidth = 1 layer.borderColor = UIColor.black.cgColor view.backgroundColor = .cyan addSubview(view) translatesAutoresizingMaskIntoConstraints = false let label = UILabel() label.text = \"AUTO\" addSubview(label) label.translatesAutoresizingMaskIntoConstraints = false label.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 5).isActive = true label.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -5).isActive = true label.topAnchor.constraint(equalTo: topAnchor, constant: 5).isActive = true view.translatesAutoresizingMaskIntoConstraints = false view.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 5).isActive = true view.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -5).isActive = true view.topAnchor.constraint(equalTo: label.bottomAnchor, constant: 5).isActive = true view.widthAnchor.constraint(equalToConstant: 50).isActive = true heightConstraint.isActive = true } required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } Criando uma BeagleView Uma BeagleView pode ser criada como uma UIView. Segue um exemplo abaixo de uma ViewController com um container que possui um texto e um bot√£o:\nclass CustomViewController: UIViewController { private lazy var beagleView = BeagleView( Container( widgetProperties: WidgetProperties( id: \"container\", style: Style().backgroundColor(\"#D3D3D3\") .margin(EdgeValue(all: 5)) .padding(EdgeValue(all: 5)) .flex(Flex().flexWrap(.wrap))) ) { Text(\"YOGA\") Button( text: \"ADD\", onPress: [AddChildren(componentId: \"container\", value: [AutoLayoutComponent()])] ) AutoLayoutComponent() } ) override func viewDidLoad() { super.viewDidLoad() navigationItem.title = \"BeagleView\" setupView() } private func setupView() { view.backgroundColor = .white let margin = view.layoutMarginsGuide view.addSubview(beagleView) beagleView.translatesAutoresizingMaskIntoConstraints = false beagleView.topAnchor.constraint(equalTo: margin.topAnchor).isActive = true beagleView.leadingAnchor.constraint(equalTo: margin.leadingAnchor).isActive = true beagleView.trailingAnchor.constraint(lessThanOrEqualTo: margin.trailingAnchor).isActive = true beagleView.bottomAnchor.constraint(lessThanOrEqualTo: margin.bottomAnchor).isActive = true } } Note que no onPress do bot√£o √© chamado um m√©todo AddChildren que adiciona o layout nativo, ou seja, toda vez que o bot√£o for clicado √© adicionado uma view com o layout nativo.\n","excerpt":" Introdu√ß√£o Beagle View √© uma UIView que deve ser usada quando √© ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/beagle-view/","title":"Beagle View"},{"body":" Introduction Beagle Navigation Controller is a class like the UINavigationController, but more focused on handle the server-driven screen state when it starts or finishes.\nThe method serverDrivenStateDidChange() is the entry point to handle screen state changes.\nThe default implementation shows an ‚ÄúActivityIndicator‚Äù when the screen is loading and does nothing. When an error happens, you can override this method to handle errors properly.\nWhen overriding, if you want to preserve loading behavior, a ‚Äúsuper‚Äù implementation should be called or you can customize a loading behavior by yourself.\nParameters  State: New state that tells if screen is loading or any error happened ScreenController: Controller that triggered the state change  Check out below the Beagle Navigation Controller class:\nopen class BeagleNavigationController: UINavigationController { open func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { switch state { case .started: view.showLoading(.whiteLarge) case .finished: view.hideLoading() case .success, .error: break } } } The ServerDrivenState is an enum that typifies the screen state. See its structure below:\npublic typealias BeagleRetry = () -\u003e Void public enum ServerDrivenState { case started case finished case success case error(ServerDrivenState.Error, BeagleRetry) } extension ServerDrivenState { public enum Error: Swift.Error { case remoteScreen(Request.Error) case action(Swift.Error) case lazyLoad(Request.Error) case submitForm(Request.Error) case webView(Swift.Error) case declarativeText } } Example class CustomBeagleNavigationController: BeagleNavigationController { private var errorView = ErrorView(message: nil) { } override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) guard case let .error(serverDrivenError, retry) = state else { return } let message: String switch serverDrivenError { case .remoteScreen(let error), .lazyLoad(let error), .submitForm(let error): switch error { case .networkError(let messageError): message = messageError.localizedDescription case .decoding(let messageError): message = messageError.localizedDescription case .loadFromTextError, .urlBuilderError: message = error.localizedDescription } case .action(let error): message = error.localizedDescription default: message = \"Unknow Error.\" } if !view.subviews.contains(errorView) { errorView = ErrorView(message: message, retry: retry) errorView.present(in: view) } else { errorView.addRetry(retry) } } }  You must register this class in Beagle‚Äôs dependencies.  let dependencies = BeagleDependencies() dependencies.navigation.registerNavigationController( builder: CustomBeagleNavigationController.init, forId: \"CustomBeagleNavigation\" ) Beagle.dependencies = dependencies  You can register as many BeagleNavigationController as you need.  Now when you instantiating the BeagleScreenViewController, you can pass the controllerId ‚ÄúCustomBeagleNavigation‚Äù so that your BeagleScreenViewController use your CustomBeagleNavigationController.\nfunc screenController() -\u003e UIViewController { let screen = Screen( child: Text() ) return BeagleScreenViewController( .declarative(screen), controllerId: \"CustomBeagleNavigation\" ) } ","excerpt":" Introduction Beagle Navigation Controller is a class like the ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/custom-beagle-navigation-controller/","title":"Custom Beagle Navigation Controller"},{"body":" Introduction action is a code block that can run when some event is defined. Beagle already has some by pattern, however it is possible to create your own customized action.\nExample How to create a custom action? To create a custom action, follow the next steps:\n Create a class that implements an action interface:  struct CustomAction: Action { func execute( controller: BeagleController, origin: UIView) { print(\"Custom action foi chamada!\") } }  After that, the interface will request that the method execute is implemented. On this method the code block will be implemented, then your action will run;\n  Now, it is necessary to register this new action on Beagle‚Äôs dependencies:\n  let dependencies = BeagleDependencies() dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\" ) Beagle.dependencies = dependencies How to use it? See below an example on how to use the button that runs the customized action on the click event:\nButton( text: \"do request\", onPress: [ CustomCAction() ] ) ","excerpt":" Introduction action is a code block that can run when some event is ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/custom-action/","title":"Custom Action"},{"body":" Introdu√ß√£o BeagleScreenViewController √© uma classe que gerencia a hierarquia de exibi√ß√£o na aplica√ß√£o e possui o mesmo funcionamento de uma UIViewController.\nComo implementar essa classe? Voc√™ precisa criar um objeto BeagleScreenViewController com um conjunto de atributos e par√¢metros.\nEsse processo pode ser feito com seguintes passos:\n Crie um objeto BeagleScreenViewModel com o screenType remote que deve passar uma URL, um fallback opcional, ou um declarative que passa a tela para o modo declarativo.  Voc√™ pode encontrar os comandos a serem executados a seguir:\npublic class BeagleScreenViewModel { public enum ScreenType { case remote(String, fallback: Beagle.Screen?) case declarative(BeagleUI.Screen) } public init(screenType: BeagleUI.BeagleScreenViewModel.ScreenType, delegate: BeagleUI.BeagleScreenDelegate? = nil) } let viewController = BeagleScreenViewController( viewModel: viewModel) Al√©m dos comandos acima, h√° outros exemplos de inicializa√ß√£o utilizando o declarative e remote:\n//1  let viewModel = BeagleScreenViewModel(screenType: .declarative(content: Home().screen)) //2 let viewModel = BeagleScreenViewModel(screenType: .remote(\"/cash-withdrawal/home\"), fallback: nil)) //3 let viewModel = BeagleScreenViewModel( screenType:.remote( \"http://localhost:8090/cash-withdrawal/home\"), fallback: Home().screen)) Voc√™ pode instanciar o BeagleScreenViewModel com um screenType do tipo declarative passando uma tela criada para o seu modo declarativo.\nNesse exemplo, o BeagleScreenViewModel foi instanciado com um screenType do tipo remote onde se passa uma URL relativa e um fallback nulo. Para usar essa URL voc√™ deve colocar primeiro uma URL base no BeagleDependencies do seu projeto.\nO segundo BeagleScreenViewModel foi instanciado com um screenType do tipo remote onde passa a URL absoluta e um fallback de uma tela no modo declarativo.\nEstados da tela Para acompanhar o estado da tela temos o enum state:\npublic enum State { //1 case loading //2 case success //3 case failure(Beagle.Request.Error) //4 case rendered }  O estado loading √© executado enquanto a requisi√ß√£o n√£o foi recebida ou a tela n√£o foi renderizada e assim que as informa√ß√µes s√£o recebidas e a tela √© renderizada, o estado muda para sucesso e se der erro o estado muda para failure. O estado de sucesso √© executado logo ap√≥s que a verifica√ß√£o da requisi√ß√£o for conclu√≠da e a tela renderizada. O failure √© executado quando h√° algo errado na requisi√ß√£o ou na renderiza√ß√£o da tela, logo BeagleUI.Request.Error informa qual foi o erro. O rendered √© utilizado logo ap√≥s o sucesso, quando a tela √© chamada para ser renderizada.  Quando tudo executa o BeagleScreenViewModel com o screenType do tipo declarative, o estado passa direto para sucesso pulando o loading.\nNo BeagleScreenViewModel h√° uma vari√°vel delegate que est√° relacionada ao BeagleScreenDelegate. Ao estender esse protocolo, caso ocorra algum erro de requisi√ß√£o ao implementar um screenType do tipo remote, ele cair√° na fun√ß√£o de erro desse protocolo. Onde o usu√°rio pode complementar essa fun√ß√£o com o erro.\npublic protocol BeagleScreenDelegate : AnyObject { typealias ViewModel = Beagle.BeagleScreenViewModel func beagleScreen(viewModel: Self.ViewModel, didFailToLoadWithError error: Beagle.Request.Error) } Exemplo para implementar o protocolo BeagleScreenDelegate: //1 let viewModel = BeagleScreenViewModel(screenType: .remote(\"/cash-withdrawal/home\"), fallback: nil)) viewModel.delegate = self //2 extension ViewController: BeagleScreenDelegate { func beagleScreen(viewModel: ViewController.ViewModel, didFailToLoadWithError error: Beagle.Request.Error) { print(\"didFailToLoadWithError: \\(error)\") } }  Reutilizando o exemplo de instanciar o BeagleScreenViewModel voc√™ pode adicionar o viewModel.delegate = self, onde se acontecer algum erro de requisi√ß√£o voc√™ pode fazer uma tratativa. Ao implementar o protocolo BeagleScreenViewModel voc√™ pode complementar essa fun√ß√£o, como no exemplo e a fun√ß√£o ir√° mostrar o erro.  A BeagleScreenViewController trabalha com a customiza√ß√£o de componentes na view:\nextension BeagleScreenViewController: Beagle.BeagleContext { //1  public func register(action: Beagle.Action, inView view: UIView) //2 public func register(form: BeagleSchema.Form, formView: UIView, submitView: UIView, validatorHandler: Beagle.ValidatorProvider?) //3 public func lazyLoad(url: String, initialState: UIView) //4 public func doAction(_ action: Beagle.Action, sender: Any) } ","excerpt":" Introdu√ß√£o BeagleScreenViewController √© uma classe que gerencia a ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/screen-view-controller/","title":"Screen View Controller"},{"body":" Introdu√ß√£o Beagle Navigation Controller √© uma classe como uma UINavigationController, por√©m focada em observar o estado da tela server-driven para, por exemplo, saber quando ela inicia ou finaliza.\nO serverDrivenStateDidChange() √© o m√©todo que observa as mudan√ßas de estado da tela.\nA implementa√ß√£o padr√£o mostra um ‚ÄúActivityIndicator‚Äù enquanto o estado da tela √© ‚Äúloading‚Äù e nada acontece. Se um erro acontece, voc√™ pode sobrescrever esse m√©todo para tratar o erro.\nCaso queira preservar o loading depois que ele for sobrescrito, voc√™ deve implementar o ‚Äúsuper‚Äù ou personalizar o pr√≥prio loading.\nPar√¢metros  State: Novo estado que indica se a tela est√° carregando ou ocorreu algum erro. ScreenController: Controller que indica a mudan√ßa de estado.  Confira abaixo a classe BeagleNavigationController:\nopen class BeagleNavigationController: UINavigationController { open func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { switch state { case .started: view.showLoading(.whiteLarge) case .finished: view.hideLoading() case .success, .error: break } } } O ServerDrivenState √© um enum que define as possibilidades de estados da tela. Veja essa estrutura abaixo:\npublic typealias BeagleRetry = () -\u003e Void public enum ServerDrivenState { case started case finished case success case error(ServerDrivenState.Error, BeagleRetry) } extension ServerDrivenState { public enum Error: Swift.Error { case remoteScreen(Request.Error) case action(Swift.Error) case lazyLoad(Request.Error) case submitForm(Request.Error) case webView(Swift.Error) case declarativeText } } Exemplo class CustomBeagleNavigationController: BeagleNavigationController { private var errorView = ErrorView(message: nil) { } override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) guard case let .error(serverDrivenError, retry) = state else { return } let message: String switch serverDrivenError { case .remoteScreen(let error), .lazyLoad(let error), .submitForm(let error): switch error { case .networkError(let messageError): message = messageError.localizedDescription case .decoding(let messageError): message = messageError.localizedDescription case .loadFromTextError, .urlBuilderError: message = error.localizedDescription } case .action(let error): message = error.localizedDescription default: message = \"Unknow Error.\" } if !view.subviews.contains(errorView) { errorView = ErrorView(message: message, retry: retry) errorView.present(in: view) } else { errorView.addRetry(retry) } } }  √â muito importante que voc√™ registre sua CustomBeagleNavigationController nas configura√ß√µes de depend√™ncias do Beagle.  let dependencies = BeagleDependencies() dependencies.navigation.registerNavigationController( builder: CustomBeagleNavigationController.init, forId: \"CustomBeagleNavigation\" ) Beagle.dependencies = dependencies  √â poss√≠vel registrar quantas BeagleNavigationController voc√™ quiser.  Quando iniciar uma BeagleScreenViewController, voc√™ deve passar o par√¢metro controllerId com o id escolhido para sua custom BeagleNavigationController e usar a controller desejada.\nfunc screenController() -\u003e UIViewController { let screen = Screen( child: Text() ) return BeagleScreenViewController( .declarative(screen), controllerId: \"CustomBeagleNavigation\" ) } ","excerpt":" Introdu√ß√£o Beagle Navigation Controller √© uma classe como uma ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/beagle-navigation-controller-customizada/","title":"Beagle Navigation Controller customizada"},{"body":" Introduction Beagle already have basic widgets, that can be used to alter your UI application through backend. However you can add new components to make the views of your applications visible to Beagle and also make them be used in the backend.\nHow to create components (custom views) and widgets? Passo 1: Create a Widget See below an example of a customized component that represents UILabel:\nstruct MyCustomComponent: ServerDrivenComponent { let text: String func toView(renderer: BeagleRenderer) -\u003e UIView { let label = UILabel(frame: .zero) label.text = text label.numberOfLines = 0 return label } } You can see in the example MyCustomComponent is a ServerDrivenComponent, it is a protocol that conforms to Decodable which is responsible to decode the properties your widgets exposes to the backend.\nStep 2: Register the Widget It is required you register to Beagle. Inside the configure file use the registerCustomComponent(). method. The first parameter is a string tha refers as your BFF will call it and the second parameter is the component‚Äôs class.\nBeagle.registerCustomComponent( \"MyCustomComponent\", componentType: MyCustomComponent.self ) After you register your customized component, you can use via server-driven.\nStep 3: Display the component You can use your component declaratively or put it in an instance until BeagleScreenViewController or call it with the toView() method and present the UIView that appears in your own view controller.\nlet beagleScreenViewController = Beagle.screen( .declarative( .init(child: MyCustomComponent(text: \"Hello Beagle!\") ) ) ) Even if you have a more complex component in your UIViews, the process will be very similar, you just have to provide an ServerDrivenComponent or a Widget type.\n","excerpt":" Introduction Beagle already have basic widgets, that can be used to ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/custom-widgets/","title":"Custom Widgets"},{"body":" Introdu√ß√£o O Beagle realiza todas requisi√ß√µes web a partir da depend√™ncia networkClient presente no BeagleDependencies, ela √© do tipo NetworkClient, sendo assim √© poss√≠vel substituir a implementa√ß√£o default utilizada no framework por outra.\nVoc√™ precisa fazer a substitui√ß√£o nos casos em que:\n √â preciso unificar a camada de networking do sistema em um m√≥dulo; Modificar algumas propriedades como, por exemplo, cabe√ßalhos de requisi√ß√µes, m√©todos request, body response, data response, executar criptografia, etc.  public protocol NetworkClient { typealias Error = NetworkError typealias NetworkResult = Result\u003cNetworkResponse, NetworkError\u003e typealias RequestCompletion = (NetworkResult) -\u003e Void @discardableResult func executeRequest( _ request: Request, completion: @escaping RequestCompletion ) -\u003e RequestToken? }  A implementa√ß√£o default do protocolo NetworkClient usada pelo Beagle utiliza recursos do Foundation para realizar as requisi√ß√µes como o URLSession.  Customiza√ß√µes Para customizar o seu protocolo NetworkClient, veja as se√ß√µes abaixo:\nAdicione header fields Para adicionar header fields nas requisi√ß√µes criadas pelo NetworkClient default basta seguir os seguintes passos:\n No AppDelegate ou na classe de configura√ß√µes do ambiente do beagle instancie o NetworkClientDefault passando as depend√™ncias rec√©m criadas no inicializador; Adicione os headers desejados no atributo additionalHeaders presente no objeto HttpRequestBuilder. Ele √© uma depend√™ncia do NetworkClientDefault respons√°vel por criar as URLRequest que s√£o passadas para a dataTask do URLSession; Atribuia o NetworkClient instanciado e modificado como o networkClient das depend√™ncias:  let dependencies = BeagleDependencies() let client = NetworkClientDefault(dependencies: dependencies) client.httpRequestBuilder.additionalHeaders = [ \"X-Frame-Options\": \"deny\", \"client-Identification\":\"123123123\" ] dependencies.networkClient = client Beagle.dependencies = dependencies Modifique URL base Para modificar a URL base utilizada pelo Beagle, siga os passos:\n No AppDelegate ou na classe de configura√ß√µes do ambiente do Beagle, instancie um objeto do tipo URLBuilder e passe a URL base no inicializador; Atribua o objeto criado ao atributo urlBuilder presente no BeagleDependencies:  let dependencies = BeagleDependencies() let urlBuilder = UrlBuilder(baseUrl: URL(string: Constants.Server.baseURL)) dependencies.urlBuilder = urlBuilder Beagle.dependencies = dependencies Substituindo a camada de Networking Para substituir a classe respons√°vel por realizar as requisi√ß√µes Http para o Beagle, siga os passos a seguir:\nPasso 1: implementar a NetworkClient Implemente o protocolo NetworkClient na classe que deseja utilizar para realizar as requisi√ß√µes, neste caso o CustomNetworkClient ser√° usado como exemplo:\nclass CustomNetworkClient: NetworkClient { func executeRequest( _ request: Request, completion: @escaping RequestCompletion ) -\u003e RequestToken? { let url: URL = request.url let requestType = request.type let headers = request.additionalData //Implementacao de Requisicoes } //Implementacao Network Client... } Esse protocolo tem a responsabilidade de executar as requisi√ß√µes a partir da fun√ß√£o executeRequest que recebe 2 par√¢metros:\n request: valor do tipo Request que cont√©m os dados necess√°rios para a requisi√ß√£o:  URL Headers RequestType   completion: bloco que deve ser chamado ao final da execu√ß√£o da fun√ß√£o passando o resultado da requisi√ß√£o.  Al√©m disso a fun√ß√£o pode retornar o RequestToken, para que a requisi√ß√£o possa ser cancelada internamente pelo Beagle.\nPasso 2: atribuir as depend√™ncias No AppDelegate ou na classe de configura√ß√µes do ambiente do Beagle, atribua a inst√¢ncia de CustomNetworkClient ao atributo networkClient presente no Beagle Dependencies:\nlet dependencies = BeagleDependencies() let client = CustomNetworkClient() dependencies.networkClient = client Beagle.dependencies = dependencies Pronto! Agora o Beagle utilizar√° a sua classe com todas as modifica√ß√µes e defini√ß√µes necess√°rias para realizar as requisi√ß√µes Http.\n","excerpt":" Introdu√ß√£o O Beagle realiza todas requisi√ß√µes web a partir da ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/camada-de-rede/","title":"Camada de rede"},{"body":" Added in Beagle 1.0.0 Beagle uses the unified log system recommend by Apple, to provide different log messages in critical stages of a server driven flow.\nThe log messages provided for Beagle iOS can be access through:\n Xcode console Application console  They are divided in 4 categories:\n Network: related to the network layer, information and error messages for each request, response and network URL construction. Decoding: displays messages every time a parse error occurs. Navigation: informative messages that describes the navigations inside the server driven flow and possible errors may occur. Form: related to forms.  It is possible to disable triggered log messages. Beagle will not call the Log‚Äôs API, even if it is a pattern or customized. You will need to change the attribute isLoggingEnabled ofBeagleDependencies tofalse.\nThe log messages can be filtered using these categories names and the main package identifier of the application as a subsystems.\nInstructions to filter log messages: Follow the steps below to filter the log messages:\nStep 1: open Console App;\nStep 2: select device on the Devices menu;\nStep 3: insert the filters in the search bar, search only for log messages with the Network category in the subsystem br.com.zup.BeagleDemoApp\nStep 4: when you open the BeagleDemo application, you will see two log messages with the network category, one will show that Beagle made a request and the other indicating the response.\nStep 5: error messages will be displayed with a yellow dot in the field Type, as showed below:\nStep 6: to select the second log message received with a Network filter, you will see a verbosa version of this response.\nStep 7: the body of the response contains the server-driven screen and all its attributes and specifications can be accessed.\nInstructions to replace the Logs API In order to let Beagle‚Äôs environment open to modifications, the API logs pattern can be replaced to any other. Follow th next steps to make the API‚Äôs logs replacement:\nStep 1: implement BeagleLoggerType protocol on the class you want to use as log API, you will see that it is necessary to implement the methods log(_ log: LogType) and logDecodingError(type: String) that are internally called by Beagle when a message needs to be triggered:\nclass CustomLogger: BeagleLoggerType { func log(_ log: LogType) { print(log.message) } func logDecodingError(type: String) { print(type) } } Step 2: on Beagle‚Äôs configuration of your project, assign to a class' instance to the logger dependency on BeagleDependencies:\nlet dependencies = BeagleDependencies() dependencies.logger = CustomLogger() Beagle.dependencies = dependencies ","excerpt":" Added in Beagle 1.0.0 Beagle uses the unified log system recommend by ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/log-system/","title":"Log System"},{"body":" Introdu√ß√£o Para customizar os comportamentos de carregamento e erro no Beagle iOS, voc√™ precisa criar seu pr√≥prio navigation controller.\nAo cria-lo, voc√™ precisa seguir os seguintes passos:\n Extender sua controller a partir daBeagleNavigationController Alterar as depend√™ncias do Beagle para utiliz√°-lo.  O m√©todo serverDrivenStateDidChange deve ser sobrescrito para fazer a customiza√ß√£o.  Exemplo Criando o Beagle navigation controller Passo 1: Criar um Beagle navigation controller: import Beagle class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { // TODO:Exibir carregamento e erros quando necess√°rio. } } Passo 2: Configurar a depend√™ncia: let dependencies = BeagleDependencies() dependencies.navigation.registerNavigationController( builder: MyAppNavigationController.init, forId: \"MyAppNavigationController\") Beagle.dependencies = dependencies √â poss√≠vel cadastrar mais de uma customiza√ß√£o do BeagleNavigationController. Para escolher qual delas usar, o BFF precisa que voc√™ informe o forId.\nFa√ßa a configura√ß√£o do navigationControllerType com as demais configura√ß√µes do Beagle para n√£o sobrescrev√™-las_._  Configurando o Carregamento Por padr√£o, a implementa√ß√£o no Beagle sempre retorna uma interface com fundo preto semitransparente. Voc√™ pode ver isso por meio do UIActivityIndicatorView.\nSe voc√™ quiser apresentar um carregamento espec√≠fico da sua aplica√ß√£o, verifique o estado da tela (state) e reaja apropriadamente. Veja no exemplo a seguir:\nextension UIView { func showLoading() { // ... } func hideLoading() { // ... } } class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { switch state { case .loading(let loading): loading ? view.showLoading() : view.hideLoading() case .error: view.hideLoading() } } } Caso queira manter o estilo original de carregamento, basta executar a implementa√ß√£o padr√£o e seguir para o tratamento de erros.\noverride func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) // TODO:Tratar casos de erro } Tratando os erros Quando ocorre algum erro na aplica√ß√£o, o Beagle altera o estado da tela (state) para ServerDrivenState.Error. Nesse caso, voc√™ deve verificar qual foi tipo do erro e fazer a tratativa quando necess√°rio.\nOs poss√≠veis erros s√£o:\n remoteScreen(Request.Error): A requisi√ß√£o para carregar uma tela remota falhou. Veja abaixo quando isso ocorre. lazyLoad(Request.Error): A requisi√ß√£o para carregar um componente Lazy falhou. Veja abaixo quando isso ocorre. action(Swift.Error): A execu√ß√£o de uma Action falhou.  Erros em uma requisi√ß√£o (Request.Error):\n urlBuilderError: A URL do recurso ou a baseURL √© inv√°lida. networkError: N√£o foi poss√≠vel estabelecer a conex√£o ou um erro foi retornado pelo BFF. decoding: A resposta enviado pelo BFF √© diferente do objeto esperado.  O erro possui um bloco retry que permite executar novamente a a√ß√£o que falhou.  Veja o exemplo de como exibir uma tela de erro quando o carregamento de uma tela falha:\nclass ErrorView: UIVIew { var retry: (() -\u003e Void)? func present(in view: UIView) { // ... } } class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) if case let .error(serverDrivenError, retry) = state, case .remoteScreen = serverDrivenError { let errorView = ErrorView() errorView.retry = retry errorView.present(in: view) } } } ","excerpt":" Introdu√ß√£o Para customizar os comportamentos de carregamento e erro ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/carregamento-e-tratamento-de-erros/","title":"Carregamento e tratamento de erros"},{"body":" Added in Beagle 1.0.0 To customize the loading and error treatment behaviors on Beagle iOS, you have to create your own navigation controller.\nIt can be done by:\n Extending BeagleNavigationController Changing the dependencies to use them.  The serverDrivenStateDidChange method must be overwritten to make this customization.  See how to create a navigation controller:\nimport Beagle class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { // TODO:Exibir carregamento e erros quando necess√°rio. } } And, right after, how to configure a dependency:\nlet dependencies = BeagleDependencies() dependencies.navigation.registerNavigationController( builder: MyAppNavigationController.init, forId: \"MyAppNavigationController\") Beagle.dependencies = dependencies It‚Äôs possible register more than one custom BeagleNavigationController. To choose which one to use, the BFF needs to inform the forId.\nMake thenavigationControllerType configuration with other Beagle‚Äôs settings, so you don‚Äôt overwrite them.  Configuring the Loading As standard, Beagle‚Äôs implementation always return an interface with partially transparent black background. You can see this through UIActivityIndicatorView.\nIf you want to display a specific loading behavior on your application, check the screen state (state) and react to it properly. See how on the example below:\nextension UIView { func showLoading() { // ... } func hideLoading() { // ... } } class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { switch state { case .loading(let loading): loading ? view.showLoading() : view.hideLoading() case .error: view.hideLoading() } } } If you want to keep the original loading style, just run the standard implementation and move forward toerror treatment\noverride func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) // TODO:Tratar casos de erro } Checking the Error Treatment When occurs an error on the application, Beagle changes the screen state (state) to ServerDrivenState.Error. In this case, you must check out what kind of error and make the necessary treatment.\nThe possibles errors are:\n remoteScreen(Request.Error): When the request to load a remote screen fails. Check out on the example below when it happens. lazyLoad(Request.Error): When the request to load a Lazy component fails. Check out on the example below when it happens. action(Swift.Error): When an Action ‚Äôs execution fails.  Errors on a request (Request.Error):\n urlBuilderError: When the resource URL or a baseURL is invalid. networkError: When it‚Äôs not possible to establish a connection or an error was returned from the BFF. decoding: When the answer sent from BFF is different than the object expected.  The error has a retry block that allows you to run again the action that has failed.  See the example below how to display an error screen when the screen loading fails:\nclass ErrorView: UIVIew { var retry: (() -\u003e Void)? func present(in view: UIView) { // ... } } class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) if case let .error(serverDrivenError, retry) = state, case .remoteScreen = serverDrivenError { let errorView = ErrorView() errorView.retry = retry errorView.present(in: view) } } } ","excerpt":" Added in Beagle 1.0.0 To customize the loading and error treatment ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/loading-and-error-treatment/","title":"Loading and Error Treatment"},{"body":" Introdu√ß√£o A sua aplica√ß√£o pode mudar o comportamento default do Beagle, a partir da customiza√ß√£o de propriedades da inst√¢ncia do Beagle.dependencies.\nElas possuem um papel espec√≠fico na capacidade do Beagle, esta √© a raz√£o pela qual voc√™ deve tratar o Beagle.dependenciescomo principal foco de customiza√ß√£o para que as outras partes de sua aplica√ß√£o possa ver as modifica√ß√µes feitas nas depend√™ncias.\nVoc√™ deve confiar nas implementa√ß√µes padr√£o, como nos exemplos abaixo:\nclass BeagleDependencies: BeagleDependenciesProtocol { var urlBuilder: UrlBuilderProtocol var networkClient: NetworkClient var decoder: ComponentDecoding var appBundle: Bundle var theme: Theme var validatorProvider: ValidatorProvider? var deepLinkHandler: DeepLinkScreenManaging? var localFormHandler: LocalFormHandler? var repository: Repository var analytics: Analytics? var navigation: BeagleNavigation var preFetchHelper: BeaglePrefetchHelping var cacheManager: CacheManagerProtocol? var formDataStoreHandler: FormDataStoreHandling var windowManager: WindowManager var opener: URLOpener var globalContext: GlobalContext var isLoggingEnabled: Bool var logger: BeagleLoggerType } As depend√™ncias do Beagle dever√£o ser registradas no AppDelegate, veja o exemplo abaixo:\n@UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool { let dependencies = BeagleDependencies() dependencies.theme = AppTheme.theme dependencies.urlBuilder = UrlBuilder(baseUrl: URL(string: .baseURL)) dependencies.navigation.defaultAnimation = .init( pushTransition: .init( type: .fade, subtype: .fromRight, duration: 0.1 ), modalPresentationStyle: .formSheet ) dependencies.isLoggingEnabled = true dependencies.decoder.register( component: CustomComponent.self, named: \"CustomComponent\" ) dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\") Beagle.dependencies = dependencies let rootViewController = MainScreen().screenController() window?.rootViewController = rootViewController return true } } UrlBuilder Configura uma URL base para sua aplica√ß√£o, √© usada quando os fluxos de navega√ß√£o via Beagle ser√£o definidos, voc√™ pode usar uma URL relativa.\nVeja abaixo um exemplo de como usar:\ndependencies.urlBuilder = UrlBuilder(baseUrl: URL(string: \"SUA URL BASE\")) NetworkClient √â respons√°vel por executar network requests. A sua aplica√ß√£o dever√° ser customizada nesta parte porque cada projeto possui uma demanda espec√≠fica para network layer. Por isso, a implementa√ß√£o padr√£o pode n√£o servir dependendo das necessidades do seu neg√≥cio.\nDecoder Transforma um JSON em Componentes do Beagle (Se√ß√£o Elementos). Ele j√° possui uma l√≥gica para decodificar todos os componentes default. Se voc√™ precisar trabalhar com componentes customiz√°veis, voc√™ pode registr√°-los nesta inst√¢ncia.\nVeja abaixo um exemplo de como registrar um componente e uma action customizada:\nBeagle.dependencies.decoder.register( component: CustomWidget.self, named: \"CustomWidget\" ) Beagle.dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\" ) AppBundle Voc√™ pode fornecer um pacote para sua aplica√ß√£o de modo que o Beagle possa acessar seus recursos, como por exemplo, imagens, fontes, cores, etc.\nTheme Armazena todos os seus styles e sabe como aplic√°-los em seus componentes.\nAlguns widgets possuem uma vari√°vel que permite voc√™ definir o estilo. O nome de cada uma dever√° ser repassada √† depend√™ncia do Theme, de modo que aquele estilo possa ser usado no seu respectivo componente.\nPara configurar os estilos customizados, siga os seguintes passos:\nVoc√™ ir√° usar o Text como um widget que possui o UITextView como seu UIKit view. Depois disso, voc√™ ir√° aplicar suas mudan√ßas de estilo para esse view nos quais ter√£o tamb√©m customiza√ß√µes de font e textColor.  Passo 1: crie uma fun√ß√£o que ir√° receber a representa√ß√£o o UIKit com a representa√ß√£o do widget que voc√™ quer aplicar o estilo.\nstatic func blackTextNormalStyle() -\u003e (UITextView?) -\u003e Void { return { $0?.font = .systemFont(ofSize: 16) $0?.textColor = .black } } Passo 2: crie uma inst√¢ncia concreta do AppTheme com os nomes dos seus estilos e as fun√ß√µes correspondentes.\nlet theme = AppTheme(styles: [ \"myStyleName\": blackTextNormalStyle ]) Passo 3: atribua sua inst√¢ncia Theme √†s depend√™ncias do Beagle.\nBeagle.dependencies.theme = theme Passo 4: agora, voc√™ pode usar o Text com sua propriedade de style definida e assim configurar o nome que voc√™ definiu para o seu style customizado.\nText(\"Some text\", style: \"myStyleName\") ValidatorProvider Valida a customiza√ß√£o que ser√° realizada quando o widget Form for utilizado.\nDeepLinkHandler Este handler √© usado para uma a√ß√£o de deep link navigation. A vari√°vel possui um valor default, voc√™ pode adicionar novas telas ou substituir por outras na aplica√ß√£o.\nAbaixo, voc√™ encontra um comando de como adicionar uma tela com um poss√≠vel roteamento para deep linking usando um valor default:\nlet deepLinkHandler = DeeplinkScreenManager.shared deepLinkHandler[\"MyDeepLinkScreen\"] = MyDeepLinkScreenClass.self Beagle.dependenciesdeepLinkHandler = deepLinkHandler LocalFormHandler Sua aplica√ß√£o pode lidar com o envio de formul√°rio por conta pr√≥pria usando o FormLocalAction.\nO LocalFormHandler definido nas depend√™ncias do Beagle ser√° usado para executar isso.\nRepository √â respons√°vel pelas tr√™s principais opera√ß√µes no:\n fetchComponent: Orquestra a requisi√ß√£o para buscar widgets no servidor. submitForm: Submete forms no widget. fetchImage: Busca imagens para o networkImage;  Analytics √â um protocolo que pode ser implementado para rastrear a√ß√µes de aparecimento da tela ou sua finaliza√ß√£o e eventos de clique.\nVeja o exemplo abaixo:\nclass AnalyticsSample: Analytics { func trackEventOnScreenAppeared(_ event: AnalyticsScreen) { print(\"Screen \\(event.screenName)appeared\") } func trackEventOnScreenDisappeared(_ event: AnalyticsScreen) { print(\"Screen \\(event.screenName)disappeared\") } func trackEventOnClick(_ event: AnalyticsClick) { print(\"Button touch with:\\ncategory = \\(event.category)\\nlabel = \\(event.label ?? \"empty\")\\nvalue = \\(event.value ?? \"empty\")\") } } Navigation O navigation lida com tipo de a√ß√µes de navigate da sua aplica√ß√£o. Existe uma implementa√ß√£o que √© usada como valor default, mas que tamb√©m pode ser substitu√≠da por uma classe que est√° de acordo com BeagleNavigation\nNesse mesmo atributo tamb√©m √© poss√≠vel definir uma anima√ß√£o de navega√ß√£o.\nPreFetchHelper Este componente √© usado como pr√©-busca do BeagleScreenViewControllers e entrega uma experi√™ncia para o usu√°rio mais fluida. Ela j√° possui um valor e pode ser alterado para se adequar em que voc√™ precisa.\nA pr√©-busca √© acionada quando h√° um navigation widget de modo que voc√™ possa fazer um pr√© carregamento dos dados das poss√≠veis pr√≥ximas telas, evitando delays na navega√ß√£o. Este comportamento pode ser desativado.\nCacheManager √â respons√°vel por manter e gerenciar o cache do conte√∫do server-driven da aplica√ß√£o.\nFormDataStoreHandler √â uma forma de persistir os dados de um formul√°rio.\nWindowManager √â respons√°vel por gerenciar uma janela.\nOpener √â um protocolo que tem um m√©todo que abre URL caso necessite navegar para um link externo.\nGlobalContext Vari√°vel para definir um contexto de escopo global.\nIsLoggingEnabled √â uma vari√°vel boolean para habilitar ou desabilitar os logs e j√° vem habilitada por padr√£o.\nLogger O logger √© uma vari√°vel do tipo BeagleLoggerType que organiza os logs da aplica√ß√£o. Esses logs seguem o protocolo LogType, o qual tem os par√¢metros:\n category: assunto do log; message: mensagem do log; level: classifica o n√≠vel cr√≠tico.  √â poss√≠vel criar um logger customizado, o qual possu√≠ categorias especificas da aplica√ß√£o.  ","excerpt":" Introdu√ß√£o A sua aplica√ß√£o pode mudar o comportamento default do ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/depend%C3%AAncias-do-beagle/","title":"Depend√™ncias do Beagle"},{"body":" Added in Beagle 1.0.0 Protocol public protocol BeagleNavigation { var defaultAnimation: BeagleNavigatorAnimation? { get set } func navigate(action: Navigate, controller: BeagleController, animated: Bool) } On BeagleNavigation protocol we have a defaultAnimation variable that allows you to change the transition animation of your application, and also another function that deals with the navigate actions types and define their behaviours.\nWe suggest that you use the default implementation, but if it is necessary, it is allowed that this implementation is replaced by a class according to the protocol above.\nDefault implementation There is a implementation for this protocol used as a default value on BeagleDependencies It will treat the action with a more intuitive way.\nOpenExternalURL This action opens an available browser on the device from a informed URL.\nOpenNativeRoute This action opens a locally defined screen. It can be or not defined in the backend. It also allows you to add a ViewController to the stack with a push operation.\nSee the code below:\ncase openNativeRoute(String, data: [String: String]? = nil, shouldResetApplication: Bool = false) The attributes from the example above are:\n Route: represents the registered route for a native screen. ShouldResetAplication: indicates the stack view restart of the application. Data: passes the information between screens.  PushStack It is responsible for preseting a new ViewController with a default animation system, that can change the defaultAnimation variable provided in the BeagleNavigation protocol above.\nOn this case, this action presents aViewController to a stack with a present operation.  PopStack This action dismisses the presented ViewController .\nPushView Opens a new screen in the same stack using a route.\nThis ViewController is added with apushViewController operation.  popView It closes the current screen and remove it from the stack.\nThis ViewController is removed from the stack with a √© retirada da stack popViewController operation.  PopToView Returns a specific ViewController stack.\nThis operation returns to a specificViewControllerusing a popToViewController operation.  ResetApplication Opens a informed route of a new flow and erases the views stacks of the whole application.\nResetStack Open a screen with an informed route of a new flow and cleans the loaded screen stacks.\nTransition Animation On BeagleNavigation Protocol we provide a defaultAnimation variable that determines how the view is animated onscreen when it is presented.\nWe allow you to change transitions for pushing and popping view controllers with pushTransition and popTransition variables and you can also change your modalPresentationStyle and modalTransitionStyle.\npublic struct BeagleNavigatorAnimation { var pushTransition: Transition? var popTransition: Transition? var modalPresentationStyle: UIModalPresentationStyle? var modalTransitionStyle: UIModalTransitionStyle } In the structure below, we provide you the types of CATransition , where you can transition between a layer‚Äôs states by creating and adding a CATransition object to it.\npublic struct Transition { var type: CATransitionType var subtype: CATransitionSubtype? var duration: Double } In the example below, we changed the apps default push transition and modalPresentationStyle.\nlet animation = BeagleNavigatorAnimation( pushTransition: .init( type: .fade, subtype: .fromRight, duration: 1.0), modalPresentationStyle: .formSheet) let dependencies = BeagleDependencies() dependencies.navigation.defaultAnimation = animation  This configuration is applied to all of the navigations in your application.  ","excerpt":" Added in Beagle 1.0.0 Protocol public protocol BeagleNavigation { var ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/navigation/","title":"Navigation"},{"body":" Added in Beagle 1.0.0 Introduction Beagle makes all the web request from the networkClient dependency that it is in the BeagleDependencies, and its type is NetworkClient, because of that it is possible to replace a default implementation used in the framework to another.\nYou need to make the replacement in the following cases:\n It is necessary to unify the networking layer in the module system; Modify some properties for example, like request headers, request methods, body response, data response, run cryptography, etc.  public protocol NetworkClient { typealias Error = NetworkError typealias NetworkResult = Result\u003cNetworkResponse, NetworkError\u003e typealias RequestCompletion = (NetworkResult) -\u003e Void @discardableResult func executeRequest( _ request: Request, completion: @escaping RequestCompletion ) -\u003e RequestToken? }  The default implementation of the NetworkClient protocol used on Beagle has the Foundation resources to make the URLSession requests  Customization To customize your NetworkClient protocol, see the sections below:\nAdding header fields To add header fields on the requests created by the NetworkClient default, follow the steps:\n No AppDelegate ou na classe de configura√ß√µes do ambiente do beagle instancie o NetworkClientDefault passando as depend√™ncias rec√©m criadas no inicializador; Adicione os headers desejados no atributo additionalHeaders presente no objeto HttpRequestBuilder. Ele √© uma depend√™ncia do NetworkClientDefault respons√°vel por criar as URLRequest que s√£o passadas para a dataTask do URLSession; Atribuia o NetworkClient instanciado e modificado como o networkClient das depend√™ncias:  let dependencies = BeagleDependencies() let client = NetworkClientDefault(dependencies: dependencies) client.httpRequestBuilder.additionalHeaders = [ \"X-Frame-Options\": \"deny\", \"client-Identification\":\"123123123\" ] dependencies.networkClient = client Beagle.dependencies = dependencies Modifying URL base To modify the URL base used on Beagle, follow the steps:\n On AppDelegate or in a Beagle‚Äôs environment configuration class, instantiate an object with the URLBuilder type and pass the URL base in the initiator; Assign the created object to the urlBuilder attribute that it is on BeagleDependencies:  let dependencies = BeagleDependencies() let urlBuilder = UrlBuilder(baseUrl: URL(string: Constants.Server.baseURL)) dependencies.urlBuilder = urlBuilder Beagle.dependencies = dependencies Replacing the Networking layer To replace the class responsible for making Http request to Beagle, follow the next steps:\nStep 1: implement NetworkClient Implement the NetworkClient protocol in the class you want to use to make requests, in this case, the CustomNetworkClient will be used, like the example below:\nclass CustomNetworkClient: NetworkClient { func executeRequest( _ request: Request, completion: @escaping RequestCompletion ) -\u003e RequestToken? { let url: URL = request.url let requestType = request.type let headers = request.additionalData //Implementacao de Requisicoes } //Implementacao Network Client... } This protocol run the requests from the executeRequest function, it receives two parameters:\n request: request type value that contains the data necessary to make a request:  URL Headers RequestType   completion: block that must be called in the end of the function execution, passing the request result.  Besides that, the function can return the RequestToken, in order to make the request be able to be canceled internally by Beagle.\nStep 2: assign the dependencies OnAppDelegate or on Beagle‚Äôs environment, assing the instance CustomNetworkClient to the networkClient attribute that it is on Beagle Dependencies:\nlet dependencies = BeagleDependencies() let client = CustomNetworkClient() dependencies.networkClient = client Beagle.dependencies = dependencies Done! Now, Beagle will use your class with all the changes and definition needed to make the http requests.\n","excerpt":" Added in Beagle 1.0.0 Introduction Beagle makes all the web request ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/networkclient/","title":"Networkclient"},{"body":" Introdu√ß√£o O Beagle usa o sistema de log unificado recomendado pela Apple para fornecer mensagens de logs diferentes em est√°gios cr√≠ticos de um fluxo Server Driven.\nAs mensagens de log fornecidas pelo Beagle iOS podem ser acessadas pelo:\n Console do Xcode Console da Aplica√ß√£o  Elas s√£o divididas em 4 categorias:\n Network: relacionada √† camada Rede, informa√ß√µes e mensagens de erro para cada solicita√ß√£o, resposta e constru√ß√£o de URL da rede. Decoding: exibe mensagens toda vez que ocorre um erro de parse. Navigation: mensagens informativas que descrevem todas as navega√ß√µes dentro de um fluxo Server Driven e poss√≠veis erros que podem ocorrer. Form: relacionado a formul√°rios.  √â poss√≠vel desabilitar as mensagens de log disparadas, dessa forma o Beagle n√£o ir√° mais chamar a API de Log, seja ela a padr√£o ou customizada. Voc√™ precisa passar o atributo isLoggingEnabled do BeagleDependencies para false.\nAs mensagens de log podem ser filtradas usando esses nomes como categorias e o identificador do pacote principal do aplicativo como subsistema.\nFiltrando mensagens de log: Siga os passos abaixo para filtrar mensagens de log:\nPasso 1: abra o Console App;\nPasso 2: selecione o device no menu Devices;\nPasso 3: insira os filtros na barra de busca, procure somente as mensagens de log com a categoria Networkno subsistema br.com.zup.BeagleDemoApp\nPasso 4: ao abrir a aplica√ß√£o BeagleDemo vemos duas mensagens de log com a categoria network, uma mostrando que o Beagle fez uma requisi√ß√£o e outra indicando a resposta dessa requisi√ß√£o:\nPasso 5: mensagens de erro ser√£o exibidas com um ponto amarelo no campo Type, como mostrado abaixo:\nPasso 6: ao selecionar a segunda mensagem de log recebida com filtro Networkvoc√™ ver√° a vers√£o verbosa dessa resposta:\nPasso 7: o corpo da resposta cont√©m a tela Server Driven e todos os seus atributos e especifica√ß√µes podem ser acessados.\nCustomiza√ß√£o Para deixar o ambiente do Beagle aberto a modifica√ß√µes, a API de Logs padr√£o pode ser substitu√≠da por qualquer outra. Siga os passos abaixo fazer a substitui√ß√£o a API de logs:\nPasso 1: implemente o protocolo BeagleLoggerType na classe que deseja utilizar como API de logs, voc√™ ir√° observar que √© preciso implementar os m√©todos log(_ log: LogType) e logDecodingError(type: String) que s√£o chamados internamente pelo Beagle sempre que uma mensagem precisa ser disparada:\nclass CustomLogger: BeagleLoggerType { func log(_ log: LogType) { print(log.message) } func logDecodingError(type: String) { print(type) } } Passo 2: nas configura√ß√µes do Beagle de seu projeto atribua uma inst√¢ncia da classe √† depend√™ncia logger no BeagleDependencies:\nlet dependencies = BeagleDependencies() dependencies.logger = CustomLogger() Beagle.dependencies = dependencies ","excerpt":" Introdu√ß√£o O Beagle usa o sistema de log unificado recomendado pela ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/sistema-de-log/","title":"Sistema de Log"},{"body":" Added in Beagle 1.0.0 What is Screen View Controller? It is a class that manages the display hierarchy in the application and it works like a UIViewController.\nHow to implement this class? You have to create an object BeagleScreenViewController with a set of attributes and parameters.\nThis process can be done following the next steps:\n Create an object BeagleScreenViewModel with screenType remote that have to send a URL, a optional fallback or a declarative that changes the screen to a declarative mode.  You can find the commands below:\npublic class BeagleScreenViewModel { public enum ScreenType { case remote(String, fallback: Beagle.Screen?) case declarative(BeagleUI.Screen) } public init(screenType: BeagleUI.BeagleScreenViewModel.ScreenType, delegate: BeagleUI.BeagleScreenDelegate? = nil) } let viewController = BeagleScreenViewController( viewModel: viewModel) There are other boot examples using declarative and remote:\n//1  let viewModel = BeagleScreenViewModel(screenType: .declarative(content: Home().screen)) //2 let viewModel = BeagleScreenViewModel(screenType: .remote(\"/cash-withdrawal/home\"), fallback: nil)) //3 let viewModel = BeagleScreenViewModel( screenType:.remote( \"http://localhost:8090/cash-withdrawal/home\"), fallback: Home().screen)) You can instantiate BeagleScreenViewModel with a declarative type, screenType changing your created screen to the declarative mode.\nIn this example, BeagleScreenViewModeli was instantiated with a remote type screenType where there‚Äôs a relative URL and a null fallback. To use this URL you must put a base URL in the BeagleDependencies of your projects.\nThe second BeagleScreenViewModel was instantiated with a remote type screenType where there‚Äôs an absolute URL and a screen with a declarative fallback.\nScreen states To follow the screen states, there is the enum state:\npublic enum State { //1 case loading //2 case success //3 case failure(BeagleUI.Request.Error) //4 case rendered }  Loading state happens when a request was not received or the screen was not rendered, when the information are received the state changes to success, if not it changes to failure. Success state happens right after the request verification is finished and the screen rendered. Failure happens when something is wrong in the request or screen render, BeagleUI.Request.Error informs what was the error. Rendered is used right after the success, when the screen is rendered.  When everything runs BeagleScreenViewModel with declarative screenType, the state goes straight to success, skipping loading.\nBeagleScreenViewModel has a variable delegate, it is related to BeagleScreenDelegate. When this protocol is extended, in case of any request error to implement remote screenType, it will fall into the error function of this protocol, where the user may complement the function with the error.\npublic protocol BeagleScreenDelegate : AnyObject { typealias ViewModel = Beagle.BeagleScreenViewModel func beagleScreen(viewModel: Self.ViewModel, didFailToLoadWithError error: Beagle.Request.Error) } Example to implement the BeagleScreenDelegate protocol: //1 let viewModel = BeagleScreenViewModel(screenType: .remote(\"/cash-withdrawal/home\"), fallback: nil)) viewModel.delegate = self //2 extension ViewController: BeagleScreenDelegate { func beagleScreen(viewModel: ViewController.ViewModel, didFailToLoadWithError error: Beagle.Request.Error) { print(\"didFailToLoadWithError: \\(error)\") } }  Reuse the instantiate BeagleScreenViewModel example, you can add the viewModel.delegate = self. When implementing the BeagleScreenViewModel protocol you may complete this function, it will show the error.  BeagleScreenViewController works with components customization in the view:\nextension BeagleScreenViewController: Beagle.BeagleContext { //1  public func register(action: Beagle.Action, inView view: UIView) //2 public func register(form: BeagleSchema.Form, formView: UIView, submitView: UIView, validatorHandler: Beagle.ValidatorProvider?) //3 public func lazyLoad(url: String, initialState: UIView) //4 public func doAction(_ action: Beagle.Action, sender: Any) } ","excerpt":" Added in Beagle 1.0.0 What is Screen View Controller? It is a class ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/screen-view-controller/","title":"Screen View Controller"},{"body":" Introdu√ß√£o O Beagle j√° possui alguns widgets b√°sicos que podem ser usados para alterar a sua aplica√ß√£o UI atrav√©s do backend. No entanto, voc√™ pode adicionar novos componentes para fazer as views da sua aplica√ß√£o fiquem ‚Äúvis√≠veis‚Äù ao Beagle e que possam tamb√©m ser usadas no backend.\nComo criar componentes (custom views) e widgets? Passo 1: Criar o Widget Segue abaixo um exemplo de um componente customizado que representa um UILabel:\nstruct MyCustomComponent: ServerDrivenComponent { let text: String func toView(renderer: BeagleRenderer) -\u003e UIView { let label = UILabel(frame: .zero) label.text = text label.numberOfLines = 0 return label } } Podemos ver que o MyCustomComponent √© do tipo ServerDrivenComponent, que √© um protocolo que conforma com Decodable e √© respons√°vel por decodificar as propriedades que seu widget exp√µem ao backend.\nPasso 2: Registrar o Widget √â obrigat√≥rio registr√°-lo no Beagle. Dentro do arquivo de configura√ß√£o utilize o m√©todo registerCustomComponent(). O primeiro par√¢metro √© uma string que referencia como o seu BFF ir√° chama-lo e o segundo par√¢metro √© a classe criada do componente.\nBeagle.registerCustomComponent( \"MyCustomComponent\", componentType: MyCustomComponent.self ) Ap√≥s registrar o seu componente de customiza√ß√£o, voc√™ pode us√°-lo via server-driven.\nPasso 3: Exibir o Componente Voc√™ pode usar o seu componente declarativamente assim como pass√°-lo por uma inst√¢ncia at√© o BeagleScreenViewController ou cham√°-lo via m√©todo toView() para apresentar oUIView que aparece dentro do seu pr√≥prio view controller.\nlet beagleScreenViewController = Beagle.screen( .declarative( .init(child: MyCustomComponent(text: \"Hello Beagle!\") ) ) ) Se voc√™ usar componentes mais complexos que estejam no UIViews ou outros componentes n√£o mencionados, o processo seria parecido, voc√™ apenas precisa providenciar um tipo de ServerDrivenComponent ou Widget.\n","excerpt":" Introdu√ß√£o O Beagle j√° possui alguns widgets b√°sicos que podem ser ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/widgets-customizados/","title":"Widgets customizados"},{"body":" What is Sourcery? Sourcery is a code generator that helps boilerplate code creation.\nIt is recommended, however the installation of this library is optional. If you want to install, follow the instructions below.\nInstallation After you have integrated Beagle, now you can intall Sourcery in your computer using Homebrew.\n$ brew install sourcery Configuration It is necessary to configure the path files template, the generated files and the path where Sourcery will scan the font code. Follow the next steps:\nStep 1: in Build Phases, create a new Run Script Phase;\nStep 2: put ABOVE Compile Sources; If you don‚Äôt do this, sourcery won‚Äôt be able to compile the generated code.\nStep 3: paste the following code:\nif which sourcery \u003e/dev/null; then unset SDKROOT sourcery --config $SRCROOT else echo \"warning: Sourcery not installed, download using brew install sourcery\" fi This script warns Xcode to look for a .sourcery.yml file in your project root. It will have some properties that Sourcery will have to know to generate the code.\nThe list below shows the attributes used in this file:\n sources : path for your swift files. It is the root of the project. templates : path for your template files that Sourcery will use to generate the code. output : o path for generates files.  For more information and details about Sourcery, check their documentation.  .yml file configuration The .yml file configuration are different due to the way Cocoapods and Carthage deals with the Beagle‚Äôs files.\nFor the Sourcery to use the Beagle‚Äôs templates, you must specify the SourceryProtocols.swif in sources and the template path in templates.\nThe attributes written inside the.yml consider that Cartfile or Podfile file are in the same directory that .xcodeproj or .xcworkspace  Cocoapods Carthage sources:include:- RootOfYourProject- Pods/BeagleUI/iOS/Sources/BeagleUI/CodeGeneration/SourceryProtocols.swifttemplates:- Pods/BeagleUI/iOS/Sources/BeagleUI/CodeGeneration/Templatesoutput:RootOfYourProject/CodeGeneration/Generated sources:include:- RootOfYourProject- Carthage/Checkouts/beagle/iOS/Sources/BeagleUI/CodeGeneration/SourceryProtocols.swifttemplates:- Carthage/Checkouts/beagle/iOS/Sources/BeagleUI/CodeGeneration/Templatesoutput:RootOfYourProject/CodeGeneration/Generated Use By default, custom widgets need to implementinit(from decoder: Decoder) throws. This can be automated with Sourcery, like the example below:\nimport UIKit import BeagleUI enum ComponentColorTypes: String, Decodable { case veryColorful case blackAndWhite } struct SomeComponent: Widget { var widgetProperties: WidgetProperties var property1: String var property2: Double? var colorPallete: ComponentColorTypes = .blackAndWhite func toView(context: BeagleContext, dependencies: RenderableDependencies) -\u003e UIView { return UIView() } } Without the metaprogramming, it is necessary to write the following code:\nextension SomeComponent { enum CodingKeys: String, CodingKey { case property1 case property2 case colorPallete } internal init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) widgetProperties = try WidgetProperties(from: decoder) property1 = try container.decode(String.self, forKey: .property1) property2 = try container.decodeIfPresent(Double.self, forKey: .property2) colorPallete = try container.decode(ComponentColorTypes.self, forKey: .colorPallete) } } It is necessary with Sourcery, to do the structs in accordance with AutoDecodable and the same code will be generated\nThis same process works for all protocols and it is also possible to create templates and customized protocols.\nAfter the file generation AutoDecodable.generated.swift and Equality.generated.swift using Sourcery, it is necessary to insert them in the project.  Available protocols Some protocols are already on Beagle. They are located in SourceryProtocols.swift. See the list below:\n   Protocol Use     AutoEquatable Implements equatable   AutoDecodable Implements customized decodable, according to the Beagle‚Äôs pattern. It only works for structs   AutoInitiable Implements customized init, according to the Beagle‚Äôs pattern   AutoInitiableAndDecodable Protocols combination AutoInitiable and AutoDecodable    ","excerpt":" What is Sourcery? Sourcery is a code generator that helps boilerplate ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/sourcery/","title":"Sourcery"},{"body":" O que √© o Sourcery? O Sourcery √© uma ferramenta de gera√ß√£o de c√≥digo que auxilia na cria√ß√£o de c√≥digo boilerplate, ou seja, aqueles trechos de c√≥digo inclu√≠dos em mais locais com pouca ou sem altera√ß√£o.\nA instala√ß√£o dessa biblioteca √© opcional, apesar de recomendada. Caso queira instalar, siga as instru√ß√µes abaixo.\nInstala√ß√£o Depois de integrar o Beagle ao seu projeto, voc√™ pode instalar o Sourcery no seu computador usando o Homebrew.\n$ brew install sourcery Configura√ß√£o Depois da instala√ß√£o, √© necess√°rio configurar o path dos arquivos de template, dos arquivos gerados e o path onde o Sourcery ir√° escanear o c√≥digo fonte. Siga os passos a seguir:\nPasso 1: Em Build Phases, crie um novo Run Script Phase;\nPasso 2: Coloque ACIMA de Compile Sources; Isso √© importante pois, caso n√£o seja feito, o sourcery n√£o ir√° compilar os arquivos que foram gerados.\nPasso 3: Cole o c√≥digo a seguir:\nif which sourcery \u003e/dev/null; then unset SDKROOT sourcery --config $SRCROOT else echo \"warning: Sourcery not installed, download using brew install sourcery\" fi Esse script avisa o Xcode para procurar por um arquivo .sourcery.yml na raiz do seu projeto. Ele ter√° algumas propriedades que o Sourcery precisa saber para gerar o c√≥digo.\nA lista abaixo, mostra os atributos utilizados neste arquivo:\n sources : o path de seus arquivos swift. √â a raiz do projeto. templates : o path dos arquivos de template que o Sourcery vai usar para gerar o c√≥digo. output : o path dos arquivos gerados.  Para mais informa√ß√µes e detalhes sobre o Sourcery, acesse a documenta√ß√£o oficial.  Configura√ß√£o do arquivo .yml As configura√ß√µes do arquivo .yml s√£o diferentes devido a forma que Cocoapods e o Carthage lidam com os arquivos do Beagle.\nPara que o Sourcery use os templates do Beagle, voc√™ deve especificar o SourceryProtocols.swif em sources e o path de templates em templates.\nOs atributos escritos dentro do.yml consideram que os arquivos Cartfile ou Podfile est√£o no mesmo diret√≥rio que o .xcodeproj ou .xcworkspace  Cocoa Pods Carthage sources:include:- RootOfYourProject- Pods/Beagle/iOS/Sources/Beagle/CodeGeneration/SourceryProtocols.swifttemplates:- Pods/Beagle/iOS/Sources/Beagle/CodeGeneration/Templatesoutput:RootOfYourProject/CodeGeneration/Generated sources:include:- RootOfYourProject- Carthage/Checkouts/beagle/iOS/Sources/Beagle/CodeGeneration/SourceryProtocols.swifttemplates:- Carthage/Checkouts/beagle/iOS/Sources/Beagle/CodeGeneration/Templatesoutput:RootOfYourProject/CodeGeneration/Generated Utiliza√ß√£o Por default, os Custom Widgets precisam implementar init(from decoder: Decoder) throws. Isso pode ser automatizado com o Sourcery, como no exemplo abaixo:\nimport UIKit import BeagleUI enum ComponentColorTypes: String, Decodable { case veryColorful case blackAndWhite } struct SomeComponent: Widget { var widgetProperties: WidgetProperties var property1: String var property2: Double? var colorPallete: ComponentColorTypes = .blackAndWhite func toView(context: BeagleContext, dependencies: RenderableDependencies) -\u003e UIView { return UIView() } } Sem o uso de metaprograma√ß√£o, √© necess√°rio escrever o seguinte trecho de c√≥digo:\nextension SomeComponent { enum CodingKeys: String, CodingKey { case property1 case property2 case colorPallete } internal init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) widgetProperties = try WidgetProperties(from: decoder) property1 = try container.decode(String.self, forKey: .property1) property2 = try container.decodeIfPresent(Double.self, forKey: .property2) colorPallete = try container.decode(ComponentColorTypes.self, forKey: .colorPallete) } } Com o Sourcery √© necess√°rio fazer as structs conformarem com AutoDecodable e o mesmo c√≥digo ser√° gerado.\nEsse mesmo processo funciona para todos os protocolos e tamb√©m √© poss√≠vel criar templates e protocolos customizados.\nAp√≥s a gera√ß√£o dos arquivos AutoDecodable.generated.swift e Equality.generated.swift usando o Sourcery, √© necess√°rio inseri-los no projeto.  Protocolos dispon√≠veis Alguns protocolos (protocols) j√° est√£o no Beagle. Eles est√£o localizados em SourceryProtocols.swift. Veja a lista:\n   Protocolo Uso     AutoEquatable Implementa equatable   AutoDecodable Implementa decodable customiz√°vel, de acordo com os padr√µes do Beagle. Funciona apenas para structs   AutoInitiable Implementa init customiz√°vel, de acordo com os padr√µes do Beagle   AutoInitiableAndDecodable Combina√ß√£o dos protocolos AutoInitiable and AutoDecodable    ","excerpt":" O que √© o Sourcery? O Sourcery √© uma ferramenta de gera√ß√£o de c√≥digo ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/sourcery/","title":"Sourcery"},{"body":" You will find here the main class that are part of Beagle‚Äôs framework for Web.\n","excerpt":" You will find here the main class that are part of Beagle‚Äôs framework ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/","title":"Beagle for Web"},{"body":" O Beagle possui essas principais classes para Web: \n","excerpt":" O Beagle possui essas principais classes para Web: \n","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/","title":"Beagle para Web"},{"body":" ","excerpt":" ","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/","title":"Advanced topics"},{"body":" √â poss√≠vel criar a√ß√µes customizadas para o seus components com o Beagle.\nCriar um ActionHandler Passo 1: Crie um interface com a propriedade obrigat√≥ria _beagleAction_ e outra com os outros valores necess√°rios, como no exemplo abaixo onde dois par√¢metros foram criados: A e B.\nO nome da a√ß√£o customizada _beagleAction_\ninterface CustomAction { _beagleAction_: 'custom:myCustomAction', parameterA: string, parameterB: number } Passo 2: Crie a fun√ß√£o ActionHandler com a seguinte interface:\nimport { ActionHandler } from '@zup-it/beagle-web' export const customAction: ActionHandler\u003cCustomAction\u003e = ({ action }) =\u003e { }  Na fun√ß√£o ActionHandler, voc√™ pode acessar os valores definidos como no exemplo acima:action.parameterA e action.parameterB.  Passo 3: Adicione o nome da a√ß√£o no arquivo de associa√ß√£o do seu framework.\nAngular React Para Angular: adicione beagle.module.ts\n@BeagleModule({ ... customActions:{ \"custom:myCustomAction\": customAction //nome do action handler  } }) export class Beagle {}  Para React: adicione ao seu arquivo de configura√ß√£o do Beagle\nexport default createBeagleUIService\u003cany\u003e({ ... customActions:{ \"custom:myCustomAction\": customAction //nome do action handler  } })  Adicione a√ß√µes ao JSON Adicione a a√ß√£o customizada ao JSON e adicione os par√¢metros definidos na inteface do ActionHandler.\nVeja abaixo um exemplo com button:\n{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"Clique para a√ß√£o customizada\", \"onPress\": { \"_beagleAction_\": \"custom:myCustomAction\", \"parameterA\": \"Beagle Web\", \"parameterB\": 10 } }  Fique atento aos tipos de classe, quando voc√™ adicionar um par√¢metro a a√ß√£o cusomizada, o exemplo acima era uma string enumber.  ","excerpt":" √â poss√≠vel criar a√ß√µes customizadas para o seus components com o ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/a%C3%A7%C3%B5es-customizadas/","title":"A√ß√µes customizadas"},{"body":" Loading Component A biblioteca do Beagle j√° possui por padr√£o um componente que √© chamado quando ocorre o carregamento de uma tela. Se necess√°rio, √© poss√≠vel troc√°-lo por um customizado de acordo com a necessidade da sua aplica√ß√£o.\nPara criar um componente loading, siga os passos abaixo:\nReact Angular No React:\nPasso 1: Crie um componente que ser√° o substituto.\nVeja o exemplo:\nimport React, { FC } from 'react' const CustomLoadingComponent: FC\u003cany\u003e = () =\u003e { return ( \u003cdiv\u003eCarregando\u003c/div\u003e ) } export default CustomLoadingComponent Passo 2: Adicione-o √† lista de componentes do Beagle Service para substituir o componente padr√£o:\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomLoadingComponent from '../components/CustomLoading' export default createBeagleUIService\u003cany\u003e({ baseUrl: \"localhost:4000\", components: { \"custom:loading\":CustomLoadingComponent } })  No Angular\nPasso 1: Crie um componente que ser√° o substituto.\nVoc√™ pode usar o angular cli se preferir com o comando para gerar automaticamente o componente, veja:\nng generate component components/custom-loading Passo 2: Depois, abra o arquivo beagle-components.module.ts e adicione o componente a lista:\nimport { NgModule } from '@angular/core' import { CustomLoadingComponent } from './components/custom-loading/custom-loading.component'; // import all the components you're going to use with beagle const components = [ CustomLoadingComponent ]; @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} Passo 3: Finalmente voc√™ pode substituir o componente padr√£o no arquivo beagle.module.ts\nimport { BeagleModule } from '@zup-it/beagle-angular'; import { CustomLoadingComponent } from './components/custom-loading/custom-loading.component'; // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://mypath', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { 'custom:loading': CustomLoadingComponent } }) export class Beagle { } Os arquivos beagle.module.ts e beagle-components.module.ts s√£o gerados automaticamente pela biblioteca no angular. Se voc√™ n√£o encontrou verifique sua instala√ß√£o\n  Error Component O componente de erro padr√£o do Beagle √© chamado quando ocorrem erros de conex√£o como, por exemplo, um caminho para o servidor est√° inacess√≠vel.\nPara este componente a biblioteca exp√µe uma interface chamada ErrorComponentParams, por meio dela voc√™ tem acesso a lista de erros e a um m√©todo retry, respons√°vel por refazer a requisi√ß√£o para o servidor.\nErrorComponentParams    Atributo Tipo Defini√ß√£o     retry M√©todo Refaz a requisi√ß√£o para o servidor    Usando essa interface voc√™ pode criar o componente, veja o exemplo de acordo com cada framework:\nReact Angular No React, √© preciso criar um Functional Component que usa a interface ErrorComponentParams, note que ao us√°-la voc√™ tem acesso √† duas props errors e retry, que s√£o respectivamente a lista de erros e o m√©todo retry ambos descritos na interface:\nimport { ErrorComponentParams } from '@zup-it/beagle-react' import React, { FC } from 'react' const CustomErrorComponent: FC\u003cErrorComponentParams\u003e = ({ retry }) =\u003e { return ( \u003c\u003e \u003cp\u003e Unexpected Error! \u003c/p\u003e \u003cbutton onClick={retry}\u003eRetry\u003c/button\u003e \u003c/\u003e ) } export default CustomErrorComponent Depois de criado basta adicion√°-lo a lista de componentes do Beagle Service:\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomErrorComponent from '../components/CustomError' export default createBeagleUIService\u003cany\u003e({ baseUrl: \"localhost:4000\", components: { \"custom:error\":CustomErrorComponent } })  No Angular, crie primeiro um componente, se voc√™ preferir pode usar o angular cli para gerar automaticamente a estrutura inicial:\nng g component components/custom-error Abra o arquivo controller do componente que acabou de ser criado e adicione a interface ErrorComponentParams. A interface nos da acesso a dois @Inputs errors e retry que s√£o respectivamente a lista de erros e o m√©todo para refazer a requisi√ß√£o:\nimport { Component, Input } from '@angular/core'; import { ErrorComponentParams } from '@zup-it/beagle-angular'; @Component({ selector: 'app-custom-error', templateUrl: './custom-error.component.html', styleUrls: ['./custom-error.component.less'] }) export class CustomErrorComponent implements ErrorComponentParams { @Input() retry: () =\u003e void; handleRetry() { this.retry(); } } Agora, adicione o componente criado a lista do arquivo beagle-components.module.ts\nimport { NgModule } from '@angular/core'; import { CustomErrorComponent } from './components/custom-error/custom-error.component'; // import all the components you're going to use with beagle const components = [ CustomErrorComponent ]; @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} Finalmente, substitua o componente padr√£o no arquivo beagle.module.ts\nimport { CustomErrorComponent } from './components/custom-error/custom-error.component'; // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4202/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { 'custom:error': CustomErrorComponent } }) export class Beagle { } Os arquivos beagle.module.ts e beagle-components.module.ts s√£o gerados automaticamente pela biblioteca no angular. Se voc√™ n√£o os encontrou verifique sua instala√ß√£o\n  ","excerpt":" Loading Component A biblioteca do Beagle j√° possui por padr√£o um ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/carregamento-e-tratamento-de-erros/","title":"Carregamento e tratamento de erros"},{"body":" How does Beagle represent a view? The features described here are only available in versions 1.2.0 and above.  Beagle works over a tree of components and in order to work, it must follow some rules. In Typescript terms, Beagle Tree can be defined as follows:\nexport interface BeagleUIElement { _beagleComponent_: string, id: string, context?: DataContext, children?: BeagleUIElement[], style?: Style, [key: string]: any, } See below every tree‚Äôs componenent:\n _beagleComponent_ is the name of the UI component to render. id is a unique identifier for the node. Observation: although the id is required by the internal tree structure, before processing the tree, Beagle assigns random unique ids for each node without an id, making it optional in the json provided by the backend. context is a context defined for the component and its children. children is an array of nodes representing the children of the current node. style is the stylization rules for the component. These rules are not CSS, instead it‚Äôs a structure defined by Beagle; Additionally, a node has every property expected by the component itself, a text component could have text and justify, while a button could have onPress, text and disabled.  Below, we show an example of a tree of components ready to be processed by Beagle:\n{ \"_beagleComponent_\": \"container\", \"id\": \"container\", \"children\": [ { \"_beagleComponent_\": \"image\", \"id\": \"logo\", \"url\": \"https://i.ibb.co/rvRN9kv/logo.png\" }, { \"_beagleComponent_\": \"text\", \"id\": \"welcome\", \"text\": \"Welcome to the Beagle playground!\" }, { \"_beagleComponent_\": \"text\", \"id\": \"instructions\", \"text\": \"Use the panel on the left to start coding!\" }, { \"_beagleComponent_\": \"button\", \"id\": \"fast-guide\", \"text\": \"Access the fast guide\" } ] } The json above is a simpler version of the welcome page of the Beagle Playground website. It renders a container to hold the rest of the elements: an image, two texts and a button. To see the full example and the UI rendered by it, access the Beagle Playground.\nThe Beagle Payload The type defined in the last section (BeagleUIElement), you can see the id is a required property and that the children of a node must always be named children. The backend, however, may not guarantee any of that. For this reason, Beagle internally generates unique ids for every node without one and translates the children property. A table component, for instance, might have its children in the property rows. Before starting to process, Beagle converts rows to the expected name children (see section The children property).\nIn fact, the payload returned by the backend can be anything, but internally Beagle must work with a tree of components (BeagleUIElement). You must be able to traverse the tree and detect every component and its children. The payload can be anything, because it gives the developer a chance to change it before it gets processed by Beagle.\nWe recommend that the backend always return a JSON representing a tree of components, as it is expected by Beagle, but if, for some reason, it is not possible, Beagle Web makes it possible to pre-process the response and build the tree in the front-end before Beagle actually works upon it, like in lifecycles.\nThe children property You should always use an array named children to specify the child nodes of a component. But, Beagle will work out of the box, if instead of an array of components, a single node is passed, and will also work if the name child is used.\nIf a component that represents a table, the children might be named rows instead of children, in this case, you can inform Beagle that, for this specific component, the name of the property children is different. See the example below:\n@BeagleChildren({ property: 'rows' }) @Component({ // ... }) class Table { // ... } The example above is for Angular, but it would work the same way in other platforms. If your component is functional or if you don‚Äôt want to use decorators (annotations), you can use it as a function, see the example below:\nconst Table = (props) =\u003e { // ... } BeagleChildren({ property: 'rows' })(Table) ","excerpt":" How does Beagle represent a view? The features described here are ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/data-structure/","title":"Data structure"},{"body":" Criar um componente customizado O primeiro passo que voc√™ deve fazer √© criar um componente comum. Para isso, crie um novo componente em seu projeto.\nAngular React Neste exemplo, o componente ser√° criado com o nome customText. Basta utilizar o comando abaixo no seu terminal:\nng generate component components/customText --skip-import  Neste exemplo, ser√° criado um componente chamado CustomTextComponent para renderizar um texto. Basta criar um novo arquivo chamado CustomTextComponent.tsx dentro da pasta components (se esta pasta n√£o existir basta cri√°-la dentro da pasta src).\nNo arquivo criado coloque o seguinte c√≥digo:\nimport React from 'react' function CustomTextComponent() { return ( \u003cp\u003eBeagle Web React\u003c/p\u003e ) } export default CustomTextComponent;  Feito isso, adicione no arquivo de associa√ß√µes da biblioteca Beagle do seu projeto como indicado nos exemplos a seguir.\nAngular React Abra o arquivo beagle-components.module.ts e adicione o novo CustomTextComponent gerado na lista, como no exemplo abaixo:\n... import { CustomTextComponent } from './components/custom-text/custom-text.component' // import all the components you're going to use with beagle const components = [ CustomTextComponent ] @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} No arquivo beagle.module.ts adicione seu novo componente na lista de associa√ß√µes\nimport { BeagleModule } from '@zup-it/beagle-angular' import { CustomTextComponent } from './components/custom-text/custom-text.component' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. \"custom:text\": CustomTextComponent }, }) export class Beagle {} Se voc√™ n√£o encontrou os arquivos beagle-components.module.ts ou beagle.module.ts, veja como configurar a biblioteca Beagle Web para o Angular.\n  Abra o arquivo de configura√ß√£o da biblioteca Beagle em seu projeto (se voc√™ seguiu o tutorial √© o arquivo beagle-service.ts) e adicione o seu componente a lista de associa√ß√µes.\nCaso voc√™ n√£o tenha este arquivo em seu projeto, veja como configurar a biblioteca Beagle Web para o React.\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomTextComponent from '../components/CustomTextComponent' export default createBeagleUIService\u003cany\u003e({ baseUrl: '', components: { 'custom:text': CustomTextComponent } })  Observe que, no passo acima, a palavra custom foi adicionada para identificar os componentes. Isto far√° com que a biblioteca Beagle entenda que este componente n√£o faz parte da lista de componentes pr√©-definidos.\nAdicionando propriedades ao componente Para adicionar propriedades ao componente criado, siga os seguintes passos:\nAngular React Abra o arquivo custom-text.component.ts e adicione um @Input, como no c√≥digo abaixo:\nimport { Component, OnInit, Input } from '@angular/core'; @Component({ selector: 'app-custom-text', templateUrl: './custom-text.component.html', styleUrls: ['./custom-text.component.less'] }) export class CustomTextComponent implements OnInit { @Input() myCustomText: string constructor() { } ngOnInit(): void { } } Feito isso, adicione a refer√™ncia ao arquivo custom-text.component.html\n\u003cdiv\u003e \u003ch1\u003e{{myCustomText}}\u003c/h1\u003e \u003c/div\u003e Se voc√™ estiver com o projeto rodando, √© necess√°rio reinici√°-lo com um dos comandos:yarn serve ou npm run serve\n  No React, todos os atributos definidos no JSON podem ser acessados atrav√©s de props, veja o exemplo\nimport React from 'react' interface CustomText { myCustomText: string } function CustomTextComponent(props: CustomText) { return ( \u003cp\u003e{props.myCustomText}\u003c/p\u003e ) } export default CustomTextComponent;  Criando o JSON Podemos agora adicionar o nosso componente ao arquivo JSON. Se voc√™ seguiu o tutorial, abra o arquivo payload.json e o substitua com o conte√∫do abaixo, caso contr√°rio, apenas substitua a fonte de onde o seu JSON foi guardado ou gerado.\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"custom:text\", \"myCustomText\": \"Beagle Web is Awesome\" } ] }  Parab√©ns, voc√™ criou seu primeiro componente customizado no Beagle!\nLembrando que este componente recebe propriedades e √© renderizado pela biblioteca Beagle.\n ","excerpt":" Criar um componente customizado O primeiro passo que voc√™ deve fazer ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/componentes-customizados/","title":"Componentes customizados"},{"body":" Accessing and controlling the BeagleView The features described here are only available in versions 1.2.0 and above.  The Beagle View is the entity responsible to manage a server-driven view. It can be created through the Beagle Service via the function createBeagleView. The BeagleView can fetch a new view, update its tree, navigate, etc.\nAccessing the Beagle View A Beagle View is created in Angular or React when the component BeagleRemoteView is used. To get access to it, you should use the property onCreateBeagleView, in Angular, or viewRef in React.\nSee the examples below:\nAngular \u003cbeagle-remote-view [loadParams]=\"loadParams\" (onCreateBeagleView)=\"onCreateBeagleView($event)\"\u003e beagle-remote-view\u003e import { Component } from '@angular/core' import { BeagleView } from '@zup-it/beagle-web' @Component({ // ... }) class MyComponent { private beagleView: BeagleView | undefined // ... logBeagleView() { if (!this.beagleView) return console.log(this.beagleView)) } onCreateBeagleView(beagleView) { this.beagleView = beagleView this.logBeagleView() } } React import React, { useRef, MutableRefObject, useEffect } from 'react' import { BeagleRemoteView } from '@zup-it/beagle-react' import { BeagleView } from '@zup-it/beagle-web' const MyComponent: FC = () =\u003e { const beagleView = useRef() as MutableRefObject\u003cBeagleView | undefined\u003e // ... logBeagleView() { if (!beagleView.current) return console.log(beagleView.current) } useEffect(logBeagleView, []) return \u003cBeagleRemoteView path=\"/my-path\" viewRef={beagleView} /\u003e } In the examples above, we accessed the Beagle View and logged it. It is important to notice that you need to check for the Beagle View availability before using it. Since the Beagle View is created by a child component, it won‚Äôt be available before the children components are created.\nFetching a view To fetch a view from the backend and update the current view, you need to use the method fetch of the BeagleView.\nA fetch operation can be over the entire tree or just a branch. If it‚Äôs the entire tree, it gets replaced by the result of the request. Otherwise, the tree is kept the same, but for the branch you use fetch to update, this specific branch will get replaced by the result of the request. See an example of a call to the function fetch:\n// fetches the remote view at /my-path and uses it to replace the entire current view beagleView.fetch({ path: '/my-path' }) // fetches the remote view at /my-lazy-container and uses it to replace the component with id 'lazy' beagleView.fetch({ path: '/my-lazy-container' }, 'lazy') fetch can accept 3 parameters, they are:\n loadParams: required. object containing the parameters to control the request, the options are the following:    path: required. Path to the view in the backend.\n  fallback: optional. A Beagle Tree to fallback to in case of an error.\n  method: optional. get by default. Use this option if you need another http method.\n  headers: optional. Use this option to pass additional headers to this single request.\n  shouldShowLoading: optional. Tells wether to use or not the loadingComponent while the view loads. Will use the global configuration if not specified.\n  shouldShowError: optional. Tells wether or not to show the error component if the request fails. Will use the global configuration if not specified.\n  strategy: optional. Tells which cache strategy should be used to load this specific view. Will use the global configuration if not specified.\n  loadingComponent: optional. The loading component to use. Will use the global configuration if not specified.\n  errorComponent: optional. The error component to use. Will use the global configuration if not specified.\n anchor: optional. Id of the node to attach the resulting view to. By default, it uses the root node and it uses to update a single branch.\n  mode: optional. How to attach the resulting view to the anchor, there are four modes:\n    replaceComponent: default. Replaces the entire anchor with the result of the request.\n  replace: replaces the children of the anchor with the result of the request.\n  prepend: adds the result of the request at the start of the list of children of the anchor.\n  append: adds the result of the request at the end of the list of children of the anchor.\n  Subscribing to events You can subscribe to events in the Beagle View. There are two types of subscriptions, one that listens to every update to the tree (beagleView.subscribe) and another that listens to every error in the fetch/renderization process (beagleView.addErrorListener).\nWhen calling beagleView.subscribe, you must pass a single parameter, which is a function that receives the current rendered tree. See the example below:\nconst unsubscribeLogger = beagleView.subscribe((newTree) =\u003e { console.log('The tree was updated!') console.log(newTree) }) To remove a listener, just call the function it returned. In the previous example unsubscribeLogger().\nError listeners are registered in a similar way. The only difference is that they receive a list of errors:\nconst removeErrorListener = beagleView.addErrorListener((errors) =\u003e { console.log('Oops! An error just happened!') console.log(errors) }) By default, Beagle logs every error in the fetch/rendering process to the console. Once a custom error listener is added to the Beagle View, Beagle will stop logging errors by itself and use the treatment provided by the developer instead.\nDestroying the Beagle View To avoid memory leaks, the Beagle View must be destroyed if it won‚Äôt be used again. If you‚Äôre using Angular or React, there‚Äôs no need to worry about it, it will get done under the hood. If you‚Äôre using Beagle Web directly, you must call beagleView.destroy() when the remote view is removed from the page.\nAPI Below you can find all methods of the Beagle View and their description:\n   Attribute Type Definition     subscribe  function Receives the listener and returns a function to unsubscribe.   \naddErrorListener  function subscribes to errors. Receives the listener and returns a function to remove the listener.   fetch  function fetches a view from the backend and uses it to update the current tree.   getRenderer  function returns the renderer of the view. Can be used to update the tree directly.   getTree  function returns a copy of the currently rendered tree.   getBeagleNavigator  function returns the navigator.   getBeagleService  function returns the BeagleService that created this view.   destroy  function destroys this view.    ","excerpt":" Accessing and controlling the BeagleView The features described here ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/the-beagle-view/","title":"The Beagle View"},{"body":" O Beagle Web oferece algumas estrat√©gias de cache, entre elas o protocolo de cache padr√£o do Beagle guiado pelo backend.\nOutras estrat√©gias que voc√™ pode usar s√£o:\n beagle-with-fallback-to-cache beagle-cache-only network-with-fallback-to-cache cache-with-fallback-to-network network-only cache-first  As duas primeiras implementam o protocolo de cache do Beagle, j√° as demais s√£o independentes deste protocolo.  Onde o cache √© armazenado? No framework para Web, os dados de cache s√£o armazenados no local storage do navegador.\nTipos de estrat√©gias No Beagle, voc√™ tem duas possibilidades de estrat√©gia: as que s√£o compat√≠veis com o protocolo de cache e as que s√£o independentes. A seguir, voc√™ ver√° como funciona cada uma delas:\nEstrat√©gias compat√≠veis 1. beagle-with-fallback-to-cache Estrat√©gia padr√£o que implementa:\n Protocolo de cache do Beagle. A adi√ß√£o de um fallback.  Nela, √© salvo de forma local no storage tanto a √°rvore quanto os metadados relacionados ao protocolo de cache (beagle-hash, max-age e um identificador da hora em que a chamada foi enviada).\nEssa estrat√©gia permite que voc√™ use o fallback para retornar uma √°rvore, mesmo em casos de erro. Quando isso acontece, o fallback retorna a √°rvore que j√° tenha sido salva localmente antes (se existir), mesmo que ela esteja desatualizada.\nImportante deixar claro que essa configura√ß√£o s√≥ funcionar√° se o backend estiver com cache habilitado.\nIsso porque o Beagle Web s√≥ extrai as informa√ß√µes do header das requisi√ß√µes. Se elas n√£o estiverem dispon√≠veis, as requisi√ß√µes ser√£o sempre enviadas e, mesmo com o cache armazenado, ele n√£o ser√° utilizado, a n√£o ser para o fallback.\nSe o seu backend estiver com cache desabilitado, os payloads da √°rvore ser√£o salvos no storage e n√£o ser√£o utilizados.\n 2. beagle-cache-only Estrat√©gia que implementa apenas no caso do protocolo de cache do Beagle. Isso significa que ela funciona igual √† estrat√©gia padr√£o, mas sem o fallback.\nQuando voc√™ habilita essa estrat√©gia, a √°rvore que est√° no cache s√≥ √© utilizada se tiver um max-age v√°lido ou se receber o status de 304 do backend.\nCaso a requisi√ß√£o falhe, a view n√£o vai ser exibida e pode n√£o exibir o componente de erro, de acordo com a defini√ß√£o da config.\nEstrat√©gias independentes 1. network-with-fallback-to-cache Estrat√©gia que inicia a chamada no backend para trazer como resultado o que estiver salvo no cache. Esse cache s√≥ ser√° usado em casos de falha na requisi√ß√£o, funcionando como fallback.\nSe a requisi√ß√£o falhar e o dado estiver no cache, voc√™ conseguir√° fazer o retorno corretamente. Caso isso n√£o aconte√ßa, o componente de erro √© (ou n√£o) exibido de acordo com a defini√ß√£o da config.\n2. cache-with-fallback-to-network: Estrat√©gia que inicia a chamada no cache para retornar a √°rvore que estiver renderizada nesse cache. Se n√£o for encontrado nada, o fallback √© realizar a chamada para buscar a √°rvore.\nDesta forma, a chamada s√≥ √© disparada se o dado n√£o for encontrado no cache.\nNo caso desse tipo de estrat√©gia, n√£o h√° uma estrat√©gia de invalida√ß√£o ou revalida√ß√£o do cache. Enquanto o dado estiver no cache, ele √© considerado v√°lido.  3. network-only Estrat√©gia que busca fazer chamadas exclusivamente do backend. Nesse caso, voc√™ sempre enviar√° a requisi√ß√£o para buscar as √°rvores a serem renderizadas.\nSe a requisi√ß√£o falhar, n√£o existe fallback para exibir (ou n√£o) o componente de erro.\nEsta √© a √∫nica estrat√©gia que n√£o salva dados no local storage. Por isso, ela √© recomendada nos casos em que voc√™ quer que o Beagle Web n√£o salve nenhuma informa√ß√£o no storage.  4. cache-first: Estrat√©gia que envia a view depois de fazer a busca no cache, mesmo que n√£o encontre a requisi√ß√£o que estiver procurando.\nSe a √°rvore √© encontrada no cache, ela √© utilizada para renderizar a view. Quando a requisi√ß√£o retorna, a view √© atualizada com o resultado da requisi√ß√£o. No caso de retornar algum erro, √© mantida a view exibida com a informa√ß√£o do cache.\nComo alterar a estrat√©gia de cache utilizada? Para mudar a estrat√©gia de cache, voc√™ deve utilizar o par√¢metro strategy com o nome da estrat√©gia escolhida dentro no config do Beagle.\nNas configs abaixo, voc√™ encontra um exemplo de como alterar a estrat√©gia paranetwork-only:\nAngular React @BeagleModule({ baseUrl: 'yourBackendUrlGoesHere', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, strategy: 'network-only' }) export class Beagle { }  export default createBeagleUIService({ baseUrl: \"\", components: {}, strategy: 'network-only' })  ","excerpt":" O Beagle Web oferece algumas estrat√©gias de cache, entre elas o ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/estrat%C3%A9gias-de-cache/","title":"Estrat√©gias de Cache"},{"body":" The features described here are only available in versions 1.2.0 and above.  We recommend you to read about Beagle tree data structure in order to help you understand rendering.\nEvery Beagle Web library has a very well defined process of how it fetches, process and renders a view. There‚Äôs an order that must always be respected and hook points where the developer can execute some code of his own (lifecycles).\nSee the full rendering process of Beagle Web:\nThe Beagle lifecycles are:\n BeforeStart BeforeViewSnapshot AfterViewSnapshot BeforeRender  They can be used as global hooks to the lifecycle:\nconst config = { // ... lifecycles: { beforeStart: (payload) =\u003e { // ... }, beforeViewSnapshot: (payload) =\u003e { // ... }, afterViewSnapshot: (payload) =\u003e { // ... }, beforeRender: (payload) =\u003e { // ... }, } } Or local hooks to the lifecycles in a per-component basis (annotations/decorators):\n// Attention: these won't work with production builds in Angular. Keep reading for more details. @BeforeStart((textComponentPayload) =\u003e { // ... }) @BeforeViewSnapshot((textComponentPayload) =\u003e { // ... }) @AfterViewSnapshot((textComponentPayload) =\u003e { // ... }) @BeforeRender((textComponentPayload) =\u003e { // ... }) @Component({ // ... }) class Text { // ... } The example above won‚Äôt work with Angular when building for production, because of the Angular compiler. To write a readable code you must choose one of two options:\n Place the comment // @dynamic before calling the decorator:  // @dynamic @BeforeRender((textComponentPayload) =\u003e { // ... }) @Component({ // ... }) class Text { // ... } Replace the arrow function for a common function and export it:  export function beforeRender(textComponentPayload) { // ... } @BeforeRender(beforeRender) @Component({ // ... }) class Text { // ... } Since annotations/decorators cannot be used for functions, if you have a functional component or if you simply don‚Äôt want to use decorators, you can use them as normal function calls:\nconst Table = (props) =\u003e { // ... } BeforeStart((textComponentPayload) =\u003e { // ... })(Table) It is important to notice, mainly for React, where Higher Order Components (HOCs) are common, that the component to receive the decorator must be the final component. For instance, if you want to apply a hoc named withTheme to your component:\nconst MyComponent: FC = () =\u003e { // ... } // This is wrong, it has no effect! // BeforeRender(myLifecycleFunction)(MyComponent) // export default withTheme(MyComponent) // You need to apply the decorator to the final component instead: const MyComponentWithTheme = withTheme(MyComponent) BeforeRender(myLifecycleFunction)(MyComponentWithTheme) export default MyComponentWithTheme The return value of a lifecycle hook can be either nothing (undefined) or a tree. If it is a tree, the rendering process will discard the previous tree and start working on the tree returned by the hook.\nTo take control over the rendering process, besides the lifecycles, Beagle also offers the Renderer API, which can be accessed through BeagleView.getRenderer(). The BeagleView can be accessed via the BeagleRemoteView component through the attributes onCreateBeagleView, in Angular and viewRefin React.\nAnother way to get access to the BeagleView is through the ViewContentManager API, which can be found under this.viewContentManager in an Angular component that extends BeagleComponent; or under props.viewContentManager in a React component that implements the BeagleComponent interface.\nProcess and lifecycles Lifecycles deprecates the feature middlewares. Middlewares will still be supported at least until the next major version (2.0.0) and they will be interpreted as they were part of the global lifecycle beforeViewSnapshot.  Beagle Web has a very well defined process from when a new payload is received to the moment it gets rendered in the browser screen. We also have some ‚Äúbreakpoints‚Äù in this process where you do your own stuff, this is called breakpoints ‚Äúlifecycles‚Äù.\nProcess to render a view See below the steps to render a view:\n Run the global beforeStart hook; Run the beforeStart hook of each component; Identify the children of each component considering the decorator ‚ÄúBeagleChildren‚Äù; Assign an id to every node that doesn‚Äôt have one yet; Remove any properties of the object that has a null value (nulls are interpreted as inexistent in Beagle); If needed, pre-fetch views that could be accessed next; Run the global beforeViewSnapshot hook; Run the beforeViewSnapshot hook of each component; Takes a snapshot of the current tree and stores it. From now on, any reference to the current rendered tree will be referencing the copy. Starts processing a copy of the snapshotted view, the next lifecycles will run over this copy. Run the global afterViewSnapshot hook; Run the afterViewSnapshot hook of each component; Deserialize beagle actions into javascript functions; Evaluate contexts and expressions; Interpret styles, converting the Beagle styling syntax to css; Run the global beforeRender hook; Run the beforeRender hook of each component; Hand the component tree to the render function. This function is different in Angular and React.  Lifecycles There are four lifecycle hooks, but you probably want to use just two of them: beforeViewSnapshot and beforeRender. The main difference between them is that the first runs before any expression or action has been evaluated and the second runs after. Also important to notice is that, when using the Renderer API, doFullRender will run both lifecycles, but doPartialRender will run only the beforeRender lifecycle.\nA simple rule to decide if you want to alter the tree via beforeViewSnapshot or beforeRender is: if your modification doesn‚Äôt depend on the result of an expression, use beforeViewSnapshot otherwise usebeforeRender.\nA lifecycle hook receives the Beagle Tree and returns either nothing (undefined) or a tree. If it is a tree, the rendering process will discard the previous tree and start working on the tree returned by the hook. If it‚Äôs a global lifecycle, by ‚Äútree‚Äù we mean the entire Beagle Tree, if it‚Äôs a component lifecycle, by ‚Äútree‚Äù, we mean the branch corresponding to the component.\nBelow, see detailed explanations and examples of each lifecycle:\nBeforeStart This lifecycle runs before anything else. Here it should be done modifications that must happen before any id is assigned or any children property is computed. Since it runs so early, if the payload is not at all what Beagle expects, here is the place to completely change it.\nSince the children translation has not run yet, components decorated with @BeforeStart might not run at all, since they might not be considered part of the tree. Take, for instance, a text inside a component table that has its children defined by the property rows. In this lifecycle, Beagle has no idea that rows actually represents the children of table and when traversing the tree, it would ignore everything inside rows, including the text we mentioned.\nThis is the only lifecycle where new nodes can be added to the tree and not have ids. Every lifecycle after this is run after the ids are assigned, i.e. if they add a new node, they must also provide its id.\nExamples of usage Custom ID generator This lifecycle can be used to ignore Beagle‚Äôs default id generation and use one of your own. Since Beagle only computes random ids for nodes without id‚Äôs, you can use this lifecycle to assign your own unique ids to every node.\nconst config = { // ... lifecycles: { beforeStart: (tree) =\u003e { let next = 1 function assignIds(data: any) { // if it's not a component or not a structure that can have a component inside, return if (!data || typeof data !== 'object') return // if it's an array, assign ids to the components inside if (Array.isArray(data)) return data.forEach(assignIds) // if it is a component node, assign an ID if (data._beagleComponent_) data.id = `myAppID-${next++}` // if it's an object, assign ids to the components inside const keys = Object.keys(data) keys.forEach(key =\u003e assignIds(data[key])) } assignIds(tree) } } } Complex children calculation\nAnother use case would be complex children calculations. Let‚Äôs say the children of a table component is actually the union of three properties: header, rows and footer. This cannot be expressed via the decorator @BeagleChildren and is not at all what Beagle expects. This lifecycle could be used to remove these properties from the original JSON and create the property children, which would be the union of the three.\nimport { BeforeStart } from '@zup-it/beagle-web' @BeforeStart((table) =\u003e { table.children = [header, ...rows, footer] delete table.header delete table.rows delete table.footer }) class Table { // ... } The code above works only if every other component has children as the name of the property that represents its children. If this is not the case, a global lifecycle should be used instead.\nThis feature could also be implemented using BeforeViewSnapshot, but, in this case, you‚Äôd have to assign id‚Äôs to every node inside the new property children, since in BeforeViewSnapshot the ids have already been assigned. See the example here.\nBeforeViewSnapshot Runs just before the view snapshot, useful to alter the payload, but after the ids were already assigned. This is where you should do most of your modifications to the tree, since id‚Äôs have already been assigned and the tree structure is ready to be traversed.\nThe only thing we must be aware of is: if we create any new node, we must assign an id to it.\nExample of usage Writing a shortcut to control text-inputs The component beagle:textInput can be controlled through a context. Let‚Äôs see an example where the value of the input ‚Äúemail‚Äù is controlled by the context property email.address and the input ‚Äúmessage‚Äù is controlled by the context property email.message.\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"email\", \"value\": { \"address\": \"\", \"message\": \"\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"E-mail\", \"value\": \"@{email.address}\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"email\", \"path\": \"address\", \"value\": \"@{onChange.value}\" } ] }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Message\", \"value\": \"@{email.message}\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"email\", \"path\": \"message\", \"value\": \"@{onChange.value}\" } ] }, ] } It is possible to add a shortcut. Let‚Äôs say whenever the json brings the property model we create the entire structure automatically? In model, it must be typed which value in the context will control the input. Let‚Äôs see the same example, but now using this new property model that we just came up with.\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"email\", \"value\": { \"address\": \"\", \"message\": \"\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"E-mail\", \"model\": \"email.address\" }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Message\", \"model\": \"email.message\" } ] } Much simpler, right? But for this to work, we still need to write the lifecycle that will transform model to the expected structure.\nimport { BeforeViewSnapshot } from '@zup-it/beagle-web' @BeforeViewSnapshot((component) =\u003e { component.value = `@{${component.model}}` component.onChange = component.onChange || [] const [contextId, ...path] = component.model.split('.') component.onChange.push({ _beagleAction_: 'beagle:setContext', contextId, path: path ? path.join('.') : undefined, value: \"@{onChange.value}\" }) }) @Component({ // ... }) class TextInput { // ... } With this code, despite receiving model from the backend, the payload processed by Beagle will have the expected values.\nThis example might not have worked if it was placed under the lifecycle BeforeStart. This is because, at this time, the children wouldn‚Äôt have been interpreted yet. Let‚Äôs say we had a component custom:table where the children is placed under the property rows and inside one of the rows there was a beagle:textInput. The property model wouldn‚Äôt be transformed for this particular text input, because, by this time (BeforeStart), Beagle still has no idea that rows are the children of a custom:table and the beagle:textInput would‚Äôve been inaccessible.\nComplex children calculation with BeforeViewSnapshot The example from the previous lifecycle (BeforeStart) could also have been done here without the danger of skipping the component‚Äôs lifecycle due to a children property named incorrectly. The only difference is that we‚Äôd must assign the ids ourselves:\nimport { BeforeViewSnapshot, Tree, Component } from '@zup-it/beagle-web' @BeforeStart((table) =\u003e { table.children = [header, ...rows, footer] delete table.header delete table.rows delete table.footer // assigns a random id for each component in the tree table.children Tree.forEach(table.children, Component.assignId) }) class Table { // ... } AfterViewSnapshot When using the Renderer API we have two different types of render: full renders and partial renders. The two previous lifecycles will run only in full renders, while this lifecycle and the next runs on both full and partial renders.\nDifferently from the two previous lifecycles, the changes done here are valid for the current render only. Since any update to the view is done over a tree based on the snapshotted view, the modifications done in this lifecycle are not permanent and will be executed in every render. For instance, if we have a property counter with the value 0 in the tree and in our lifecycle we increment counter by 1. In the 5th full render these would be the values for counter depending on which lifecycle was used:\n BeforeStart: 5 BeforeViewSnapshot: 5 AfterViewSnapshot: 1 BeforeRender: 1  This lifecycle can be used to run code that needs to run every time the view is rendered but doesn‚Äôt require actions, context, expressions and styles to have already been processed.\nExample of usage Contexts are defined, referenced and manipulated in the JSON of the view. But what if we want to access data of the application and not the view itself? Beagle offers a feature called ‚ÄúGlobal context‚Äù that is able to deal with this scenario, but suppose there is no Global context, we can still implement this behavior by using the AfterViewSnapshot lifecycle.\nLet‚Äôs say we have a financial application and we want to show the user‚Äôs balance. We must guarantee that, in every re-render the most recent value for the balance will be used.\n{ \"_beagleComponent_\": \"container\", \"context\": { \"id\": \"user\", \"value\": { \"name\": \"\", \"balance\": 0 } }, \"children\": [ { \"_beagleComponent_\": \"text\", \"text\": \"@{user.name}, your balance is $@{user.balance}\" } ] } In the JSON above, we use the context user, where it starts with empty values and the view has no way of knowing the correct values. Now, replace the values of the context in the JSON by the values you have in your application. See the example below:\nimport Tree from '@zup-it/beagle-web' function findContextById(tree, id) { const it = Tree.iterator(tree) let next = it.next() while (!next.done) { const component = next.value if (component.context \u0026\u0026 component.context.id === id) return component.context next = it.next() } } const config = { // ... lifecycles: { afterViewSnapshot: (payload) =\u003e { const userContext = findContextById(payload, 'user') const userData = getUserData() // this method gets the user data from the application userContext.name = userData.name userContext.balance = userData.balance } } } The code above tells Beagle to replace the values in the context ‚Äúuser‚Äù by the values in the application. This piece of code cannot be placed before the view is snapshotted because we have the requirement to update the balance value in every render. It also can‚Äôt be placed in the next lifecycle (BeforeRender), because the context would then be already evaluated and our values wouldn‚Äôt be processed.\nIt is important to notice that the action setContext would not work over the context user, since we are always replacing the values for this context before processing any expression. This is just an example to show how this lifecycle could be used. To use application values in your beagle view, it is always preferred to use the global context.\nBeforeRender The changes here are valid for the current render only and is executed in every render. The difference from BeforeRender to AfterViewSnapshot, is that it is guaranteed that all actions, expressions and styles have already been processed.\nExample of usage When the backend decided to express colors in the following format: { red: number, green: number, blue: number }. For example, black would be { red: 0, green: 0, blue: 0 }. This is not a valid color for browsers, so we decide to convert the value of every color property to a valid RGB format. Basically, the function that could do this work is the following:\nconst colorProperties: ['color', 'backgroundColor', 'borderColor'] function fixColorCodes(componentPayload) { const style = componentPayload.style if (!style) return colorProperties.forEach((property) =\u003e { if (!style[property]) return style[property] = `rgb(${style[property].red}, ${style[property].green}, ${style[property].blue})` }) } Now, just need to run the function above for every component in the tree. If you want to have a dynamic behavior for the color by changing it via the context feature, check the JSON below:\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"bgColor\", \"value\": { \"red\": 255, \"green\": 255, \"blue\": 255 }, }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"My dynamically colored text\", \"style\": { \"backgroundColor\": \"@{bgColor}\" } }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"red\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 255, \"green\": 0, \"blue\": 0 } } ], \"_beagleComponent_\": \"beagle:button\", \"text\": \"green\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 0, \"green\": 255, \"blue\": 0 } } ], \"_beagleComponent_\": \"beagle:button\", \"text\": \"blue\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 0, \"green\": 0, \"blue\": 255 } } ] } ] } The text starts with a white background and as soon as the user presses a button, the background color changes.\nIf you call fixColorCodes before the context is evaluated, it will be trying to execute it over the string @{bgColor} instead of the object { red: 255, green: 255, blue: 255 } which will get you a massive runtime error, since red, green or blue are not properties of a string.\nBeforeStart, BeforeViewSnapshot and AfterViewSnapshot are executed before the context gets evaluated, so everything that might be affected by the context, must be executed in the last lifecycle: BeforeRender.\nimport { Tree } from '@zup-it/beagle-web' const config = { // ... lifecycles: { // ... beforeRender: tree =\u003e Tree.forEach(tree, fixColorCodes), } } The Renderer API For fine control of the rendering process, Beagle also let you manage when to render a new tree to your Beagle View. You can have a component, that when clicks changes the current Beagle Tree, so a new component is added or a property is modified.\nA common scenario is when you need to create an action that modifies the current tree. Take for example the action addChildren, when executed, it must get the current tree and add the given children to the component with the given id. To do it, we must have a way to get the current tree, modify it and tell the Beagle View to render it again.\nA renderization can be one of two processes: a full renderization or a partial renderization. The first runs all steps of the renderization (1 to 8 in this list). The second executes only the view snapshot and the steps after it (9 to 18 in this list).\nAccessing the Renderer Each Beagle View has its renderer, to get access to it, you must call beagleView.getRenderer().\nSee examples of how to get the renderer:\n In React: a reference to the BeagleView can be obtained through the property viewRef of the BeagleRemoteView:  import React, { FC, useRef, useEffect, MutableRefObject } from 'react' import { BeagleRemoteView } from '@zup-it/beagle-react' import { BeagleView } from '@zup-it/beagle-web' const Home: FC = () =\u003e { const beagleView = useRef() as MutableRefObject\u003cBeagleView | undefined\u003e useEffect(() =\u003e { if (beagleView.current) { const renderer = beagleView.current.getRenderer() } }, []) return ( \u003cBeagleRemoteView path=\"/home\" viewRef={beagleView} /\u003e ) }  In Angular: you can use the attribute onCreateBeagleView of the beagle-remote-view component:  import { Component } from '@angular/core' import { LoadParams, BeagleView } from '@zup-it/beagle-web' @Component({ selector: 'home', template: '', }) export class Home { loadParams: LoadParams private beagleView: BeagleView constructor() { this.loadParams = { path: '/home' } } onCreateBeagleView(beagleView: BeagleView) { this.beagleView = beagleView } getRenderer() { return this.beagleView \u0026\u0026 this.beagleView.getRenderer() } } When inside a component rendered by Beagle, you can use the ViewContentManager to get the BeagleView and obtain access to the renderer.\nWhen inside an action handler (custom actions), the Beagle View is provided via parameter, which can be used to get the renderer. See the example below:\nconst MyCustomActionHandler: ActionHandler\u003cMyCustomAction\u003e = ({ action, beagleView }) =\u003e { const renderer = beagleView.getRenderer() // ... } Using the Renderer The renderer has only two functions: doFullRender and doPartialRender.\n doFullRender: renders the tree passed as parameter by running all rendering steps over it. Full renders must be done every time new nodes are created doPartialRender: it only runs the view snapshot and the steps after that. Partial renders should be used to modify existent nodes.  The tree received by doFullRender is of type BeagleUIElement, for example, it might or not have ids. The tree received by doPartialRender is of type IdentifiableBeagleUIElement:\nExample: it must have ids for every node. You can never pass a tree to doPartialRender with missing ids.\nBesides the type of the tree, there is no difference to the way we call doFullRender and doPartialRender. They both accept the following parameters:\n The first parameter is the tree. The second parameter is optional and it is the anchor. If the anchor is not specified, the tree passed in the first parameter will replace the entire currently rendered tree. If the anchor is specified, the tree passed as parameter will be attached to the currently rendered tree at the same position as the node with the id referenced by anchor. How the attachment is done is defined by the third parameter. The third parameter is optional and it is the mode. If the mode is not defined, it is treated as replaceComponent. There are four different modes:  replaceComponent: replaces the node with the same id as the parameter anchor (or the root if no anchor is specified) with the tree passed in the first parameter. replace: replaces the children of the node with the same id as the parameter anchor (or the root if no anchor is specified) with the tree passed in the first parameter. prepend: pre-pends the tree passed in the first parameter to the children of the node with the same id as the parameter anchor (or the root if no anchor is specified). append: appends the tree passed in the first parameter to the children of the node with the same id as the parameter anchor (or the root if no anchor is specified).    Examples: /* example 1: renders a container with an empty list */ beagleView.getRenderer().doFullRender({ _beagleComponent_: 'beagle:container', children: [ _beagleComponent_: 'custom:list', id: 'list', ], }) /* example 2: adds a property to the root of the currently rendered tree */ const current = beagleView.getTree() current.newProperty = 'new' beagleView.getRenderer().doPartialRender(current) /* example 3: adds an element to the \"custom:list\" inside the container */ const item = { _beagleComponent_: 'beagle:container', children: [ { _beagleComponent_: 'beagle:text', text: 'Client name: Jasnah Kholin' }, { _beagleComponent_: 'beagle:text', text: 'Client age: 30' } ] } // we should always do full renders when creating new nodes beagleView.getRenderer().doFullRender(item, 'list', { mode: 'append' })  With the renderer API you get to alter the view whenever you want. You can‚Äôt, for instance, call renderer.doFullRender(tree, componentId) in the onInit of the Angular component with id componentId. If this is done, Beagle will remove a component of the tree before it even gets the chance to be fully rendered. Cases like this can happen using the Beagle Renderer inside components lifecycles, so be careful!\nA solution to the example given would be to replace the children of the component instead of the component itself (renderer.doFullRender(tree, componentId, 'replace')).\n The ViewContentManager API List view component is a component that needs to use the Renderer API, but how do we access the renderer from the component itself? In both Angular and React this can be done via the ViewContentManager.\nThe ViewContentManager provides a way to access the Beagle View and the node in the current Beagle Tree that gave origin to the component being rendered and with that you can access the renderer and call re-renders for this specific component.\nAccessing the ViewContentManager React The ViewContentManager can be accessed inside a React component if this component implements the BeagleComponent interface.\nSee below an example to re-render the component with a new set of children based on the data source and the template:\nimport React, { FC, useRef, useEffect, MutableRefObject } from 'react' import { BeagleComponent } from '@zup-it/beagle-react' interface ListViewInterface extends BeagleComponent { // ... } const ListView: FC\u003cListViewInterface\u003e = (props) =\u003e { useEffect(() =\u003e { /* Once the component implements the BeagleComponent interface, we have access to the viewContentManager, but if the component was not instantiated by Beagle, the viewContentManager will be undefined. We must verify it before continuing. */ if (!props.viewContentManager) return const children = createChildrenFromTemplate(props.dataSource, props.template) const element = props.viewContentManager.getElement() element.children = children props.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id) }, [props.dataSource, props.template]) return ( // ... ) } The re-render happens every time the data source or the template changes.\nAngular In Angular, if you need access to the ViewContentManager, the component class must extend BeagleComponent, then, you just need to reference this.viewContentManager.\nimport { Component, Input } from '@angular/core' import { BeagleComponent } from '@zup-it/beagle-angular' @Component({ // ... }) export class ListView extends BeagleComponent { // ... renderDataSource() { /* Checks if the viewContentManager is available. If the components has not been created by Beagle, it won't be. */ if (!this.viewContentManager) return const children = this.createChildrenFromTemplate(this.dataSource, this.template) const element = this.viewContentManager.getElement() element.children = children this.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id) } } The method renderDataSource should be called every time the data source or the template changes.\nUsing the ViewContentManager The ViewContentManager have the following properties/functions\n   Property Type Definition     \u003cb\u003e\u003c/b\u003e\ngetElement()  function returns the node in the Beagle Tree responsible for the renderization of the component.   \ngetElementId()  function shortcut to getElement().id    getBeagleView()  function returns the BeagleView responsible for the view containing the component.    Updating the view with the result of a request In case you need to update the current view with a tree that comes from the backend, you should use the method fetch of the BeagleView. It will internally use all the cache mechanisms of Beagle and also do the rendering part.\n","excerpt":" The features described here are only available in versions 1.2.0 and ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/rendering/","title":"Rendering"},{"body":" O Beagle Web envia dois tipos de headers que s√£o padr√µes para o Beagle:\n beagle-platform: header utilizado que indica para o backend que a requisi√ß√£o partiu da Web. Desta forma, o valor enviado √© sempre WEB. beagle-hash: header utilizado para o correto funcionamento do protocolo de cache de Beagle.  Por padr√£o, esses headers s√£o sempre enviados, por√©m podem ser desabilitados pelo par√¢metro useBeagleHeaders na config.\nAbaixo, voc√™ confere exemplos de como desabilitar o envio desses headers nas configs do Angular e React:\nAngular React @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: {}, useBeagleHeaders: false }) export class Beagle { }  export default createBeagleUIService({ baseUrl: \"\", components: {}, useBeagleHeaders: false })  Voc√™ deve manter os headers habilitados para o correto funcionamento do protocolo de cache do Beagle.  ","excerpt":" O Beagle Web envia dois tipos de headers que s√£o padr√µes para o ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/headers-padr%C3%B5es/","title":"Headers Padr√µes"},{"body":" Introduction It is possible to create customized actions with Beagle for your components.\nCreate an ActionHandler Step 1: Create an interface with the required property _beagleAction_ and with other necessary values, like the example below, where two parameters were created: A and B.\n__The customized action name is _beagleAction_\ninterface CustomAction { _beagleAction_: 'custom:myCustomAction', parameterA: string, parameterB: number } Step 2: Create the function ActionHandler with the interface:\nimport { ActionHandler } from '@zup-it/beagle-web' export const customAction: ActionHandler\u003cCustomAction\u003e = ({ action }) =\u003e { }  In the ActionHandler function, you can access the defined values like the example above: action.parameterA or action.parameterB.  Step 3: Add the action name in the association file according to your framework:\nAngular React For Angular: Add beagle.module.ts\n@BeagleModule({ ... customActions:{ \"custom:myCustomAction\": customAction //nome do action handler  } }) export class Beagle {}  For React: add to your Beagle configuration file\nexport default createBeagleUIService\u003cany\u003e({ ... customActions:{ \"custom:myCustomAction\": customAction //nome do action handler  } })  Adding actions to JSON Add the customized action to the JSON and add the defined parameters in the ActionHandler interface\nSee below an example with a button:\n{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"Clique para a√ß√£o customizada\", \"onPress\": { \"_beagleAction_\": \"custom:myCustomAction\", \"parameterA\": \"Beagle Web\", \"parameterB\": 10 } }  Pay attention to the class types when you add a customized action parameter, the example above was string and number.  ","excerpt":" Introduction It is possible to create customized actions with Beagle ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/customized-actions/","title":"Customized Actions"},{"body":" Beagle Remote View A biblioteca do Beagle fornece um componente auxiliar para renderizar as telas server-driven, o remote view:\nAngular React \u003cbeagle-remote-view [loadParams]=\"loadParams\"\u003e\u003c/beagle-remote-view\u003e  \u003cBeagleRemoteView {...loadParams} /\u003e  Tanto no Angular como no React, o remote view aceita propriedades que s√£o chamadas de Load Params. √â por meio dela que algumas op√ß√µes s√£o configuradas para influenciar a maneira como as telas s√£o renderizadas.\nVeja abaixo as propriedades aceitas, apenas path √© obrigat√≥ria:\nimport { LoadParams } from '@zup-it/beagle-web'; const params: LoadParams = { path: '/payload.json', fallback: {_beagleComponent_: 'beagle:text', text:'Fallback Error'}, method: 'get', headers: {'header': 'value'}, shouldShowLoading: true, shouldShowError: true, strategy: \"network-only\", loadingComponent: 'myComponentLoading', errorComponent: 'myComponentError' }    Propriedade Tipo Descri√ß√£o     path string Obrigat√≥ria. Caminho do servidor para carregar o JSON com a tela server-driven.   fallback BeagleComponent Componente para ser renderizado caso a requisi√ß√£o falhe.   method m√©todo Http M√©todo Http para fazer a requisi√ß√£o.   headers Mapa\u003cchave, valor\u003e Lista de header para anexar ao fazer a requisi√ß√£o.   shouldShowLoading booleano Mostra ou n√£o o componente de loading.   shouldShowError booleano Mostra ou n√£o o componente de erro.   strategy string\u003cEstrat√©gia de cache\u003e Estrat√©gia de cache adotada na requisi√ß√£o.   loadingComponent string Componente customizado para loading.   errorComponent string Componente customizado para error.    ","excerpt":" Beagle Remote View A biblioteca do Beagle fornece um componente ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/par%C3%A2metros-remote-view/","title":"Par√¢metros Remote View"},{"body":" Creating a customized component To create a customized component, follow the next steps:\n You need an ordinary component, after that you have to create a new one in your project:  Angular React The component will be created with customText name, in this example. In your terminal, use the following command:\nng generate component components/customText --skip-import  Here, a component will be created to render a CustomTextComponent text.\nimport React from 'react' function CustomTextComponent(){ return ( \u003cp\u003eBeagle Web React\u003c/p\u003e ) } export default CustomTextComponent;  Now, add Beagle‚Äôs library association in your project  Angular React Open beagle-components.module.ts file and add the new CustomTextComponent generated in the list, see the example below:\n... import { CustomTextComponent } from './components/custom-text/custom-text.component' // import all the components you're going to use with beagle  const components = [ CustomTextComponent ] @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on  ], }) export class BeagleComponentsModule {} On beagle.module.ts file, add your new component in the association‚Äôs list:\nimport { BeagleModule } from '@zup-it/beagle-angular' import { CustomTextComponent } from './components/custom-text/custom-text.component' // import all the components you wish to use with Beagle.  @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component.  \"custom:text\": CustomTextComponent }, }) export class Beagle {} If you didn‚Äôt find the beagle-components.module.ts files or beagle.module.ts, see how to configure Beagle‚Äôs library in your project. \n  Now, access Beagle‚Äôs library configuration file in your project and add your component to the association list. If you don‚Äôt have this file in your project,learn here how to configure Beagle Web React library. \nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomTextComponent from '../components/CustomTextComponent' export default createBeagleUIService\u003cany\u003e({ baseUrl: '', components: { 'custom:text': CustomTextComponent } })  On the step below, the word custom was added to identify the components, this will make Beagle‚Äôs library understand that this component does not belong to the predefined component‚Äôs list.\nAdding properties to the component To add properties to the created component, follow the next steps:\nAngular React  Open the custom-text.component.ts file and add an @Input like the code below:  import { Component, OnInit, Input } from '@angular/core'; @Component({ selector: 'app-custom-text', templateUrl: './custom-text.component.html', styleUrls: ['./custom-text.component.less'] }) export class CustomTextComponent implements OnInit { @Input() myCustomText: string constructor() { } ngOnInit(): void { } } Add the reference to the file custom-text.component.html  \u003cdiv\u003e \u003ch1\u003e{{myCustomText}}\u003c/h1\u003e \u003c/div\u003e If you have a project that is currently running, it is necessary to restart with the commands: yarn serve or npm run serve\n  On React, all the attributes defined in the JSON can be accessed through props, see the example:\nimport React from 'react' function CustomTextComponent(props){ return ( \u003cp\u003e{props.myCustomText}\u003c/p\u003e ) } export default CustomTextComponent;  Creating a JSON Now you can add your component to a JSON file:\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"custom:text\", \"myCustomText\":\"Beagle Web is Awesome\" } ] }  Done! You have created a customized component that receives properties and it is rendered by Beagle‚Äôs library.  ","excerpt":" Creating a customized component To create a customized component, ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/custom-component/","title":"Custom Component"},{"body":" Beagle Service Para usar a biblioteca Beagle se faz necess√°ria a cria√ß√£o de um Beagle Service com as configura√ß√µes de onde e como buscar as telas server-driven.\n No React voc√™ pode facilmente criar um Beagle Service por meio da fun√ß√£o createBeagleService(beagleServiceOptions)\n  No Angular o c√≥digo base √© gerado automaticamente e as propriedades podem ser modificadas e adicionadas em beagle.module.ts\n O objeto de configura√ß√£o possui as propriedades a seguir:\n   Atributo Tipo Default Obrigat√≥rio Descri√ß√£o     baseUrl string  ‚úì URL para o servidor com as telas (JSON) no formato Beagle   components Map\u003cstring,Component\u003e  ‚úì Um mapa de componentes que ser√£o renderizados atrav√©s da biblioteca Beagle. Os valores s√£o pares chave e valor onde a chave √© o identificador Beagle e sempre come√ßar√° por beagle: ou custom:. J√° o valor ser√° o componente ligado ao identificador   strategy Strategy beagle-with-fallback-to-cache  Estrat√©gia de cache aplicada nas requisi√ß√µes de telas ao servidor   fetchData fetch   Permite adicionar uma fun√ß√£o customizada para fazer requisi√ß√µes HTTP.   analytics Analytics   Permite o uso de handlers para a captura e tagueamento de alguns eventos.   customActions Map\u003cstring,ActionHandler\u003e   Um mapa de a√ß√µes customizadas que podem ser interpretadas pela biblioteca Beagle. √â um mapa chave e valor onde a chave ser√° sempre um identificador come√ßado por beagle: ou custom: e o valor ser√° o ActionHandler ligado aquela a√ß√£o.   lifecycles LifeCycleHook   Um mapa global para adicionar comportamentos aos ciclos de vida dos componentes. Cada ciclo ocorre no processo de renderiza√ß√£o das telas, antes dos componentes se tornarem HTML   customStorage Storage localStorage  Substitui o localStorage padr√£o dos browsers   useBeagleHeaders boolean true  Usar ou n√£o headers espec√≠ficos do Beagle ao fazer as requisi√ß√µes de telas para o servidor   navigationControllers Map\u003cstring, NavigationController\u003e   Permite adicionar op√ß√µes de controle de reposta visual, como mostrar ou n√£o itens de carregamento e componentes de erro    ","excerpt":" Beagle Service Para usar a biblioteca Beagle se faz necess√°ria a ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/par%C3%A2metros-beagle-service/","title":"Par√¢metros Beagle Service"},{"body":" Beagle Web offers some cache strategies, one of them is the Beagle‚Äôs pattern cache protocol guided by the backed.\nOther strategies you are able to use:\n beagle-with-fallback-to-cache beagle-cache-only network-with-fallback-to-cache cache-with-fallback-to-network network-only cache-first  The two first implements Beagle‚Äôs cache protocol, the others are independent from it.  Where is the cache stored? On the web, the cache data are stored in the browser.\nTypes of strategies You have two strategy possibilities on Beagle: the ones that are compatible with the cache protocol and the others that are independent. You will see next how each works:\nCompatible strategies 1. beagle-with-fallback-to-cache Standard strategy that implements:\n Beagle‚Äôs cache protocol. Adding to a fallback.  Here, it is locally saved on the storage the tree and the related cache protocol metadata (beagle-hash, max-age and a time identifier that shows the time the request has been sent).\nThis strategy allows you to use a fallback to return a tree, even in some error cases. When this happens, the fallback returns a tree that has already been locally saved before (if it exists), even if it is not updated.\nIt is important to make it clear, this configuration will only work if the backend has the cache enabled.\nBeagle Web only extracts the header information from the requests. If they are not available, the request will always be sent and even with the stored cache, it won‚Äôt be used, the exception is the for a fallback.\nIf you backend is with disabled cache, the payload from the tree will be saved on the storage and it will not be used.\n 2. beagle-cache-only This strategy only implements Beagle‚Äôs cache protocol. This means that, it works the same way the standard one, but without the fallback.\nWhen you enable this strategy, the tree that is on cache it is only used if there is a valid max-age or if it receives a 304 status from the backend.\nIn case the request fails, the view will not be displayed and it can not exhibit the error component, according to the config definition.\nIndependents strategies 1. network-with-fallback-to-cache This strategy starts the request on backend to bring as a result what it is saved on cache. This cache will only be used in case the request fails, working as fallback.\nIf the request fails and the data is on cache, you will be able to make the return correctly. In case this does not happens, the error component is (or not) displayed according the to the config definition.\n2. cache-with-fallback-to-network: This one starts the request on cache to return the tree that it is rendered in this cache. If nothing is found, the fallback will make a request to search the tree.\nThis way, the request is only triggered if the data is not found on cache.\nOn this kind of strategy, there isn‚Äôt an invalid one or a cache revalidation. While the data is on cache, it is considered valid.  3. network-only This strategy makes exclusive backend requests. On this case, you will always send a request to search the trees to be rendered.\nIf the request fails, there isn‚Äôt a fallback to display (or not) the error component.\nThis is the only strategy that does not save data on local storage. For that, this one is recommended for cases you want Beagle Web to not save any information on the storage.  4. cache-first: This one sends the view after searching on cache, even if it doesn‚Äôt find the request that it is looking for.\nIf the tree is found on cache, it is used to render the view. When the request returns, the view is updated with the request result. In case it returns an error, the displayed view is kept with the cache information.\nHow do I alter the cache strategy used? To change the cache strategy, you have to use the strategy parameter with the strategy name chosen inside Beagle‚Äôs config.\nOn the configs below, you will find an example on how to alter the strategy to network-only:\nAngular  @BeagleModule({ baseUrl: 'yourBackendUrlGoesHere', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, strategy: 'network-only' }) export class Beagle { }  ","excerpt":" Beagle Web offers some cache strategies, one of them is the Beagle‚Äôs ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/cache-strategy/","title":"Cache strategy"},{"body":" ","excerpt":" ","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/t%C3%B3picos-avan%C3%A7ados/","title":"T√≥picos avan√ßados"},{"body":" Beagle Web sends two types of headers that are a standart for Beagle:\n beagle-platform: header used to indicate to the backend that this request came from the Web. This way, the value is sent is always WEB. beagle-hash: header used to make Beagle‚Äôs cache protocol work properly.  By pattern, these headers are always sent, however it can be disabled by the useBeagleHeaders parameter on the config.\nSee below the examples on how to disable the headers request on the Angular and React‚Äôs configs.\nAngular React @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: {}, useBeagleHeaders: false }) export class Beagle { }  export default createBeagleUIService({ baseUrl: \"\", components: {}, useBeagleHeaders: false })  You must keep the headers enabled to make Beagle‚Äôs cache protocol working properly.  ","excerpt":" Beagle Web sends two types of headers that are a standart for Beagle: ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/standard-headers/","title":"Standard headers"},{"body":" Como o Beagle representa a view? As features descritas aqui est√£o dispon√≠veis apenas nas vers√µes acima de 1.2.0.  Beagle trabalha em uma √°rvore de componenentes e para fazer funcionar, √© preciso seguir algumas regras. Nos termos do Typescript, a √°rvore do Beagle pode ser definida como:\nexport interface BeagleUIElement { _beagleComponent_: string, id: string, context?: DataContext, children?: BeagleUIElement[], style?: Style, [key: string]: any, } Veja abaixo cada componente da √°rvore:\n _beagleComponent_ √© o nome do componenete UI a ser renderizado; id √© o identificador √∫nico para o node. Observa√ß√£o: mesmo que o id √© obrigat√≥rio pela estrutura interna da √°rvore, antes de process√°-la, o Beagle atribui um id √∫nico qualquer para cada node sem um id, tornando-o opcional no json fornecido pelo backend. context √© um contexto definido para um componente e seus filhos. children √© uma array de nodes representando os filhos que est√£o no node atual. style √© a regra de estiliza√ß√£o dos componentes. Essas regras n√£o s√£o CSS, mas estruturas definidas pelo Beagle. O node possui propriedades esperadas pelo pr√≥prio componente, como text, que poderia ter text e justify, enquanto o bot√£o poderia ter onPress, text e disabled.  Veja abaixo um exemplo da √°rvore de componentes, pronta para ser processada pelo Beagle:\n{ \"_beagleComponent_\": \"container\", \"id\": \"container\", \"children\": [ { \"_beagleComponent_\": \"image\", \"id\": \"logo\", \"url\": \"https://i.ibb.co/rvRN9kv/logo.png\" }, { \"_beagleComponent_\": \"text\", \"id\": \"welcome\", \"text\": \"Welcome to the Beagle playground!\" }, { \"_beagleComponent_\": \"text\", \"id\": \"instructions\", \"text\": \"Use the panel on the left to start coding!\" }, { \"_beagleComponent_\": \"button\", \"id\": \"fast-guide\", \"text\": \"Access the fast guide\" } ] } O json acima √© uma vers√£o simplificada da p√°gina inicial do Beagle Playground. Ele renderiza o container para guardar o resto dos elementos: uma imagem, dois textos e um bot√£o. Para ver o exemplo completo e o UI renderizado, veja o Beagle Playground.\nO payload do Beagle No tipo definido anteriormente (BeagleUIElement), voc√™ pode ver que o id √© uma propriedade obrigat√≥ria e que os filhos de um node devem sempre ser nomeados children. No backend isso n√£o √© uma garantia, por essa raz√£o, o Beagle gera internamente ids √∫nicos para cada node sem um e traduz a propriedade children. Uma mesa de componente, por exemplo, pode ter seus filhos em uma propriedade rows. Antes de come√ßar o processo da √°rvore, o Beagle converte o rows para o nome esperado children, veja a se√ß√£o abaixo sobre the children property.\nO payload pode retornar para o backend qualquer coisa, mas internamente o Beagle deve trabalhar com a √°rvore de componentes BeagleUIElement. Voc√™ deve atravessar a √°rvore e detectar cada componente e seus filhos.\n√â recomendado que o backend retorne o JSON representando a √°rvore de componentes, como √© esperado pelo Beagle, mas se por alguma raz√£o isso n√£o seja poss√≠vel, o Beagle Web torna poss√≠vel o pr√© processamento da resposta e constr√≥i a √°rvore no front-end antes que o Beagle come√ße a trabalhar com ela, como em lifecycles.\nA propriedade children √â recomendado sempre usar a array com o nome children para especificar os filhos nodes de um componente. Mas, o Beagle ir√° trabalhar fora da caixa, se ao inv√©s de um array de componentes, o √∫nico node √© passado e o nome child tamb√©m pode ser usado. Em alguns casos, quando o componente representa uma tabela, os filhos podem ser nomeados rows ao inv√©s de children, nesse caso voc√™ pode informar ao Beagle que √© um componente espec√≠fico e que o nome da propriedade children √© diferente. Veja o exemplo abaixo:\n@BeagleChildren({ property: 'rows' }) @Component({ // ... }) class Table { // ... } O exemplo acima √© para Angular, mas funciona da mesma forma em outras plataformas. Se o componente √© funcional ou se voc√™ n√£o quiser usar anota√ß√µes, voc√™ pode us√°-lo como uma fun√ß√£o, veja o exemplo abaixo:\nconst Table = (props) =\u003e { // ... } BeagleChildren({ property: 'rows' })(Table) ","excerpt":" Como o Beagle representa a view? As features descritas aqui est√£o ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/t%C3%B3picos-avan%C3%A7ados/estrutura-de-dados/","title":"Estrutura de dados"},{"body":" Loading Component Beagle‚Äôs library already has by pattern a component that it is called when a screen loads. If necessary, you are able to change it to a customized one, according your application‚Äôs needs.\nTo create a loading component, follow the steps below:\nReact Angular On React:\nStep 1: Create a substitute component;\nSee an example:\nimport React, { FC } from 'react' const CustomLoadingComponent: FC\u003cany\u003e = () =\u003e { return ( \u003cdiv\u003eCarregando\u003c/div\u003e ) } export default CustomLoadingComponent Step 2: Add it to Beagle‚Äôs Service components list to substitute the pattern component:\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomLoadingComponent from '../components/CustomLoading' export default createBeagleUIService\u003cany\u003e({ baseUrl: \"localhost:4000\", components: { \"custom:loading\":CustomLoadingComponent } })  On Angular\nStep 1: Create a substitute component.\nYou can use angular CLI, if you want, to generate the component automatically, see:\nng generate component components/custom-loading Step 2: After that, open the file beagle-components.module.ts and add the component to the list:\nimport { NgModule } from '@angular/core' import { CustomLoadingComponent } from './components/custom-loading/custom-loading.component'; // import all the components you're going to use with beagle const components = [ CustomLoadingComponent ]; @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} Step 3: Now, you can substitute the pattern component in the beagle.module.ts file:\nimport { BeagleModule } from '@zup-it/beagle-angular'; import { CustomLoadingComponent } from './components/custom-loading/custom-loading.component'; // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://mypath', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { 'custom:loading': CustomLoadingComponent } }) export class Beagle { } The files beagle.module.ts and beagle-components.module.ts are automatically generated by Angular‚Äôs library. If you haven‚Äôt found it, check you installation.\n  Error Component The pattern error component on Beagle it is called when connection error happens, for example, when a server path cannot be reached.\nTo this component, the library shows an interface called ErrorComponentParams, throught it you have access to the error list and a retry method, responsible to retry the server request.\nErrorComponentParams    Attribute Type Definition     retry Method Retry the request to the server.    When using this interface, you can create a component, see the example below with each framework:\nReact Angular On React, you have to create a Functional Component that uses the ErrorComponentParams interface. When using it, you have access to two props errors and retry, which are the errors list and the retry method, both described on the interface:\nNo React, √© preciso criar um Functional Component que usa a interface ErrorComponentParams, note que ao us√°-la voc√™ tem acesso √† duas props errors e retry, que s√£o respectivamente a lista de erros e o m√©todo retry ambos descritos na interface:\nimport { ErrorComponentParams } from '@zup-it/beagle-react' import React, { FC } from 'react' const CustomErrorComponent: FC\u003cErrorComponentParams\u003e = ({ retry }) =\u003e { return ( \u003c\u003e \u003cp\u003e Unexpected Error! \u003c/p\u003e \u003cbutton onClick={retry}\u003eRetry\u003c/button\u003e \u003c/\u003e ) } export default CustomErrorComponent After that, add it to the Beagle Service components list:\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomErrorComponent from '../components/CustomError' export default createBeagleUIService\u003cany\u003e({ baseUrl: \"localhost:4000\", components: { \"custom:error\":CustomErrorComponent } })  On Angular, create a component, if you prefer use angula cli to automatically generate the inicial structure:\nng g component components/custom-error Open the controller file of the created component and add the ErrorComponentParams interface. The interface gives access to two @Inputs errors and retry, which are the errors list and the request method:\nimport { Component, Input } from '@angular/core'; import { ErrorComponentParams } from '@zup-it/beagle-angular'; @Component({ selector: 'app-custom-error', templateUrl: './custom-error.component.html', styleUrls: ['./custom-error.component.less'] }) export class CustomErrorComponent implements ErrorComponentParams { @Input() retry: () =\u003e void; handleRetry() { this.retry(); } } Now, add the created component to the file list beagle-components.module.ts\nimport { NgModule } from '@angular/core'; import { CustomErrorComponent } from './components/custom-error/custom-error.component'; // import all the components you're going to use with beagle const components = [ CustomErrorComponent ]; @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} Finally, replace the pattern component to the beagle.module.ts file:\nimport { CustomErrorComponent } from './components/custom-error/custom-error.component'; // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4202/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { 'custom:error': CustomErrorComponent } }) export class Beagle { } The files beagle.module.ts and beagle-components.module.ts are automatically generated by Angular‚Äôs library. If you haven‚Äôt found them, check your installation.\n  ","excerpt":" Loading Component Beagle‚Äôs library already has by pattern a component ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/loading-components-and-error-treatment/","title":"Loading components and error treatment"},{"body":" Acessar e controlar o BeagleView As features descritas aqui est√£o dispon√≠veis apenas em vers√µes acima de 1.2.0.  Beagle View √© uma entidade respons√°vel por gerenciar a view do server-driven. Pode ser criada por meio do Beagle Service, pela fun√ß√£o createBeagleView. O BeagleView pode buscar uma nova view, atualizar a sua √°rvore, navegar, etc.\nAcessando o Beagle View O Beagle View √© criado no Angular ou React quando o componenenteBeagleRemoteView √© usado. Para acess√°-lo, voc√™ deve usar a propriedade onCreateBeagleView no Angular ou a viewRef no React. Veja os exemplos abaixo:\nAngular \u003cbeagle-remote-view [loadParams]=\"loadParams\" (onCreateBeagleView)=\"onCreateBeagleView($event)\"\u003e beagle-remote-view\u003e import { Component } from '@angular/core' import { BeagleView } from '@zup-it/beagle-web' @Component({ // ... }) class MyComponent { private beagleView: BeagleView | undefined // ... logBeagleView() { if (!this.beagleView) return console.log(this.beagleView)) } onCreateBeagleView(beagleView) { this.beagleView = beagleView this.logBeagleView() } } React import React, { useRef, MutableRefObject, useEffect } from 'react' import { BeagleRemoteView } from '@zup-it/beagle-react' import { BeagleView } from '@zup-it/beagle-web' const MyComponent: FC = () =\u003e { const beagleView = useRef() as MutableRefObject\u003cBeagleView | undefined\u003e // ... logBeagleView() { if (!beagleView.current) return console.log(beagleView.current) } useEffect(logBeagleView, []) return \u003cBeagleRemoteView path=\"/my-path\" viewRef={beagleView} /\u003e } Nos exemplos acima, o Beagle View foi acessado e logado. √â importante lembrar que √© preciso checar a disponibilidade do Beagle View antes de us√°-lo, uma vez que ele √© criado por um componente child, ele n√£o estar√° dispon√≠vel antes da cria√ß√£o dos componentes children.\nBuscando a view Para buscar uma view do backend e atualizar a view atual, voc√™ precisa usar o m√©todo fetch do BeagleView.\nA opera√ß√£o de busca por ser em toda a √°rvore ou apenas nas branch. Se for a primeira, a √°rvore √© toda substitu√≠da pelo resultado da requisi√ß√£o. Caso contr√°rio, a √°rvore √© mantida, mas a branch √© atualizada pelo fetch, √© ela que ser√° substitu√≠da pelo resultado da requisi√ß√£o.\nAbaixo veja o exemplo da chamada da fun√ß√£o fetch:\n// fetches the remote view at /my-path and uses it to replace the entire current view beagleView.fetch({ path: '/my-path' }) // fetches the remote view at /my-lazy-container and uses it to replace the component with id 'lazy' beagleView.fetch({ path: '/my-lazy-container' }, 'lazy') fetch aceita 3 par√¢metros, e eles s√£o:\n loadParams: obrigat√≥rio. Objeto contendo os par√¢metros para controlar a requisi√ß√£o, veja as op√ß√µes a seguir:    path: obrigat√≥rio. Caminho para a view no backend.\n  fallback: opcional. A √°rvore do Beagle √© retornada em caso de erro.\n  method: opcional. get por padr√£o. Use essa op√ß√£o se voc√™ precisar de um m√©todo http.\n  headers: opcional. Use essa op√ß√£o para passar headers adicionais para uma √∫nica requisi√ß√£o.\n  shouldShowLoading: opcional. Mostra se voc√™ deve usar ou n√£o o loadingComponent. E usar√° a configura√ß√£o global caso n√£o for especificado.\n  shouldShowError?: opcional. Mostra se o componente da requisi√ß√£o falhou. E usar√° a configura√ß√£o global caso n√£o for especificado.\n  strategy: opcional. Mostra qual estrat√©gia de cache deve ser usada para carregar uma view espec√≠fica. E usar√° a configura√ß√£o global caso n√£o for especificado.\n  loadingComponent: opcional. O componente de carregamento a ser usado. E usar√° a configura√ß√£o global caso n√£o for especificado.\n  errorComponent: optional. O componente de erro a ser usado.\n anchor: opcional. Id do node a ser anexado no resultado da view, por padr√£o use o node raiz. √â usado para atualizar apenas uma branch.\n  mode: opcional. Como anexar o resultado da view direto do anchor, veja os quatro modos poss√≠veis:\n    replaceComponent: default. Substitui a √¢ncora com o resultado da requisi√ß√£o.\n  replace: substitui os filhos (children) da √¢ncora com o resultado da requisi√ß√£o.\n  prepend: adiciona o resultado da requisi√ß√£o no come√ßo da lista dos filhos da √¢ncora.\n  append: adiciona o resultado da requisi√ß√£o no final da lista dos filhos.\n  Inscrevendo os eventos Voc√™ pode se inscrever a eventos no Beagle View. H√° dois tipos de assinatura, a primeira escuta cada atualiza√ß√£o da √°rvore (beagleView.subscribe) e a outra observa cada erro do processo de busca/renderiza√ß√£o (beagleView.addErrorListener).\nQuando o beagleView.subscribe √© chamado, voc√™ deve passar o √∫nico par√¢metro, onde a fun√ß√£o recebe a √°rvore renderizada atual. Veja o exemplo abaixo:\nconst unsubscribeLogger = beagleView.subscribe((newTree) =\u003e { console.log('The tree was updated!') console.log(newTree) }) Para remover o ouvinte, apenas chame a fun√ß√£o retornada. No exemplo anterior unsubscribeLogger().\nOuvintes de erros s√£o registrados de forma similar, a √∫nica diferen√ßa √© que eles recebem uma lista de erros:\nconst removeErrorListener = beagleView.addErrorListener((errors) =\u003e { console.log('Oops! An error just happened!') console.log(errors) }) Por padr√£o, o Beagle loga cada erro que foi renderizado/buscado no processo at√© o console. Uma vez que o erro do ouvinte √© adicionado no Beagle View, o Beagle ir√° parar de de logar os erros por ele mesmo e usar o tratamento que voc√™ adicionou.\nDestruindo o Beagle View Para evitar vazamento de mem√≥ria, o Beagle View precisa ser destru√≠do, se n√£o for usado novamente. Se voc√™ estiver usando Angular ou React, n√£o h√° necessidade de se preocupar com isso, porque ser√° feito pelo framework. Se voc√™ estiver usando o Beagle Web, voc√™ deve chamar o beagleView.destroy() quando a remote view √© removida da p√°gina.\nAPI Voc√™ encontra abaixo todos os m√©todos do Beagle View e sua descri√ß√£o:\n   Atributo Tipo Defini√ß√£o     subscribe  fun√ß√£o Recebe o ouvinte e retorna a fun√ß√£o para cancelar a inscri√ß√£o.   \naddErrorListener  fun√ß√£o Subscreve aos erros. Recebe o ouvinte e retorna a fun√ß√£o para remov√™-lo.   fetch  fun√ß√£o Busca a view do backend e a usa para a atualizar a √°rvore.   getRenderer  fun√ß√£o retorna o redenrizador da view. Pode ser usado para atualizar a √°rvore diretamente.   getTree  fun√ß√£o retorna a c√≥pia da √°rvore renderizada.   getBeagleNavigator  fun√ß√£o retorna o navegador.   getBeagleService  fun√ß√£o retorna o BeagleService para criar a view.   destroy  fun√ß√£o destr√≥i a view.    ","excerpt":" Acessar e controlar o BeagleView As features descritas aqui est√£o ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/t%C3%B3picos-avan%C3%A7ados/beagle-view/","title":"Beagle view"},{"body":" Beagle Remote View Beagle‚Äôs library offers a component to help render the server-driven screens, remote view:\nAngular React \u003cbeagle-remote-view [loadParams]=\"loadParams\"\u003e\u003c/beagle-remote-view\u003e  \u003cBeagleRemoteView {...loadParams} /\u003e  Angular and React accept remote view‚Äôs properties that are called Load Params. It is through it, that some options are configured to influence the way the screens are rendered.\nSee below that properties accepted by it:\nimport { LoadParams } from '@zup-it/beagle-web'; const params: LoadParams = { path: '/payload.json', fallback: {_beagleComponent_: 'beagle:text', text:'Fallback Error'}, method: 'get', headers: {'header': 'value'}, shouldShowLoading: true, shouldShowError: true, strategy: \"network-only\", loadingComponent: 'myComponentLoading', errorComponent: 'myComponentError' }    Property Type Description     path string Required. Server path to load the JSON with the server-drive screen.   fallback BeagleComponent Component to be rendered in case the request fails.   method Http method Http method to make a request.   headers Map\u003ckey, value\u003e Header list to attach when you make a request.   shouldShowLoading boolean Show or not the loading component.   shouldShowError boolean Show or not the error component.   strategy string\u003cCache strategy\u003e Cache strategy used in the request.   loadingComponent string Customized component for loading.   errorComponent string Customized component for error.    ","excerpt":" Beagle Remote View Beagle‚Äôs library offers a component to help render ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/remote-view-parameters/","title":"Remote view parameters"},{"body":" As features descritas aqui, est√£o dispon√≠veis nas vers√µes a partir de 1.2.0.  Para entender melhor sobre renderiza√ß√£o, recomendamos a leitura da se√ß√£o estrutura de dados.\nCada biblioteca do Beagle Web possui um processo definido de como busca, processa e renderiza a view. H√° uma ordem que deve ser sempre respeitada e pontos de extens√£o (hooks), onde voc√™ pode executar seus c√≥digos (lifecycles).\nVeja o processo de renderiza√ß√£o do Beagle Web:\nOs lifecycles (ciclos de vida) do Beagle, s√£o:\n BeforeStart BeforeViewSnapshot AfterViewSnapshot BeforeRender  Eles podem ser usados como ganchos globais para o lifecycle:\nconst config = { // ... lifecycles: { beforeStart: (payload) =\u003e { // ... }, beforeViewSnapshot: (payload) =\u003e { // ... }, afterViewSnapshot: (payload) =\u003e { // ... }, beforeRender: (payload) =\u003e { // ... }, } } Ou os hooks locais para os lifecycles na base do componente (anota√ß√µes):\n// Attention: these won't work with production builds in Angular. Keep reading for more details. @BeforeStart((textComponentPayload) =\u003e { // ... }) @BeforeViewSnapshot((textComponentPayload) =\u003e { // ... }) @AfterViewSnapshot((textComponentPayload) =\u003e { // ... }) @BeforeRender((textComponentPayload) =\u003e { // ... }) @Component({ // ... }) class Text { // ... } O exemplo acima n√£o funciona com Angular quando for constru√≠do para produ√ß√£o, por causa do compilador. Para escrever um c√≥digo para a leitura do compilador dele, voc√™ deve escolher duas op√ß√µes:\n Adicione o coment√°rio// @dynamic antes de chamar a anota√ß√£o:  // @dynamic @BeforeRender((textComponentPayload) =\u003e { // ... }) @Component({ // ... }) class Text { // ... } Substitua a fun√ß√£o da flecha para uma fun√ß√£o comum e a exporte:  export function beforeRender(textComponentPayload) { // ... } @BeforeRender(beforeRender) @Component({ // ... }) class Text { // ... } Desde que as anota√ß√µes n√£o podem ser usadas por fun√ß√µes, se voc√™ tem algum componente funcional ou n√£o quer usar as anota√ß√µes, use normalmente as chamadas de fun√ß√µes:\nconst Table = (props) =\u003e { // ... } BeforeStart((textComponentPayload) =\u003e { // ... })(Table) √â importante notar que para o React, onde Higher Order Components (HOC) s√£o comuns, o componente que recebe a anota√ß√£o deve ser o final. Por isso, voc√™ deve aplicar ao nome do hoc withTheme ao seu componente:\nconst MyComponent: FC = () =\u003e { // ... } // This is wrong, it has no effect! // BeforeRender(myLifecycleFunction)(MyComponent) // export default withTheme(MyComponent) // You need to apply the decorator to the final component instead: const MyComponentWithTheme = withTheme(MyComponent) BeforeRender(myLifecycleFunction)(MyComponentWithTheme) export default MyComponentWithTheme O valor retornado do hook do lifecycle pode ser indefinido ou uma √°rvore. Se for uma √°rvore, o processo de renderiza√ß√£o ser√° descartar a √°rvore anterior e come√ßar a trabalhar na √°rvore retornada pelo hook.\nPara controlar o processo de renderiza√ß√£o, al√©m do lifecycles, o Beagle tamb√©m oferece a Renderer API, que pode ser acessada por meio do BeagleView.getRenderer(). O BeagleView pode ser acessado via o componente BeagleRemoteView, por meio de atributos como onCreateBeagleView no Angular e o viewRef no React.\nOutra forma de acessar o BeagleView √© por meio do ViewContentManager API, que pode ser encontrado no this.viewContentManager no componente do Angular que extende o BeagleComponent ou no props.viewContentManager no React, um componente que implementa a interface do BeagleComponent.\nProcesso e lifecycles Lifecycles deprecates the feature middlewares. Middlewares will still be supported at least until the next major version (2.0.0) and they will be interpreted as they were part of the global lifecycle beforeViewSnapshot.  Beagle possui um processo definido desde quando o payload √© recebido at√© quando √© renderizado na tela do browser. H√° tamb√©m os ‚Äòbreakpoints‚Äô que √© quando voc√™ faz seu processo, e isso √© chamado de lifecycle.\nProcesso para renderizar uma view Veja os passos abaixo para renderizar a view:\n Rode o hook global beforeStart; Rode o hook beforeStart para cada componente; Identifique os filhos de cada componente considerando a anota√ß√£o ‚ÄúBeagleChildren‚Äù; Atribua um id para cada node que n√£o tenha; Remova qualquer propriedade do objeto que possua o valor null; Se necess√°rio, fa√ßa uma pr√© busca das views que ser√£o acessadas em seguida; Rode o hook global beforeViewSnapshot; Rode o hook beforeViewSnapshot de cada componente; Tire um captura de tela da √°rvore e reserve. A partir de agora, qualquer refer√™ncia a a √°rvore renderizada, ser√° da c√≥pia dessa √°rvore. Come√ße processando a c√≥pia da captura de tela da view, o pr√≥ximo lifecycle rodar√° em cima dessa c√≥pia; Rode o hook global afterViewSnapshot; Rode o hook afterViewSnapshot para cada componente; Deserialize as a√ß√µes do Beagle em fun√ß√µes javascript;Deserialize beagle actions into javascript functions; Avalie os contextos e express√µes; Interprete os estilos, convertendo o estilo do Beagle a sintaxe de estilo do css; Rode o hook global beforeRender; Rode o hook beforeRender para cada componente; Passe a √°rvore do componente para a fun√ß√£o de renderiza√ß√£o. Essa fun√ß√£o √© diferente em Angular e React.  Lifecycles Existem quatro hooks de lifecycles, mas vo√™ usar√° apenas dois: beforeViewSnapshot e beforeRender. A diferen√ßa entre eles √© que o primeiro roda antes de qualquer express√£o ou a√ß√£o tenha sido avaliada e o segundo roda depois. √â importante mencionar, quando voc√™ usar a API Renderer, doFullRender rodar√° ambos lifecycles, mas o doPartialRender rodar√° apenas o lifecycle beforeRender.\nA regra simples para decidir se voc√™ uqer alterar a √°rvore via beforeViewSnapshot oubeforeRender √©: se sua modifica√ß√£o n√£o depende do resultado da express√£o, use o beforeViewSnapshot, caso contr√°rio, use o beforeRender.\nO lifecycle hook recebe da √°rvore do Beagle e retorna nada ou uma √°rvore. Se for uma √°rvore, o processo de renderiza√ß√£o discarta a √°rvore anterior e trabalha na retornada pelo hook.\n Lifecycle global: a √°rvore toda no Beagle. Componente lifecycle: a √°rvore significa uma branch correspondente ao componente.  Veja abaixo os detalhes de cada lifecycle:\nBeforeStart Este lifecycle roda antes de tudo, aqui algumas modifica√ß√µes devem ser feitas antes que id seja atribuido ou qualquer propriedade filho seja computada. Se o seu payload n√£o √© tudo que o Beagle espera, aqui √© onde voc√™ pode mud√°-lo.\nDesde que a tradu√ß√£o dos filhos ainda tenha sido rodada, os componentes decorados com @BeforeStart podem n√£o rodar. Por exemplo, um texto dentro do componente table que tem seus filhos definidos pela propriedade rows. Nesse cen√°rio o Beagle n√£o sabe que rows representa os filhos de table, ent√£o ele ignoraria tudo dentro desse componente.\nEsse √© o √∫nico lifecycle onde novas nodes podem ser adicionadas a √°rvores que n√£o tenha ids. Cada um deles, roda depois que os ids s√£o atribu√≠dos.\nExemplos de uso Custom ID generator Esse lifecycle pode ser usado para ignorar a gera√ß√£o de id padr√£o do Beagle e usar a sua pr√≥pria. O Beagle apenas aceita ids aleat√≥rios de nodes sem ids, voc√™ pode usar esse lifecycle para atribuir seu √∫nico ids para cada node:\nconst config = { // ... lifecycles: { beforeStart: (tree) =\u003e { let next = 1 function assignIds(data: any) { // if it's not a component or not a structure that can have a component inside, return if (!data || typeof data !== 'object') return // if it's an array, assign ids to the components inside if (Array.isArray(data)) return data.forEach(assignIds) // if it is a component node, assign an ID if (data._beagleComponent_) data.id = `myAppID-${next++}` // if it's an object, assign ids to the components inside const keys = Object.keys(data) keys.forEach(key =\u003e assignIds(data[key])) } assignIds(tree) } } } Complex children calculation\nUm caso complexo seria a c√°lculo de children. Os children de uma tabela de componentes √© a uni√£o de tr√™s propriedades header, rows e footer, mas isso n√£o pode ser expressado via anota√ß√£o @BeagleChildren, por isso esse lifecylce remove as propriedades do JSON original e cria a propriedade dos seus filhos, que seria a uni√£o das tr√™s propriedades.\nimport { BeforeStart } from '@zup-it/beagle-web' @BeforeStart((table) =\u003e { table.children = [header, ...rows, footer] delete table.header delete table.rows delete table.footer }) class Table { // ... } O exemplo acima funciona apenas com componentes que possuem children como nome da propriedade que representa seus filhos. E se esse n√£o for o caso, o lifecycle global pode ser usado.\nBeforeViewSnapshot Esse roda logo antes do snapshot da view, √© √∫til para alterar o payload, mas depois que os ids j√° fora atribu√≠dos. Aqui √© onde voc√™ deve modificar a √°rvore, j√° que os ids j√° est√£o atribu√≠dos e a estrutura da √°rvore est√° pronta para ser atravessada.\nTenha cuidado quando criar qualquer node nova, √© preciso atribuir os ids a ela.  Exemplos de uso Escrevendo um atalho para controlar os text-inputs O componente beagle:textInput pode ser controlado pelo contexto. Veja um exemplo, onde o valor de entrada do ‚Äòemail‚Äô √© controlado pela propriedade de contexto email.adress e a entrada de ‚Äòmessage‚Äô √© controlado por email.message:\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"email\", \"value\": { \"address\": \"\", \"message\": \"\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"E-mail\", \"value\": \"@{email.address}\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"email\", \"path\": \"address\", \"value\": \"@{onChange.value}\" } ] }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Message\", \"value\": \"@{email.message}\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"email\", \"path\": \"message\", \"value\": \"@{onChange.value}\" } ] }, ] } O ideal √© criar um atalho para evitar repeti√ß√µes, por exemplo, quando um json traz a propriedade model, √© criado uma estrutura automaticamente. No model, √© preciso ser digitado qual valor de contexto ir√° controlar essa entrada, veja abaixo:\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"email\", \"value\": { \"address\": \"\", \"message\": \"\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"E-mail\", \"model\": \"email.address\" }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Message\", \"model\": \"email.message\" } ] } Para isso funcionar, √© preciso escrever o lifecycle que ir√° transformar o model na estrutrua esperada:\nimport { BeforeViewSnapshot } from '@zup-it/beagle-web' @BeforeViewSnapshot((component) =\u003e { component.value = `@{${component.model}}` component.onChange = component.onChange || [] const [contextId, ...path] = component.model.split('.') component.onChange.push({ _beagleAction_: 'beagle:setContext', contextId, path: path ? path.join('.') : undefined, value: \"@{onChange.value}\" }) }) @Component({ // ... }) class TextInput { // ... } Com esse c√≥digo, apesar de estar recebendo o model do backend, o payload processado pelo Beagle ter√° os valores esperados.\nC√°lculo complexo da children com o BeforeViewSnapshot O exemplo anterior poderia ter sido feito sem o risco de pular algum lifecycle do componente devido a propriedade children estar nomeada incorretamente. A √∫nica diferen√ßa √© que voc√™ deve atribuir os ids:\nimport { BeforeViewSnapshot, Tree, Component } from '@zup-it/beagle-web' @BeforeStart((table) =\u003e { table.children = [header, ...rows, footer] delete table.header delete table.rows delete table.footer // assigns a random id for each component in the tree table.children Tree.forEach(table.children, Component.assignId) }) class Table { // ... } AfterViewSnapshot Quando usar a API Renderer, h√° dois tipos de renderizar: renderiza√ß√£o completa e renderiza√ß√£o parcial. Os dois lifecycles anteriores funcionam na completa, enquanto esse e os pr√≥ximos lifecycles funcionam nos dois.\nAs mudan√ßas feitas aqui s√£o v√°lidas para a renderiza√ß√£o atual. Qualquer atualiza√ß√£o da view √© feita por meio da √°rvore baseada na no snapshot da view, as modifica√ß√µes feitas nesse lifecycle n√£o s√£o permanentes e ser√£o executadas a cada renderiza√ß√£o. Se voc√™ tem uma propriedade counter com o valor 0 na √°rvore e no seu lifecycle √© com o valor 1. Na quinta renderiza√ß√£o completa, os valores de counter ser√£o:\n BeforeStart: 5 BeforeViewSnapshot: 5 AfterViewSnapshot: 1 BeforeRender: 1  Esse lifecycle pode ser usado para rodar o c√≥digo necess√°rio para que a view seja renderizada e n√£o requer a√ß√µes, contexto, express√µes e estilos, pois j√° foram processados.\nExemplos de uso Contextos s√£o definidos, referenciados e manipulados no JSON da view. Mas, se voc√™ quiser acessar os dados da aplica√ß√£o o Beagle oferece uma funcionalidade chamada Contexto Global, que √© possivel lidar com esse cen√°rio. Se n√£o tivesse essa fun√ß√£o, o lifecycle AfterViewSnapshot tamb√©m consegue lidar com isso.\nUm exemplo, se voc√™ tem uma aplica√ß√£o financeira e quer saber o balan√ßo do usu√°rio. Voc√™ deve garantir que cada haja a renderiza√ß√£o de cada valor recente.\n{ \"_beagleComponent_\": \"container\", \"context\": { \"id\": \"user\", \"value\": { \"name\": \"\", \"balance\": 0 } }, \"children\": [ { \"_beagleComponent_\": \"text\", \"text\": \"@{user.name}, your balance is $@{user.balance}\" } ] } No JSON acima, o contexto user foi usado, onde come√ßa com valores vazios e n√£o h√° possibilidade de saber os valores corretos. Agora, substitua o valores do contexto por valores da sua aplica√ß√£o, como abaixo:\nimport Tree from '@zup-it/beagle-web' function findContextById(tree, id) { const it = Tree.iterator(tree) let next = it.next() while (!next.done) { const component = next.value if (component.context \u0026\u0026 component.context.id === id) return component.context next = it.next() } } const config = { // ... lifecycles: { afterViewSnapshot: (payload) =\u003e { const userContext = findContextById(payload, 'user') const userData = getUserData() // this method gets the user data from the application userContext.name = userData.name userContext.balance = userData.balance } } } O c√≥digo n√£o pode ser feito antes do view ser snapshotted, porque o requisito √© atualizar o valor em cada renderiza√ß√£o. √â importante mencionar que a a√ß√£o setContext n√£o funciona sob o contexto de user. Lifecycles podem ser usados, mas √© recomendado usar o contexto global em casos de valores no Beagle view.\nBeforeRender As altera√ß√µes aqui s√£o v√°lidas apenas para a renderiza√ß√£o atual e s√£o executadas em todas as renderiza√ß√µes. A diferen√ßa entre BeforeRender e AfterViewSnapshot √© a garantia de que todas as a√ß√µes, express√µes e estilos j√° foram processadas.\nExemplos de uso Quando o backend decide expressar cores no seguintes formatos:{ red: number, green: number, blue: number }. Por exemplo, preto seria { red: 0, green: 0, blue: 0 }. Isso n√£o √© v√°lido para cores nos browsers, ent√£o √© preciso converter o valor de cada propriedade de cor para validar o formato RGB. Veja abaixo a fun√ß√£o:\nconst colorProperties: ['color', 'backgroundColor', 'borderColor'] function fixColorCodes(componentPayload) { const style = componentPayload.style if (!style) return colorProperties.forEach((property) =\u003e { if (!style[property]) return style[property] = `rgb(${style[property].red}, ${style[property].green}, ${style[property].blue})` }) } Agora, execute a fun√ß√£o acima para cada componente na √°rvore. Se voc√™ quiser ter um comportamento din√¢mico para a mudan√ßa de cor via contexto, veja o JSON abaixo:\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"bgColor\", \"value\": { \"red\": 255, \"green\": 255, \"blue\": 255 }, }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"My dynamically colored text\", \"style\": { \"backgroundColor\": \"@{bgColor}\" } }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"red\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 255, \"green\": 0, \"blue\": 0 } } ], \"_beagleComponent_\": \"beagle:button\", \"text\": \"green\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 0, \"green\": 255, \"blue\": 0 } } ], \"_beagleComponent_\": \"beagle:button\", \"text\": \"blue\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 0, \"green\": 0, \"blue\": 255 } } ] } ] } O texto come√ßa com o fundo branco e quando o usu√°rio apertar o bot√£o, o fundo muda de cor. Se voc√™ chamar fixColorCodes antes do contexto ser validado, ele estar√° tentando executar sobre a string @{bgColor} ao inv√©s do objeto { red: 255, green: 255, blue: 255 } o que pode ocorrer um erro no tempo, j√° que eles n√£o s√£o propriedades da string.\nBeforeStart, BeforeViewSnapshot and AfterViewSnapshot s√£o executados antes de cada contexto ser avaliado, ent√£o tudo que pode ser afetado por ele deve ser executado no √∫ltimo lifecycle: BeforeRender:\nimport { Tree } from '@zup-it/beagle-web' const config = { // ... lifecycles: { // ... beforeRender: tree =\u003e Tree.forEach(tree, fixColorCodes), } } The Renderer API Para controlar o processo de renderiza√ß√£o, o Beagle permite voc√™ gerenciar quando uma nova renderiza√ß√£o √© feita na √°rvore do Beagle View. Voc√™ pode ter um componente que quando √© clicado muda a √°rvore atual, para que um novo componente seja adicionado ou uma propriedade seja modificada.\nUm cen√°rio comum √© quando voc√™ cria uma a√ß√£o que muda a √°rvore atual, por exemplo, uma a√ß√£o addChildren, quando executada deve ir a √°rvore atual e adicionar o filho ao componente com o id dado. Para fazer isso, √© preciso ter uma forma de obter a √°rvore atual, modific√°-la e avisar ao Beagle View para renderizar de novo.\nA renderiza√ß√£o pode ser feita em dois processos: a completa e a parcial. A primeira executa todos os passos da lista no in√≠cio dessa p√°gina e a segunda executa apenas o view snapshot e os passos 9 ao 18 da mesma lista.\nAcessando o Renderer Cada Beagle View possui seu renderizador, para acess√°-lo, voc√™ deve chamar o beagleView.getRenderer().\nVeja os exemplos de como chegar ao renderizador:\n React: a refer√™ncia ao BeagleView pode ser obtida por meio da propriedade do viewRef do BeagleRemoteView:  import React, { FC, useRef, useEffect, MutableRefObject } from 'react' import { BeagleRemoteView } from '@zup-it/beagle-react' import { BeagleView } from '@zup-it/beagle-web' const Home: FC = () =\u003e { const beagleView = useRef() as MutableRefObject\u003cBeagleView | undefined\u003e useEffect(() =\u003e { if (beagleView.current) { const renderer = beagleView.current.getRenderer() } }, []) return ( \u003cBeagleRemoteView path=\"/home\" viewRef={beagleView} /\u003e ) }  Angular: voc√™ pode usar o atributo onCreateBeagleView do componente beagle-remote-view :  import { Component } from '@angular/core' import { LoadParams, BeagleView } from '@zup-it/beagle-web' @Component({ selector: 'home', template: '', }) export class Home { loadParams: LoadParams private beagleView: BeagleView constructor() { this.loadParams = { path: '/home' } } onCreateBeagleView(beagleView: BeagleView) { this.beagleView = beagleView } getRenderer() { return this.beagleView \u0026\u0026 this.beagleView.getRenderer() } } Quando dentro do componente renderizado pelo Beagle, voc√™ pode usar o ViewContentManager para acessar o BeagleView e obter o renderizador.\nQuando dentro do action handler (a√ß√µes customizadas), o Beagle View √© provido via parametro que pode ser usado para obter o renderizador, veja o exemplo abaixo:\nconst MyCustomActionHandler: ActionHandler\u003cMyCustomAction\u003e = ({ action, beagleView }) =\u003e { const renderer = beagleView.getRenderer() // ... } Usando o Renderer O renderizador possui duas fun√ß√µes: doFullRender edoPartialRender.\n doFullRender: renderiza a √°rvore passada como par√¢metro rodando todo os passos para renderiza√ß√£o. Renderiza√ß√£o completa deve ser feita toda vez que novas nodes s√£o criadas. doPartialRender: apenas roda a view snapshot e os passos depois disso. Renderiza√ß√£o parcial deve ser usada para modificar nodes existentes.  A √°rvore recebida pelo doFullRender √© o tipo de BeagleUIElement, por exemplo, e pode ou n√£o ter ids. A √°rvore recebida do doPartialRender √© o tipo de IdentifiableBeagleUIElement:\nExemplo: deve ter ids para cada node. Voc√™ nunca pode passar a √°rvore para odoPartialRender sem ids.\nAl√©m do tipo de √°rvore, n√£o h√° diferen√ßa na forma que o doFullRender e o doPartialRenders√£o chamados. Eles aceitam os seguintes par√¢metros:\n  O primeiro √© a √°rvore;\n  O segundo √© opcional e a √¢ncora. Se a √¢ncora n√£o for especificada, a √°rvore passada no primeiro par√¢metro ser√° substitu√≠da pela √°rvore renderizada. Se a √¢ncora √© especificada, a √°rvore passada como parametro ser√° anexada a √°rvore renderizada atual, na mesma posi√ßao que a node com id referenciado por anchor. Como o anexo √© feito √© definido pelo terceiro par√¢metro.\n  Opcional. √â o mode, se o modo n√£o √© definido, ele √© tratado como replaceComponent. H√° 4 modos diferentes:\n  replaceComponent: substitui a node com mesmo id que o par√¢metro\nanchor com a √°rvore passada no primeiro par√¢metro\n  replace: substitui a √°rvore passada no primeiro par√¢metro para a children do node com o mesmo id que o par√¢metro anchor (ou a ra√≠z, se o anchor n√£o for especificado).\n  prepend: precede a √°rvore passada no primeiro par√¢metro para a children do node com o mesmo id que o par√¢metro anchor (ou a ra√≠z, se o anchor n√£o for especificado).\n  append: acrescenta a √°rvore passada no primeiro par√¢metro para a children do node com o mesmo id que o par√¢metro anchor (ou a ra√≠z, se o anchor n√£o for especificado).\n    Exemplos: /* example 1: renders a container with an empty list */ beagleView.getRenderer().doFullRender({ _beagleComponent_: 'beagle:container', children: [ _beagleComponent_: 'custom:list', id: 'list', ], }) /* example 2: adds a property to the root of the currently rendered tree */ const current = beagleView.getTree() current.newProperty = 'new' beagleView.getRenderer().doPartialRender(current) /* example 3: adds an element to the \"custom:list\" inside the container */ const item = { _beagleComponent_: 'beagle:container', children: [ { _beagleComponent_: 'beagle:text', text: 'Client name: Jasnah Kholin' }, { _beagleComponent_: 'beagle:text', text: 'Client age: 30' } ] } // we should always do full renders when creating new nodes beagleView.getRenderer().doFullRender(item, 'list', { mode: 'append' })  Com a API do rendered, voc√™ pode alterar uma view quando quiser. Voc√™ n√£o pode chamar renderer.doFullRender(tree, componentId) no onInit do componente do Angular com o id componentId. Se isso for feito, o Beagle ir√° remover o componente da √°rvore antes de ser renderizado. Casos como esse podem acontecer usando o Beagle renderer dentro dos componentes de lifecycle.\nA solu√ß√£o do exemplo dado seria substituir a children do componente (renderer.doFullRender(tree, componentId, 'replace')).\n API ViewContentManager A list view √© um componente que precisa usar a Rendered API, mas como acessar o renderizador do componente? Em ambos Angular e React, isso pode ser feito via ViewContentManager.\nO ViewContentManager prov√™ um caminho para acessar o BeagleView e o node que a √°rvore atual do Beagle que deu origem ao componente sendo renderizado e com isso voc√™ pode acessar e chamar a renderiza√ß√£o desse componente espec√≠fico.\nAcessando o ViewContentManager React O ViewContentManager pode ser acessado dentro to componente do React, se ele implementar a interface do BeagleComponente.\nVeja abaixo o exemplo de re-renderizar o componente com um novo grupo de children baseado nos dados e no template:\nimport React, { FC, useRef, useEffect, MutableRefObject } from 'react' import { BeagleComponent } from '@zup-it/beagle-react' interface ListViewInterface extends BeagleComponent { // ... } const ListView: FC\u003cListViewInterface\u003e = (props) =\u003e { useEffect(() =\u003e { /* Once the component implements the BeagleComponent interface, we have access to the viewContentManager, but if the component was not instantiated by Beagle, the viewContentManager will be undefined. We must verify it before continuing. */ if (!props.viewContentManager) return const children = createChildrenFromTemplate(props.dataSource, props.template) const element = props.viewContentManager.getElement() element.children = children props.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id) }, [props.dataSource, props.template]) return ( // ... ) } Isso acontece quando a fonte de dados ou template mudam.\nAngular No Angular, se voc√™ precisar acessar o ViewContentManager, a classe do componente deve extender o BeagleComponent, ent√£o voc√™ pode referenciar a this.viewContentManager.\nimport { Component, Input } from '@angular/core' import { BeagleComponent } from '@zup-it/beagle-angular' @Component({ // ... }) export class ListView extends BeagleComponent { // ... renderDataSource() { /* Checks if the viewContentManager is available. If the components has not been created by Beagle, it won't be. */ if (!this.viewContentManager) return const children = this.createChildrenFromTemplate(this.dataSource, this.template) const element = this.viewContentManager.getElement() element.children = children this.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id) } } O m√©todo renderDataSource deve ser chamado toda vez que a fonte de dados ou o template mudarem.\nUsando o ViewContentManager O ViewContentManager possui as seguintes propriedades e fun√ß√µes: have the following properties/functions\n   Propriedade Tipo Defini√ß√£o     \u003cb\u003e\u003c/b\u003e\ngetElement()  fun√ß√£o retorna a node na √°rvore do Beagle respons√°vel pela renderiza√ß√£o do componente.   \ngetElementId()  fun√ß√£o atalho para o getElement().id    getBeagleView()  fun√ß√£o retorna o BeagleView respons√°vel pela view contendo o componente.    Atualizando a view com o resultado da requisi√ß√£o Caso voc√™ precisa atualizar a view atual com a √°rvore que vem do backend, voc√™ deve usar o m√©todo fetch do BeagleView. Isso ir√° internamente usar todo o mecanismo de cache do Beagle e tamb√©m a parte de renderiza√ß√£o.\n","excerpt":" As features descritas aqui, est√£o dispon√≠veis nas vers√µes a partir de ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/t%C3%B3picos-avan%C3%A7ados/renderiza%C3%A7%C3%A3o/","title":"Renderiza√ß√£o"},{"body":" Beagle Service To use the Beagle library, it is necessary to create a Beagle Service with the configurarion where and how to search server-driven screens.\n On React you can easily create a Beagle Service through the function**createBeagleService(beagleServiceOptions)**\n  On Angular the base code is automatically generated and the properties can be modify and added on beagle.module.ts.\n The configuration object has the following properties:\n   Attribute Type Default Required Description     baseUrl string  ‚úì URL to the server with screens (JSON) on Beagle format.   components Map\u003cstring,Component\u003e  ‚úì A components map that will be rendered through Beagle‚Äôs library. The values are key pairs and value where the key is identifier Beagle will always start by beagle: or custom:. The value will always be the component connected to identifier.   strategy Strategy beagle-with-fallback-to-cache  Cache strategy applied on requests of the server screen.   fetchData fetch   It allows to add a customized function t to make HTTP requests.   analytics Analytics   It allows the use of handlers to the tag capture of some events.   customActions Map\u003cstring,ActionHandler\u003e   A customized action map that can be interpreted by Beagle‚Äôs library. It is a key and value map where the key will always be an identifier starting by beagle: or custom: and the value will be the ActionHandler connected to that action.   lifecycles LifeCycleHook   A global map to add lifecycles behaviors of the components. Each cycle happens on the screen renderization process, before the components become HTML.   customStorage Storage localStorage  It replaces the localStorage default of the browsers.   useBeagleHeaders boolean true  It uses or not Beagle‚Äôs specific headers when it requests to the server screens.   navigationControllers Map\u003cstring, NavigationController\u003e   It allows you to add control options of the visual response, like show the no items of loading and errors components.    ","excerpt":" Beagle Service To use the Beagle library, it is necessary to create a ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/beagle-service-parameter/","title":"Beagle Service Parameter"},{"body":" Beagle for backend has the following customizations:\n","excerpt":" Beagle for backend has the following customizations:\n","ref":"/docs-beagle/docs/resources/customization/beagle-for-backend/","title":"Beagle for Backend"},{"body":" O Beagle para backend possui as seguintes customiza√ß√µes:\n","excerpt":" O Beagle para backend possui as seguintes customiza√ß√µes:\n","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-backend/","title":"Beagle para Backend"},{"body":" This section explains how to create a backend without using frameworks such as Spring or Micronaut. You will find the tools to create a BFF to your project.\nIt‚Äôs important to say that:\n Beagle was created to be independent, you dont need a specific backend structure. starters of the initial configuration already does all the process described in this page and automatically add the configuration below:  It‚Äôs worth to reinforce that the initial configuration customization does not apply to this module.  Follow the next steps to configure your BFF manually:\nStep 1: Add dependencies \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003eframework\u003c/artifactId\u003e \u003cversion\u003e${beagle_version}\u003c/version\u003e \u003c/dependency\u003e Step 2: Configure the Jackson‚Äôs ObjectMapper It is necessary to setup Jackson‚Äôs ObjectMapper for Beagle. There are two ways to do this:\nFirst, you can register BeagleModule in yourObjectMapper.\nval mapper = // however your ObjectMapper is initialized mapper.registerModule(BeagleModule) Or you can use the function beagleObjectMapper. This function returns a ObjectMapper using jacksonObjectMapper()https://github.com/ZupIT/beagle/pull/229/files with a BeagleModule registered.\nval mapper = BeagleSerializationUtil.beagleObjectMapper() Step 3: Configure the BeagleCacheHandler In order to use the cache mechanism, Beagle offers a class called BeagleCacheHandler and an interface RestCacheHandler. It is recommended to use them as a response filter in your project.\nBeagleCacheHandler class contains a implementation template of the protocol. This template doesn‚Äôt depend of the HTTP and REST structure and uses a handleCache method. However, it needs to interact with the HTTP response details, then RestCacheHandler is used.\nUsing the javax.servlet See below a demostration of this class, it was implemented using a javax.servlet class.\n A javax.servlet.Filter filter was created. It applies to the cache protocol for every response given by the backend. To focus on the cache managers, the javax.servlet.HttpServletResponse was left out, this omission is addressed in the codes with comments.  Step 4: Implement the RestCacheHandler You have to implement a RestCacheHandler interface, with four transformation that a manipulator needs to run in your response object. It is generic and it must be specified for the kind of response used in your HTTP structure. Your methods must behave like described below:\n   Method Behaviour     addHashHeader(response, header) Returns a response with aheader adding their headers to the BeagleCacheHandler.CACHE_HEADER key   addStatus(response, status) Returns a response with a status   callController(response) Returns a response resulting from the calling of the controller (generally following the filter chain).   getBody(response) Returns a body of the response with a String    class MyCacheHandler( private val request: HttpServletRequest, private val chain: FilterChain ) : RestCacheHandler\u003cHttpServletResponse\u003e { override fun addHashHeader( response: HttpServletResponse, header: String ): HttpServletResponse { response.setHeader(BeagleCacheHandler.CACHE_HEADER, header) return response } override fun addStatus( response: HttpServletResponse, status: Int ): HttpServletResponse { response.status = status return response } override fun callController(response: HttpServletResponse): HttpServletResponse { this.chain.doFilter(this.request, response) return response } // There is no direct way to access an HttpServletResponse's content,  // this is only to demonstrate the idea  override fun getBody(response: HttpServletResponse) = response.content } Step 5: Create a Filter that uses theBeagleCacheHandler Now, you need to create an BeagleCacheHandler instance and call the handleCache method for it. This instance can accept a string list that represents a regex‚Äôs endpoint to not be stored in cache.\nThey must be a valid java.util.regex.Pattern. The handleCache parameters are described below. This filter returns a transformed response:\n   Parameter Description     endpoint endpoint requested.   receivedHash BeagleCacheHandler.CACHE_HEADER value that came with the request.   initialResponse A type of response to be transformed.   restCacheHandler your implementation instance of the RestCacheHandler.    class MyFilter : Filter { private val beagleCacheHandler = BeagleCacheHandler() override fun doFilter( request: ServletRequest?, response: ServletResponse?, chain: FilterChain? ) { if (request is HttpServletRequest \u0026\u0026 response is HttpServletResponse \u0026\u0026 chain != null) { this.beagleCacheHandler.handleCache( request.requestURI, request.getHeader(BeagleCacheHandler.CACHE_HEADER), response, MyCacheHandler(request, chain) ) } } } Step 6: Configure the platform‚Äôs specification mechanism In order to have the element‚Äôs filtration by platform working, it is necessary to configurate. It is recommended to register a filter that verifies your BFF‚Äôs response and filters the sent elements according to the specified platform on your customized beagle-platform header.\nThe BeaglePlatformUtil class was created to provide some tools to make the configuration easier to be used in your filter. See below:\n   Constant Description     BEAGLE_PLATFORM_HEADER Name of the header field used by Beagle to verify which platform BFF is interacting with.       Method Description     treatBeaglePlatform(currentPlatform, jsonNode) Returns a JsonNode as a parameter jsonNode with elements that the platform does not correspond to the parameter currentPlatform removed    An example of a Spring interceptor:\nclass BeaglePlatformInterceptor(private val objectMapper: ObjectMapper) : HandlerInterceptor { override fun preHandle(request: HttpServletRequest, response: HttpServletResponse, handler: Any): Boolean { request.setAttribute( BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER, request.getHeader(BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER) ) return true } override fun postHandle( request: HttpServletRequest, response: HttpServletResponse, handler: Any, modelAndView: ModelAndView? ) { val responseWrapper = (response as ContentCachingResponseWrapper) val jsonTree = this.objectMapper.readTree(responseWrapper.contentAsByteArray) BeaglePlatformUtil.treatBeaglePlatform( request.getHeader(BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER), jsonTree ) val jsonData = jsonTree.toPrettyString() responseWrapper.resetBuffer() responseWrapper.outputStream.write(jsonData.toByteArray()) responseWrapper.setContentLength(jsonData.length) } } The example above, preHandle passed the information from the platform the request was made as an attribute, so that it can be accessed after by BFF and then it will make the platform‚Äôs identification easier. We also have postHandle that filters the elements according to the targeted platform in your BFF‚Äôs response.\n","excerpt":" This section explains how to create a backend without using ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-backend/beagle-framework/","title":"Beagle Framework"},{"body":" Esta se√ß√£o explica como criar um backend sem fazer uso das configura√ß√µes prontas para os frameworks Spring ou Micronaut. Voc√™ encontrar√° as ferramentas necess√°rias para criar um Backend(BFF) para o seu projeto.\n√â importante refor√ßar que:\n Beagle foi projetado para ser independente de qualquer estrutura de backend espec√≠fica, como Micronaut ou Spring. Os Starters da configura√ß√£o inicial j√° fazem todo o processo descrito nesta p√°gina e adicionam automaticamente as configura√ß√µes abaixo.  Vale refor√ßar que as customiza√ß√µes da configura√ß√£o inicial n√£o se aplicam a esse m√≥dulo.  Para configurar seu BFF manualmente, siga os seguintes passos:\nPasso 1: Adicionar as depend√™ncias \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003eframework\u003c/artifactId\u003e \u003cversion\u003e${beagle_version}\u003c/version\u003e \u003c/dependency\u003e Passo 2: Configurar o ObjectMapper do Jackson Na configura√ß√£o do projeto no backend √© necess√°rio realizar o setup doObjectMapper do Jackson para o Beagle. Existem duas maneiras de fazer isso:\nPrimeiro, voc√™ pode registrar o BeagleModule no seuObjectMapper.\nval mapper = // however your ObjectMapper is initialized mapper.registerModule(BeagleModule) Ou voc√™ pode utilizar a fun√ß√£o utilit√°riabeagleObjectMapper. Essa fun√ß√£o retorna um ObjectMapper usando o jacksonObjectMapper() com um BeagleModule registrado.\nval mapper = BeagleSerializationUtil.beagleObjectMapper() Passo 3: Configurar o BeagleCacheHandler Para fazer uso do mecanismo de cache, o Beagle oferece uma classe chamada BeagleCacheHandler e uma interface chamada RestCacheHandler. √â recomendado us√°-las como um filtro de resposta em seu projeto.\nA classe BeagleCacheHandler cont√©m um template de implementa√ß√£o do protocolo. Este template √© independente da estrutura HTTP e REST e utiliza o m√©todo de inst√¢ncia handleCache.\nNo entanto, ele precisa interagir com os detalhes da resposta HTTP, e √© aqui que o RestCacheHandler √© acionado.\nUsando o javax.servlet Para demonstrar o funcionamento dessas classes, o exemplo abaixo foi implementado utilizando uma classe do javax.servlet.\n Como recomendado, foi criado um filtro javax.servlet.Filter que aplica o protocolo de cache para toda resposta dada pelo backend do qual ele faz parte. Com o objetivo de focar no uso dos gerenciadores de cache, a parte do c√≥digo que ojavax.servlet.HttpServletResponserequer, foi omitida. Essa omiss√£o √© apontada nos c√≥digos com coment√°rios.  Passo 4: Implementar o RestCacheHandler Voc√™ precisa implementar a interface RestCacheHandler, composta por quatro transforma√ß√µes que o manipulador precisa executar no seu objeto de resposta. √â gen√©rico e deve ser especializado para o tipo de resposta disponibilizada em sua estrutura HTTP. Seus m√©todos devem se comportar conforme descrito abaixo:\n   M√©todo Comportamento     addHashHeader(response, header) Retorna a resposta com header adicionado aos headers dela na chave BeagleCacheHandler.CACHE_HEADER   addStatus(response, status) Retorna uma resposta com status ao inv√©s de uma resposta com o status do HTTP atual   callController(response) Retorna a resposta resultante da chamada do controlador atual (geralmente prosseguindo na cadeia de filtros).   getBody(response) Retorna o corpo da resposta como uma String    class MyCacheHandler( private val request: HttpServletRequest, private val chain: FilterChain ) : RestCacheHandler\u003cHttpServletResponse\u003e { override fun addHashHeader( response: HttpServletResponse, header: String ): HttpServletResponse { response.setHeader(BeagleCacheHandler.CACHE_HEADER, header) return response } override fun addStatus( response: HttpServletResponse, status: Int ): HttpServletResponse { response.status = status return response } override fun callController(response: HttpServletResponse): HttpServletResponse { this.chain.doFilter(this.request, response) return response } // There is no direct way to access an HttpServletResponse's content,  // this is only to demonstrate the idea  override fun getBody(response: HttpServletResponse) = response.content } Passo 5: Criar um Filter que utilize oBeagleCacheHandler Logo depois, voc√™ precisa criar uma inst√¢ncia do BeagleCacheHandler e chamar o m√©todo handleCache nele. O construtor do BeagleCacheHandler pode aceitar uma lista de strings que representam a regex do endpoint para n√£o ser armazenada em cache.\nEles devem ser um java.util.regex.Pattern v√°lido. Os par√¢metros para o m√©todo handleCacheest√£o descritos abaixo.\nEsse filtro retorna uma resposta totalmente transformada:\n   Par√¢metro Descri√ß√£o     endpoint O endpoint requisitado.   receivedHash O valor doBeagleCacheHandler.CACHE_HEADER que veio com a requisi√ß√£o.   initialResponse Uma inst√¢ncia do tipo de resposta a ser transformada.   restCacheHandler Inst√¢ncia da sua implementa√ß√£o do RestCacheHandler.    class MyFilter : Filter { private val beagleCacheHandler = BeagleCacheHandler() override fun doFilter( request: ServletRequest?, response: ServletResponse?, chain: FilterChain? ) { if (request is HttpServletRequest \u0026\u0026 response is HttpServletResponse \u0026\u0026 chain != null) { this.beagleCacheHandler.handleCache( request.requestURI, request.getHeader(BeagleCacheHandler.CACHE_HEADER), response, MyCacheHandler(request, chain) ) } } } Passo 6: Configurar o mecanismo de especifica√ß√£o de plataforma Para que o Beagle tenha o funcionamento esperado na filtragem de elementos por plataforma, √© necess√°rio realizar algumas configura√ß√µes.\n√â recomendado registrar um filtro ou um interceptor que verifique a resposta de seu BFF e filtre os elementos enviados de acordo com a plataforma especificada no header customizado beagle-platform.\nA classe BeaglePlatformUtil foi criada disponibilizando algumas ferramentas para facilitar essa configura√ß√£o e ser usada em seu filtro/interceptor. Elas s√£o especificadas abaixo:\n   Constante Descri√ß√£o     BEAGLE_PLATFORM_HEADER Nome do campo header utilizado pelo Beagle para verificar com qual plataforma o BFF est√° interagindo       M√©todo Descri√ß√£o     treatBeaglePlatform(currentPlatform, jsonNode) Retorna o JsonNode passado como par√¢metro jsonNode com os elementos cuja plataforma n√£o correspondem ao par√¢metro currentPlatform removidos    Um exemplo de interceptor para Spring:\nclass BeaglePlatformInterceptor(private val objectMapper: ObjectMapper) : HandlerInterceptor { override fun preHandle(request: HttpServletRequest, response: HttpServletResponse, handler: Any): Boolean { request.setAttribute( BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER, request.getHeader(BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER) ) return true } override fun postHandle( request: HttpServletRequest, response: HttpServletResponse, handler: Any, modelAndView: ModelAndView? ) { val responseWrapper = (response as ContentCachingResponseWrapper) val jsonTree = this.objectMapper.readTree(responseWrapper.contentAsByteArray) BeaglePlatformUtil.treatBeaglePlatform( request.getHeader(BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER), jsonTree ) val jsonData = jsonTree.toPrettyString() responseWrapper.resetBuffer() responseWrapper.outputStream.write(jsonData.toByteArray()) responseWrapper.setContentLength(jsonData.length) } } No exemplo acima, preHandle passa a informa√ß√£o da plataforma pela qual a requisi√ß√£o foi feita como um atributo da request, para que ele possa ser acessado posteriormente pelo BFF e facilite a identifica√ß√£o da plataforma. J√° o postHandle realiza o trabalho de filtrar os elementos devidos de acordo com a plataforma alvo na resposta de seu BFF.\n","excerpt":" Esta se√ß√£o explica como criar um backend sem fazer uso das ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-backend/beagle-framework/","title":"Beagle Framework"},{"body":" Definition  Since mostly of the frameworks integrate to Jackson and offer proprieties to customize serialization, we decided to not add our proprieties. Instead of that, we kept the compatibility with your chosen framework.\nCustomization  Inside the folder src/main/resources, look for a file called application.properties. If you don‚Äôt have it, you can easily create. In case the key isn‚Äôt listed on this file, it means that the standard configuration will be automatically applied.\nOn the links below you can see the available configurations to make the serialization according to the framework:\n ‚ÄãMicronaut‚Äã ‚ÄãSpring‚Äã  In the case of Spring, you must use only keys spring.jackson  ","excerpt":" Definition  Since mostly of the frameworks integrate to Jackson and ‚Ä¶","ref":"/docs-beagle/docs/resources/customization/beagle-for-backend/serialization/","title":"Serialization"},{"body":" Como a maioria dos frameworks integram com Jackson e oferecem propriedades para customizar serializa√ß√£o, optamos por n√£o adicionar propriedades nossas. Em vez disso, mantivemos a compatibilidade com seu framework escolhido.\nCustomiza√ß√£o Dentro da pasta src/main/resources procure por um arquivo chamado(se n√£o existir pode criar) application.properties. Caso a chave n√£o esteja listada no seu arquivo, significa que a configura√ß√£o padr√£o ser√° automaticamente aplicada.\nNos links abaixo voc√™ confere as propriedades dispon√≠veis para serializa√ß√£o de acordo com framework:\n Micronaut Spring‚Äã  No caso do Spring, deve-se utilizar apenas as chaves spring.jackson  ","excerpt":" Como a maioria dos frameworks integram com Jackson e oferecem ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-backend/serializa%C3%A7%C3%A3o/","title":"Serializa√ß√£o"},{"body":" Beagle offers two ways to define your components using builders:\n Pattern builder DSL builder  With them, you are able to use the platform‚Äôs components in a declarative way with Kotling or more practical way to assemble the components with your pattern values, in case if you are using Java instead of Kotlin.\nYou can mix two available ways to define a component.  Pattern builder The way to use the patterns builder on Beagle is similiar to any other builder you have used before. The builder‚Äôs name is generally the component‚Äôs name with the suffix Builder attached.\nThe exceptions are the components with the type:\n sealed classes, builders that has its father class as an attached prefix. Screen, builder that is a ScreenComponentBuilder.  Java Kotlin //Navigate is a sealed class with //OpenNativeRoute as a child class new NavigateOpenNativeRouteBuilder() .route(\"/route\") .shouldResetApplication(false) .data(new HashMap\u003cString, String\u003e()) .build();  //Navigate is a sealed class with //OpenNativeRoute as a child class NavigateOpenNativeRouteBuilder() .route(\"/route\") .shouldResetApplication(false) .data(mutableMapOf\u003cString, String\u003e()) .build()  DSL builder To define a Beagle component using this method, you have to declare the component and its properties using keys and methods with the same field name to be declared or directly by the attribution operator (=). See the example below:\nalert{ title{ valueOf(\"Titulo\") }//using the keys  message( valueOf(\"Message\") )//using the methods  labelOk = \"OK\"//attributing the value directly } //equivalent Alert( title = valueOf(\"Titulo\"), message = valueOf(\"Message\"), labelOk = \"OK\" ) In cases where the field waits a list or a map, you have to put before the elemement to be added in the collection with the operator ‚Äò+‚Äô. This operator also accepts a unique element. See the examples:\nLists Maps container{ children{ +Text(\"Hello\") +Text(\"There\") +listOf(Text(\"General\"), Text(\"Kenobi\")) } } //equivalent Container(children = listOf( Text(\"Hello\"), Text(\"There\"), Text(\"General\"), Text(\"Kenobi\") ))  navigateOpenNativeRoute { route = \"/route\" shouldResetApplication = false data{ +(\"Content-Type\" to \"application/json\") +mapOf( \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\" ) } } //equivalent Navigate.OpenNativeRoute( route = \"/route\", shouldResetApplication = false, data = mapOf( \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\" ) )  Example The example below defines a simple declared screen in the three available options on Beagle:\nPattern Builder DSL Pattern builder Screen( navigationBar = NavigationBar( title = \"Navigation Bar Title\", showBackButton = false ), child = Text( text = valueOf(\"Hello There\") ).applyStyle(Style( margin = EdgeValue(bottom = 10.unitReal()) )) )  screen{ navigationBar{ title = \"Navigation Bar Title\" showBackButton = true } child{ text{ text = valueOf(\"Hello There\") }.style { margin{ bottom = 10.unitReal() } } } }  ScreenComponentBuilder() .navigationBar( NavigationBarBuilder() .title(\"Navigation Bar Title\") .showBackButton(true) .build() ).child( TextBuilder() .text(valueOf(\"Hello There\")) .build().applyStyle( StyleBuilder() .margin( EdgeValueBuilder() .bottom(10.unitReal()) .build() ) .build() ) ).build()  ","excerpt":" Beagle offers two ways to define your components using builders: ‚Ä¶","ref":"/docs-beagle/docs/resources/builders-for-kotlin-dsl/","title":"Builders for Kotlin Dsl"},{"body":" Criando a a√ß√£o no frontend No Beagle, √© poss√≠vel criar uma a√ß√£o customizada a partir de uma CustomAction .\nCada plataforma tem sua forma pr√≥pria para fazer esta implementa√ß√£o no frontend. Abaixo, listamos exemplos para cada uma.\nAndroid iOS Web Primeiro, voc√™ deve criar uma classe anotada com @RegisterAction que implemente a interface Action. Esta mesma interface solicitar√° que o m√©todo execute seja implementado e, aqui, voc√™ ir√° declarar o resultado da action.\nO atributo msg listado √© apenas um exemplo de par√¢metro que pode ser declarado no construtor desta classe. O exemplo a seguir mostra uma a√ß√£o com Toast:\n@RegisterAction data class CustomAction( val msg: String? = null ) : Action { override fun execute(rootView: RootView) { Toast.makeText( rootView.getContext(), msg, Toast.LENGTH_LONG).show() } }  Primeiro, voc√™ deve criar uma classe que implemente o tipo Action. Esta mesma classe solicitar√° que o m√©todo execute seja implementado e ir√° ditar as a√ß√µes da action .\nO atributo msg listado √© apenas um exemplo de par√¢metro que pode ser declarado no construtor desta classe. O exemplo a seguir mostra uma a√ß√£o com Alert:\nclass CustomAction: Action { let msg: String? init(msg: String? = nil) { self.msg = msg } func execute(controller: BeagleController, sender: Any) { let alert = UIAlertController( title: nil, message: msg, preferredStyle: .alert ) controller.present(alert, animated: true) } } Para registrar a a√ß√£o, basta criar um m√©todo onde ter√° todas suas custom action e chamar o m√©todo do Beagle registerCustomAction que far√° o registro.\nChame o m√©todo criado no BeagleConfig, tal como no tutorial da se√ß√£o ‚ÄúCriando um projeto do zero‚Äù. \nprivate func registerCustomAction() { Beagle.registerCustomAction(\"CustomAction\", actionType: CustomAction.self) }  Primeiro, voc√™ deve criar uma interface com a propriedade obrigat√≥ria _beagleAction_ __e os par√¢metros necess√°rios para sua a√ß√£o. Para este exemplo, criaremos o atributo msg do tipo string.\nEm ___beagleAction_ , coloque o nome da a√ß√£o customizada seguindo o padr√£o ‚Äòcustom:nomeDaA√ß√£o‚Äô\ninterface CustomAction { _beagleAction_: 'custom:CustomAction', msg: string } Feito isso, declare uma fun√ß√£o do tipo ActionHandler com a interface que voc√™ acabou de criar.\nimport { ActionHandler } from '@zup-it/beagle-web' export const customHandler: ActionHandler\u003cCustomAction\u003e = ({ action }) =\u003e { /* Podemos acessar nosso par√¢metro definido na interface, por exemplo action.msg nos traz o valor de msg. */ alert(action.msg) } Por fim, adicione o nome da a√ß√£o no arquivo de associa√ß√µes de acordo com cada framework:\nPara o Angular, adicione em beagle.module.ts\n@BeagleModule({ ... customActions:{ \"custom:CustomAction\": customHandler //nome do action handler  } }) export class Beagle {} Para o React, adicione ao seu arquivo de configura√ß√µes do Beagle\nexport default createBeagleUIService\u003cany\u003e({ ... customActions:{ \"custom:CustomAction\": customHandler //nome do action handler  } })  Criando a refer√™ncia da a√ß√£o no backend Para criar a refer√™ncia, o seu c√≥digo deve ficar assim:\n@RegisterAction data class CustomAction( val msg: String? = null ) : Action Abaixo, temos um exemplo de Action em um componente do tipo Bot√£o.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Beagle Button\", \"onPress\": [ { \"_beagleAction_\": \"custom:customAction\", \"msg\": \"Eu sou um Toast.\" } ] }  Button( text = \"Beagle Button\", onPress = listOf(CustomAction(\"Eu sou um Toast\")) )  ","excerpt":" Criando a a√ß√£o no frontend No Beagle, √© poss√≠vel criar uma a√ß√£o ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/cria%C3%A7%C3%A3o-de-novas-a%C3%A7%C3%B5es/","title":"Cria√ß√£o de novas a√ß√µes"},{"body":" O Beagle fornece duas maneiras para definir seus componentes utilizando builders.\n Builder padr√£o Builder DSL  Com eles, voc√™ consegue usar os componentes da plataforma de forma declarativa com Kotlin ou de uma maneira mais pr√°tica para montar os componentes com seus valores padr√µes, caso esteja utilizando Java ao inv√©s de Kotlin.\nVoc√™ pode misturar as 3 maneiras dispon√≠veis para definir um componente.  Builder padr√£o A maneira de usar os builders padr√µes do Beagle √© semelhante a qualquer outro builder que voc√™ j√° tenha utilizado. O nome de cada builder de forma geral √© o nome do componente com o sufixo Builder anexado.\nAs exce√ß√µes s√£o componentes do tipo:\n sealed classes, cujo builders possuem o nome de sua classe pai como prefixo anexado. Screen, cujo builder √© ScreenComponentBuilder.  Java Kotlin DSL //Navigate √© uma sealed class com //OpenNativeRoute como uma classe filha new NavigateOpenNativeRouteBuilder() .route(\"/route\") .shouldResetApplication(false) .data(new HashMap\u003cString, String\u003e()) .build();  //Navigate √© uma sealed class com //OpenNativeRoute como uma classe filha NavigateOpenNativeRouteBuilder() .route(\"/route\") .shouldResetApplication(false) .data(mutableMapOf\u003cString, String\u003e()) .build()  Builder DSL Para definir um componente do Beagle utilizando esse m√©todo, voc√™ deve declarar o componente e suas propriedades utilizando chaves e m√©todos com o mesmo nome do campo a ser declarado ou diretamente pelo operador de atribui√ß√£o (=). Veja o exemplo:\nalert{ title{ valueOf(\"Titulo\") }//utilizando as chaves  message( valueOf(\"Message\") )//utilizando os m√©todos  labelOk = \"OK\"//atribuindo o valor diretamente } //equivalente Alert( title = valueOf(\"Titulo\"), message = valueOf(\"Message\"), labelOk = \"OK\" ) Nos casos em que o campo espera uma lista ou um mapa, voc√™ deve colocar antes do elemento a ser adicionado na cole√ß√£o com o operador ‚Äò+‚Äô. Esse operador tamb√©m aceita elemento √∫nico. Veja os exemplos:\nListas Mapas container{ children{ +Text(\"Hello\") +Text(\"There\") +listOf(Text(\"General\"), Text(\"Kenobi\")) } } //equivalente Container(children = listOf( Text(\"Hello\"), Text(\"There\"), Text(\"General\"), Text(\"Kenobi\") ))  navigateOpenNativeRoute { route = \"/route\" shouldResetApplication = false data{ +(\"Content-Type\" to \"application/json\") +mapOf( \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\" ) } } //equivalente Navigate.OpenNativeRoute( route = \"/route\", shouldResetApplication = false, data = mapOf( \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\" ) )  Exemplo O exemplo abaixo define uma tela simples declarada nas tr√™s maneiras dispon√≠veis pelo Beagle:\nPadr√£o Builder DSL Builder Padr√£o Screen( navigationBar = NavigationBar( title = \"Navigation Bar Title\", showBackButton = false ), child = Text( text = valueOf(\"Hello There\") ).applyStyle(Style( margin = EdgeValue(bottom = 10.unitReal()) )) )  screen{ navigationBar{ title = \"Navigation Bar Title\" showBackButton = true } child{ text{ text = valueOf(\"Hello There\") }.style { margin{ bottom = 10.unitReal() } } } }  ScreenComponentBuilder() .navigationBar( NavigationBarBuilder() .title(\"Navigation Bar Title\") .showBackButton(true) .build() ).child( TextBuilder() .text(valueOf(\"Hello There\")) .build().applyStyle( StyleBuilder() .margin( EdgeValueBuilder() .bottom(10.unitReal()) .build() ) .build() ) ).build()  ","excerpt":" O Beagle fornece duas maneiras para definir seus componentes ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/builders-para-kotlin-dsl/","title":"Builders para Kotlin Dsl"},{"body":" Beagle offers a style resources for your components. You can know more about this process checking out the styles for each operational system in the next pages:\n","excerpt":" Beagle offers a style resources for your components. You can know ‚Ä¶","ref":"/docs-beagle/docs/resources/style/","title":"Style"},{"body":" Introduction Inside Beagle‚Äôs library, there is a DesignSystem class that can be used to personalize the components used on your application.\nThis class also can map application‚Äôs local resources so we can refer to BFF when you build a Server-Driven screen.\nBeside the images, Beagle‚Äôs Design System can customize:\n the appearance of the texts; the style of the input components; the style of the buttons; the style of the toolbars and tabViews.  Customized attributes For Beagle to be able to apply customized styles to components, when they are declared in the application, their parents must refer to each corresponding family. That is, to customize the components:\n Text, your style should extend from Widget.AppCompat.TextView TextInput, your style should extend from Widget.AppCompat.EditText Button, your style should extend from Widget.AppCompat.Button Toolbar, your style should extend from Widget.AppCompat.Toolbar TabView, your style should extend from Widget.Design.TabLayout   Text The text‚Äôs components for Beagle Android are totally customized. To make this change, you just have to follow the pattern below:\n\u003c!-- Custom style for textual components. --\u003e \u003cstyle name=\"CustomText\" parent=\"Widget.AppCompat.TextView\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e TextInput The input components in Beagle Android are also fully customizable. To make any changes, just follow the pattern below:\n\u003c!-- Custom style for textual components. --\u003e \u003cstyle name=\"CustomInput\" parent=\"Widget.AppCompat.EditText\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"android:background\"\u003e@drawable/text_input_background\u003c/item\u003e \u003c/style\u003e Button Like the texts and inputs, the buttons on the Beagle Android are fully customizable. To make any changes, just follow the pattern below:\n\u003c!-- Custom style for Button components. --\u003e \u003cstyle name=\"CustomButton\" parent=\"Widget.AppCompat.Button\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e18sp\u003c/item\u003e \u003citem name=\"android:textAllCaps\"\u003efalse\u003c/item\u003e \u003citem name=\"android:background\"\u003e?attr/selectableItemBackground\u003c/item\u003e \u003c/style\u003e Toolbar Inside Beagle‚Äôs library for Android, the tool bar is part ofNavigationBar‚Äôs class. To make it properly work on BeagleActivity, you need to inform Beagle which bar will be used on your application.\nThe bar customization can be done in the moment that she passes through Beagle. Besides these attributes, Toolbar has other four that are exclusive:\n backgroundColor: defines the Tool Bar‚Äôs background color. navigationIcon: receives a drawable and attributes it to a navigation bar icon on tool bar. titleTextAppearance: receives a text style to personalize a tool bar‚Äôs title. centerTitle: when activated, centralize the tool bar‚Äôs title.  \u003c!-- Custom style for Toolbar components. --\u003e \u003cstyle name=\"CustomToolbar\" parent=\"Widget.AppCompat.Toolbar\"\u003e \u003citem name=\"backgroundColor\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"navigationIcon\"\u003e?attr/homeAsUpIndicator\u003c/item\u003e \u003citem name=\"titleTextAppearance\"\u003e@style/CustomTitleToolbar\u003c/item\u003e \u003citem name=\"centerTitle\"\u003etrue\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"CustomTitleToolbar\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e TabView The Beagle‚Äôs TabView component represents the Android‚Äôs TabLayout and all its visual structure tha can be stylized with the following attributes:\n tabSelectedTextColor: attributes a different color to a selected tab‚Äôs text. tabTextColor: attributes a text color to all tabs, which means not selected tabs. tabBackground: receives a drawable and attributes it to TabView‚Äôs background. tabIndicatorColor: attributes a color to a selection‚Äôs indicator of one tab. tabIconTint: receives a drawable to define icons' colors, being selected or not.  \u003c!-- Custom style for TabLayout components. --\u003e \u003cstyle name=\"CustomTab\" parent=\"Widget.Design.TabLayout\"\u003e \u003citem name=\"tabSelectedTextColor\"\u003e@color/colorWhite\u003c/item\u003e \u003citem name=\"tabTextColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"tabBackground\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"tabIndicatorColor\"\u003e@color/colorWhite\u003c/item\u003e \u003citem name=\"tabIconTint\"\u003e@color/selector_icon_color\u003c/item\u003e \u003c/style\u003e To manage all the selected tabs, we recommend you the use of a selector for the tabIconTint attribute, as in the example below:\n\u003cselector xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:color=\"@android:color/white\" android:state_selected=\"true\" /\u003e \u003citem android:color=\"@android:color/black\" /\u003e \u003c/selector\u003e ","excerpt":" Introduction Inside Beagle‚Äôs library, there is a DesignSystem class ‚Ä¶","ref":"/docs-beagle/docs/resources/style/android/","title":"Android"},{"body":" O Beagle disponibiliza na sua biblioteca o recurso de estiliza√ß√£o de componentes. Voc√™ pode conhecer melhor o processo para cada sistema operacional nas pr√≥ximas p√°ginas:\n","excerpt":" O Beagle disponibiliza na sua biblioteca o recurso de estiliza√ß√£o de ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/estiliza%C3%A7%C3%A3o/","title":"Estiliza√ß√£o"},{"body":" Introdu√ß√£o Dentro da biblioteca do Beagle, existe a classe DesignSystem que pode ser usada para personalizar os componentes utilizados na sua aplica√ß√£o.\nEsta classe serve para mapear os recursos locais de um aplicativo para podermos referenci√°-los no BFF ao construir uma tela Server-Driven.\nAl√©m de imagens, o Design System do Beagle pode personalizar:\n A apar√™ncia dos textos; O estilo dos componentes de input; O estilo dos bot√µes; O estilo das toolbars e Das tabViews.  Atributos customiz√°veis Para o Beagle ser capaz de aplicar os estilos customizados aos componentes, quando forem declarados na aplica√ß√£o seus pais devem se referir a cada familia correspondente. Ou seja, para customizar os componentes:\n Text, seu estilo deve estender de Widget.AppCompat.TextView TextInput, seu estilo deve estender de Widget.AppCompat.EditText Button, seu estilo deve estender de Widget.AppCompat.Button Toolbar, seu estilo deve estender de Widget.AppCompat.Toolbar TabView, seu estilo deve estender de Widget.Design.TabLayout   Text Os textos no Beagle Android s√£o totalmente customiz√°veis. Para realizar qualquer mudan√ßa, basta seguir o padr√£o abaixo:\n\u003c!-- Custom style for textual components. --\u003e \u003cstyle name=\"CustomText\" parent=\"Widget.AppCompat.TextView\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e TextInput Os componentes de input no Beagle Android tamb√©m s√£o totalmente customiz√°veis. Para realizar qualquer mudan√ßa, basta seguir o padr√£o abaixo:\n\u003c!-- Custom style for textual components. --\u003e \u003cstyle name=\"CustomInput\" parent=\"Widget.AppCompat.EditText\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"android:background\"\u003e@drawable/text_input_background\u003c/item\u003e \u003c/style\u003e Button Assim como os textos e inputs, os bot√µes no Beagle Android s√£o totalmente customiz√°veis. Para realizar qualquer mudan√ßa, basta seguir o padr√£o abaixo:\n\u003c!-- Custom style for Button components. --\u003e \u003cstyle name=\"CustomButton\" parent=\"Widget.AppCompat.Button\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e18sp\u003c/item\u003e \u003citem name=\"android:textAllCaps\"\u003efalse\u003c/item\u003e \u003citem name=\"android:background\"\u003e?attr/selectableItemBackground\u003c/item\u003e \u003c/style\u003e Toolbar Dentro da biblioteca Beagle no Android, a barra de ferramentas faz parte da classe NavigationBar. Para que ela funcione corretamente no BeagleActivity, voc√™ precisar informar ao Beagle qual barra ir√° utilizar na sua aplica√ß√£o.\nA customiza√ß√£o da barra pode ser feita no momento em que ela √© passada para o Beagle. A Toolbar, al√©m dos atributos j√° mencionados, possui outros quatro que s√£o exclusivos:\n backgroundColor: define a cor de fundo da Barra de Ferramentas. navigationIcon: recebe um drawable e o atribui ao √≠cone de navega√ß√£o da barra de ferramentas. titleTextAppearance: recebe um estilo de texto para personalizar o t√≠tulo da barra de ferramentas. centerTitle: quando ativado, centraliza o t√≠tulo na barra de ferramentas.  \u003c!-- Custom style for Toolbar components. --\u003e \u003cstyle name=\"CustomToolbar\" parent=\"Widget.AppCompat.Toolbar\"\u003e \u003citem name=\"backgroundColor\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"navigationIcon\"\u003e?attr/homeAsUpIndicator\u003c/item\u003e \u003citem name=\"titleTextAppearance\"\u003e@style/CustomTitleToolbar\u003c/item\u003e \u003citem name=\"centerTitle\"\u003etrue\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"CustomTitleToolbar\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e TabView O componente TabView no Beagle representa o TabLayout do Android e toda a sua estrutura visual pode ser estilizada com os seguintes atributos:\n tabSelectedTextColor: atribui uma cor diferente ao texto da aba selecionada. tabTextColor: atribui uma cor ao texto a todas as guias, ou seja, as abas n√£o selecionadas. tabBackground: recebe um drawable e atribu√≠-lo ao plano de fundo do TabView. tabIndicatorColor: atribui uma cor ao indicador de sele√ß√£o de uma aba. tabIconTint: recebe um drawable para definir as cores dos √≠cones, sendo selecionados ou n√£o.  \u003c!-- Custom style for TabLayout components. --\u003e \u003cstyle name=\"CustomTab\" parent=\"Widget.Design.TabLayout\"\u003e \u003citem name=\"tabSelectedTextColor\"\u003e@color/colorWhite\u003c/item\u003e \u003citem name=\"tabTextColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"tabBackground\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"tabIndicatorColor\"\u003e@color/colorWhite\u003c/item\u003e \u003citem name=\"tabIconTint\"\u003e@color/selector_icon_color\u003c/item\u003e \u003c/style\u003e Para gerenciar as abas selecionadas, √© recomendado o uso de um seletor para o atributotabIconTint. Como no exemplo abaixo:\n\u003cselector xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:color=\"@android:color/white\" android:state_selected=\"true\" /\u003e \u003citem android:color=\"@android:color/black\" /\u003e \u003c/selector\u003e ","excerpt":" Introdu√ß√£o Dentro da biblioteca do Beagle, existe a classe ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/estiliza%C3%A7%C3%A3o/android/","title":"Android"},{"body":" Introdu√ß√£o Inside Beagle‚Äôs library for iOS, there‚Äôs an AppTheme class that allows you to personalize components used on your application.\nThis class also can map application‚Äôs styles so it can be referenced on BFF to build a Server-Driven screen.\nIt makes possible to personalize, for example:\n Texts' styles; Button‚Äôs styles; TabView.  It‚Äôs importante to make clear that iOS doesn‚Äôt map all the components' attributes. However, the more important are already mapped, so they can be modified if necessary.\nCustomized attributes As not all customization‚Äôs attributes can be stylized, on the list below we‚Äôll see which elements can be personalized through Beagle.\nAnother important point is that styles created on iOS and related to componentes that came from backend. On these cases, you can configure the styles so each of them can be referenced, just like the example below:\nlet theme = AppTheme(styles: [ Styles.customButton.key : Styles.customButton.style, Styles.customText.key : Styles.customText.style, Styles.customTab.key : Styles.customTab.style ]) dependencies.theme = theme Besides reference styles, you have to create a key value pair defining a name to each style created:\nstruct StylePair { var key: String var style: Any } class Styles { static let customText = StylePair(key: \"CustomText\", style: customText) static let customButton = StylePair(key: \"CustomButton\", style: customButton) static let customTab = StylePair(key: \"CustomTab\", style: customTab) } Text The text‚Äôs components for Beagle iOS are totally personalized. To make any attribute change, you just have to follow the pattern below:\nprivate static func textH1() -\u003e (UITextView?) -\u003e Void { BeagleStyle.text(font: .boldSystemFont(ofSize: 32), color: UIColor(named: \"ColorText\")!) } Button Besides the complete text personalization, the Button component can be customized with another attribute: the withTitleColor, which is responsible to personalize button‚Äôs color.\nOn Swift, you can also add extra styles to a component by using the \u003c\u003e note , according to the example below:\nstatic func defaultStylishButton() -\u003e (UIButton?) -\u003e Void { return BeagleStyle.button(withTitleColor: .white) \u003c\u003e { $0?.titleLabel |\u003e BeagleStyle.label(withFont: .systemFont(ofSize: 16, weight: .regular)) $0?.layer.cornerRadius = 6 $0?.clipsToBounds = true $0?.backgroundColor = UIColor(hex: \"#3C3737\") } } TabView The Beagle‚Äôs TabView component for iOS can be stylized with these attributes:\n backGroundColor: attributes a different color to a selected tab background. indicatorColor: attributes a color to a selected background.  static func customTab() -\u003e (UITabBar) -\u003e Void { return BeagleStyle .tabView(backgroundColor: .blue, indicatorColor: .white) } ","excerpt":" Introdu√ß√£o Inside Beagle‚Äôs library for iOS, there‚Äôs an AppTheme class ‚Ä¶","ref":"/docs-beagle/docs/resources/style/ios/","title":"IOS"},{"body":" Introdu√ß√£o Na biblioteca do Beagle para iOS, existe a classe AppTheme que permite personalizar os componentes utilizados na sua aplica√ß√£o.\nEsta classe mapeia os estilos de um aplicativo para que seja poss√≠vel referenci√°-los no BFF ao construir uma tela Server-Driven.\nIsso possibilita personalizar, por exemplo:\n Apar√™ncia dos textos Estilo dos bot√µes TabView  √â importante deixar claro que o Beagle para iOS n√£o mapeia todos os atributos destes componentes, por√©m os mais j√° est√£o mapeados e, portanto, podem ser modificados se necess√°rio.\nAtributos customiz√°veis Como nem todos os atributos de customiza√ß√£o podem ser estilizados, abaixo voc√™ encontra a lista com quais elementos podem ser personalizados pelo Beagle.\nOutro ponto importante √© o dos estilos criados no iOS e vinculados a componentes vindos do Backend. Nestes casos, voc√™ precisa configurar os estilos para que cada um deles esteja referenciado, como no exemplo abaixo:\nlet theme = AppTheme(styles: [ Styles.customButton.key : Styles.customButton.style, Styles.customText.key : Styles.customText.style, Styles.customTab.key : Styles.customTab.style ]) dependencies.theme = theme Al√©m de referenciar os estilos, √© preciso criar um par chave valor definindo um nome para cada style criado:\nstruct StylePair { var key: String var style: Any } class Styles { static let customText = StylePair(key: \"CustomText\", style: customText) static let customButton = StylePair(key: \"CustomButton\", style: customButton) static let customTab = StylePair(key: \"CustomTab\", style: customTab) } Text Os componentes de texto no Beagle iOS s√£o totalmente personaliz√°veis. Quando for realizar qualquer altera√ß√£o nos atributos, √© s√≥ seguir o padr√£o abaixo:\nprivate static func textH1() -\u003e (UITextView?) -\u003e Void { BeagleStyle.text(font: .boldSystemFont(ofSize: 32), color: UIColor(named: \"ColorText\")!) } Button Al√©m da personaliza√ß√£o completa para textos, o componente Button possibilita customizar outro atributo: withTitleColor, que √© respons√°vel por personalizar a cor do bot√£o.\nNo Swift, voc√™ pode ainda adicionar estilos extras ao componente utilizando a anota√ß√£o \u003c\u003e , de acordo com o exemplo abaixo:\nstatic func defaultStylishButton() -\u003e (UIButton?) -\u003e Void { return BeagleStyle.button(withTitleColor: .white) \u003c\u003e { $0?.titleLabel |\u003e BeagleStyle.label(withFont: .systemFont(ofSize: 16, weight: .regular)) $0?.layer.cornerRadius = 6 $0?.clipsToBounds = true $0?.backgroundColor = UIColor(hex: \"#3C3737\") } } TabView O componente TabView no Beagle iOS pode ser estilizado com os seguintes atributos:\n backGroundColor: atribui uma cor diferente ao background da aba selecionada. indicatorColor: atribui uma cor ao background selecionado.  static func customTab() -\u003e (UIView?) -\u003e Void { return BeagleStyle .tabView(backgroundColor: .blue, indicatorColor: .white) } ","excerpt":" Introdu√ß√£o Na biblioteca do Beagle para iOS, existe a classe AppTheme ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/estiliza%C3%A7%C3%A3o/ios/","title":"IOS"},{"body":" Introduction It‚Äôs possible to make two main kinds of stylization with Beagle for Web:\n Adding style classes JSON components style  Here, you will see a detailed explanation for each of these stylizations.\nAdding style classes Adding style‚Äôs propriety on JSON To make this change, you must add on your JSON file a styleId propriety with the name of the style‚Äôs class that you created on your angular component.\nOn the example below, you see how this addition was done to a ‚Äúcard‚Äù hypothetical class.\n{ \"_beagleComponent_\": \"custom:card\", \"myCustomTitle\": \"Beagle Web\", \"myCustomDescription\": \"Lorem ipsum dolor ...\" \"styleId\": \"card\" } Inserting a class on components The process to insert a class to a component varies according to the framework you‚Äôre using. Check out the step by step of each case in the following tabs:\nAngular React On Angular, there are two ways to add a class we receive through styleId propriety:\n1. Through ViewEncapsulation Open the file on your angular component and right down the styleUrls propriety on @Component decorator, add the ViewEncapsulation.none. enum.\nSee how it works on the example below:\n@Component({ selector: 'app-card', templateUrl: './card.component.html', styleUrls: ['./card.component.less'], encapsulation: ViewEncapsulation.None, }) Once you made it, you just have to run the project with one of these commands:\nnpm run serve yarn serve After you add the None enum to a @Component() encapsulation propriety, it‚Äôs necessary to make it useful. See how to make it on the image below:\nIf you want to see more about ViewEncapsulation, check out Angular‚Äôs documentation.\n 2. Through StyleId propriety Another way to add a class is by maintaining a native encapsulation propriety. To do so, you have to open your Angular‚Äôs component file and add a new @Input, that in this case is StyleId.\nSee how it works on the example below:\nexport class CardComponent implements OnInit { @Input() myCustomTitle: string @Input() myCustomDescription: string @Input() styleId: string constructor() { } ... } Once you made it, this Input has the reference of the class' name you added on JSON in the previous step. In the sequence, you need to change the HTML as in the model below:\n\u003cdiv class=\"{{styleId}}\"\u003e \u003cdiv\u003e \u003ch1\u003e{{myCustomTitle}}\u003c/h1\u003e \u003ch3\u003e{{myCustomDescription}}\u003c/h3\u003e \u003c/div\u003e \u003c/div\u003e Finally, you just have to run the project with one of the these commands:\nnpm run serve yarn serve Anyway you used to connect your style class to a component may brings the same result and your component can be changed according to the defined style in your class.\n On React‚Äôs projects, you have to access your class through styleId propriety.\nImport your style‚Äôs file on the component and then you need to attribute a value to styleId on className through the props.\nimport React from 'react' import './custom-text.style.css' function CustomTextComponent(props){ return ( \u003cp className={props.styleId}\u003e{props.customText}\u003c/p\u003e ) } export default CustomTextComponent; The elements' components can now receive the class defined on JSON.\n It‚Äôs worth reinforcing that to define a class withstyleId class added, it‚Äôs fundamental that you have a style file inside your project (Ex: CSS, SASS, LESS).  Stylizing components through JSON Another Beagle Web‚Äôs possibility is to stylize its components. You see on the following topics what can be done directly through JSON:\nPosition You can change the element‚Äôs position on the screen by using the position propriety, like in the example:\n{ ... { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Welcome to the Beagle playground!\", \"style\": { \"positionType\":\"relative\", \"position\": { \"top\": { \"value\": 10, \"type\": \"REAL\" }, \"left\": { \"value\": 10, \"type\": \"REAL\" } } } } ] } Margin e Padding You can change the element‚Äôs margin or spacing on the screen by using margin e padding proprieties, like in the example below:\n{ ... { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Welcome to the Beagle playground!\", \"style\": { \"margin\": { \"top\": { \"value\": 10, \"type\": \"REAL\" }, \"left\": { \"value\": 10, \"type\": \"REAL\" } } } } ] } Size It‚Äôs also possible to change elements' dimension by using Size propriety, which receives the values on Height or Width. See on the example below:\n{ \"_beagleComponent_\": \"beagle:container\", \"size\": { \"height\": { \"value\": 100, \"type\": \"REAL\" }, \"width\": { \"value\": 100, \"type\": \"REAL\" } } } ... }  Notice that, in all the examples above, the proprieties receive the values' maps in a \u003cvalue, type\u003e format.\nIn Beagle‚Äôs case, the available values are:\n REAL - Value on pixel (‚Äòpx‚Äô) PERCENT - Value on percentage (%)   Flex Finally, you have the possibility to add proprieties in a flexbox layout model with Beagle‚Äôs library.\n{ \"_beagleComponent_\": \"beagle:container\", \"style\": { \"backgroundColor\":\"red\", \"flex\": { \"flexDirection\": \"COLUMN\", \"alignItems\": \"CENTER\", \"justifyContent\": \"CENTER\" } } } ...  Besides these functionalities, there are some components that have specific proprieties like text change color or alignement. Check out more about Beagle‚Äôs components.  ","excerpt":" Introduction It‚Äôs possible to make two main kinds of stylization with ‚Ä¶","ref":"/docs-beagle/docs/resources/style/web/","title":"WEB"},{"body":" Introdu√ß√£o √â poss√≠vel realizar duas principais maneiras de estiliza√ß√£o com Beagle para Web. S√£o elas:\n Adi√ß√£o de classes de estilo  Estiliza√ß√£o de componentes via JSON  Abaixo, voc√™ encontra a explica√ß√£o detalhada para cada uma delas.\nAdicionando classes de estilo Adicionar propriedade de estilo ao JSON Para fazer essa mudan√ßa, voc√™ deve adicionar, em seu arquivo JSON, a propriedade styleId com o nome da classe de estilo que voc√™ criou em seu componente angular.\nNo exemplo abaixo, voc√™ v√™ como foi feita a adi√ß√£o para uma classe hipot√©tica com nome ‚Äòcard‚Äô.\n{ \"_beagleComponent_\": \"custom:card\", \"myCustomTitle\": \"Beagle Web\", \"myCustomDescription\": \"Lorem ipsum dolor ...\" \"styleId\": \"card\" } Inserir a classe ao componente O processo de inserir uma classe ao componente varia de acordo com o framework que estiver utilizando. Confira o processo para cada um deles nas abas a seguir:\nAngular React No Angular, h√° duas formas de adicionar a classe que recebemos da propriedade styleId:\n1. Pelo ViewEncapsulation Abra o arquivo do seu componente angular e, logo abaixo da propriedade styleUrls do decorator @Component, adicione o enum ViewEncapsulation.none.\nVeja como funciona no exemplo abaixo:\n@Component({ selector: 'app-card', templateUrl: './card.component.html', styleUrls: ['./card.component.less'], encapsulation: ViewEncapsulation.None, }) Feito isso, basta rodar o projeto com um dos comandos:\nnpm run serve yarn serve Depois que voc√™ adicionar o enum None √† propriedade encapsulation do @Component(), √© necess√°rio fazer com que ela seja utilizada. Veja como na imagem abaixo:\nPara entender mais sobre o ViewEncapsulation, acesse a documenta√ß√£o do Angular.\n 2. Pela propriedade StyleId Outra maneira de voc√™ adicionar a classe √© mantendo a propriedade encapsulation como nativo. Para isso, √© s√≥ abrir o arquivo do seu componente Angular e adicionar um novo @Input, no caso, o styleId.\nVeja no exemplo a seguir:\nexport class CardComponent implements OnInit { @Input() myCustomTitle: string @Input() myCustomDescription: string @Input() styleId: string constructor() { } ... } Uma vez feito isso, este Input est√° com a refer√™ncia do nome da classe que voc√™ adicionou ao JSON no passo anterior. Na sequ√™ncia, voc√™ precisa mudar o HTML como no modelo abaixo:\n\u003cdiv class=\"{{styleId}}\"\u003e \u003cdiv\u003e \u003ch1\u003e{{myCustomTitle}}\u003c/h1\u003e \u003ch3\u003e{{myCustomDescription}}\u003c/h3\u003e \u003c/div\u003e \u003c/div\u003e Por fim, basta rodar o projeto com um dos comandos:\nnpm run serve yarn serve Qualquer uma das formas que voc√™ usou para conectar sua classe de estilo ao componente deve gerar o mesmo resultado e seu componente deve ser alterado de acordo com o estilo definido em sua classe.\n Para projetos React, voc√™ acessa a sua classe por meio da propriedade styleId.\nImporte seu arquivo de estilos no componente e voc√™ precisa atribuir o valor de styleId ao className por meio das props.\nimport React from 'react' import './custom-text.style.css' function CustomTextComponent(props){ return ( \u003cp className={props.styleId}\u003e{props.customText}\u003c/p\u003e ) } export default CustomTextComponent; Pronto, os elementos do seu componente j√° devem receber a classe definida no JSON\n Vale refor√ßar que para definir a classe adicionada com valor de styleId, √© fundamental que voc√™ tenha um arquivo de estilo dentro do seu projeto (Ex: CSS, SASS, LESS).  Estilizando componentes via JSON Mais uma possibilidade do Beagle Web √© o de estilizar os seus componentes. Abaixo, voc√™ confere o que pode ser feito diretamente pelo JSON:\nPosition Voc√™ pode modificar a posi√ß√£o de elementos na tela usando a propriedade position, como no exemplo:\n{ ... { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Welcome to the Beagle playground!\", \"style\": { \"positionType\":\"relative\", \"position\": { \"top\": { \"value\": 10, \"type\": \"REAL\" }, \"left\": { \"value\": 10, \"type\": \"REAL\" } } } } ] } Margin e Padding Voc√™ pode tamb√©m mudar a margem e o espa√ßamento dos elementos na tela usando as propriedades margin e padding, como no modelo abaixo:\n{ ... { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Welcome to the Beagle playground!\", \"style\": { \"margin\": { \"top\": { \"value\": 10, \"type\": \"REAL\" }, \"left\": { \"value\": 10, \"type\": \"REAL\" } } } } ] } Size √â poss√≠vel ainda alterar as dimens√µes dos elementos na tela usando a propriedade Size, que recebe os valores de Height ou Width. Veja como no exemplo:\n{ \"_beagleComponent_\": \"beagle:container\", \"size\": { \"height\": { \"value\": 100, \"type\": \"REAL\" }, \"width\": { \"value\": 100, \"type\": \"REAL\" } } } ... }  Repare que, em todos os exemplos acima, as propriedades recebem os mapas de valores no formato \u003cvalue, type\u003e.\nNo caso do Beagle, os valores dispon√≠veis para type s√£o:\n REAL - Valor em pixel (‚Äòpx‚Äô) PERCENT - Valor em porcentagem (%)   Flex Por fim, voc√™ tem a possibilidade de adicionar propriedades no modelo de layout flexbox com a biblioteca do Beagle.\n{ \"_beagleComponent_\": \"beagle:container\", \"style\": { \"backgroundColor\":\"red\", \"flex\": { \"flexDirection\": \"COLUMN\", \"alignItems\": \"CENTER\", \"justifyContent\": \"CENTER\" } } } ...  Al√©m dessas funcionalidades, alguns componentes possuem propriedades espec√≠ficas como mudan√ßa na cor do texto ou alinhamento. Conhe√ßa mais sobre os componentes do Beagle  ","excerpt":" Introdu√ß√£o √â poss√≠vel realizar duas principais maneiras de ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/estiliza%C3%A7%C3%A3o/web/","title":"WEB"},{"body":" Introduction Live Preview is a visualization resource that helps with layout development. It allows that screens in development be rendered without need to run your backend server for the layout changes done, thus reducing a screen‚Äôs development time.\nIn other words, when a developer edits code defining a screen, they can use the plugin so that updates are communicated to the client and it renders them. This way, it‚Äôs possible to view change without running a backend server.\nThis frontend and backend connection is done through a WebSocketon port: 9721.  Requirements To use Live Preview, you must:\n Use Beagle SDK in your BFF**;** Install BeaglePreview plugin;  BFF Configuration You must have a configured BFF with Beagle to use Live Preview. In case you haven‚Äôt done it, click here to download an initial project. As an alternative, follow our tutorial on how to implement a Beagle configured backend.\nIntelliJ plugin installation To install BeaglePreview, click on the link below to install:\n{% embed url=‚Äúhttps://plugins.jetbrains.com/plugin/14575-beagle-sdk-live-preview\" caption=‚ÄúLive Preview plugin for IntelliJ‚Äù %}}\nLive Preview Use You must configure both backend and frontend for the Live Preview The frontend can be Android or iOS client.  Step 1: Backend‚Äôs Configuration The following steps allow you to view a screen defined in the backend using Live Preview:\n You will create a declarative screen to test. The code ahead will return a simple screen as an example. You will create a function that returns the screen to be viewed through the plugin. Finally, you must annotate this function with@BeaglePreview.  After this, Live Preview will be capable of receiving the developed screen to be rendered. Some interesting points on the example below:\n Notice the screen itself is defined in the ScreenBeagleBuilder class. The buildPreview function is annotated with @BeaglePreview and, therefore, the sender of our screen to be rendered by the plugin.  @BeaglePreview fun buildPreview() = ScreenBeagleBuilder() class ScreenBeagleBuilder: ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text(\"Live Preview!!!\") ) ) ) } If your function is recognized by the plugin, the Beagle logo will appear as a button to the left of the function. When clicking this button, BeaglePreview will push the layout to the client (frontend application), allowing it to update on your layout instantly!\nAfter running the plugin on some function, you only need to save the changes done in your layout so that the Live Preview updates the screen being rendered by the frontend. It does this by compiling your modified code and verifying if there is some change and, if there is, push your new layout to the client.\nStep 2: Frontend‚Äôs configuration Once you have configured your backend, the next step is to configure the frontend‚Äôs application emulator for a Beagle Android or iOS project.\nAndroid client iOS client Step 1: Installing the submodule To make this installation, your gradle file must contain the following fragment:\nThe latest Beagle‚Äôs version:![https://img.shields.io/bintray/v/zupit/repo/beagle](https://img.shields.io/bintray/v/zupit/repo/beagle]()\n// Add in your plugins apply plugin: 'kotlin-kapt' // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" debugImplementation \"br.com.zup.beagle:android-preview:$beagle_version\" } On ext.beagle_version = \"${beagle_version}\", insert the Beagle‚Äôs release version on the place of ${beagle.version}. That means that you put the Beagle‚Äôs version indicated on the blue badge, but without the v character.\nFor example: undefined-ext.beagle.version = \"0.2.8\"\nOnce you made it, you can update your dependencies.\nStep 2: Creating a Preview Activity First of all, it‚Äôs necessary to state a PreviewActivity on your application‚Äôs manifest to show a preview:\nIt‚Äôs not necessary to create, in fact, an Activity because it‚Äôs already internally created on Beagle. You should only refer it on your manifest indicating that it‚Äôs part of Activities' hall accessible on this application.\n Copy and paste the Activity below on your AndroidManifest:\n... \u003capplication\u003e ... \u003cactivity android:exported=\"true\" android:name=\"br.com.zup.beagle.android.preview.PreviewActivity\" android:theme=\"@style/AppTheme.NoToolbar\"/\u003e \u003c/application\u003e \u003c/manifest\u003e As well as in BeagleActivity, you must inform onPreviewActivity state that the theme has not the ActionBar, because Beagle already coordinates this component.\nAnother important point is that you have to enable the exported flag so it can start through ADB\n Visualizing screens through Android Studio‚Äôs Emulator After you finished the previous configurations, you must start the IntelliJ plugin by clicking on Beagle‚Äôs symbol next to the function that notes @BeaglePreview and opensPreviewActivity to receive the updates sent from BFF to be automatically rendered.\n To start the PreviewActivity through intent, you just have to call the intent below to see the emulator‚Äôs screen:  startActivity(PreviewActivity.newIntent(this)) However, if you prefer to start through ADB, just call the method:\nadb shell am start -n applicationpackagename/br.com.zup.beagle.android.preview.PreviewActivity For more information about your package, access the attribute‚Äôs package on yourAndroidManifest‚Äôs file\n Visualizing screens through Android Device You can also view the screen you‚Äôre creating by an Android device. To do so, it‚Äôs necessary to inform your network‚Äôs IP on the intent that calls the Live Preview screen.\nThe Live Preview‚Äôs Activity connects to the Backend ‚Äôs screen through the client‚Äôs\nwebsocket connection. In this way, this client needs to know whichIP must be used to establish the connection.\n  To start a PreviewActivity through device, you just have to call the intent below so you can see the screen on your device:  startActivity( PreviewActivity .newIntent( this, endpoint = \"http://myIP:9721\" ) )  Step 1: Installing the submodule To make the installation, your pod file must contain the following fragments:\n... pod 'BeagleUI', :git =\u003e 'https://github.com/ZupIT/beagle.git' pod 'BeagleUI/Preview', :git =\u003e 'https://github.com/ZupIT/beagle.git' ... After that, you can update your dependencies:\n$ pod install Step 2: Use The user must present the preview‚Äôs controller of any visible UIViewController with BeaglePreview.present(in:self) code.\nOnce you made it, the preview controller will connect to a plugin and start to listen the received messages about layout change.\nOn the hypothetical example below, you can see how the UIViewController must be shown:\nimport BeagleUI class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) BeaglePreview.present(in: self) } }  Limitations When using Live Preview, there are two important points to keep in mind:\n The Live Preview client can render any change using the elements available to it when it was started. Custom elements added afterward require a client to rebuild and restart. The @BeaglePreview annotation works with public methods with no parameters outside any class or in a public class that has a constructor with no parameters. See the snippets below.  class UnsupportedConstructor(thing: Any) { @BeaglePreview fun preview() = Text(\":(\") } class SupportedPrimaryConstructor { @BeaglePreview fun preview() = Text(\":)\") } class SupportedBySecondaryConstructor(thing: Any) { constructor() : this(\"solved\") @BeaglePreview fun preview() = Text(\":)\") } class MethodSupport { @BeaglePreview fun supportedMethod() = Text(\":)\") @BeaglePreview fun unsupportedMethod(thing: Any) = Text(\":(\") } @BeaglePreview fun unsupportedFunction(thing: Any) = Text(\":(\") @BeaglePreview fun supportedFunction() = Text(\":)\") ","excerpt":" Introduction Live Preview is a visualization resource that helps with ‚Ä¶","ref":"/docs-beagle/docs/resources/live-preview/","title":"Live Preview"},{"body":" Introdu√ß√£o O Live Preview √© um recurso de visualiza√ß√£o que auxilia no desenvolvimento de layouts. Ele permite que as telas em desenvolvimento sejam renderizadas sem a necessidade de subir seu servidor backend para as altera√ß√µes de layout feitas, reduzindo, assim, o tempo de desenvolvimento de uma tela.\nEm outras palavras, o Live Preview d√° a op√ß√£o de editar um c√≥digo que define a tela e, assim, o desenvolvedor pode utilizar o plugin para que as atualiza√ß√µes sejam comunicadas ao cliente e ele as renderize.\nDesta forma, √© poss√≠vel visualizar as mudan√ßas sem precisar subir um servidor backend.\nEsta conex√£o entre frontend e backend √© feita via WebSocket utilizando a porta :9721  Requisitos Para usar o Live Preview voc√™ deve:\n Usar o Beagle SDK em seu BFF**;** Instalar o BeaglePreview plugin;  Configura√ß√£o do BFF Voc√™ precisa que seu BFF esteja configurado com o Beagle para utilizar o Live Preview. Caso ainda n√£o o tenha, fa√ßa o download de um projeto inicial pronto. Outra possibilidade que voc√™ pode fazer, √© o nosso tutorial de como implementar um backend com o Beagle configurado.\nInstala√ß√£o do plugin IntelliJ Para instalar o BeaglePreview entre no link abaixo e clique na op√ß√£o instalar na IDE:\n{% embed url=‚Äúhttps://plugins.jetbrains.com/plugin/14575-beagle-sdk-live-preview\" caption=‚ÄúPlugin do Live Preview para IntelliJ‚Äù %}}\nUso do Live Preview Voc√™ deve configurar tanto o backend quanto o frontend para esse Live Preview. O frontend pode ser cliente Android ou iOS.  Passo 1: Configurar o Backend Os passos a seguir nos permitir√£o visualizar uma tela definida no backend usando o Live Preview:\n Vamos criar uma tela declarativa para teste. O c√≥digo mais adiante trar√° uma tela bem simples como exemplo. Iremos criar uma fun√ß√£o que retorna a tela a ser visualizada pelo plugin. Por fim, vamos anotar essa fun√ß√£o com @BeaglePreview.  Feito isso, o Live Preview j√° ser√° capaz de receber a tela em desenvolvimento a ser renderizada.\nAlguns pontos interessantes de se notar do exemplo abaixo:\n Perceba que a tela em si est√° definida na classe ScreenBeagleBuilder. A fun√ß√£o buildPreview est√° anotada com @BeaglePreview, com isso o plugin consegue utilizar ela para renderizar a tela.  @BeaglePreview fun buildPreview() = ScreenBeagleBuilder() class ScreenBeagleBuilder: ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text(\"Live Preview!!!\") ) ) ) } Se sua fun√ß√£o for reconhecida pelo plugin, o s√≠mbolo do Beagle aparecer√° como um bot√£o √† esquerda da fun√ß√£o. Clicando neste bot√£o, o BeaglePreview faz um push do layout para o cliente (aplica√ß√£o frontend), permitindo que ele atualize seu layout instantaneamente.\nVeja como no exemplo abaixo:\nDepois de acionar o plugin para alguma fun√ß√£o, basta voc√™ salvar as modifica√ß√µes realizadas no seu layout para que o Live Preview atualize a tela sendo renderizada pelo frontend.\nO Live Preview faz isso ao compilar seu c√≥digo modificado e verificar se existe alguma altera√ß√£o a ser feita. Se for o caso, ele faz o push de seu novo layout para o cliente.\nPasso 2: Configurar o frontend iOS e Android Uma vez configurado o seu backend, o pr√≥ximo passo √© configurar o emulador no frontend da sua aplica√ß√£o com um projeto Beagle Android ou Beagle iOS.\nCliente Android Cliente iOS Passo 1: Instalar o subm√≥dulo Para realizar a instala√ß√£o, seu arquivo de gradle deve conter o fragmento abaixo:\nA vers√£o atual do Beagle :![https://img.shields.io/bintray/v/zupit/repo/beagle](https://img.shields.io/bintray/v/zupit/repo/beagle]()\n// Add in your plugins apply plugin: 'kotlin-kapt' // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" debugImplementation \"br.com.zup.beagle:android-preview:$beagle_version\" } Em ext.beagle_version = \"${beagle_version}\", insira a vers√£o de release do Beagle no lugar de ${beagle.version}. Ou seja, coloque a vers√£o do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os n√∫meros de vers√£o.\nPor exemplo:undefined-ext.beagle.version = \"0.2.8\"\nFeito isso, voc√™ pode atualizar suas depend√™ncias.\nPasso 2: Criar uma Preview Activity Antes de tudo, √© necess√°rio declarar uma PreviewActivity no manifesto da aplica√ß√£o para mostrar a pr√©-visualiza√ß√£o:\nAqui n√£o √© necess√°rio criar uma Activity de fato, pois ela j√° est√° criada internamente no Beagle. Voc√™ deve somente refer√™ncia-la no manifesto indicando que ela faz parte do hall de Activities acess√≠veis nessa aplica√ß√£o\n Copie e cole a Activity abaixo em seu AndroidManifest:\n... \u003capplication\u003e ... \u003cactivity android:exported=\"true\" android:name=\"br.com.zup.beagle.android.preview.PreviewActivity\" android:theme=\"@style/AppTheme.NoToolbar\"/\u003e \u003c/application\u003e \u003c/manifest\u003e Assim como oBeagleActivity, voc√™ deve informar na declara√ß√£o do PreviewActivity que o tema que n√£o tem ActionBar, pois o Beagle j√° coordena esse componente.\nOutro ponto importante √© que voc√™ precisa habilitar a flag exportada que poder√° come√ßar via ADB\n Visualizando telas no Emulador do Android Studio Ap√≥s realizar estas configura√ß√µes, √© s√≥ come√ßar o plugin no IntelliJ clicando no simbolo do Beagle ao lado da fun√ß√£o que anota @BeaglePreview e abrir o PreviewActivity para receber as atualiza√ß√µes do enviadas pelo BFF para renderiz√°-los automaticamente.\n Para come√ßar uma PreviewActivity via intent, basta fazer a chamada com intent abaixo para visualizar a tela no emulador:  startActivity(PreviewActivity.newIntent(this)) No entanto, se voc√™ preferir come√ß√°-la por meio por meio da ADB, √© s√≥ chamar o m√©todo:\nadb shell am start -n applicationpackagename/br.com.zup.beagle.android.preview.PreviewActivity Para mais informa√ß√µes sobre o seu pacote, acesse seu pacote de atributo no seu arquivo AndroidManifest\n Visualizando telas no Device Android Voc√™ tamb√©m pode visualizar a tela que esta criando utilizando um device Android. Para isso √© necess√°rio informar o IP da sua rede no intent que chama tela de Live Preview.\nA Activity de Live Preview se conecta a tela no Backend via uma conex√£o websocket do client (emulador ou dispositivo f√≠sico) utilizando o BFF atrav√©s do plugin BeaglePreview. Dessa forma, o client precisa saber qual IP deve utilizar para estabelecer a conex√£o.\n  Para come√ßar uma PreviewActivity via device, basta fazer a chamada com o intent abaixo para visualizar a tela no dispositivo:  startActivity( PreviewActivity .newIntent( this, endpoint = \"http://seuIP:9721\" ) )  Passo 1: Instalar o subm√≥dulo Para realizar a instala√ß√£o, √© necess√°rio primeiro j√° ter seguido os passos de instala√ß√£o do Beagle para iOS. Assim os passos seguintes variam de acordo com o m√©todo utilizado.\nUtilizando via CocoaPods Adicione a depend√™ncia do LivePreview no seu arquivo Podfile:\n... pod 'Beagle/Preview' ... Depois disso, voc√™ pode instalar essa nova depend√™ncia:\n$ pod install Utilizando via Carthage Junto com o Beagle.framework gerado, haver√° tamb√©m o BeaglePreview.framework. Basta ent√£o adicion√°-lo como mais uma depend√™ncia no seu projeto.\nPasso 2: Usar Depois de instalado, √© necess√°rio agora apresentar o UIViewController do BeaglePreview utilizando o seguinte c√≥digo BeaglePreview.present(in:self).\nUma vez que voc√™ fizer isso, ele ir√° se conectar ao plugin e come√ßar a escutar as mensagens recebidas de mudan√ßa de layout.\nAbaixo, voc√™ encontra um exemplo hipot√©tico de como fazer essa inicializa√ß√£o:\nimport Beagle class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) BeaglePreview.present(in: self) } }  Limita√ß√µes Durante o uso do Live Preview, existem dois pontos importantes de ter em mente:\n O cliente do Live Preview pode renderizar qualquer altera√ß√£o usando os elementos dispon√≠veis quando o recurso foi iniciado. Os elementos personalizados que forem adicionados posteriormente requerem uma reconstru√ß√£o e reinicializa√ß√£o do cliente. A anota√ß√£o @BeaglePreview funciona com m√©todos p√∫blicos sem par√¢metros, fora de qualquer classe ou em uma classe p√∫blica e que possui um construtor sem par√¢metros, permitindo que ele retorne um widget. Veja como nos trechos abaixo:  class UnsupportedConstructor(thing: Any) { @BeaglePreview fun preview() = Text(\":(\") } class SupportedPrimaryConstructor { @BeaglePreview fun preview() = Text(\":)\") } class SupportedBySecondaryConstructor(thing: Any) { constructor() : this(\"solved\") @BeaglePreview fun preview() = Text(\":)\") } class MethodSupport { @BeaglePreview fun supportedMethod() = Text(\":)\") @BeaglePreview fun unsupportedMethod(thing: Any) = Text(\":(\") } @BeaglePreview fun unsupportedFunction(thing: Any) = Text(\":(\") @BeaglePreview fun supportedFunction() = Text(\":)\") ","excerpt":" Introdu√ß√£o O Live Preview √© um recurso de visualiza√ß√£o que auxilia no ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/live-preview/","title":"Live Preview"},{"body":" On Beagle, navigation works as a type of Action, which can be used by all components that receives an action.\nBefore configuring the navigation between screens of your application, it is required you have installed Beagle, checked the use configuration and tested Beagle‚Äôs framework on the displaying a server-driven screen tutorial  After these configuration, just add the example code as a return of you service and call the endpoint, defining in your controller, in your frontend.\nNavigation‚Äôs routes Some navigation actions needs a parameter. It is possible to receive two route type:\n Local: intern navigation that expects a new screen. Remote: expects that the url points into an API that will return one of more Beagle‚Äôs components.  On the example below, we case a case where the route is remote:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushStack\", \"route\": { \"url\": \"/my-next-screen\", \"shouldPrefetch\": false } } ] }  Button( text = \"Click me!\", onPress = listOf( Navigate.PushStack( route = Route.Remote(\"/my-next-screen\") ) ) )  Types of navigation The following pages, you will see more details about Beagle‚Äôs navigation types:\n","excerpt":" On Beagle, navigation works as a type of Action, which can be used by ‚Ä¶","ref":"/docs-beagle/docs/resources/screen-navigation/","title":"Screen navigation"},{"body":" No Beagle, a navega√ß√£o (ou Navigate) √© um tipo de A√ß√£o e que, por isso, pode ser usada por todos componentes que recebem uma a√ß√£o.\nVale lembrar que, antes de configurar a navega√ß√£o entre telas da sua aplica√ß√£o, √© preciso que voc√™ j√° tenha feito a instala√ß√£o do Beagle, as configura√ß√µes de uso e testado o framework do Beagle no tutorial para exibir uma tela server-driven.  Depois de fazer todas as configura√ß√µes, basta colocar o c√≥digo dos exemplos como retorno do seu servi√ßo e chamar o endpoint, definido na sua controller, no frontend de sua prefer√™ncia.\nRotas de Navega√ß√£o Algumas a√ß√µes de navega√ß√£o precisam de um par√¢metro. √â poss√≠vel receber dois tipos de rota, que s√£o:\n Local: navega√ß√£o interna que j√° espera pela nova tela. Remote: navega√ß√£o que, a partir de uma URL, aponta para uma API que ir√° retornar um ou mais componentes do Beagle.  No exemplo abaixo, voc√™ v√™ um caso onde o route √© remote:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushStack\", \"route\": { \"url\": \"/my-next-screen\", \"shouldPrefetch\": false } } ] }  Button( text = \"Click me!\", onPress = listOf( Navigate.PushStack( route = Route.Remote(\"/my-next-screen\") ) ) )  Tipos de navega√ß√£o Nas p√°ginas a seguir, voc√™ confere mais detalhes de cada tipo de navega√ß√£o do Beagle:\n","excerpt":" No Beagle, a navega√ß√£o (ou Navigate) √© um tipo de A√ß√£o e que, por ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/navega%C3%A7%C3%A3o-de-telas/","title":"Navega√ß√£o de telas"},{"body":" Introduction Most elements from Beagle use a field to points out a path to define the URLs. This field, in special, it is sent to backend to indicate HTTP requests that an application needs to do and that are managed by Beagle‚Äôs client.\nTypes of paths You have two ways to use these paths on Beagle:\n Absolute Relative  Absolute path A type of path used when you want to ignore the base URL already configured in your frontend application. If you make this indication, Beagle will understand that the URL is already complete and it will use it like this:\nExample of absolute path:https://api.zup.com.br/my-bff/home\nRelative path A type of path used when you decide to keep the base URL configured in your frontend application.\nFor example, if you define a base URL like https://api.zup.com.br/my-bff and receive a relative path somewhere like / home, Beagle will create the complete URL like https://api.zup.com. br /my-bff/home.\nIt is recommended that you start with the relative path with an inverted bar (/), because this is how Beagle‚Äôs indicates a relative URL.  Encode type Beagle uses the Encoding type RFC 3986 standard when handling URLs.\n","excerpt":" Introduction Most elements from Beagle use a field to points out a ‚Ä¶","ref":"/docs-beagle/docs/resources/urls/","title":"Urls"},{"body":" Introdu√ß√£o A maior parte dos elementos disponibilizados pelo Beagle usa um campo para indicar o caminho para definir as URLs.\nEste campo, em espec√≠fico, √© enviado pelo backend para indicar as chamadas HTTP que o aplicativo precisa fazer e que s√£o gerenciadas pelo cliente do Beagle.\nTipos de caminhos Voc√™ tem duas maneiras de utilizar estes caminhos no Beagle:\n Forma Absoluta Forma Relativa  Caminho Absoluto √â o tipo de caminho usado quando voc√™ deseja ignorar a URL base configurada no aplicativo frontend. Se voc√™ faz esta indica√ß√£o, o Beagle entender√° que essa URL j√° est√° completa e ir√° us√°-la dessa forma.\nUm exemplo de caminho absoluto:https://api.zup.com.br/my-bff/home\nCaminho Relativo √â o tipo de caminho usado quando voc√™ decide respeitar a URL base configurada no seu aplicativo frontend.\nPor exemplo, se voc√™ definir uma URL base como https://api.zup.com.br/my-bff e receber um caminho relativo em algum lugar como / home, o Beagle ir√° criar a URL completa como https://api.zup.com. br /my-bff/home.\nSugerimos que voc√™ sempre comece um caminho relativo com uma barra invertida (/), pois esta √© a marca usada no Beagle para indicar que √© uma a URL relativa.  Encode type O Beagle utiliza o padr√£o Encoding type RFC 3986 ao tratar URLs.\n","excerpt":" Introdu√ß√£o A maior parte dos elementos disponibilizados pelo Beagle ‚Ä¶","ref":"/docs-beagle/pt/docs/recursos/urls/","title":"Urls"},{"body":" What is Beagle? Beagle is an open source framework of cross-platform development, it is based on the native Server-Driven UI implementation in iOS and Android. You can easily change your application‚Äôs layout and DATA changing only the screen code in backend.\nHow does Beagle work? The developer declares the backend screens and the expose the endpoints that represent them. These endpoints are called using Beagle to render the screen components on the web or mobile.\nBeagle works as a ‚Äòbridge‚Äô between front and backend, it is possible that the design components of your application have a parameter in backend which makes a native application possible.\nMy application‚Äôs architecture will change if I use? No, Beagle does not interfere with your project‚Äôs architecture.\nWhy should I use Beagle and not React Native or Flutter? Beagle‚Äôs solution is different from other tecnologies. It is a tool to make the development easier, it has UI oriented concept of continuous delivery. Beagle allows you to handle through backend, native components of your application, change layouts and the display of these components.\nIs it possible to make tests in server driven screens? Yes! Unit tests like instrumented test work the same way on Beagle.\nCan I use Beagle in an application that already has developed resources? Yes! If your application already have the developed components in a design system, you are able to use them on Beagle. You only have to see if these components are defined and then it will be easy to register them on Beagle.\nDoes a Beagle application need to be 100% Server Driven? No, the application can use only one Server Driven screen in some app‚Äôs flows. You can continue in one server driven flow or return to the native screen normally.\nDo I have to use Beagle in the whole application? No, your application will continue the same and it can be native even with Beagle on it. You may use Beagle whenever you want.\nWill my application work offline? Depends. All server driven application when requests the server a flow, it needs to be connected in order to receive a response from backend. The server driven flows cannot be solved without a connection. But, your if your application is not 100% server driven, there is a part of it that doesn‚Äôt need to get online information, then it will work. The application also can be configured to call other screens in case they are offline.\nIf my my internet connection is interrupted in the middle of the application flow? The way to deal with disconnection cases it is to create local declaratives screens to fallback.\nWill I have problems to upload an application with Beagle on App Store or Play Store? No! All the components used will be defined in your application when the store‚Äôs upload happens. Beagle is dynamic when dealing with updates, this happens because the work is in the backend and there isn‚Äôt any frontend configuration that is big enough to cause a block on Apple or Google. Beagles wants to minimize the deploys on the stores.\nWill I have performance problems with Beagle? Not, it‚Äôs the quite opposite. We made a renderization benchmark and Beagle - using Yoga‚Äôs Layout mechanism - had a better answer than other native renderization strategies, like Auto Layout (IOS) and Constraint Layout (Android).\nHow about backend‚Äôs answer time? Will my application be slower? No, because Beagle uses a cache mechanism to store adjacent screens and, then, optimize backend‚Äôs calls. This means that you don‚Äôt need to request again to backend in the user‚Äôs click moment.\nWhat is the latest Beagle‚Äôs version? Beagle‚Äôs latest version is:undefined\nIs Beagle a free tool? Yeas! Beagle is an open source development framework, which means that its totally free.\nCan I create a BFF with a different language than JVM? It‚Äôs possible to create a BFF in a different language. However, we don‚Äôt have ready libs to help you on this process, so it would be necessary that the developer create a mechanism to respect Beagle‚Äôs contracts.\nWhat are the advantages of using Beagle? One of the main advantages is that Beagles facilitates the development because of backend‚Äôs configuration based on BFF paradigm.\nThis means that Beagle helps you on changing screen‚Äôs layouts, screen‚Äôs flows and app‚Äôs navigation. All of this is made from pages declaratively created in your BFF with a components' library defined on your application‚Äôs frontend, which helps on interface‚Äôs change.\nIt allows you to:\n Decide which visual component must be presented: which texts, subtitles and any other visual information that must be shown, centralized and abstracted on the server.  This avoids a replication on each frontend‚Äôs platform that consumes this API. The server applies this business logic and use its results to assemble the API response representing it.\n Make A/B tests to change the order how components are presented.  Can I use Beagle for Android, iOs or Web development? Yes! As a cross-platform framework, Beagle helps you on developing application on these three platforms by using the Server-Driven UI concept, which enables that even a BFF may be used on all of these applications.\nYou can see more how to create Beagle‚Äôs projects with each of these platforms on:\n Beagle for Android  Beagle for iOS Beagle for Web  How to make unitary and instrumented tests on Server-Driven screens? Yes! Unitary and instrumented tests can be normally done when using Beagle because its structure doesn‚Äôt interfere in these tests.\nHow to make unitary tests using Beagle? Unitary tests has the goal to gauge the code‚Äôs functionality in a minor fraction. The applications' tests that use Beagle are done in the same way as in applications that don‚Äôt use our tool. That means Beagle doesn‚Äôt interfere in these tests.\nHow to make instrumented tests using Beagle? Instrumented tests are done in applications using Beagle in the same way as in applications that don‚Äôt use our tool.\nHowever, it‚Äôs important to reinforce that, usually, a server-driven component may not contain an ID that mostly identifies an instrumented test. Thinking of it, we add a WIDGET element (that refers a component) and a ID attribute so it can be possible to programatically identify it.\n","excerpt":" What is Beagle? Beagle is an open source framework of cross-platform ‚Ä¶","ref":"/docs-beagle/docs/faq/","title":"FAQ"},{"body":" A comunica√ß√£o entre componentes √© uma forma de compartilhar informa√ß√µes com o uso de Observables que, de modo geral, emitem notifica√ß√µes sempre que uma mudan√ßa acontece com eles.\nAbaixo, voc√™ ver√° como fazer a configura√ß√£o dessa comunica√ß√£o usando o Contexto, um componente do Beagle. \nConfigurando a comunica√ß√£o entre componentes. O que vou comunicar? Nesse exemplo, consumiremos o resultado de uma API p√∫blica que retorna valores de cota√ß√£o das moedas no mercado ou Currency Rates .\nO endpoint abaixo retorna um JSON semelhante. Listamos somente os dados que vamos utilizar, mas vale dizer que a resposta desse JSON √© bem maior.\n Endpoint: https://api.exchangeratesapi.io/latest?base=USD  { \"rates\": { \"CAD\": 1.3563421308, \"BRL\": 5.3397475505, \"EUR\": 0.8826904405, \"USD\": 1.0, }, \"base\": \"USD\", \"date\": \"2020-07-13\" } Como vou comunicar? Uma fun√ß√£o chamada SetContext √© a respons√°vel por atualizar os valores do componente contexto. Ela poder√° ser chamada na tela se voc√™ quiser usar as informa√ß√µes que estiverem nesse contexto.\nPara fazer a comunica√ß√£o, basta seguir os pr√≥ximos passos:\n Ao definir o contexto na estrutura Kotlin DSL no backend √© necess√°rio implementar uma classe que estruture as informa√ß√µes que ser√£o recebidas no contexto. Utilizar duas estruturas para configurar e utilizar o contexto, sendo elas, uma classe para representar a informa√ß√£o da resposta da API e um Container para exibir essa informa√ß√£o em uma tela.  Passo 1: Criar a classe Currency De acordo com a resposta da API de exemplo, escrevemos a classe abaixo para estruturar os dados. Essa √© a primeira estrutura:\ndata class Currency( val eur: String, val brl: String, val cad: String, val usd: String ) Passo 2: Criar o Container Criada a primeiro estrutura, √© o momento de estruturar o Container que conter√° os componentes que desejamos exibir. √â nele que listaremos os componentes e tamb√©m o *Contexto para esse grupo de componentes.\n√â importante lembrar que o *Contexto , nesse caso, √© a funcionalidade do Beagle que registra informa√ß√µes de um componente e que podem ser recuperadas em outro componente. Ele n√£o √© o contexto(Context) das views no Android.  O Container est√° dividido em 2 partes principais:\n O context : √â um objeto do tipo ContextData que ser√° a vari√°vel respons√°vel por conter as informa√ß√µes que voc√™ deseja transferir. O children: √â uma lista dos componentes que fazem parte desse container e que ter√£o acesso ao contexto definido nele.  JSON Kotlin { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Currency Table in USD\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click to get the currency Table\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:sendRequest\", \"url\" : \"https://api.exchangeratesapi.io/latest?base=USD\", \"method\" : \"GET\", \"onSuccess\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"myContext\", \"value\" : { \"eur\" : \"@{onSuccess.data.rates.EUR}\", \"usd\" : \"@{onSuccess.data.rates.USD}\", \"brl\" : \"@{onSuccess.data.rates.BRL}\", \"cad\" : \"@{onSuccess.data.rates.CAD}\" }, \"path\" : \"currency\" } ] } ] }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"EUR: @{myContext.currency.eur}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"BRL: @{myContext.currency.brl}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"CAD: @{myContext.currency.cad}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"USD: @{myContext.currency.usd}\" } ], \"context\" : { \"id\" : \"myContext\", \"value\" : { \"eur\" : \"\", \"usd\" : \"\", \"brl\" : \"\", \"cad\" : \"\" } } }  Container( context = ContextData( id = \"myContext\", value = Currency( eur = \"\", brl = \"\", cad = \"\", usd = \"\" ) ), children = listOf( Text(\"Currency Table in USD\"), Button( text = \"Click to get the currency Table\", onPress = listOf( SendRequest( url = \"https://api.exchangeratesapi.io/latest?base=USD\", method = RequestActionMethod.GET, onSuccess = listOf( SetContext( contextId = \"myContext\", path = \"currency\", value = Currency( eur = \"@{onSuccess.data.rates.EUR}\", brl = \"@{onSuccess.data.rates.BRL}\", cad = \"@{onSuccess.data.rates.CAD}\", usd = \"@{onSuccess.data.rates.USD}\" ) ) ) ) ) ), Text( text = \"EUR: \" + \"@{myContext.currency.eur}\" ), Text( text = \"BRL: \" + \"@{myContext.currency.brl}\" ), Text( text = \"CAD: \" + \"@{myContext.currency.cad}\" ), Text( text = \"USD: \" + \"@{myContext.currency.usd}\" ) ) )  O Container A estrutura dessa p√°gina tem 1 t√≠tulo, 1 bot√£o e 4 text views que receber√£o as informa√ß√µes do contexto.\n O t√≠tulo √© meramente ilustrativo para exemplificar a estrutura e hierarquia da p√°gina. O bot√£o √© utilizado para disparar a resposta da API e chamar a fun√ß√£o SetContext para atribuir o resultado da resposta ao contexto. Os 4 text views receber√£o as informa√ß√µes vindas do contexto.  O Bot√£o e as fun√ß√µes SendRequest e SetContext Para configurar o bot√£o √© preciso definir primeiro, a fun√ß√£o que ser√° acionada quando o bot√£o for clicado, ou seja, voc√™ deve configurar o atributo onPress do bot√£o. A fun√ß√£o que deve ser chamada no clique √© a SendRequest e ela ser√° respons√°vel por requisitar a resposta da API configurada nela.\nVeja abaixo os par√¢metros dessa fun√ß√£o cujo exemplo est√° no c√≥digo do container acima.\nSendRequest    Atributo Descri√ß√£o     url Endpoint que responder√° com as informa√ß√µes que desejamos definir no contexto.   method Define o method do request. Nesse exemplo ser√° o GET.   onSuccess Define uma a√ß√£o a ser realizada quando a requisi√ß√£o da API √© bem sucedida. √â aqui no onSuccess que ser√° chamada de fun√ß√£o SetContext.    Quando a requisi√ß√£o da API recebe uma resposta, o m√©todo SetContext √© chamado e √© nele que atribuiremos o resultado da chamada da API ao contexto.\nVeja abaixo os atributos do SetContext:\nSetContext    Atributo Descri√ß√£o     contextId Obrigat√≥rio. O ID que foi definido no ContextData, que referencia esse contexto. No exemplo o id √© \"MyContext\"   path Este atributo pode ser implementando para definir uma path especializado. Neste exemplo o definimos como ‚Äúcurrency‚Äù , que √© como os valores ser√£o requisitados do contexto.   value Obrigat√≥rio. Ele atribui valor aos atributos declarados no contexto de acordo com a resposta da API. Neste exemplo para recuperar o valor da API devemos construir esse valor da seguinte forma: \"@{onSuccess.data.rates.EUR}\", ou seja, a parte onSuccess.data representa a informa√ß√£o recebida na resposta da API, e de acordo com o JSON que representa essa estrura o resultado pode ser acessado usando .rates.EUR por exemplo, que √© a chave do valor que queremos acessar.    O texto Temos 4 componentes visuais nesse exemplo, eles que exibir√£o as informa√ß√µes atribu√≠das ao contexto. E aqui voc√™ percebe como ocorre a comunica√ß√£o entre componentes, no passo anterior enviamos uma informa√ß√£o para o contexto, que agora ir√° ser recuperada.\nAqui temos somente o atributo text desse componente textual, porque √© ele que definir√° a informa√ß√£o a ser exibida.\n   Atributo Descri√ß√£o     text Valor no formato String que ser√° exibido na tela. Para recuperar o valor do contexto use a nota√ß√£o \"@{myContext.currency.eur}\", ou seja, voc√™ deve definir o caminho para acessar as informa√ß√µes salvas no contexto utilizando o \"@{ID_DO_CONTEXTO+PATH+NOME_DO_ATRIBUTO}\"    A tela E agora a tela est√° pronta! Foi configurado um exemplo de contexto e demonstrado como acontece a comunica√ß√£o entre os componentes.\nNo final deste exemplo a sua tela deve estar assim:\n","excerpt":" A comunica√ß√£o entre componentes √© uma forma de compartilhar ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/como-fazer-comunica%C3%A7%C3%A3o-entre-componentes/","title":"Como fazer comunica√ß√£o entre componentes"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/release-notes/","title":"Release Notes"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/tutoriais/","title":"Tutoriais"},{"body":" Siga as orienta√ß√µes de acordo com o sistema operacional que estiver usando:\nAndroid e Backend iOS Configurando o Gradle Se voc√™ trabalha com aplica√ß√µes Android ou via Backend, deve come√ßar configurando o arquivo**gradle.properties**, que se encontra na **pasta root**. Essa configura√ß√£o vale tanto para vers√µes remotas como locais.\nAssim que abrir o arquivo, o primeiro passo √© mudar o nome da vers√£o que ser√° gerada. Para isso, voc√™ pode alterar o valor da vari√°vel **VERSION_NAME**para o valor desejado.\nEssa vari√°vel serve para referenciar o nome da vers√£o quando voc√™ for importar o Beagle.\n Al√©m disso, √© preciso acrescentar uma vari√°vel chamada RELEASE_SIGNING_ENABLED e atribui-l√° ao valor false. Isso significa que voc√™ n√£o precisa assinar a vers√£o, j√° que essa configura√ß√£o permite gerar uma vers√£o do Beagle de forma local ou para um reposit√≥rio pr√≥prio.\nDepois que terminar essas configura√ß√µes, voc√™ ter√° de ter no seu gradel as seguintes vari√°veis de acordo com o nome que escolher para sua vers√£o (neste exemplo, usamos**beagle-test**):\nVERSION_NAME=beagle-test RELEASE_SIGNING_ENABLED=false Publicando em um reposit√≥rio remoto Ao final da configura√ß√£o do gradle.properties, voc√™ precisa configurar um arquivo que est√° na pasta root do Beagle, no caso, o maven-publish.gradle. Nesse arquivo, adicione um target, que definir√°:\n Em qual reposit√≥rio ser√° gerado a vers√£o As credenciais necess√°rias para acessar esse reposit√≥rio.     Chaves Defini√ß√£o     releaseRepositoryUrl URL do reposit√≥rio onde a vers√£o ser√° gerada.   repositoryUsername Nome de usu√°rio.   repositoryPassword Senha do nome de usu√°rio declarado.    Segue abaixo um exemplo de publica√ß√£o:\napply plugin: \"com.vanniktech.maven.publish\" def versionName = System.env.VERSION_DEPLOY != null ? System.env.VERSION_DEPLOY : VERSION_NAME ?: \"\" version = versionName mavenPublish { nexus { stagingProfile = \"br.com.zup\" } targets { uploadArchives { releaseRepositoryUrl = \"https://meu-repo.com.br\" repositoryUsername = \"username\" repositoryPassword = \"password\" } } } Publicando em um reposit√≥rio local Ao final da configura√ß√£o do gradle.properties , voc√™ deve rodar alguns comandos do gradle.\nPara isso, v√° at√© a pasta root da plataforma em que voc√™ deseja gerar vers√£o (Android ou Backend) e no terminal de sua prefer√™ncia execute o seguinte comando:\nSe estiver em um terminal do Windows:\ngradlew clean build publishToMavenLocal Caso esteja nos demais terminais:\n./gradlew clean build publishToMavenLocal Depois de rodar o comando, a vers√£o ser√° gerada automaticamente.\n Diferente da configura√ß√£o para Android e Backend, em aplica√ß√µes iOS voc√™ n√£o precisa configurar o arquivo gradle.properties. Nesse caso, basta seguir direto para as configura√ß√µes de acordo com a vers√£o que deseja gerar.\nPublicando em um reposit√≥rio remoto Usando o CocoaPods No arquivo podfile , assim como qualquer outra depend√™ncia, coloque o Beagle e aponte o endere√ßo do seu reposit√≥rio , como no exemplo a baixo:\npod 'Beagle', :git =\u003e 'https://github.com/profile/myrepo' Depois de configurado o podfile execute o seguinte comando para baixar do seu reposit√≥rio:\npod install Usando o Carthage No arquivo Cartfile, adicione o reposit√≥rio da sua vers√£o do Beagle:\ngithub ‚ÄúYourUser/YourRepository‚Äù Publicando em um reposit√≥rio local Usando o CocoaPods Abra o terminal e v√° para a pasta raiz do Beagle e digite o seguinte comando:\npod spec create MyBeagle E MyBeagle.podspec ser√° criado. Agora abra esse arquivo com um editor de texto e siga como o exemplo abaixo:\nPod::Spec.new do |spec| spec.name = \"MyBeagle\" spec.version = \"1.0.0\" spec.summary = \"A short description\" spec.description = \"Complete description\" spec.platform = :ios, \"12.2\" spec.source = { :path =\u003e '.' } Em seguida execute o seguinte comando no terminal com a pasta raiz do projeto:\npod install Usando o Carthage No arquivo Cartfile, adicione o diret√≥rio da sua vers√£o do Beagle da seguinte forma:\ngit \"file:////Users/beagle\" \"master\" Importante que voc√™ adicione o caminho completo do diret√≥rio com a sua vers√£o do Beagle para que essa chamada funcione corretamente.\n  ","excerpt":" Siga as orienta√ß√µes de acordo com o sistema operacional que estiver ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/como-gerar-uma-vers%C3%A3o-do-beagle-local-ou-remota/","title":"Como gerar uma vers√£o do Beagle local ou remota"},{"body":" What is Playground? Playground is a development tool where you can create components and pages using Beagle. It is very fast and simple, without any installation process. It has a interface that allows you to write a JSON and see the result instantly.\nAccessing Playground You can access the playground through the following link:\n{% embed url=‚Äúhttps://beagle-playground.netlify.app‚Äù %}}\nYou will have access to the following demo project:\nThe files menus are on the left, JSON files are centered and on the right you will see the JSON preview.\n","excerpt":" What is Playground? Playground is a development tool where you can ‚Ä¶","ref":"/docs-beagle/docs/playground/playground-web/","title":"Playground Web"},{"body":" Criando uma a√ß√£o do frontend No Beagle, √© poss√≠vel criar uma a√ß√£o customizada a partir de uma CustomAction.\nCada plataforma possui sua forma especificia de fazer essa implementa√ß√£o no frontend. Voc√™ pode ver exemplos abaixo de como fazer em cada uma delas:\nAndroid iOS Web  Crie uma classe anotada com @RegisterAction que implementa uma interface Action. Essa interface ir√° requistar a implementa√ß√£o do m√©todo execute e voc√™ ir√° declarar o resultudo da action. O atributo msg listado, √© o √∫nico exemplo de par√¢metro que deve ser declarado na classe construtora.  O exemplo abaixo mostra um a√ß√£o com Toast:\n@RegisterAction data class CustomAction( val msg: String? = null ) : Action { override fun execute(rootView: RootView) { Toast.makeText( rootView.getContext(), msg, Toast.LENGTH_LONG).show() } }   Voc√™ deve criar a classe que implementa uma Action. Essa mesma classe ir√° fazer a requisi√ß√£o da implementa√ß√£o do m√©todo execute e ir√° ditar as a√ß√µes na action. O atributo listado msg √© o √∫nico par√¢metro que deve ser declarado na classe construtora.  O exemplo abaixo mostra um a√ß√£o com Alert:\nclass CustomAction: Action { let msg: String? init(msg: String? = nil) { self.msg = msg } func execute(controller: BeagleController, sender: Any) { let alert = UIAlertController( title: nil, message: msg, preferredStyle: .alert ) controller.present(alert, animated: true) } }  Para registrar a a√ß√£o, apenas crie o m√©todo com todo seu custom action e chame o m√©todo do Beagle registerCustomAction para fazer o registro;\n  Chame o m√©todo criado no BeagleConfig, ele pode ser visto nesse exemplo:\n  private func registerCustomAction() { Beagle.registerCustomAction(\"CustomAction\", actionType: CustomAction.self) }   Voc√™ deve criar a interface com o _beagleAction_ como uma propriedade obrigat√≥ria e com os par√¢metros necess√°rios para a sua a√ß√£o. Para esse exemplo, ser√° criado o atributo msg do tipo string. No ___beagleAction_, coloque o nome da a√ß√£o customizada no padr√£o: ‚Äòcustom:nomeDaA√ß√£o‚Äô:  interface CustomAction { _beagleAction_: 'custom:CustomAction', msg: string } Depois de ter feito isso, declare a fun√ß√£o do tipo ActionHandler com a interface que voc√™ criou:  import { ActionHandler } from '@zup-it/beagle-web' export const customHandler: ActionHandler\u003cCustomAction\u003e = ({ action }) =\u003e { /* Podemos acessar nosso par√¢metro definido na interface, por exemplo action.msg nos traz o valor de msg. */ alert(action.msg) } Adicione o nome da a√ß√£o nos arquivos de associa√ß√£o, de acordo com cada framework:  Angular: adicione no beagle.module.ts\n@BeagleModule({ ... customActions:{ \"custom:CustomAction\": customHandler //nome do action handler  } }) export class Beagle {} React: adicione nos arquivos de configura√ß√£o do Beagle:\nexport default createBeagleUIService\u003cany\u003e({ ... customActions:{ \"custom:CustomAction\": customHandler //nome do action handler  } })  Criando uma a√ß√£o no backend Para criar essa a√ß√£o, o seu c√≥digo deve estar assim:\n@RegisterAction data class CustomAction( val msg: String? = null ) : Action Veja abaixo um exemplo de uma A√ß√£o em um componente do tipo Button:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Beagle Button\", \"onPress\": [ { \"_beagleAction_\": \"custom:customAction\", \"msg\": \"Eu sou um Toast.\" } ] }  Button( text = \"Beagle Button\", onPress = listOf(CustomAction(\"Eu sou um Toast\")) )  ","excerpt":" Criando uma a√ß√£o do frontend No Beagle, √© poss√≠vel criar uma a√ß√£o ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/como-criar-novas-actions/","title":"Como criar novas actions"},{"body":" Using the playground Files menu On the files menu, the left of the screen, you are able to create, delete or select a file and then click on the first top icon or press CRTL+B you can minimize or expand the menu.\nJSON The JSON‚Äôs changes can be saved clicking on the second top icon or pressing CRTL+S. You can update the screen preview with a new JSON, click on the fourth icon on the top corner or press F9.\nWhen the changes are saved, a link will be available for your project, it is on the cloud and then you are able to access anywhere you want.\nPlatform On the right top menu, it is possible to select which platform you want to use, React Web or Angular are available.\n","excerpt":" Using the playground Files menu On the files menu, the left of the ‚Ä¶","ref":"/docs-beagle/docs/playground/playground-web/using-the-playground/","title":"Using the Playground"},{"body":" Examples of demo components You will see below a list with the demo components implemented in the Playground:\nButton Try it on the Playground\nComponent‚Äôs documentation\nContainer Try it on the Playground\nComponent‚Äôs Documentation\nLazy Component Try it on the Playground\nComponent‚Äôs Documentation\nList View Experimente no Playground\nComponent‚Äôs Documentation\nModal Try it on the Playground\nPage View Try it on the Playground\nComponent‚Äôs Documentation\nSimple Form Try it on the Playground\nComponent‚Äôs Documentation\nTab View Try it on the Playground\nComponent‚Äôs Documentation\nText Try it on the Playground\nComponent‚Äôs Documentation\nTouchable Try it on the Playground\nComponent‚Äôs Documentation\n","excerpt":" Examples of demo components You will see below a list with the demo ‚Ä¶","ref":"/docs-beagle/docs/playground/playground-web/demo-components/","title":"Demo components"},{"body":" Exibindo uma tela a partir de uma URL Cada plataforma tem sua forma pr√≥pria para exibir uma tela server-driven no frontend usando o Beagle. Abaixo, listamos exemplos para cada uma delas.\nAndroid iOS Web Para exibir uma tela full server-driven, voc√™ deve usar o m√©todo this.newServerDrivenIntent\u003cBeagleActivity\u003e() onde o this √© a o contexto da sua tela atual.\nEste m√©todo requer apenas o par√¢metro ScreenRequest\nVoc√™ deve seguir tal como o comando abaixo:\nCertifique-se de listar a sua Beagle Activity assim como nomeada em seu AndroidManifest.\nNo exemplo abaixo a chamamos somente de \u003cBeagleActivity\u003e. Esse nome √© voc√™ quem define ao criar sua BeagleActivity. Em nosso tutorial Criando um projeto do zero , chamamos ela de AppBeagleActivity\n val intent = this.newServerDrivenIntent\u003cBeagleActivity\u003e(ScreenRequest(\"/screen\")) startActivity(intent) Para testar o comando acima, o componente ScreenRequest requer somente uma URL que traga o JSON com as informa√ß√µes da tela server-driven que voc√™ quer exibir.\nNeste caso, siga estes passos:\n Use o exemplo de tela no link abaixo. Ele traz um JSON de uma tela simples para teste. Basta copiar e colar no lugar da URL \"/screen\" . https://run.mocky.io/v3/73322be2-96bf-467b-b6dc-e3fff179852c Veja como fica o c√≥digo abaixo.  val intent = this.newServerDrivenIntent\u003cBeagleActivity\u003e(ScreenRequest(\"https://run.mocky.io/v3/73322be2-96bf-467b-b6dc-e3fff179852c\")) startActivity(intent)   A classe Screen Request. AScreenRequest √© uma classe interna do Beagle utilizada para solicitar qual tela voc√™ deseja exibir. Voc√™ listar√° apenas o atributo URL referente a p√°gina que deseja carregar vinda do BFF.\nNo entanto, esse elemento possui outros atributos, que podem ser utilizados na transi√ß√£o e entre telas. Para saber mais sobre essa classe, veja em Screen Request\n Para renderizar uma tela server-driven, basta criar uma inst√¢ncia BeagleScreenViewController do tipo remote e fazer a inicializa√ß√£o com a URL do seu BFF, como no exemplo abaixo:\nlet beagleViewController = Beagle.screen( .remote( .init(url: \"// URL AQUI\") ) ) Feito isso, basta apresent√°-la onde preferir. Neste caso, voc√™ deve seguir como no comando de exemplo.\npresent(beagleViewController, animated: true, completion: nil) A resposta do seu BFF deve ser um JSON que representa um componente visual definido localmente na aplica√ß√£o.\nVoc√™ tamb√©m pode renderizar uma tela de exemplo. Para isso, basta passar esta mesma URL na inicializa√ß√£o da**BeagleScreenViewController**.\n Por fim, execute a aplica√ß√£o e veja uma tela definida em uma URL remota renderizada na sua aplica√ß√£o local.\nParab√©ns, voc√™ conseguiu exibir uma tela full server-driven üéâ\nDesta forma, ser√° poss√≠vel criar telas com conte√∫do din√¢mico, e controle no seu backend.\n  Para projetos no Angular Para definir onde voc√™ quer mostrar uma tela server-driven no Angular, voc√™ deve usar o componente fornecido pela biblioteca \u003cbeagle-remote-view\u003e\nEste componente tem outros atributos que podem ser configurados. No entanto nessa implementa√ß√£o voc√™ utilizar√° somente o atributo path, descrito no exemplo abaixo.\nPara mais detalhes sobre esse componente clique no link a seguir e verifique os detalhes do Remote View\n No arquivo html do seu componente, adicione o remote view.\n\u003cbeagle-remote-view [loadParams]=\"loadParams\"\u003e\u003c/beagle-remote-view\u003e Feito isso, acesse o controller do componente e crie o loadParams que √© esperado pelo remote view.\nloadParams: LoadParams; constructor() { this.loadParams = { path: '/pathToScreen' }; } No campo path, deve ficar o caminho para seu JSON que ser√° associado com o baseUrl definido em beagle.module.ts.\n Para projetos no React Para definir uma tela server-driven no React, voc√™ precisa criar um servi√ßo com uma configura√ß√£o m√≠nima, como no exemplo:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} }) Feito isso, usamos dois componentes fornecidos pela biblioteca Beagle para definir onde a tela server-driven ser√° renderizada:\n O BeagleProvider O BeagleRemoteView  ... import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView path={'/pathToScreen'} /\u003e \u003c/BeagleProvider\u003e ); } export default App; No campopath, deve ficar o caminho para seu JSON que ser√° associado com o baseUrl definido em seu servi√ßo.\n  Exibindo uma tela a partir de um JSON Android iOS Para renderizar uma tela a partir de um JSON, √© necess√°rio ter uma Activity ou Fragment com um FrameLayout como no exemplo a baixo:\n\u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/frame_layout_android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"/\u003e Agora basta chamar o m√©todo renderScreen() a partir do frame layout criado no xml passando como par√¢metro a sua activity e o JSON.\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) frame_layout_android.renderScreen( activity = this, screenJson = \"// JSON here\" ) } } O m√©todo renderScreen() tamb√©m pode receber um fragment como par√¢metro seguindo o exemplo abaixo:\nrenderScreen(fragment = yourFragment, screenJson = \"// JSON here\")\n  Para renderizar uma tela de um JSON, basta criar uma inst√¢ncia BeagleScreenViewController do tipo declarativeText e fazer a inicializa√ß√£o com o JSON, como no exemplo abaixo:\nlet beagleViewController = Beagle.screen( .declarativeText( .init(text: \"// JSON HERE\") ) ) Feito isso, basta apresent√°-la onde preferir. Neste caso, voc√™ deve seguir como no comando de exemplo.\npresent(beagleViewController, animated: true, completion: nil)  ","excerpt":" Exibindo uma tela a partir de uma URL Cada plataforma tem sua forma ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/exibindo-uma-tela/","title":"Exibindo uma tela"},{"body":" Existem duas formas que os componentes do Beagle podem ser adicionados a sua aplica√ß√£o:\n Via BFF (como um server driven componente); Como um componente declarativo no front end.  Veja abaixo mais detalhes de como adicionar um componente Beagle a sua tela nativa:\n","excerpt":" Existem duas formas que os componentes do Beagle podem ser ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/adicionando-o-beagle-a-uma-parte-da-tela-nativa/","title":"Adicionando o Beagle a uma parte da tela nativa"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/playground/","title":"Playground"},{"body":" What is it? For now, there are two common accessibility attribute types in all platforms Beagle supports.\n   Attributes Type Required Definition     accessible Boolean ‚úì Indicates whether the component will be interpreted as accessible. Default is true.   accessibilityLabel String  string containing a message that will be spoken by programs, like VoiceOver.    If backend does not specify accessibility, the default values ‚Äã‚Äãfor each platform will be used.  How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/rvRN9kv/logo.png\" }, \"accessibility\": { \"accessibilityLabel\": \"Image Label\", \"accessible\": true } } ] }  iner( children = listOf( Image( path = ImagePath.Remote(\"https://i.ibb.co/rvRN9kv/logo.png\") ).applyAccessibility( accessibility = Accessibility(true, \"Image Label\") ) ) )  üëâ Test this example on Web Playground ","excerpt":" What is it? For now, there are two common accessibility attribute ‚Ä¶","ref":"/docs-beagle/docs/api/accessibility/","title":"Accessibility"},{"body":" √â poss√≠vel que alguns componentes de uma tela que sejam exibidos via server-driven (tela nativa) recebam somente uma se√ß√£o da p√°gina , ou mesmo um √∫nico componente do servidor BFF.\nNo exemplo abaixo, vamos exibir um bot√£o server-driven em uma tela nativa. O resultado que deve aparecer na sua aplica√ß√£o √© esse:\nPr√©-requisitos Para que essa configura√ß√£o funcione corretamente, voc√™ precisa de:\n Um BFF configurado com o Beagle. Caso n√£o o tenha, veja como configurar nesse tutorial. Um frontend configurado com o Beagle para Android ou iOS. Caso n√£o o tenha, siga um dos tutoriais de acordo com sistema operacional:  Android iOS    Passo 1: Criar o componente no backend Neste exemplo, criaremos um bot√£o como componente server-driven para que possamos exib√≠-lo em uma tela nativa.\nPara isso, siga os passos a seguir:\n Crie uma classe Kotlin em seu backend. Nomeie-o SingleComponentBuilder. Essa ser√° a classe que vai construir o seu componente (objeto) server-driven. Feito isso, copie e cole o c√≥digo abaixo.  import br.com.zup.beagle.widget.action.Alert import br.com.zup.beagle.widget.ui.Button class SingleComponentBuilder() { fun createButton(): Button { return Button( \"Sou um bot√£o server-driven\", onPress = listOf( Alert( \"Bot√£o server-driven\", \"Sou um bot√£o server-driven\", labelOk = \"OoooK\" ) ) ) } }  Este bot√£o ter√° uma a√ß√£o do tipo \"Alert\", que j√° est√° configurada no c√≥digo acima.  Passo 2: Atualizar a classe Service e Controller no backend Depois que voc√™ criou o componente, ser√° preciso atualizar algumas classes. Veja como fazer essa configura√ß√£o de acordo com cada uma delas.\nAtualizando o Service O Service √© a classe respons√°vel por configurar o servi√ßo que usaremos, que pode ser de v√°rios tipos. No caso desse exemplo, s√≥ ser√° listado o que est√° sendo configurando.\nComece abrindo a classe ScreenBeagleService.kt (nome escolhido para o tutorial de configura√ß√£o do BFF, mas voc√™ pode renome√°-la se quiser).\nFeito isso, copie a linha abaixo e cole dentro da classe ScreenBeagleService:\n fun createServerDrivenComponent() = SingleComponentBuilder().createButton()  import com.example.bff.builder.SingleComponentBuilder import org.springframework.stereotype.Service @Service class ScreenBeagleService { fun createServerDrivenComponent() = SingleComponentBuilder().createButton() } Atualizando Controller Se a configura√ß√£o acima funcionar, voc√™ atualizar√° o controller e o componente e eles estar√£o prontos para serem enviados ao frontend, caso haja uma requisi√ß√£o.\nAgora, na classe controller, voc√™ deve chamar o servi√ßo que acabamos de configurar e definir a URL que ser√° o endpoint do componente criado.\nPara isso, siga os passos:\n Abra a classeScreenController. Esse nome foi dado a essa classe no tutorial, ela que √© respons√°vel por expor os componentes via API REST. Adicione outra fun√ß√£o √† essa classe (Lembrando que a classe j√° tem algumas fun√ß√µes implementadas). Anote a fun√ß√£o com o @GetMapping()e listar o endpoint (Path relativo da URL) que identifica esse componente.  Veja como deve ficar a configura√ß√£o:\n@RestController class ScreenController( private val screenBeagleService: BeagleService ) { @GetMapping(\"/serverDrivenComponent\") fun getServerDrivenComponent() = screenBeagleService.createServerDrivenComponent() } Teste o endpoint Agora que o componente esta criado e configurado, voc√™ deve testar o endpoint e verificar a resposta JSON. Para isso, realize essas a√ß√µes:\n Inicie a sua aplica√ß√£o no backend (Lembre-se que sua aplica√ß√£o Backend est√° configurada para apresentar as resposta no localhost). Abra o um browser e acesse o endpoint: http://localhost:8080/serverDrivenComponent  Voc√™ deve receber o JSON abaixo:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Sou um bot√£o server-driven\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Bot√£o server-driven\", \"message\" : \"Sou um bot√£o server-driven\", \"labelOk\" : \"OoooK\" } ] }  Button( \"Sou um bot√£o server-driven\", onPress = listOf( Alert( \"Bot√£o server-driven\", \"Sou um bot√£o server-driven\", labelOk = \"OoooK\" ) ) )  Passo 3: Exibir o componente server-driven Depois dos dois passos anteriores, o seu componente est√° pronto. Agora, voc√™ s√≥ precisa exibi-lo em uma tela nativa.\nPara essa configura√ß√£o, siga as orienta√ß√µes espec√≠ficas para cada plataforma:\nAndroid iOS WEB Voc√™ deve utilizar o frame layout para ‚Äúreceber‚Äù o componente do BFF e, assim, exibi-lo em uma tela Android nativa.\nPara isso, basta seguir esses passos:\n Crie o arquivo .XML abaixo que representa uma tela nativa com um t√≠tulo e um frame layout. Nesse exemplo definimos essa pagina como nossa MainActivity Depois, copie e cole a configura√ß√£o abaixo:  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003cTextView android:id=\"@+id/tv_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"100dp\" android:text=\"Sou componente Nativo!\" android:textSize=\"30sp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cFrameLayout android:id=\"@+id/fr_server_driven\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" app:layout_constraintTop_toBottomOf=\"@id/tv_title\" android:layout_marginTop=\"40dp\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e Ap√≥s configurar o frame layout, √© preciso informar ao Beagle qual componente ser√° exibido. Para isso, utilize a fun√ß√£o loadView como listado no exemplo a seguir.\n Veja como fazer isso:\n Abra a activity onde voc√™ deseja exibir a sua tela nativa. Crie uma vari√°vel do tipo FrameLayout que deve receber a FrameLayout View que configuramos. Agora basta chamar a fun√ß√£o .loadView a partir da vari√°vel frameLayout  val frameLayout = findViewById\u003cFrameLayout\u003e(R.id.fr_server_driven) frameLayout.loadView(this, ScreenRequest(\"/serverDrivenComponent\")) E pronto: basta iniciar sua aplica√ß√£o e voc√™ ver√° a tela a seguir!\n .![](/docs-beagle/assets%2F-M-Qy7jZbUpzGRP5GbCZ%2F-MC8IwWJstYtvxLbosfv%2F-MC8QfhsPkq60mGJKtfy%2Fserver-driven-comp-ios.gif?alt=media\u0026token=b5500211-e2bc-477d-aea4-835245be1531).  Clique no bot√£o e perceba que a fun√ß√£o nesse componente est√° implementada e funcional, ou seja, o Beagle exibe todos os componentes como se fossem nativos.\n Voc√™ deve utilizar um view controller para ‚Äúcolocar‚Äù esse componente do BFF e, assim, exib√≠-lo em tela iOS nativa.\nMas antes, √© preciso criar esse view controller para a tela nativa. Para isso, basta seguir os passos:\n Instancie o componente server-driven a partir da classe BeagleScreenViewController. Utilize o addChild para adicionar o view controller. Tamb√©m adicione o view do beagleScreenViewController comosubview do nosso view controller nativo. Por √∫ltimo, √© necess√°rio adicionar algumas constraints para a UILabel e para a view do beagleScreenViewController como no c√≥digo abaixo:  class NativeViewController: UIViewController { private let beagleScreenViewController = BeagleScreenViewController(.remote(.init(url: \"http://localhost:8080/serverDrivenComponent\"))) private lazy var descriptionText: UILabel = { let label = UILabel() label.text = \"Sou um componente nativo\" label.font = .systemFont(ofSize: 25, weight: .semibold) return label }() override func viewDidLoad() { super.viewDidLoad() setupView() } func setupView() { view.backgroundColor = .white addChild(beagleScreenViewController) view.addSubview(descriptionText) descriptionText.anchorCenterXToSuperview() descriptionText.anchor(top: view.topAnchor, topConstant: 150) guard let beagleView = beagleScreenViewController.view else { return } view.addSubview(beagleView) beagleView.anchorCenterXToSuperview() beagleView.anchor(top: descriptionText.bottomAnchor, topConstant: 50, widthConstant: 300, heightConstant: 50) beagleScreenViewController.didMove(toParent: self) } Ao final do processo, voc√™ poder√° ‚Äúchamar‚Äù pela nossa tela nativa que ir√° aparecer a imagem abaixo. Lembrando que, para esse exemplo, foi criada uma tela composta de uma UILabel e de uma vari√°vel do tipo BeagleScreenViewController , onde fica o componente server-driven.\n Se voc√™ ainda n√£o configurou a biblioteca em seu projeto, veja aqui como fazer isso.\nVoc√™ deve utilizar o Remote View, fornecido pela biblioteca do Beagle, para criar telas h√≠bridas com alguns componentes server driven na web.\nVeja a seguir como funciona para cada framework:\nReact\nNo React, voc√™ s√≥ precisa criar uma fun√ß√£o que retorna dois componentes. Um deles √© o BeagleRemoteView com o caminho para carregar o componente server-driven.\nimport React, { FC } from 'react' import { LoadParams } from '@zup-it/beagle-web'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from '../../beagle/beagle.service'; import NativeComponent from '../NativeComponent'; const params: LoadParams = { path: '/mypath', } const Main = () =\u003e { return ( \u003c\u003e \u003cNativeComponent text=\"Sou um componente nativo!\"\u003e\u003c/NativeComponent\u003e \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView {...params} /\u003e \u003c/BeagleProvider\u003e \u003c/\u003e ) } export default Main Angular\nNo Angular, basta criar um componente nativo normalmente e adicionar o beagle-remote-view junto ao template no local que voc√™ quer que os itens server-driven sejam renderizados.\n\u003capp-native-component text=\"Sou um componente nativo\"\u003e\u003c/app-native-component\u003e \u003cbeagle-remote-view [loadParams]=\"loadParams\"\u003e\u003c/beagle-remote-view\u003e No caso do Angular, n√£o √© poss√≠vel usar o componente BeagleRemoteView caso ele seja carregado pela biblioteca de outra forma server-driven porque isso causa uma depend√™ncia circular e quebra a aplica√ß√£o.\n Lembre-se de rodar seu projeto Angular usando um dos comandos:\nyarn run serve ou npx run serve\n A sua tela h√≠brida com elementos nativos e server driven est√° pronta\n ","excerpt":" √â poss√≠vel que alguns componentes de uma tela que sejam exibidos via ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/adicionando-o-beagle-a-uma-parte-da-tela-nativa/adicionando-um-componente-beagle-server-driven/","title":"Adicionando um componente Beagle Server-driven"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/api/","title":"API"},{"body":" What is it? On Beagle, an action deals with behaviours (functions), that are performed in your application when an event is triggred. These actions can be a Beagle‚Äôs pattern or customized by you.\nAny Beagle‚Äôs event must be associated with an action list. See below a button‚Äôs component example, that associates with a pattern action alert to its onPress event:\n{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"click to show alert\", \"onPress\": [{ \"_beagleAction_\": \"beagle:alert\", \"title\": \"Hello\", \"message\": \"World\" }] } An action is map key/value with at least a _beagleAction_ property. Its value indicates which action must be performed when the event it is triggered. The other properties specify the parameters expected by the indicated action.\nThere are several implemented actions on Beagle by pattern and all of them start with prefix ‚Äúbeagle:‚Äù and the customized actions start with ‚Äúcustom:‚Äù.\nTo learn how to create custom actions, check out Beagle‚Äôs customization section.\nAction types Below, you will find a complete description of the attributes that are part of the Standard Actions on Beagle.\n","excerpt":" What is it? On Beagle, an action deals with behaviours (functions), ‚Ä¶","ref":"/docs-beagle/docs/api/actions/","title":"Actions"},{"body":" Passo 1: Criar a tela nativa Android iOS Para criar a tela nativa no Android, crie uma nova Activity. Aqui ser√° usado a MainActivity como modelo:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) declarative_content.addView(declarativeComponente().toView(this)) } } Nesse momento, a MainActivity.kt n√£o ter√° modifica√ß√µes. √â necess√°rio que o seu arquivo activity_main.xml seja modificado primeiro.\n  Abra o activity_main.xml Por padr√£o, este arquivo vem configurado com o Contraint Layout e ele pode ser mantido dessa forma. Para que ele possa ser utilizado pelo Beagle √© necess√°rio que se declare um Fragment Layout nesse arquivo xml. √â nesse fragment que ser√° carregado o componente declarativo.  Veja o exemplo de xml utlizado nesse tutorial, o que finaliza a cria√ß√£o da tela Nativa.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003cFrameLayout android:id=\"@+id/declarative_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c/FrameLayout\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e  Nesse exemplo criamos a seguinte UIViewController:\nclass NativeViewController: UIViewController { private lazy var firstLabel = makeLabel(text: \"I'm a native UILabel\") private lazy var secondLabel = makeLabel(text: \"Another native UILabel\") private func makeLabel(text: String) -\u003e UILabel { let label = UILabel() label.text = text label.textAlignment = .center label.font = .systemFont(ofSize: 25, weight: .semibold) label.backgroundColor = UIColor(hex: grayColor) return label } override func viewDidLoad() { super.viewDidLoad() navigationItem.title = \"Beagle Native\" navigationItem.backBarButtonItem = UIBarButtonItem( title: nil, style: .plain, target: nil, action: nil ) setupView() } private func setupView() { view.backgroundColor = .white view.addSubview(firstLabel) firstLabel.anchorCenterXToSuperview() firstLabel.anchor( top: topLayoutGuide.bottomAnchor, topConstant: 50 ) let layoutMargins = view.layoutMarginsGuide view.addSubview(secondLabel) secondLabel.anchorCenterXToSuperview() secondLabel.anchor(top: beagleView.bottomAnchor, topConstant: 30) secondLabel.bottomAnchor.constraint(lessThanOrEqualTo: layoutMargins.bottomAnchor).isActive = true } private let grayColor = \"#EEEEEE\" }  Passo 2: Criar o componente declarativo Android iOS Para criar um componente declarativo do Beagle, ser√° usado um Container (um componente do Beagle que agrupa outros componentes). Ele pode ser declarado como uma vari√°vel ou como uma fun√ß√£o que retorna um container. Nesse exemplo, foi configurado como retorno de uma fun√ß√£o:\nfun declarativeComponente() = Container( children = listOf( Text( text = \"These buttons are rendered by Beagle\" ).applyFlex( Flex( alignSelf = AlignSelf.CENTER ) ), Button( \"I'm a server-driven button 1\", onPress = listOf( Alert(message = \"I'm a working button\")) ) ), Button( \"I'm a server-driven button too\", onPress = listOf( Alert(message = \"I'm a working as well\")) ) ) ) )  Para criar um componente declarativo do Beagle em forma de UIView utilizamos o componente BeagleView, ele pode ser declarado como os componentes nativos criados no passo anterior. Segue um exemplo abaixo com um Container que possui um texto e dois bot√µes:\nprivate lazy var beagleView = BeagleView(Container( widgetProperties: .init(style: Style() .backgroundColor(grayColor) .margin(.init(all: 20)) .padding(.init(all: 10)) ) ) { Text( \"These buttons are rendered by Beagle\", widgetProperties: .init(style: .init( margin: .init(bottom: 10), flex: Flex().alignSelf(.center) )) ) Button( text: \"I'm a server-driven button\", onPress: [ Alert( title: \"Server-driven button\", message: \"I'm a server-driven button\" ) ] ) Button( text: \"Navigate to Navigator\", onPress: [Navigate.openNativeRoute(.init(route: .navigateStep1Endpoint))] ) })  Passo 3: Adicionar o componente na tela Android iOS Para adicionar esse componente a tela, ser√° necess√°rio chamar a fun√ß√£o **addView**do Android a partir do Fragment Layout view que foi declarado no activity_main.xml como listado no exemplo abaixo:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) declarative_content.addView(declarativeComponente().toView(this)) } } Como par√¢metro do addView foi listado a fun√ß√£o que retorna o componente criado aplicando o m√©todo do Beagle .toView(this)v\n O BeagleView pode ser adicionado como a UIView , nesse exemplo foi usado o m√©todo addSubview() para adicionar este componente na tela.\nSegue abaixo o m√©todo setupView() que √© respons√°vel por adicionar e ancorar os componentes da tela:\nprivate func setupView() { view.backgroundColor = .white view.addSubview(firstLabel) firstLabel.anchorCenterXToSuperview() firstLabel.anchor( top: topLayoutGuide.bottomAnchor, topConstant: 50 ) let layoutMargins = view.layoutMarginsGuide view.addSubview(beagleView) beagleView.translatesAutoresizingMaskIntoConstraints = false beagleView.topAnchor.constraint(equalTo: firstLabel.bottomAnchor, constant: 50).isActive = true beagleView.leadingAnchor.constraint(greaterThanOrEqualTo: layoutMargins.leadingAnchor).isActive = true beagleView.trailingAnchor.constraint(lessThanOrEqualTo: layoutMargins.trailingAnchor).isActive = true beagleView.centerXAnchor.constraint(equalTo: firstLabel.centerXAnchor).isActive = true view.addSubview(secondLabel) secondLabel.anchorCenterXToSuperview() secondLabel.anchor(top: beagleView.bottomAnchor, topConstant: 30) secondLabel.bottomAnchor.constraint(lessThanOrEqualTo: layoutMargins.bottomAnchor).isActive = true }  E pronto. Basta inicializar a sua aplica√ß√£o e a tela declarativa ser√° renderizada nativamente.\n","excerpt":" Passo 1: Criar a tela nativa Android iOS Para criar a tela nativa no ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/adicionando-o-beagle-a-uma-parte-da-tela-nativa/adicionando-um-componente-beagle-declarativo/","title":"Adicionando um componente Beagle Declarativo"},{"body":" What is it? The AddChildrenAction class is responsible for adding - at the beginning or in the end - or changing all views that inherit from Widget and who accept children.\nThe AddChildrenAction structure is:\n   Attribute Type Required Definition     componentId String ‚úì Defines the widget‚Äôs id, in which you want to add the views.   value List\u003cServerDrivenComponent\u003e ‚úì Defines the list of children you want to add.   mode Mode  Defines the placement of where the children will be inserted in the list or if the contents of the list will be replaced. By default the set mode is APPEND.    Mode It is an ENUM, which values are:\n   Values Definition     APPEND Adds the view in the end of the children‚Äôs list.   PREPEND Adds the view on the beginning of the children‚Äôs list.   REPLACE Replaces all children of the widget.    How to use it? JSON Kotlin DSL \"_beagleAction_\": \"beagle:addChildrenAction\", \"componentId\": \"MyContainerID\", \"value\": [{ \"_beagleComponent_\": \"beagle:text\", \"text\": \"This is the new view added\" } ], \"mode\": \"APPEND\" } ] } ], \"id\": \"MyContainerID\"  Container( children = listOf( Button(\"AddChildren\", onPress = listOf( AddChildrenAction( componentId = \"MyContainerID\", value = listOf( Text(\"This is the new view added\") ), mode = Mode.APPEND ) )) ) ).apply { id = \"MyContainerID\" }   ","excerpt":" What is it? The AddChildrenAction class is responsible for adding - ‚Ä¶","ref":"/docs-beagle/docs/api/actions/addchildren/","title":"Addchildren"},{"body":" Introdu√ß√£o Para este tutorial, iremos usar algumas a√ß√µes e tamb√©m APIs:\nActions\n SetContext SendRequest  APIs\n Context Binding Express√µes  Apesar do conceito Server-Driven trabalhar componentes separadamente, √© poss√≠vel realizar a transmiss√£o das informa√ß√µes para uma API e √© o que vamos demonstrar abaixo.\nExemplo de Uso Neste exemplo, iremos utilizar os componentes TextInput e Button para simularmos uma tela de Login.\nPasso 1: Criar uma tela de Login At√© este momento, vamos apenas sinalizar ao Beagle de que ele deve renderizar na tela dois componentes TextInputs e um componente Button para representarmos a tela de Login.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Username\" }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Password\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Login\" } ] }  Container( children = listOf( TextInput(placeholder = \"Username\"), TextInput(placeholder = \"Password\"), Button(text = \"Login\") ) )  Passo 2: Configurar o SetContext Agora utilize uma a√ß√£o chamada SetContext, que altera um contexto espec√≠fico em uma tela. Isto √© necess√°rio para dar vida √† tela e fazer com que os dados que forem digitados nela sejam enviados para uma API.\nNeste cen√°rio, o contexto √© que ir√° guardar os dados digitados de nome do usu√°rio e da senha para que, posteriormente, encaminhar estes dados para a API.\nAltere o c√≥digo para adicionar essa l√≥gica do SetContext:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"@{credentials.username}\", \"placeholder\": \"Username\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"credentials\", \"value\": \"@{onChange.value}\", \"path\": \"username\" } ] }, { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"@{credentials.password}\", \"placeholder\": \"Password\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"credentials\", \"value\": \"@{onChange.value}\", \"path\": \"password\" } ] }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Login\" } ], \"context\": { \"id\": \"credentials\", \"value\": { \"username\": \"\", \"password\": \"\" } } }  data class Credentials( val username: String, val password: String ) Container( context = ContextData( id = \"credentials\", value = Credentials(username = \"\",password = \"\") ), children = listOf( TextInput( placeholder = \"Username\", value = \"@{credentials.username}\", onChange = listOf( SetContext( contextId = \"credentials\", path = \"username\", value = \"@{onChange.value}\" ) ) ), TextInput( placeholder = \"Password\", value = \"@{credentials.password}\", onChange = listOf( SetContext( contextId = \"credentials\", path = \"password\", value = \"@{onChange.value}\" ) ) ), Button(text = \"Login\") ) )  Neste exemplo, utilizamos o evento onChange do pr√≥prio TextInput que √© chamado sempre que o usu√°rio digita um texto novo no input. Dentro do onChange, existe um contexto impl√≠cito chamado onChange no qual o value √© o √∫ltimo valor digitado pelo usu√°rio.\nOnChange Ainda dentro deste contexto, a a√ß√£o de SetContext ser√° executada a cada caractere digitado pelo usu√°rio. Por isso que neste SetContext √© obrigat√≥rio o contextId, que far√° refer√™ncia ao contexto que ser√° alterado, al√©m do value que representa o novo valor e do path que √© o caminho dentro do contexto que iremos alterar.\nPath √â o √∫nico par√¢metro opcional. Isto significa que, caso ele n√£o passe, o SetContext ir√° alterar a raiz do contexto para que o value seja o novo valor. No exemplo acima, estamos deixando claro que queremos alterar somente a chave username e password nos seus respectivos SetContexts.\nO poder do contexto + express√µes √© bem grande, pois √© poss√≠vel que, dentro de uma Action, voc√™ referencie o contexto impl√≠cito de quem a executou. No exemplo que vimos, √© o caso do onChange, mas √© poss√≠vel fazer refer√™ncia a outros contextos dentro de um contexto impl√≠cito, assim como usar m√∫ltiplas express√µes.\nVoc√™ pode inicializar uma tela com valores pr√©-definidos no contexto. Com isso, √© poss√≠vel que a tela renderize esses valores utilizando express√µes.\nNo exemplo visto acima, inicializamos os campos username e password com valores vazios vindo do contexto.\n Passo 3: Enviar dados para uma API At√© o momento, o que fizemos foi ‚Äúsalvar‚Äù estes valores no contexto para que, a partir desta etapa, possamos envi√°-los para uma API por meio de uma requisi√ß√£o.\nEsta etapa n√£o tem nenhuma diferen√ßa visual do passo anterior.  Para finalizar o fluxo de Login, vamos agora adicionar uma Action chamada SendRequest que, basicamente, permite fazer uma requisi√ß√£o HTTP e, no caso do onSuccess, mostrar um Alert dando boas-vindas ao usu√°rio.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"@{credentials.username}\", \"placeholder\": \"Username\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"credentials\", \"value\": \"@{onChange.value}\", \"path\": \"username\" } ] }, { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"@{credentials.password}\", \"placeholder\": \"Password\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"credentials\", \"value\": \"@{onChange.value}\", \"path\": \"password\" } ] }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Login\", \"onPress\": [ { \"_beagleAction_\": \"beagle:sendRequest\", \"url\": \"http://beagle.free.beeceptor.com/login\", \"method\": \"POST\", \"headers\":{ \"Content-Type\":\"application/json\" }, \"data\": { \"username\": \"@{credentials.username}\", \"password\": \"@{credentials.password}\", \"authType\": \"login\" }, \"onSuccess\": [ { \"_beagleAction_\": \"beagle:alert\", \"title\": \"You are logged-in\", \"message\": \"@{onSuccess.data.message}\" } ] } ] } ], \"context\": { \"id\": \"credentials\", \"value\": { \"username\": \"\", \"password\": \"\" } } }  data class Credentials( val username: String, val password: String ) data class RequestCredentials( val username: String, val password: String, val authType: String ) Container( context = ContextData( id = \"credentials\", value = Credentials(username = \"\", password = \"\") ), children = listOf( TextInput( placeholder = \"Username\", value = \"@{credentials.username}\", onChange = listOf( SetContext( contextId = \"credentials\", path = \"username\", value = \"@{onChange.value}\" ) ) ), TextInput( placeholder = \"Password\", value = \"@{credentials.password}\", onChange = listOf( SetContext( contextId = \"credentials\", path = \"password\", value = \"@{onChange.value}\" ) ) ), Button( text = \"Login\", onPress = listOf( SendRequest( url = \"http://beagle.free.beeceptor.com/login\", method = RequestActionMethod.POST, headers = mapOf( \"Content-Type\" to \"application/json\" ), data = RequestCredentials( username = \"@{credentials.username}\", password = \"@{credentials.password}\", authType = \"login\" ), onSuccess = listOf( Alert( title = \"You are logged-in\", message = \"@{onSuccess.data.message}\" ) ) ) ) ) ) )  Ao executar este c√≥digo, voc√™ deve preencher os campos e pressionar o bot√£o ‚ÄúLogin‚Äù.\nFeito isso, o evento onPress ir√° executar o SendRequest enviando os dados que est√£o dentro do Context com o ID credentials.\nAssim que o SendRequest for feito e a requisi√ß√£o for conclu√≠da, o evento onSuccess ir√° executar a Action Alert que ir√° mostrar um alerta contendo os dados retornados da API.\n","excerpt":" Introdu√ß√£o Para este tutorial, iremos usar algumas a√ß√µes e tamb√©m ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/criando-um-formul%C3%A1rio-e-submetendo-para-uma-api/","title":"Criando um formul√°rio e submetendo para uma Api"},{"body":" What is it? Alert class creates a confirmation element.\nAlert structure is:\n   Attribute Type Required Definition     title String or Binding  Box alert title.   message String or Binding ‚úì Box alert message.   onPressOk Action  Confirmation button action.   labelOk String  Confirmation button label.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Alert Example\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"title\": \"My Title\", \"message\": \"Alert message\", \"labelOk\": \"Close\" } ] } ] }  Container( children = listOf( Button( text = \"Alert Example\", onPress = listOf( Alert( title = \"My Title\", message = \"Alert message\", labelOk = \"Close\" ) ) ) ) )  üëâ Test this example in the Web Playground‚Äã ","excerpt":" What is it? Alert class creates a confirmation element.\nAlert ‚Ä¶","ref":"/docs-beagle/docs/api/actions/alert/","title":"Alert"},{"body":" Testes Unit√°rios Testes que t√™m por objetivo medir a funcionalidade do c√≥digo em sua menor fra√ß√£o. √â poss√≠vel realizar testes unit√°rios no Beagle seguindo o mesmo processo utilizado para caso de aplica√ß√µes que n√£o utilizem nossa ferramenta, j√° que o Beagle n√£o interfere na realiza√ß√£o dos testes.\nTestes Instrumentados Testes que s√£o feitos como os testes unit√°rios, com a diferen√ßa de que, em alguns casos, um um componente server driven pode n√£o conter um ID, o que que geralmente o identifica como teste instrumentado.\nVale refor√ßar que estes tipos de testes feitos em aplica√ß√µes que usam Beagle da mesma maneira que em aplica√ß√µes que n√£o usam nossa ferramenta.\nPara sanar problemas nos testes instrumentados, adicionamos ao elemento WIDGET (que referencia um componente) um atributo ID para que seja poss√≠vel identific√°-lo programaticamente.\nListamos um exemplo de um caso abaixo em que fizemos testes usando um elemento server driven.\nComo testamos? Neste exemplo, fizemos um teste instrumentado na plataforma Android utilizando o Espresso (Framework de automa√ß√£o), em que verificamos a funcionalidade de sele√ß√£o e inser√ß√£o de valores em um componente text field, que √© server-driven.\n@Test public void TestSelectTextField() { new BeagleRobot() .checkViewContainsText(\"Beagle Sample\") .selectMenuOption() .clickOnText(\"TextField\") .typeIntoTextField(0,0,\"beagle\") ; } Passo 1: Iniciar o teste Voc√™ deve come√ßar o teste validando se a aplica√ß√£o foi devidamente aberta na p√°gina principal. Isso √© feito para confirmar na fun√ß√£o abaixo se o Header foi apresentado na tela.\nComo este componente n√£o possui uma ID propriamente dita, utilizamos o texto contido no Header para localizar essa view na p√°gina principal. Veja o exemplo a seguir:\npublic BeagleTest checkViewContainsText(String text) { onView(allOf(withText(text))).check(matches(isDisplayed())); return this; } Passo 2: Apresentar o menu Ap√≥s localizar o Header, o pr√≥ximo passo √© utilizarmos a fun√ß√£o abaixo para selecionar o hamburguer icon e apresentar as op√ß√µes deste menu.\nPor ser um componente server driven e n√£o possuir um ID nesta implementa√ß√£o, utilizamos o posicionamento do componente para realizar a sele√ß√£o.\nDesta forma, buscamos pelo texto presente no ContentDescription (\"More options\") e, em seguida, o seu posicionamento na hierarquia do componente. Confira no exemplo:\npublic BeagleTest selectMenuOption() { onView(allOf(withContentDescription(\"More options\"), childAtPosition(childAtPosition(withId(R.id.action_bar), 1), 0))).perform(click()); return this; } Passo 3: Selecionar componente Neste passo, o teste ir√° clicar em um componente (novamente localizado a partir do texto que cont√©m) chamado text field, que √© um item do menu aberto no passo anterior.\npublic BeagleTest clickOnText(final String text) { onView(allOf(withText(text), isDisplayed())).perform(click()); return this; } Passo 4: Inserir o componente Neste √∫ltimo passo, vamos inserir um texto ao componente text field. Uma vez que este componente n√£o possui ID e nem um texto, ele ser√° localizado pelo seu posicionamento na hierarquia do componente. Veja no exemplo a seguir:\npublic BeagleTest typeIntoTextField(int position1, int position2, String text) { onView(allOf(childAtPosition( childAtPosition( withId(R.id.fragment_content), position1), position2) ) ).perform(typeText(text)); Espresso.closeSoftKeyboard(); return this; }  Pronto, o seu teste instrumento foi realizado!  ","excerpt":" Testes Unit√°rios Testes que t√™m por objetivo medir a funcionalidade ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/testes/","title":"Testes"},{"body":" What is it? It is an action that has a boolean parameter and according to the value the action runs onTrue or onFalse.\n   Attribute Type Required Definition     condition Boolean or Binding ‚úì Condition to define which action will run.   onTrue List\u003cAction\u003e  List of actions that it will be run when the condition is true.   onFalse List\u003cAction\u003e  List of actions that it will be run when the condition is false.    How to use it? The example below is a Container with a context that has a 18 value and the event onPress of the button is defined as an action with the Condition type, that verifies if the values is the same as 21 and shows an Alert depending on the context value.\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:button\", \"text\":\"Is equal to 21?\", \"onPress\":[ { \"_beagleAction_\":\"beagle:condition\", \"condition\":\"@{eq(age, 21)}\", \"onTrue\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"onTrue\", \"message\":\"Condition is true\" } ], \"onFalse\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"onFalse\", \"message\":\"Condition is false\" } ] } ] } ], \"context\":{ \"id\":\"age\", \"value\":18 } }  Container( context = ContextData( id = \"age\", value = 18 ), children = listOf( Button( text = \"Is equal to 21?\", onPress = listOf( Condition( condition = \"@{eq(age, 21)}\", onTrue = listOf( Alert(message = \"The condition is true\") ), onFalse = listOf( Alert(message = \"The condition is false\") ) ) ) ) ) )  ","excerpt":" What is it? It is an action that has a boolean parameter and ‚Ä¶","ref":"/docs-beagle/docs/api/actions/condition/","title":"Condition"},{"body":"Benchmark: Beagle Movies Contexto O Beagle Movies √© um aplicativo de filmes que foi desenvolvido usando o framework do Beagle. Com ele, √© poss√≠vel conferir resenhas de filmes e s√©ries, al√©m de criar listas personalizadas com o que voc√™ quer ou j√° assistiu.\nQuais foram os testes? Tamanho do Payload De modo geral, √© esperado que o payload do Server-Driven UI seja maior que o nativo, pois toda estrutura de layout vem no payload, enquanto o nativo somente as informa√ß√µes a serem mostradas.\nApesar disso, em algumas telas o tamanho do payload √© inferior ao server driven. Isso acontece porque BFF (Backend For Frontend) filtra os dados que n√£o s√£o usados no aplicativo e n√£o envia no payload.\n   Telas Resposta em telas Server-Driven (em KB) Resposta em telas nativas (em KB)     Home 423,89 KB 300,73 KB   Detalhes 2,15 KB 3,37 KB   Search 12,8 KB 14,45 KB   Resultado do teste 438,84 KB 318,55 KB    Para telas mais complexas, o payload do server-driven ficar√° maior. √â importante ressaltar que o Beagle utiliza um mecanismo de cache e que esse teste √© considerado apenas a primeira requisi√ß√£o.\nA vantagem em usar o Beagle √© porque voc√™ s√≥ desenvolve a tela apenas uma vez, enquant em telas nativas voc√™ ter√° de desenvolver para cada plataforma.  Tempo de Resposta  Telas Nativas: √â necess√°rio fazer v√°rias requisi√ß√µes para montar a tela Telas Server-Driven: √â necess√°rio apenas uma requisi√ß√£o do BFF     Telas Tempo de resposta em telas Server-Driven (em ms) Tempo de resposta em telas nativas (em ms)     Home 312 ms 448 ms   Detalhes 179 ms 346 ms   Search 176 ms 271 ms   Resultado do teste 668 ms 1065 ms    Teste de performance iOS Veja a diferen√ßa de performance em telas nativas e server-driven considerando o processo de inicializa√ß√£o, chamada e resposta dos servi√ßos de renderiza√ß√£o da tela.\n   Etapas Tempo decorrido em telas Server-Driven (em segundos) Tempo decorrido em telas nativas (em segundos)     Start test 0,00 s 0,00 s   Set up 0,10 s 0,06 s   Open project 0,13 s 0,08 s   Launch app 0,15 s 0,12 s   Setting up automation session 3,95 s 2,17 s   Resultado do teste 8,21 segundos 6,39 segundos    ","excerpt":"Benchmark: Beagle Movies Contexto O Beagle Movies √© um aplicativo de ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/testes/benchmark-beagle-movies/","title":"Benchmark Beagle Movies"},{"body":" What is it? confirm class is responsible for creating a confirmation modal element.\nConfirm structure is:\n   Attribute  Type  Required Definition      title String or\nBinding\u003cb\u003e\u003c/b\u003e\n  Title of the confirmation box.   message String or\n\u003cb\u003e\u003c/b\u003eBinding\u003cb\u003e\u003c/b\u003e\n ‚úì Confirmation box message.   onPressOk \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  Confirm button action.   onPressCancel \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  Cancel button action.   labelOk String  Confirmation button message.   labelCancel String  Cancel button message.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Confirm Example\", \"onPress\": [ { \"_beagleAction_\": \"beagle:confirm\", \"title\": \"Confirm Title\", \"message\": \"Confirm Message\", \"onPressOk\": { \"_beagleAction_\":\"beagle:alert\", \"message\": \"Confirmed\" } } ] } ] }  Button(text = \"Confirm Example\", onPress = listOf( Confirm(title = \"Confirm Title\", message = \"Confirm Message\", onPressOk = Alert( title = \"Ok\", message = \"Confirmed\"), onPressCancel = Alert( title = \"Cancel\", message = \"Cancelled\"), labelOk = \"Accept\", labelCancel = \"Deny\" ) ) )  üëâ Test this action in the Web Playground ","excerpt":" What is it? confirm class is responsible for creating a confirmation ‚Ä¶","ref":"/docs-beagle/docs/api/actions/confirm/","title":"Confirm"},{"body":" O que √©? O Roboletric √© um framework para testes unit√°rios no Android. Uma de suas fun√ß√µes √© simular informa√ß√µes sobre o contexto do Android durante a realiza√ß√£o desses testes.\nAntes de utiliz√°-lo, √© preciso configurar uma depend√™ncia do Yoga Layout chamada de SoLoader que, se n√£o estiver habilitado para modo TESTE, vai ocorrer um erro de nullPointerException, uma vez que a view n√£o existir√° naquele contexto.\nVale lembrar que o Beagle utiliza Yoga Layout para posicionar os componentes na tela  Sendo assim, voc√™ precisa configurar o nosso SDK para ativar o ‚ÄúTesteMode‚Äù no SoLoader quando iniciar um teste e desativ√°-lo assim que terminar. Para tal, basta utilizar as fun√ß√µes conforme indicado a seguir.\nComo configurar? Para configurar o Beagle para os testes do Roboeletric, adicione o c√≥digo abaixo no seu caso de teste:\n@BeforeClass fun setup() { BeagleSdk.setInTestMode() } @AfterClass fun teardown() { BeagleSdk.deinitForTest() } ","excerpt":" O que √©? O Roboletric √© um framework para testes unit√°rios no ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/testes/configura%C3%A7%C3%A3o-do-robolectric/","title":"Configura√ß√£o do Robolectric"},{"body":" This action has been deprecated alongside Form  What is it? It defines the local action of a form, it doesn‚Äôt make HTTP requests, like for example, an action that creates a customized dialogue box.\nFormLocalAction structure is:\n   Attribute Type Required Definition     \nname\n String ‚úì Defines the action name.   data Map\u003cString, String\u003e  Data that can be sent as an action parameter.    ","excerpt":" This action has been deprecated alongside Form  What is it? It ‚Ä¶","ref":"/docs-beagle/docs/api/actions/formlocalaction/","title":"Formlocalaction"},{"body":" Para testar sua aplica√ß√£o, voc√™ precisa de um Widget ID. Para fazer isso, Beagle oferece alguns m√©todos set e get.\nNessa se√ß√£o, voc√™ ver√° dois espec√≠ficos:\n Set Id Get Id  Set Id O m√©todo Set Id √© usado quando voc√™ precisa setar um Id no widget fornecido para o BFF. Para fazer isso, voc√™ precisa chamar esse m√©todo no widget que voc√™ quer o Id setado durante o momento que voc√™ est√° criando o seu widget.\nVeja como funciona abaixo:\nText(text = \"Text with id\").setId(\"myTextId\") Get Id No Get Id, voc√™ tem diferentes maneiras de setar de acordo com a sua plataforma frontend.\nVeja abaixo:\nAndroid iOS Web No Android para obter um Widget Id voc√™ precisa chamar a String.toAndroidId() e esse m√©todo retornar√° um Id para voc√™ usar onde precisar.\nVeja como funciona, abaixo:\n\"myTextId\".toAndroidId()  No iOS, o Id √© registrado no accessibilityIdentifier. Com isso, para us√°-lo, voc√™ precisa usar o mesmo valor que est√° no setId().\nVeja como funciona, abaixo:\n\"myTextId\"  Na Web, existe uma configura√ß√£o default que cada componente renderizado pelo Beagle recebe o ‚Äòdata-beagle-id‚Äô que est√° em html, se o backend n√£o setar o Id.\nSe voc√™ quiser recuperar, use o javascript e html rodando o comando abaixo:\nelement.getAttribute(widgetId) O valor do Widget Id ser√° personalizado, se o backend setar o Id (como no exemplo, ‚ÄúmyTextId‚Äù) ou ele ser√° um valor default (‚Äòdata-beagle-id‚Äô).\n ","excerpt":" Para testar sua aplica√ß√£o, voc√™ precisa de um Widget ID. Para fazer ‚Ä¶","ref":"/docs-beagle/pt/docs/tutoriais/testes/usando-widget-id/","title":"Usando widget Id"},{"body":" This action has been deprecated alongside Form  What is it? It is an action to make the request to submit a form.\nFormRemoteAction structure is:\n   Attribute Type Required Definition     \npath\n String ‚úì Defines the URL service path that it will receive the form's data.   method FormMethodType ‚úì Defines the type of operation to submit a form.    FormMethodType ENUM to define the HTTP method that it will use to submit a form.\nSee the values below:\n   Type Definition     GET It is used for methods that only receive data.   POST It is used for methods that submit data.   PUT It is used for methods that replace the data.   DELETE It is used for method that remove data.    \u0000\n","excerpt":" This action has been deprecated alongside Form  What is it? It is an ‚Ä¶","ref":"/docs-beagle/docs/api/actions/formremoteaction/","title":"Formremoteaction"},{"body":" This action has been deprecated alongside Form.  What is it?  ‚ÄåThis action is used to configure the error messages returned toby the external service to submit the form, for example, verify the CPF register status when it is submitted.\nFormValidation structure is:\n   Attribute Type Required Definition     errors List\u003cFieldError\u003e ‚úì Errors list.    ‚Äå\nFieldError  FieldError is class that defines error.\nThe FieldError structure is:\n   Attribute Type Required Definition     inputName String ‚úì Name of the component which the error refers to.   message String ‚úì Error message to be displayed.    ","excerpt":" This action has been deprecated alongside Form.  What is it?  ‚ÄåThis ‚Ä¶","ref":"/docs-beagle/docs/api/actions/formvalidation/","title":"Formvalidation"},{"body":" O que √© o Playground? O Playground √© uma ferramenta de desenvolvimento onde se pode criar componentes e p√°ginas utilizando o Beagle de forma simples e r√°pida, sem a necessidade de fazer qualquer instala√ß√£o. Ele possui uma interface que permite voc√™ escrever um JSON e ver o resultado de forma instant√¢nea.\nAcessando o Playground O playground pode ser acessado pelo seguinte link:\n{% embed url=‚Äúhttps://beagle-playground.netlify.app‚Äù %}}\nVoc√™ ter√° acesso ao seguinte projeto demo:\nO menu de arquivos fica √† esquerda, no centro fica o JSON do arquivo selecionado, e a direita √© onde voc√™ pode ver o preview do JSON selecionado.\n","excerpt":" O que √© o Playground? O Playground √© uma ferramenta de ‚Ä¶","ref":"/docs-beagle/pt/docs/playground/playground-web/","title":"Playground Web"},{"body":" Navigate is responsible to all screen‚Äôs navigation on Beagle. You can configure some navigation action types, which it can be seen on the following pages.\nNavigate Actions ","excerpt":" Navigate is responsible to all screen‚Äôs navigation on Beagle. You can ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/","title":"Navigate"},{"body":" Utilizando o Playground Menu de arquivos No menu de arquivos, a esquerda da tela, voc√™ pode criar, excluir ou selecionar um arquivo e ao clicar no primeiro √≠cone superior ou pressionando CTRL+B voc√™ pode minimizar ou expandir esse menu.\nJSON As altera√ß√µes do JSON podem ser salvas clicando no 2¬∞ √≠cone superior ou pressionando CTRL+S. Para voc√™ atualizar a visualiza√ß√£o da tela com o novo JSON, clique no 4¬∞ √≠cone no canto superior ou pressione F9.\nAssim que as altera√ß√µes s√£o salvas, √© disponibilizado um link do seu projeto que est√° alocado na nuvem, a partir dele, seu projeto pode ser acessado em qualquer local.\nPlataforma No menu superior direito √© poss√≠vel selecionar a plataforma que voc√™ deseja, atualmente est√£o dispon√≠veis as op√ß√µes React Webe Angular.\n","excerpt":" Utilizando o Playground Menu de arquivos No menu de arquivos, a ‚Ä¶","ref":"/docs-beagle/pt/docs/playground/playground-web/usando-o-playground/","title":"Usando o Playground"},{"body":" What is it? It opens a new screen through a deep link.‚Äã\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     route String ‚úì Identifier to open a new screen.   shouldResetApplication Boolean  Restart an applications preview stack.   Data Map \u003cString, String\u003e  Send data to a new screen.    You must configure a DeepLinkHandler in order to use this component.  How to use it? The example below, we have a screen coming from BFF with a button when you click, opens a native screen.\nTo test is, just configure Deep Link Handler for Android or openNativeRoute for iOS. Besides, your BFF‚Äôs endpoint must return the code screen below and call it in the frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:openNativeRoute\", \"route\" : \"my-native\", \"shouldResetApplication\" : false } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.OpenNativeRoute( route = \"my-native\" ) ) ) )  üëâ Test this example on Web Playground ","excerpt":" What is it? It opens a new screen through a deep link.‚Äã\nThe structure ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/opennativeroute/","title":"Opennativeroute"},{"body":" Exemplos de componentes demo Segue a lista com os exemplos de componentes implementados no Playground:\nButton Experimente no Playground\nDocumenta√ß√£o do componente\nContainer Experimente no Playground\nDocumenta√ß√£o do componente\nLazy Component Experimente no Playground\nDocumenta√ß√£o do componente\nList View Experimente no Playground\nDocumenta√ß√£o do componente\nModal Experimente no Playground\nPage View Experimente no Playground\nDocumenta√ß√£o do componente\nSimple Form Experimente no Playground\nTab View Experimente no Playground\nDocumenta√ß√£o do componente\nText Experimente no Playground\nDocumenta√ß√£o do componente\nTouchable Experimente no Playground\nDocumenta√ß√£o do componente\n","excerpt":" Exemplos de componentes demo Segue a lista com os exemplos de ‚Ä¶","ref":"/docs-beagle/pt/docs/playground/playground-web/componentes-demo/","title":"Componentes demo"},{"body":" What is it? Open the navigator by selecting the user with the informed URL.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     url String ‚úì URL sent to navigator.    How to use it? On the example below, you can see a screen that comes from BFF with a button when is clicked, open the browser with the specific URL. To test, it is necessary an endpoint of your BFF return the code below and call it in the frontend: d.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:openExternalURL\", \"url\" : \"https://docs.usebeagle.io/api/api-acoes/navigate/openexternalurl\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.OpenExternalURL( url = \"https://docs.usebeagle.io/api/api-acoes/navigate/openexternalurl\" ) ) ) )  üëâ Test this example on Web Playground ","excerpt":" What is it? Open the navigator by selecting the user with the ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/openexternalurl/","title":"Openexternalurl"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/playground/","title":"Playground"},{"body":" What is it? Presents a new screen and puts it on the pile.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route Route ‚úì Navigation route.    How to use it? On the example below there‚Äôs a screen coming from BFF with a button that when clicked, open a new server-driven activity with a screen specified by BFF.\nTo test, your BFF‚Äôs endpoint should return a the screen with the code below and call it in the frontend. You can pass a local route or a remote one that will pass the screen endpoint to the one it will navigate.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushStack\", \"route\" : { \"screen\" : { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello second Screen\" } } } } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PushStack( Route.Local( Screen( child = Text(\"Hello second Screen\") ) ) ) ) ) )  üëâ Test this example on Web Playground  ","excerpt":" What is it? Presents a new screen and puts it on the pile.\nYour ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/pushstack/","title":"Pushstack"},{"body":" O que √©? Por enquanto, existem dois atributos comuns de acessibilidade entre todas as plataformas que o Beagle suporta.\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     accessible Boolean ‚úì Indica se o componente ser√° interpretado como acess√≠vel. Default √© true.   accessibilityLabel String  Uma mensagem que ser√° dita por programas como o VoiceOver.    Caso o backend n√£o especifique acessibilidade, os valores padr√µes de cada plataforma ser√£o utilizados.  Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/rvRN9kv/logo.png\" }, \"accessibility\": { \"accessibilityLabel\": \"Image Label\", \"accessible\": true } } ] }  Container( children = listOf( Image( path = ImagePath.Remote(\"https://i.ibb.co/rvRN9kv/logo.png\") ).applyAccessibility( accessibility = Accessibility(true, \"Image Label\") ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©? Por enquanto, existem dois atributos comuns de ‚Ä¶","ref":"/docs-beagle/pt/docs/api/acessibilidade/","title":"Acessibilidade"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/api/","title":"API"},{"body":" What it is? Presents a new screen and puts it on the pile.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route Route ‚úì Navigation route.    How to use it? On the example below, there is a screen coming from BFF with a button when clicked, open a new server-drive fragment with a specific BFF screen.\nTo test is, you need a endpoint to return with the code below from your BFF and call it in the frontend. You can pass a local route (that it will pass a screen in the route) or remote route that will pass the endpoint of the screen which it will navigate.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"screen\" : { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello second Screen\" } } } } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Local( Screen( child = Text(\"Hello second Screen\") ) ) ) ) ) )  üëâ Test this example on Web Playground ","excerpt":" What it is? Presents a new screen and puts it on the pile.\nYour ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/pushview/","title":"Pushview"},{"body":" O que √©? No Beagle, uma a√ß√£o lida com os comportamentos (fun√ß√µes), que ser√£o executadas em sua aplica√ß√£o assim que um determinado evento for disparado. Essas a√ß√µes podem ser padr√£o do pr√≥prio Beagle ou customizadas.\nQualquer evento no Beagle, deve ser associado a uma lista de a√ß√µes. Veja abaixo um exemplo de componente de bot√£o, que associa uma a√ß√£o de alerta padr√£o ao seu evento de onPress:\n{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"click to show alert\", \"onPress\": [{ \"_beagleAction_\": \"beagle:alert\", \"title\": \"Hello\", \"message\": \"World\" }] } Uma a√ß√£o √© um mapa chave/valor com pelo menos uma propriedade:_beagleAction_. O valor dela indica qual a√ß√£o deve ser executada quando o evento for disparado. As demais propriedades especificam os par√¢metros esperados pela a√ß√£o indicada.\nExistem diversas a√ß√µes implementadas no Beagle por padr√£o e todas elas come√ßam com prefixo ‚Äúbeagle:‚Äù e as a√ß√µes customizadas possuem o prefixo ‚Äúcustom:‚Äù.\nPara saber como criar a√ß√µes customizadas, d√™ uma olhada na se√ß√£o de customiza√ß√£o do Beagle\nTipos de a√ß√µes Abaixo, voc√™ encontra a descri√ß√£o completa de cada a√ß√£o dispon√≠vel por padr√£o no Beagle:\n","excerpt":" O que √©? No Beagle, uma a√ß√£o lida com os comportamentos (fun√ß√µes), ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/","title":"A√ß√µes"},{"body":" What is it? Removes the current exhibition pile.\nHow to use it? On the example below there‚Äôs a screen coming from BFF with a button that when clicked, closes the current activity.\nTo test, your BFF‚Äôs endpoint should return the screen with the code below and call it in the frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popStack\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PopStack() ) ) )  üëâ Test this example on Web Playground ","excerpt":" What is it? Removes the current exhibition pile.\nHow to use it? On ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/popstack/","title":"Popstack"},{"body":" O que √©? A a√ß√£o AddChildrenAction √© respons√°vel por adicionar - no in√≠cio ou no final - ou trocar todas as views que foram herdadas de Widget e que aceitam filhos.\nA estrutura do AddChildrenAction √©:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     componentId String ‚úì Define o id do Widget, no qual deseja adicionar as views.   value List\u003cServerDrivenComponent\u003e ‚úì Define a lista de filhos que deseja adicionar.   mode Mode  Define o posicionamento de onde os filhos ser√£o inseridos na lista ou se o conte√∫do da lista ser√° substitu√≠do. Por padr√£o o modo definido √© APPEND.    Mode √â um ENUM, cujos valores s√£o:\n   Valor Defini√ß√£o     APPEND Adiciona a view no final da lista de filhos.   PREPEND Adiciona a view no come√ßo da lista de filhos.   REPLACE Substitui todos os filhos do widget.    Como usar? Veja abaixo um exemplo de um bot√£o que ao clicado adiciona uma view de texto:\nJSON Kotlin DSL \"_beagleComponent_\": \"beagle:container\", \"children\": [{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"AddChildren\", \"onPress\": [{ \"_beagleAction_\": \"beagle:addChildrenAction\", \"componentId\": \"MyContainerID\", \"value\": [{ \"_beagleComponent_\": \"beagle:text\", \"text\": \"This is the new view added\" } ], \"mode\": \"APPEND\" } ] } ], \"id\": \"MyContainerID\"  Container( children = listOf( Button(\"AddChildren\", onPress = listOf( AddChildrenAction( componentId = \"MyContainerID\", value = listOf( Text(\"This is the new view added\") ), mode = Mode.APPEND ) )) ) ).apply { id = \"MyContainerID\" }  ","excerpt":" O que √©? A a√ß√£o AddChildrenAction √© respons√°vel por adicionar - no ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/addchildren/","title":"Addchildren"},{"body":" What is it? Closes the current exhibition screen.\nHow to use it? On the example below there‚Äôs a screen coming from BFF with a button that when clicked, removes the current fragment.\nTo test, your BFF‚Äôs endpoint should return the screen with the code below and call it in the frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popView\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PopView() ) ) )  üëâ Test this example on Web Playground ","excerpt":" What is it? Closes the current exhibition screen.\nHow to use it? On ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/popview/","title":"Popview"},{"body":" O que √©? A a√ß√£o Alert √© respons√°vel por criar um elemento de confirma√ß√£o\nA estrutura do Alert √©:\n   Atributo  Tipo  Obrigat√≥rio Defini√ß√£o      title String ou\nBinding\u003cb\u003e\u003c/b\u003e\n  T√≠tulo da caixa de alerta.   message String ou\n\u003cb\u003e\u003c/b\u003eBinding\u003cb\u003e\u003c/b\u003e\n ‚úì Mensagem da caixa de alerta.   onPressOk \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  A√ß√£o do bot√£o de confirma√ß√£o.   labelOk String  Label do bot√£o de confirma√ß√£o.    Como usar? Abaixo segue um exemplo de um bot√£o que ao clicado mostra um Alert:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Alert Example\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"title\": \"My Title\", \"message\": \"Alert message\", \"labelOk\": \"Close\" } ] } ] }  Container( children = listOf( Button( text = \"Alert Example\", onPress = listOf( Alert( title = \"My Title\", message = \"Alert message\", labelOk = \"Close\" ) ) ) ) )  üëâ Teste essa a√ß√£o no Web Playground‚Äã ","excerpt":" O que √©? A a√ß√£o Alert √© respons√°vel por criar um elemento de ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/alert/","title":"Alert"},{"body":" What is it? Returns to a specific screen and cleans the navigation that was generated from that screen.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route ‚ÄãString ‚úì Route of a screen that it‚Äôs on the pile.    How to use it? On the example below, three screens were used: two first used PushView to add the screens to the piles, the last one use PopToView to return to the first.\nTo test, you will need three endpoints:\n The first endpoint will be what your frontend will call to render the screen zero. The second endpoint should be mapped as \"/firstScreen\", because this will be the chosen URL to the navigation of the button on the screen 0 and for that, this endpoint must return the screen 1. The third endpoint must be mapped \"/secondScreen\", because this will be the chose URL to the navigation of the button on the screen 1, for that, this endpoint must return the screen 2. It is through the screen 2 that it pass a route where the endpoint of the screen must return. in this case, it is ‚Äú/home‚Äù that it is the endpoint of the zero screen.  How to call the screen 0  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  How to call the screen 1  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  How to call the screen 2  JSON Kotlin DSL Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to go to first screen\", onPress = listOf( Navigate.PopToView( route = \"/home\" ) ) ) ) ) )  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to go to first screen\", onPress = listOf( Navigate.PopToView( route = \"/home\" ) ) ) ) ) )  üëâ Test this example on Web Playground ","excerpt":" What is it? Returns to a specific screen and cleans the navigation ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/poptoview/","title":"Poptoview"},{"body":" O que √©? √â uma a√ß√£o que tem um par√¢metro do tipo Boolean e de acordo com esse valor √© executado a a√ß√£o onTrue ou onFalse.\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     condition Boolean ou Binding ‚úì condi√ß√£o para definir qual a√ß√£o ser√° executada.   onTrue List\u003cAction\u003e  lista de a√ß√µes que ser√° executada quando a condi√ß√£o for verdadeira.   onFalse List\u003cAction\u003e  lista de a√ß√µes que ser√° executada quando a condi√ß√£o for falsa.    Como usar? O exemplo abaixo √© um Container com um contexto que possui o valor 18 e no evento onPress do bot√£o foi definido uma a√ß√£o do tipo Condition que verifica se o valor √© igual a 21 e mostra um Alert dependendo do valor do contexto.\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:button\", \"text\":\"Is equal to 21?\", \"onPress\":[ { \"_beagleAction_\":\"beagle:condition\", \"condition\":\"@{eq(age, 21)}\", \"onTrue\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"onTrue\", \"message\":\"Condition is true\" } ], \"onFalse\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"onFalse\", \"message\":\"Condition is false\" } ] } ] } ], \"context\":{ \"id\":\"age\", \"value\":18 } }  Container( context = ContextData( id = \"age\", value = 18 ), children = listOf( Button( text = \"Is equal to 21?\", onPress = listOf( Condition( condition = \"@{eq(age, 21)}\", onTrue = listOf( Alert(message = \"The condition is true\") ), onFalse = listOf( Alert(message = \"The condition is false\") ) ) ) ) ) )  ","excerpt":" O que √©? √â uma a√ß√£o que tem um par√¢metro do tipo Boolean e de acordo ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/condition/","title":"Condition"},{"body":" What is it? Opens a screen with an informed route of a new flow and cleans the pile of previous loaded screens.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route Route ‚úì Navigation route.    How to use it? On the example below, three screens were used: two firs used PushView to add the screens to the piles, the last one use ResetStack and reopens the first screen.\nTo test, you will need three endpoints:\n The first endpoint will be what your frontend will call to render the screen zero. The second endpoint must be mapped \"/firstScreen\", because this will be the chosen URL of the screen 0 button‚Äôs navigation and for that the endpoint must return the screen 1. The third point must be mapped**\"/secondScreen\",** because this will be the chosen URL of the screen 1 button‚Äôs navigation and for that this endpoint must return the screen 2. On the screen 2, the passed route must be the screen endpoint that you want to return when the application restarts. In this case, it is **\"/home\"** that it is screen‚Äôs 0 endpoint.  How to call the screen zero  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  How to call the screen 1  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  How to call the screen 2  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to reset stack\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:resetStack\", \"route\" : { \"url\" : \"/home\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to reset stack\", onPress = listOf( Navigate.ResetStack( route = Route.Remote(\"/home\") ) ) ) ) ) )  üëâ Test this example on Web Playground ","excerpt":" What is it? Opens a screen with an informed route of a new flow and ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/resetstack/","title":"Resetstack"},{"body":" O que √©? A a√ß√£o confirm √© respons√°vel por criar um elemento modal de confirma√ß√£o.\nA estrutura do Confirm √©:\n   Atributo  Tipo  Obrigat√≥rio Defini√ß√£o      title String ou\nBinding\u003cb\u003e\u003c/b\u003e\n  T√≠tulo da caixa de confirma√ß√£o   message String ou\nBinding\u003cb\u003e\u003c/b\u003e\n ‚úì Mensagem da caixa de confirma√ß√£o   onPressOk \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  A√ß√£o do bot√£o de confirma√ß√£o   onPressCancel \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  A√ß√£o do bot√£o de cancelamento   labelOk String  Mensagem do bot√£o de confirma√ß√£o   labelCancel String  Mensagem do bot√£o de cancelamento    Como usar? Segue abaixo um exemplo com um bot√£o que ao clicado exibe um modal de confirma√ß√£o:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Confirm Example\", \"onPress\": [ { \"_beagleAction_\": \"beagle:confirm\", \"title\": \"Confirm Title\", \"message\": \"Confirm Message\", \"onPressOk\": { \"_beagleAction_\":\"beagle:alert\", \"message\": \"Confirmed\" } } ] } ] }  Button(text = \"Confirm Example\", onPress = listOf( Confirm(title = \"Confirm Title\", message = \"Confirm Message\", onPressOk = Alert( title = \"Ok\", message = \"Confirmed\"), onPressCancel = Alert( title = \"Cancel\", message = \"Cancelled\"), labelOk = \"Accept\", labelCancel = \"Deny\" ) ) )  üëâ Teste essa a√ß√£o no Web Playground ","excerpt":" O que √©? A a√ß√£o confirm √© respons√°vel por criar um elemento modal de ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/confirm/","title":"Confirm"},{"body":" What is it? Opens a screen with an informed route and deletes all the navigation piles.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route ‚ÄãRoute‚Äã ‚úì Navigation route.    How to use it? On the example below, three screens were used: two first used PushView to add the screens to the piles, the last one use ResetApplication and reopens the first screen.\nTo test, you will need three endpoints:\n The first endpoint will be what your frontend will call to render the screen zero. The second endpoint must be mapped as \"/firstScreen\", because this will be the chose URL to the screen 0 button‚Äôs navigation, and it must return to the screen 1. The third endpoint must be mapped as \"/secondScreen\", because this will be the chosen URL to the screen 1 button‚Äôs navigation, and it must return to the screen 2. On the screen 2 the passed route must be the screen‚Äôs endpoint that you want to return when the application starts. In this case, \"/home\" is the screen‚Äôs 0 endpoint.  How to call the screen zero  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  How to call the screen 1  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  How to call the screen 2  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to reset application\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:resetApplication\", \"route\" : { \"url\" : \"/home\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to reset application\", onPress = listOf( Navigate.ResetApplication( route = Route.Remote(\"/home\") ) ) ) ) ) )  üëâ Test this example on Web Playground ","excerpt":" What is it? Opens a screen with an informed route and deletes all the ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/resetapplication/","title":"Resetapplication"},{"body":" Essa a√ß√£o foi depreciada junto com o Form!  O que √©? Define as a√ß√µes locais do formul√°rio, ou seja, n√£o fazem solicita√ß√µes de HTTP, como por exemplo, uma a√ß√£o que cria uma caixa de di√°logo personalizada.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     \nname\n String ‚úì Define o nome da a√ß√£o.   data Map\u003cString, String\u003e  Dado que pode ser enviado como par√¢metro da a√ß√£o.    ","excerpt":" Essa a√ß√£o foi depreciada junto com o Form!  O que √©? Define as a√ß√µes ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/formlocalaction/","title":"Formlocalaction"},{"body":" Route defines how the navigation must be loaded.\nYou will find below, the description of the Route‚Äôs types available on Beagle:\n","excerpt":" Route defines how the navigation must be loaded.\nYou will find below, ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/route/","title":"Route"},{"body":" Essa a√ß√£o foi depreciada junto com o Form!  O que √©? √â a a√ß√£o para fazer uma requisi√ß√£o para submeter o formul√°rio.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     \npath\n String ‚úì Define o caminho URL do servi√ßo que ir√° receber os dados do formul√°rio.   method FormMethodType ‚úì Define o tipo de opera√ß√£o para submeter o formul√°rio.    FormMethodType √â um ENUM para definir o m√©todo HTTP que usar√° para submeter o formul√°rio.\nSegue abaixo os valores:\n   Tipo Defini√ß√£o     GET √â usado para m√©todos que s√≥ recebem dados.   POST √â usado para m√©todos que submetem dados.   PUT √â usado para m√©todos que substituem os dados .   DELETE √â usado para m√©todos de remo√ß√£o de dados.    \u0000\n","excerpt":" Essa a√ß√£o foi depreciada junto com o Form!  O que √©? √â a a√ß√£o para ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/formremoteaction/","title":"Formremoteaction"},{"body":" What is it? Navigation for remote content.\nThe structure is represented by the attributes below:\n   Attribute  Type  Required Definition      url String or\nBinding\u003cb\u003e\u003c/b\u003e\n ‚úì Navigation address.   shouldPrefetch Boolean  Load the address previously.   fallback Screen\u003cb\u003e\u003c/b\u003e  Screen to be returned in case the loading fails.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushView\", \"route\": { \"url\": \"/present/view\", \"shouldPrefetch\": false } } ] }  Button( onPress = listOf( Navigate.PushView( Route.Remote(\"/present/view\") ) ), text = \"Click me!\" )  üëâ Teste this action in the Web Playground ","excerpt":" What is it? Navigation for remote content.\nThe structure is ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/route/remote/","title":"Remote"},{"body":" Essa a√ß√£o foi depreciada junto com o Form!  O que √©? Essa a√ß√£o √© usada para configurar as mensagens de erro retornadas pelo servi√ßo externo ao submeter um formul√°rio, por exemplo, verificar o status do registro de um CPF ao submet√™-lo.\nA estrutura do FormValidation √©:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     errors List\u003cFieldError\u003e ‚úì Lista de erros.    FieldError O FieldError √© uma classe para definir o erro.\nA estrutura do FieldError √©:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     inputName String ‚úì Nome do componente o qual o erro se refere.   message String ‚úì Mensagem do erro a ser exibido.    ","excerpt":" Essa a√ß√£o foi depreciada junto com o Form!  O que √©? Essa a√ß√£o √© ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/formvalidation/","title":"Formvalidation"},{"body":" What is it?  Navigation for a local content.\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     screen Screen  Screen to be loaded    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushView\", \"route\": { \"screen\": { \"_beagleComponent_\": \"beagle:screenComponent\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Hello Screen from Navigate\" } } } } ] }  Button( onPress = listOf( Navigate.PushView( Route.Local( Screen( child = Text(\"Hello Screen from Navigate\") ) ) )), text = \"Click me!\" )  üëâ Test this action in the Web Playground ","excerpt":" What is it?  Navigation for a local content.\nThe structure is ‚Ä¶","ref":"/docs-beagle/docs/api/actions/navigate/route/local/","title":"Local"},{"body":" O Navigate √© respons√°vel por toda navega√ß√£o de telas com Beagle. Nele, √© poss√≠vel configurar alguns tipos de a√ß√µes de navega√ß√£o, que voc√™ pode conferir nas pr√≥ximas p√°ginas.\nA√ß√µes de navega√ß√£o ","excerpt":" O Navigate √© respons√°vel por toda navega√ß√£o de telas com Beagle. ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/","title":"Navigate"},{"body":" O que √©? O OpenNativeRoute √© uma a√ß√£o que realiza a navega√ß√£o para uma tela nativa.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     route String ‚úì Identificador para abrir uma tela nova.   shouldResetApplication Boolean  Reinicia a pilha de visualiza√ß√£o do aplicativo.   Data Map \u003cString, String\u003e  Envia informa√ß√µes para a nova tela.    Como usar? No exemplo abaixo, temos uma tela vinda do BFF com um bot√£o que ao clicar nele, abre uma tela nativa.\nPara testar, √© preciso configurar o Deep Link Handler para Android ou o openNativeRoute, no caso de aplica√ß√£o iOS. Al√©m disso, seu endpoint do BFF precisa retornar a tela do c√≥digo abaixo e chamar esse endpoint no Frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:openNativeRoute\", \"route\" : \"my-native\", \"shouldResetApplication\" : false } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.OpenNativeRoute( route = \"my-native\" ) ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©? O OpenNativeRoute √© uma a√ß√£o que realiza a navega√ß√£o para ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/opennativeroute/","title":"Opennativeroute"},{"body":" What is it? SendRequest is used to make HTTP requests.\nThe Send Request structure is:\n   Attribute Type Required Definition     url String or Binding ‚úì Server URL.   method RequestActionMethod or Binding ‚úì HTTP method.   headers Map \u003cString, String\u003e or Binding  Header items for the request.   data Any  Content that will be deliver with the request.   onSuccess List\u003cAction\u003e  Success action.   onError List\u003cAction\u003e  Error action.   onFinish List\u003cAction\u003e  Finish action.    How to use it? See below an example of a button that send a POST request with data user:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Send Request Example\", \"onPress\": [ { \"beagleAction\":\"beagle:sendRequest\", \"url\":\"https://myUrl.com/endpoint\"\", \"method\":\"POST\", \"headers\":{ \"Content-Type\":\"application/json\" }, \"data\":{ \"email\":\"john@email.com\", \"password\":\"password\", \"confirmPassword\":\"password\", \"name\":\"John\" }, \"onSuccess\":[ { \"beagleAction\":\"beagle:alert\", \"title\":\"SUCCESS\", \"message\":\"Success\" } ], \"onError\":[ { \"beagleAction\":\"beagle:alert\", \"title\":\"ERROR\", \"message\":\"Error\" } ], \"onFinish\":[ { \"beagleAction\":\"beagle:alert\", \"title\": \"FINISH\", \"message\":\"Finish\" } ] } ] } ] }  Button( text = \"Send a request\", styleId = \"DesignSystem.MyNativeButtonStyle\", onPress = listOf( SendRequest( url = https://myUrl.com/endpoint\", method = RequestActionMethod.POST, data = User( name = \"John\", email = \"jonh@email.com\", password = \"password\", confirmPassword = \"password\" ), headers = mapOf( \"Content-Type\" to \"application/json\" ), onSuccess = listOf( Alert( title = \"SUCCESS\", message = \"Success\" ) ), onError = listOf( Alert( title = \"ERROR\", message = \"Error\" ) ), onFinish = listOf( Alert( title = \"FINISH\", message = \"Finish\" ) ) ) ) )  üëâ Test this action in the Web Playground ","excerpt":" What is it? SendRequest is used to make HTTP requests.\nThe Send ‚Ä¶","ref":"/docs-beagle/docs/api/actions/sendrequest/","title":"Sendrequest"},{"body":" O que √©? Abre o navegador selecionado pelo usu√°rio com a url informada.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     url String ‚úì URL enviada para o navegador.    Como usar? No exemplo abaixo, voc√™ pode ver um bot√£o que, ao ser clicado, abre o navegador com a URL especificada. Para testar, basta que um endpoint do seu BFF retorne a tela do c√≥digo abaixo e chame esse endpoint no frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:openExternalURL\", \"url\" : \"https://docs.usebeagle.io/api/api-acoes/navigate/openexternalurl\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.OpenExternalURL( url = \"https://docs.usebeagle.io/api/api-acoes/navigate/openexternalurl\" ) ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©? Abre o navegador selecionado pelo usu√°rio com a url ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/openexternalurl/","title":"Openexternalurl"},{"body":" What is it? The SetContext action is responsible for changing the value of a context.\nThe setContext structure is:\n   Attribute Type Required Definition     contextId String ‚úì Context identifier   value Any ‚úì New value to apply in the context   path String  Specific context point for changing value in case of arrays and maps \u003ckey, value\u003e.    Get to know more about Beagle context.  How to use it? See below an example of a text that is set by context and have an initial value ‚ÄúSet Context Example‚Äù. The click event have a SetContext action that change the context value to ‚ÄúContext has changed‚Äù.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"context\":{ \"id\": \"myContext\", \"value\":\"Set Context Example\" }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\":\"@{myContext}\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Open Modal\", \"onPress\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"myContext\", \"value\": \"Context has changed\" } ] } ] }  Container( children = listOf( Text(text = \"@{myContext}\"), Button( text = \"Open Modal\", onPress = listOf( SetContext( contextId = \"myContext\", value = \"Context has changed\" ) ) ) ), context = ContextData( id = \"myContext\", value = \"Set Context Example\" ) )  üëâ Test this action in the Web Playground ","excerpt":" What is it? The SetContext action is responsible for changing the ‚Ä¶","ref":"/docs-beagle/docs/api/actions/setcontext/","title":"Setcontext"},{"body":" O que √©? Apresenta uma nova tela e a coloca na pilha.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     route Route ‚úì Rota de navega√ß√£o.    Como usar? No exemplo abaixo, temos uma tela vinda do BFF com um bot√£o, que ao ser clicado, abre uma nova activity server-driven com a tela especificada pelo BFF.\nPara testar, basta que um endpoint do seu BFF retorne a tela do c√≥digo abaixo e chame esse endpoint no frontend. Voc√™ poder√° passar tanto uma rota local (que passar√° uma screen na rota), quanto remota (que passar√° o endpoint da tela para a qual ir√° navegar).\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushStack\", \"route\" : { \"screen\" : { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello second Screen\" } } } } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PushStack( Route.Local( Screen( child = Text(\"Hello second Screen\") ) ) ) ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©? Apresenta uma nova tela e a coloca na pilha.\nA sua estrutura ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/pushstack/","title":"Pushstack"},{"body":" What is it? SubmitForm is an exclusive action ofSimpleForm, it must be used in some event inside the form, so it will be sent.\nHow to use? For a complete example together with SimpleForm, click here.\n","excerpt":" What is it? SubmitForm is an exclusive action ofSimpleForm, it must ‚Ä¶","ref":"/docs-beagle/docs/api/actions/submitform/","title":"Submitform"},{"body":" O que √©?  Abre uma nova tela na mesma pilha usando uma rota.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     route ‚ÄãRoute‚Äã ‚úì Rota de navega√ß√£o.    Como usar? No exemplo abaixo, temos uma tela vinda do BFF com um bot√£o, que ao ser clicado, abre um novo fragment server-driven com a tela especificada pelo BFF.\nPara testar, basta que um endpoint do seu BFF retorne a tela do c√≥digo abaixo e chame esse endpoint no frontend. Voc√™ poder√° passar tanto uma rota local (que passar√° uma screen na rota), quanto remota (que passar√° o endpoint da tela para a qual ir√° navegar).\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"screen\" : { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello second Screen\" } } } } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Local( Screen( child = Text(\"Hello second Screen\") ) ) ) ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©?  Abre uma nova tela na mesma pilha usando uma rota.\nA sua ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/pushview/","title":"Pushview"},{"body":" Analytics As most projects use some sort of tagging to gather data about users behaviors and Beagle offers a way to get those informations.\nIt is necessary to configure all platforms that will be used. You can check the configuration for each one of them bellow:\nConfiguration  Select an option  ANDROID CONFIGURATION IOS CONFIGURATION WEB CONFIGURATION To make the Analytics feature work on your Android project you just need to add a Class that implements the Analytics interface and annotate this Class with the @BeagleComponent annotation:\n@BeagleComponent class SampleAnalytics: Analytics { override fun trackEventOnClick(event: ClickEvent) { //TODO: send click event to your tagging library  } override fun trackEventOnScreenAppeared(event: ScreenEvent) { //TODO: send screen appeared event to your tagging library  } override fun trackEventOnScreenDisappeared(event: ScreenEvent) { //TODO: send screen disappeared event to your tagging library  } }  To make the Analytics feature work on your iOS project you just need to add a class that implements the Analytics protocol and pass an instance of this class to the Beagle Dependencies:\nimport BeagleUI class SampleAnalytics: Analytics { func trackEventOnScreenAppeared(_ event: AnalyticsScreen) { //TODO: send screen appeared event to your tagging library  } func trackEventOnScreenDisappeared(_ event: AnalyticsScreen) { //TODO: send screen disappeared event to your tagging library  } func trackEventOnClick(_ event: AnalyticsClick) { //TODO: send click event to your tagging library  } } Transfer the Analytics implementation to the Beagle Dependencies:\nlet dependencies = BeagleDependencies() dependencies.analytics = SampleAnalytics() Beagle.dependencies = dependencies  To make the Analytics feature work on your Web project, you must create a handler to the click and screen event, see the example below:\nimport { ClickEvent, ScreenEvent } from '@zup-it/beagle-web/types' const analyticsHandler = { trackEventOnClick: (event: ClickEvent) =\u003e { //handle click event }, trackEventOnScreenAppeared: (event: ScreenEvent) =\u003e { //handle screen appeared event }, trackEventOnScreenDisappeared: (event: ScreenEvent) =\u003e { //handle screen disappeared event } } Now, add the analytics property on the configuration files of the framework‚Äôs library you are using:\nAngular: open the beagle.module.ts file and alter just like the example below:\n@BeagleModule({ ... analytics: analyticsHandler }) React: open the library configuration file and follow the example:\nexport default createBeagleUIService\u003cany\u003e({ ... analytics: analyticsHandler })  The tagging feature was at first added to only some components and mostly used behaviors. Below we listed and described those behaviors and provided some samples:‚Äå\nClick option For tagging the click event of an Widget, it was added to the Button and Touchable Widgets the property clickAnalyticsEvent with the following attributes:\n Category: This variable specifies the type of object that had some interaction with. It is a required attribute. Label: allows you to provide more context about the interaction. It is an optional attribute. Value: the value of an event. It is an optional attribute.  See below a click event of a tagged Button example:\nBACKEND - BFF ANDROID IOS { \"_beagleType_\": \"beagle:component:button\", \"text\": \"Test\", \"clickAnalyticsEvent\": { \"category\": \"Category\", \"label\": \"Label\", \"value\": \"Value\" } }  Button( text = \"Test\", clickAnalyticsEvent = ClickEvent( category = \"Category\", label = \"Label\", value = \"value\" ) )  Button( text: \"Test\", clickAnalyticsEvent: .init( category: \"Category\", label: \"Label\", value: \"Value\" ) )  ‚ÄåScreenView option if you want to tag a screen appearing and disappearing, it is necessary to add a component with the property screenAnalyticsEvent with the following attributes:\n ScreenName: the name of the screen that will appear.  See below the ScreenView event example, with the tagged screen:\nBACKEND - BFF ANDROID IOS { \"_beagleType_\": \"beagle:component:screencomponent\", \"child\": { \"_beagleType_\": \"beagle:component:button\", \"text\": \"Test\" }, \"screenAnalyticsEvent\": { \"screenName\": \"ScreenName\" } }  Screen( child = Button(\"test\"), screenAnalyticsEvent = ScreenEvent( screenName = \"ScreenName\" ) )  Screen( child: Button(text: \"Test\"), screenAnalyticsEvent: : .init( screenName: \"ScreenName\" ) )  ","excerpt":" Analytics As most projects use some sort of tagging to gather data ‚Ä¶","ref":"/docs-beagle/docs/api/analytics/","title":"Analytics"},{"body":" O que √©? Remove a pilha de exibi√ß√£o atual.\nComo usar? Para us√°-lo basta chamar o PopStack() sem necessidade de nenhum par√¢metro.\nNo exemplo abaixo, temos uma tela vinda do BFF com um bot√£o que ao clicar nele, fecha a activity atual.\nPara testar, basta que um endpoint do seu BFF retorne a tela do c√≥digo abaixo, e chamar esse endpoint no Frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popStack\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PopStack() ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©? Remove a pilha de exibi√ß√£o atual.\nComo usar? Para us√°-lo ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/popstack/","title":"Popstack"},{"body":" ServenDrivenComponent is the father of all Beagle‚Äôs components, such as widgets, forms e navigation, they will be implemented throughServerDrivenComponent.\nAny visual component is required to extend a specific class to work on Beagle. Some of these components are already implemented like Button, Text and Image.\nYou can have other visual component as well, and you are able to create customized components that will have to extend the widget class, according to your platform (Android or iOS).\nBeagle has 21 components, they are currently divided into 5 categories:\nLayout Navigation Forms Lazy UI  Container List View PageView ScrollView    Touchable    Validator Simple Form Input    LazyComponent    Button Image Tab View Text Web View   ","excerpt":" ServenDrivenComponent is the father of all Beagle‚Äôs components, such ‚Ä¶","ref":"/docs-beagle/docs/api/components/","title":"Components"},{"body":" O que √©? Remove a tela de exibi√ß√£o atual.\nComo usar? Para remover a tela atual basta chamar o m√©todo PopView() sem a necessidade de passar nenhum par√¢metro. No exemplo abaixo, temos uma tela vinda do BFF com um bot√£o, que ao clicar nele, remove a view atual.\nPara testar, basta que um endpoint do seu BFF retorne a tela do c√≥digo abaixo e chame esse endpoint no frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popView\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PopView() ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©? Remove a tela de exibi√ß√£o atual.\nComo usar? Para remover a ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/popview/","title":"Popview"},{"body":" O que √©?  Retorna para uma tela espec√≠fica e limpa a navega√ß√£o que foi gerada a partir dessa tela.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     route ‚ÄãString ‚úì Rota de alguma tela que est√° na pilha.    Como usar? No exemplo abaixo, foram utilizadas tr√™s tela: as duas primeiras utilizam o PushView para adicionar as telas na pilha, j√° a √∫ltima faz uso do PopToView para retornar para a primeira.\nPara testar, iremos precisar de tr√™s endpoints:\n O primeiro endpoint ser√° o que seu frontend ir√° chamar para renderizar a tela zero. O segundo endpoint dever√° ser mapeado como \"/firstScreen\", pois essa ser√° URL escolhida para a navega√ß√£o do bot√£o da tela 0 e, por isso, esse endpoint dever√° retornar a tela 1. O terceiro endpoint dever√° ser mapeado como \"/secondScreen\", pois essa ser√° a URL escolhida para a navega√ß√£o do bot√£o da tela 1 e, por isso, esse endpoint dever√° retornar a tela 2. √â pela tela 2 que passa a rota na qual deve ser o endpoint da tela que voc√™ deseja retornar. No caso desse exemplo, √© a \"/home\" que √© o endpoint da tela zero.  Como chamar pela tela zero JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  Como chamar a Tela 1 JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  Como chamar a Tela 2 JSON  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to first screen\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popToView\", \"route\" : \"/home\" } ] } ] } }  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©?  Retorna para uma tela espec√≠fica e limpa a navega√ß√£o que ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/poptoview/","title":"Poptoview"},{"body":" Beagle has some components (UI) already ready to facilitate the process of developing an application, it is not necessary to create a customized component whenever using a component. UI Components are a group of building blocks used to build user interfaces or mobile user-focused interfaces.\nWe can also call them Widgets\nThis category has 6 widgets:\n","excerpt":" Beagle has some components (UI) already ready to facilitate the ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/","title":"UI"},{"body":" What is it? The button widget is responsible for defining a native button using a server-driven button through Beagle.\nCheck the example below to see how the structure works:\n   Attribute  Type  Required Definition      text String or\nBinding\u003cb\u003e\u003c/b\u003e\n ‚úì \nDefines the button text and what it must be declared and it cannot be null.\n   styleId String or\n\u003cb\u003e\u003c/b\u003eBinding\u003cb\u003e\u003c/b\u003e\n  It refers to a native style to be applied in the button. This attribute is optional, meaning if it is not informed it will be used the style pattern of your application.   onPress List \u003cAction\u003e  Possible array actions that this button will go off when clicked. It is possible to adapt this action to be customized or an extension of any action already available in your interface. This attribute is optional, but if an action it is defined here, it must be configured in the frontend. To create an action in the frontend, see the example here.   clickAnalyticsEvent \u003cb\u003e\u003c/b\u003eClickEvent\u003cb\u003e\u003c/b\u003e  Click event that will go off in case an analytics service has been implemented. Check here fore more information about analytics.\u003cb\u003e\u003c/b\u003e    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Beagle Button\", \"styleId\" : \"DesignSystem.MyNativeStyle\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"Example button.\" } ] }  Button( text = \"Click me!\" styleId = \"DesignSystem.MyNativeStyle\", onPress = listOf(Alert(message=\"Example button.\")) )  üëâ Try it in the Web Playground ","excerpt":" What is it? The button widget is responsible for defining a native ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/button/","title":"Button"},{"body":" O que √©?  Abre uma tela com a rota informada e apaga todas as pilhas de navega√ß√£o.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     route ‚ÄãRoute‚Äã ‚úì Rota de navega√ß√£o.    Como usar? No exemplo abaixo, foram utilizadas tr√™s telas: as duas primeiras utilizam o PushView para adicionar as telas na pilha, j√° a √∫ltima faz uso do ResetApplication e reabre na primeira tela.\nPara testar, iremos precisar de tr√™s endpoints:\n  O primeiro endpoint ser√° o que seu frontend ir√° chamar para renderizar a tela zero.\n  O segundo endpoint dever√° ser mapeado como \"/firstScreen\", pois ser√° essa a URL escolhida para a navega√ß√£o do bot√£o da tela zero e, por isso, esse endpoint dever√° retornar a tela 1.\n  O terceiro endpoint dever√° ser mapeado como \"/secondScreen\", pois ser√° essa a URL escolhida\npara a navega√ß√£o do bot√£o da tela 1 e, por isso, esse endpoint dever√° retornar a tela 2. Na tela 2, a rota passada deve ser o endpoint da tela que voc√™ deseja retornar quando a aplica√ß√£o for reiniciada. No caso desse exemplo, √© a \"/home\" que √© o endpoint da tela zero.\n  Como chamar a tela zero JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  Como chamar a Tela 1 JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  Como chamar a Tela 2 JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to reset application\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:resetApplication\", \"route\" : { \"url\" : \"/home\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to reset application\", onPress = listOf( Navigate.ResetApplication( route = Route.Remote(\"/home\") ) ) ) ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©?  Abre uma tela com a rota informada e apaga todas as pilhas ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/resetapplication/","title":"Resetapplication"},{"body":" What is it? The Image widget defines a native image using server-driven data received through Beagle.\nYour structure is represented by the attributes below:\n   Attribute Type Required Definition     path ImagePath or Binding ‚úì Refers to a local image or URL of a remote image to be exhibited.   mode ImageContentMode  Responsible to control how the image will be internally controlled.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", { \"_beagleImagePath_\": \"remote\", \"url\": \"/imagePath.png\", \"placeholder\": \"imagePath\" } }, \"mode\": \"CENTER\" }  Image( path = ImagePath.Remote( url = \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", placeholder = ImagePath.Local(mobileId = \"imagePath\", webUrl = \"/imagePath.png\") ), mode = ImageContentMode.CENTER )  üëâ Test this example in the Web Playground ","excerpt":" What is it? The Image widget defines a native image using ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/image/","title":"Image"},{"body":" O que √©?  Abre uma tela com a rota informada de um novo fluxo e limpa a pilha de telas carregadas anteriormente.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     route ‚ÄãRoute‚Äã ‚úì Rota de navega√ß√£o.    Como usar? No exemplo abaixo, foram utilizadas tr√™s telas: as duas primeiras utilizam o PushView para adicionar as telas na pilha, j√° a √∫ltima faz uso do ResetStack e reabre na primeira tela.\nPara testar, iremos precisar de tr√™s endpoints:\n  O primeiro endpoint ser√° o que seu frontend ir√° chamar para renderizar a tela zero.\n  O segundo endpoint dever√° ser mapeado como \"/firstScreen\", pois ser√° essa a URL escolhida para a navega√ß√£o do bot√£o da tela zero e, por isso, esse endpoint dever√° retornar a tela 1.\n  O terceiro endpoint dever√° ser mapeado como \"/secondScreen\", pois ser√° essa a URL escolhida\npara a navega√ß√£o do bot√£o da tela 1 e, por isso, esse endpoint dever√° retornar a tela 2. Na tela 2, a rota passada deve ser o endpoint da tela que voc√™ deseja retornar quando a aplica√ß√£o for reiniciada. No caso desse exemplo, √© a \"/home\" que √© o endpoint da tela zero.\n  Como chamar a tela zero JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  Como chamar a Tela 1 JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  Como chamar a Tela 2 JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to reset stack\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:resetStack\", \"route\" : { \"url\" : \"/home\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to reset stack\", onPress = listOf( Navigate.ResetStack( route = Route.Remote(\"/home\") ) ) ) ) ) )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©?  Abre uma tela com a rota informada de um novo fluxo e limpa ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/resetstack/","title":"Resetstack"},{"body":" It‚Äôs an ENUM class responsible to define how the stated image will be visualized on UI.\nKotlin DSL  enum class ImageContentMode { FIT_XY, FIT_CENTER, CENTER_CROP, CENTER }  It can be configured as FIT_XY, FIT_CENTER, CENTER_CROP and CENTER:\n FIT_XY: Considers the X and Y scale so the original image matches to the predicted dimensions for the UI visualization. It can change the image proportion. FIT_CENTER: Considers a computed scale that will keep the image‚Äôs original proportion and also guarantees that it entirely fits on the UI‚Äôs space. At least two axes (X or Y) will serve. The result is centralized on the image‚Äôs local. CENTER_CROP: Considers an uniform scale (keeping the image‚Äôs proportion) so both image‚Äôs dimensions (width and height) will be equal or bigger than the dimension correspondent to UI‚Äôs view. CENTER: center image that will be visualized, but not redimensioned.  ","excerpt":" It‚Äôs an ENUM class responsible to define how the stated image will be ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/image/imagecontentmode/","title":"Imagecontentmode"},{"body":" Route define como a navega√ß√£o deve ser carregada.\nAbaixo, voc√™ encontra a descri√ß√£o completa dos tipos de Rota dispon√≠vel por padr√£o no Beagle:\n","excerpt":" Route define como a navega√ß√£o deve ser carregada.\nAbaixo, voc√™ ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/route/","title":"Route"},{"body":" What is it? The ImagePath allows you to define how the image will be loaded, which can be locally or remotely.\nHow to use it? ImagePath.Local It will reference a image that is on locais.JSONKotlin DSL assets. Your structure is represented by the attributes below:\n   Attribute Type Definition     webUrl String Absolute or relative image path to be downloaded.   mobileId String Image‚Äôs identifier that was previously registered on mobile platforms.    It will refer an image that it is already in the local assets.\nJSON Kotlin DSL \"_beagleImagePath_\": \"local\", \"url\": \"/imagemlocal.png\", \"mobileId\": \"imagemlocal\" }  ImagePath.Local( webUrl = \"/imagePath.png\", mobileId = \"imagePath\" )  ImagePath.Remote It will reference an image that its hosted on another host or it‚Äôs related to its own server.JSONKotlin DSL. Your structure is represented by the attributes below:\n   Attribute Type Required Definition     remoteUrl String ‚úì Absolute or relative image path to be downloaded.   placeholder ‚ÄãImagePath.Local‚Äã  It‚Äôs possible to pass a local asset on the app that will be shown meanwhile the remote URL is loaded.    It will refer to an image that is hosted in another host or a relative one in the own server.\nJSON Kotlin DSL \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", \"placeholder\": { \"_beagleImagePath_\": \"local\", \"url\": \"/imagemlocal.png\", \"mobileId\": \"imagemlocal\" } }  ImagePath.Remote( remoteUrl = \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", placeHolder = ImagePath.Local( webUrl = \"/imagePath.png\", mobileId = \"imagePath\" ) )  ","excerpt":" What is it? The ImagePath allows you to define how the image will be ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/image/imagepath/","title":"Imagepath"},{"body":" O que √©?  Uma rota de navega√ß√£o para um conte√∫do remoto.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo  Tipo  Obrigat√≥rio Defini√ß√£o      url String ou\nBinding\u003cb\u003e\u003c/b\u003e\n ‚úì Endere√ßo para navega√ß√£o.   shouldPrefetch Boolean  Carregar o endere√ßo previamente.   fallback Screen   Tela a ser retornada caso o carregamento falhe.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushView\", \"route\": { \"url\": \"/present/view\", \"shouldPrefetch\": false } } ] }  Button( onPress = listOf( Navigate.PushView( Route.Remote(\"/present/view\") ) ), text = \"Click me!\" )  üëâ Teste essa a√ß√£o no Web Playground ","excerpt":" O que √©?  Uma rota de navega√ß√£o para um conte√∫do remoto.\nA sua ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/route/remote/","title":"Remote"},{"body":" O que √©?  Rota de navega√ß√£o para conte√∫do local.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     screen Screen ‚úì Tela a ser carregada    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushView\", \"route\": { \"screen\": { \"_beagleComponent_\": \"beagle:screenComponent\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Hello Screen from Navigate\" } } } } ] }  Button( onPress = listOf( Navigate.PushView( Route.Local( Screen( child = Text(\"Hello Screen from Navigate\") ) ) )), text = \"Click me!\" )  üëâ Teste essa a√ß√£o no Web Playground ","excerpt":" O que √©?  Rota de navega√ß√£o para conte√∫do local.\nA sua estrutura √© ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/route/local/","title":"Local"},{"body":" What is it? The Tab Bar component is responsible for defining a table that allows navigation between views. It displays tabs corresponding to different views that can be accessed through it.\nThe structure is represented as shown below:\n   Attribute Type Required Definition     items TabBarItem ‚úì Receive a list of TabBarItems that will define the Tabs in the TabBar   styleId String  Style ID that identifies an style to be applied on the TabBar   currentTab Bind\u003cInt\u003e  Integer number that identifies that selected TabBarItem``   onTabSelection List\u003cAction\u003e  List of Actions that are performed when a TabBarItem is selected. It can be used to load views according to the selected TabBarItem.    What is Tab Bar Item? This component represents the TabBarItem presented on a Tab Bar.\n   Attributes Type Required Definition     title String  Displays the text in the Tab Bar item Title. If it is not declared or if it is set to null, it will not appear on the screen. The tab wont be displayed.   icon Path  Displays a local image as an icon in the Tab Bar Item. If it is not declared or is set to null, it will not appear on the screen.    If a title or icon is not declared in the TabBarItem, the empty space will remain. If you need navigation between viewers without the Tab interface, it is recommended that you use the navigation components  How to use it? On the following example, it will be used two componentes to explain TabBar: PageView and Context.\nPage View is used to render the pages you want to display, that is, it will create the view on each selected tab. This is where you will define the components you want to display by clicking on each tab.\nThe components will be rendered according to their position in the list of componentes defined at the Page View Component.It means that, if we have 2 text components in our list, TAB 1 and TAB 2. The first has a position of ZERO = 0, and the second has ONE = 1. The currentTab attribute is the one that defines which component is displayed according to the value defined in it.\nThe Context is used to save the indicator (position) of the selected tab, and inform it to PageView, which coordinates which element will be displayed.\nExample JSON kotlin DSL { \"_beagleComponent_\": \"beagle:screenComponent\", \"child\": { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:tabBar\", \"items\": [ {\"title\": \"Tab 1\"}, {\"title\": \"Tab 2\"} ], \"styleId\": \"TabBarStyle\", \"onTabSelection\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"contestTabId\", \"value\": \"@{onTabSelection}\" } ] }, { \"_beagleComponent_\": \"beagle:pageView\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Tab 1\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Tab 2\" } ], \"currentPage\": \"@{contestTabid}\" } ], \"context\": { \"id\": \"contestTabid\", \"value\": 0 } } }  Screen( child = Container( context = ContextData(\"contestTabid\", 0), children = listOf( TabBar( onTabSelection = listOf( SetContext( \"contestTabId\", \"@{onTabSelection}\" ) ), items = listOf( TabBarItem(\"Tab 1\"), TabBarItem(\"Tab 2\") ), styleId = \"TabBarStyle\" ), PageView( currentPage = expressionOf(\"@{contestTabid}\"), children = listOf( Text( \"Tab 1\" ), Text( \"Tab 2\" ) ) ) ) ) )     Tab Bar         üëâ Test this component on the Web Playground This example does not exist on the playground, but you can copy and paste the JSON code above and test it on the playground. The section bellow contains more information about this example  ","excerpt":" What is it? The Tab Bar component is responsible for defining a table ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/tabbar/","title":"Tabbar"},{"body":" This component was deprecated in Beagle version 1.1.0 and will be removed in a future version. Use TabBar instead.  What is TabView? A TabView is a component used to navigate between views that are listed in a tab. It displays all tabs that correspond to different previews that can be accessed through it.\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     children List\u003cTabItem\u003e ‚úì List of tab items available in the TabView component. The TabItem itself is not a widget, but its content is a server driven component received through Beagle.   styleId String  It uses a key that it is registered in the Design System of evert platform to customize your component.   context ContextData  Add a context to your TabView component.    What is TabItem? TabView components items that have this structure:\n   Attribute Type Required Definition     title String  Displays the text in a TabView item. If it is not declared or if it is configured with the null value, it will not be shown on the screen.   icon Path  Displays a local image as an icon in the TabView item. If it is not declared or if it is configured with the null value, it will not be shown on the screen.   child Component ‚úì Defines which view will be inflated in the TabItem, according to the tab clicked. Any server-driven component can be a Tab View item.    If you don‚Äôt declare the title and the icon on the TabItem, the empty space will remain. If you need a navigation between viewers without Tab interface, it is recommended that you use the navigation component.  How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:tabview\", \"children\": [ { \"title\": \"Tab 1\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\":\"First Tab Content\" } }, { \"title\": \"Tab 2\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\":\"Second Tab Content\" } } ] } ] }  Screen( child = Container( children = listOf( TabView(children = listOf( TabItem(\"Tab 1\", Image(ImagePath.Remote(\"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\") ) ), TabItem(\"Tab 2\", Image(ImagePath.Remote(\"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\") ) ) ) ) ) ) )     TabView full screen TabView with dividing screen          üëâ Test this component in the Web Playground ","excerpt":" This component was deprecated in Beagle version 1.1.0 and will be ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/tabview/","title":"Tabview"},{"body":" O que √©? A classe sendRequest √© respons√°vel por tratar requisi√ß√µes HTTP\nA estrutura do Send Request √©:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     url String ou Binding ‚úì URL do servidor.   method RequestActionMethod ou Binding ‚úì M√©todo HTTP.   headers Map \u003cString, String\u003e ou Binding  Itens do header para a requisi√ß√£o.   data Any  Conte√∫do a ser enviado junto a requisi√ß√£o.   onSuccess List\u003cAction\u003e  A√ß√£o tratativa de sucesso.   onError List\u003cAction\u003e  A√ß√£o tratativa de erro.   onFinish List\u003cAction\u003e  A√ß√£o tratativa de finaliza√ß√£o.    Como usar? Segue abaixo um exemplo de bot√£o que faz uma requisi√ß√£o do tipo POST enviando dados de um usu√°rio:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Send Request Example\", \"onPress\": [ { \"beagleAction\":\"beagle:sendRequest\", \"url\":\"https://myUrl.com/endpoint\"\", \"method\":\"POST\", \"headers\":{ \"Content-Type\":\"application/json\" }, \"data\":{ \"email\":\"john@email.com\", \"password\":\"password\", \"confirmPassword\":\"password\", \"name\":\"John\" }, \"onSuccess\":[ { \"beagleAction\":\"beagle:alert\", \"title\":\"SUCCESS\", \"message\":\"Success\" } ], \"onError\":[ { \"beagleAction\":\"beagle:alert\", \"title\":\"ERROR\", \"message\":\"Error\" } ], \"onFinish\":[ { \"beagleAction\":\"beagle:alert\", \"title\": \"FINISH\", \"message\":\"Finish\" } ] } ] } ] }  Button( text = \"Send a request\", styleId = \"DesignSystem.MyNativeButtonStyle\", onPress = listOf( SendRequest( url = https://myUrl.com/endpoint\", method = RequestActionMethod.POST, data = User( name = \"John\", email = \"jonh@email.com\", password = \"password\", confirmPassword = \"password\" ), headers = mapOf( \"Content-Type\" to \"application/json\" ), onSuccess = listOf( Alert( title = \"SUCCESS\", message = \"Success\" ) ), onError = listOf( Alert( title = \"ERROR\", message = \"Error\" ) ), onFinish = listOf( Alert( title = \"FINISH\", message = \"Finish\" ) ) ) ) )  üëâ Teste essa a√ß√£o no Web Playground ","excerpt":" O que √©? A classe sendRequest √© respons√°vel por tratar requisi√ß√µes ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/sendrequest/","title":"Sendrequest"},{"body":" What is it? Text component defines the native text using the server driven information.\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     text String or Binding ‚úì Defines the content in text to be rendered.   styleId String  Refers to a locally configured style that it will be applied on the text.   textColor String  Defines the text color.   alignment TextAlignment  Define the alignment of the text.    TextAlignment    Attributes Definition     LEFT Content align to the left in the text viewer.   CENTER Content align in the center in the text viewer.   RIGHT Content align to the right in the text viewer.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Hello World!\" }  Text(text = \"Hello World!\")  üëâ Test this component in the Web Playground ","excerpt":" What is it? Text component defines the native text using the server ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/text/","title":"Text"},{"body":" O que √©? A a√ß√£o SetContext √© respons√°vel por alterar o valor de um contexto.\nA estrutura do SetContext √©:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     contextId String ‚úì Id do contexto   value Any ‚úì Novo valor a ser aplicado no contexto   path String  Ponto espec√≠fico do contexto para ser alterado no caso de arrays e mapas \u003cchave, valor\u003e.    Conhe√ßa mais sobre o contexto no Beagle.  Como usar? Abaixo temos um exemplo de um texto que √© preenchido por contexto e possui um valor inicial ‚ÄúSet Context Example‚Äù e no evento de clique do bot√£o o valor do contexto √© alterado para ‚ÄúContext has changed‚Äù.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"context\":{ \"id\": \"myContext\", \"value\":\"Set Context Example\" }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\":\"@{myContext}\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Open Modal\", \"onPress\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"myContext\", \"value\": \"Context has changed\" } ] } ] }  Container( children = listOf( Text(text = \"@{myContext}\"), Button( text = \"Open Modal\", onPress = listOf( SetContext( contextId = \"myContext\", value = \"Context has changed\" ) ) ) ), context = ContextData( id = \"myContext\", value = \"Set Context Example\" ) )  üëâ Teste essa a√ß√£o no Web Playground ","excerpt":" O que √©? A a√ß√£o SetContext √© respons√°vel por alterar o valor de um ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/setcontext/","title":"Setcontext"},{"body":" What is it? Input is a component that displays an editable text area for the user. These text fields are used to collect inputs that the user insert using the keyboard.\nSee how the structure is represented by the attributes below:\n   Attribute  Type  Required Definition      value String or\nBinding\u003cb\u003e\u003c/b\u003e\n ‚úì Item referring to the input value that will be entered in the editable text area of the Text Input component.   placeholder String or\nBinding\u003cb\u003e\u003c/b\u003e\n  The Placeholder is a text that is displayed when nothing has been entered in the editable text field.   disabled Boolean  Enables or disables the field.   readOnly Boolean  Check if the Input will be editable or read only.   hidden Boolean  Enables the component to be visible or not.   type TextInputType or Binding\u003cb\u003e\u003c/b\u003e  This attribute identifies the text type that it will receive in the editable field area. On Android and iOS, this field also attributes the type of keyboard that will be shown to the user.   styleId String  This attribute receives a key that is registered in the Design System of each platform that customizes the component.   onChange List \u003cAction\u003e  Actions array that this field can trigger when its value is altered. It is possible to define a customized action or any available action in the interface, for example, an action that shows an Alert message. \nThis attribute is optional, but if an action is defined here it needs to be configured in the fronted.\n\n   onBlur List \u003cAction\u003e  Action array that this field can trigger when its focus is removed. It is possible to defined a customized action or any available action in the interface, for example, an action that shows an alert message (Alert).\n\nThis attribute is optional, but if an action is defined here it needs to be configured in the fronted.\n   onFocus List \u003cAction\u003e  Actions array that this field can trigger when this field is on focus. It is possible to defined a customized action or any available action in the interface, for example, an action that shows an alert message (Alert).  \u003cb\u003e\u003c/b\u003e\nThis attribute is optional, but if an action is defined here it needs to be configured in the fronted.\n    TextInputType It is an ENUM responsible to define which type of text input.\n   Type Definition     DATE Data input is a date.   EMAIL Data input is an email.   PASSWORD Data input is a password.   NUMBER Data input only with numbers.   TEXT Data input is a text.    How to use it? See below an example of text input with the password type:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"my value\", \"placeholder\": \"user@test.com.br\", \"type\": \"email\", \"onChange\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"Changing input\" } ] }  TextInput( value = \"my value\", placeholder = \"password\", type = TextInputType.PASSWORD, styleId = \"test.input.style\", onChange = listOf( Alert( message = \"Text value changed.\" ) ) )  üëâ Teste this component on Web Playground The example on the link above is from a Form, that contains a text input. But you can select the example code above and copy and past it on the playground to see how it works.  ","excerpt":" What is it? Input is a component that displays an editable text area ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/textinput/","title":"Textinput"},{"body":" O que √©? O SubmitForm √© uma a√ß√£o exclusiva do SimpleForm, pois deve ser usada em algum evento dentro do formul√°rio, para que o mesmo seja enviado.\nComo usar? Para um exemplo completo junto ao SimpleForm clique aqui\n","excerpt":" O que √©? O SubmitForm √© uma a√ß√£o exclusiva do SimpleForm, pois deve ‚Ä¶","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/submitform/","title":"Submitform"},{"body":" What is it? This component defines a native web view and uses a server-driven information.\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     url String or Binding ‚úì Defines the Web View home page that will load. It must be declared and it cannot have a null value.    When opening an insecure link (http): It is important to notice that this component will open ONLY secure links like https and it WON‚ÄôT display any not-safe links like http.  How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:webView\", \"url\": \"https://maps.google.com/\" }  WebView(url: \"https://docs.usebeagle.io/\")  üëâ Test this component in the Web Playground‚Äã ","excerpt":" What is it? This component defines a native web view and uses a ‚Ä¶","ref":"/docs-beagle/docs/api/components/ui/webview/","title":"Webview"},{"body":" Analytics Como a maioria dos projetos usam alguma forma de marca√ß√£o/tags para agrupar dados sobre o comportamento do usu√°rio, o Beagle oferece uma ajuda para voc√™ conseguir essas informa√ß√µes.\n√â necess√°rio configurar a sua plataforma para que o analytics funcione, segue abaixo os passos para a configura√ß√£o:\nConfigura√ß√£o  Selecione uma op√ß√£o de cofigura√ß√£o:  ANDROID IOS WEB Para que o Analytics funcione no seu projeto Android, voc√™ precisa adicionar uma classe que implemente a interface do Analytics. Anote essa classe com o @BeagleComponent.\n@BeagleComponent class SampleAnalytics: Analytics { override fun trackEventOnClick(event: ClickEvent) { //TODO: send click event to your tagging library  } override fun trackEventOnScreenAppeared(event: ScreenEvent) { //TODO: send screen appeared event to your tagging library  } override fun trackEventOnScreenDisappeared(event: ScreenEvent) { //TODO: send screen disappeared event to your tagging library  } }  Para que o Analytics funcione no seu projeto iOS, voc√™ precisa adicionar a classe que implemente o protocolo Analytics e passar a instanci√°-la nas depend√™ncias do Beagle:\nimport BeagleUI class SampleAnalytics: Analytics { func trackEventOnScreenAppeared(_ event: AnalyticsScreen) { //TODO: send screen appeared event to your tagging library  } func trackEventOnScreenDisappeared(_ event: AnalyticsScreen) { //TODO: send screen disappeared event to your tagging library  } func trackEventOnClick(_ event: AnalyticsClick) { //TODO: send click event to your tagging library  } } passando a implementa√ß√£o de Analytics para o Beagle Dependencies:\nlet dependencies = BeagleDependencies() dependencies.analytics = SampleAnalytics() Beagle.dependencies = dependencies  Para que o Analytics funcione no seu projeto Web, voc√™ precisa criar um handler para os eventos de clique e screen:\nimport { ClickEvent, ScreenEvent } from '@zup-it/beagle-web/types' const analyticsHandler = { trackEventOnClick: (event: ClickEvent) =\u003e { //handle click event }, trackEventOnScreenAppeared: (event: ScreenEvent) =\u003e { //handle screen appeared event }, trackEventOnScreenDisappeared: (event: ScreenEvent) =\u003e { //handle screen disappeared event } } Agora basta adicionar a propriedade analytics nos arquivos de configura√ß√£o da biblioteca dependendo do framework utilizado:\nPara Angular, abra o arquivo beagle.module.ts e altere como no exemplo:\n@BeagleModule({ ... analytics: analyticsHandler }) Para React, abra o arquivo de configura√ß√£o da biblioteca e siga o exemplo:\nexport default createBeagleUIService\u003cany\u003e({ ... analytics: analyticsHandler })  A feature de marca√ß√£o foi adicionada em apenas alguns componentes dos comportamentos mais usados. Segue abaixo a descri√ß√£o e os exemplos:\nOp√ß√£o Click Para marca√ß√£o do click event de um widget, foi adicionado o bot√£o e o Touchable Widgets da propriedade clickAnalyticsEvent com os seguintes atributos:\n Category: essa vari√°vel especifica o tipo de objeto com qual teve alguma intera√ß√£o. √â um atributo obrigat√≥rio. Label: permite que voc√™ forne√ßa mais contexto sobre a intera√ß√£o. √â um atributo opcional. Value: o valor de um evento. √â um atributo opcional.  Segue abaixo um exemplo de click event da marca√ß√£o de um bot√£o:\nBACKEND - BFF ANDROID IOS { \"_beagleType_\": \"beagle:component:button\", \"text\": \"Test\", \"clickAnalyticsEvent\": { \"category\": \"Category\", \"label\": \"Label\", \"value\": \"Value\" } }  Button( text = \"Test\", clickAnalyticsEvent = ClickEvent( category = \"Category\", label = \"Label\", value = \"value\" ) )  Button( text: \"Test\", clickAnalyticsEvent: .init( category: \"Category\", label: \"Label\", value: \"Value\" ) )  ‚ÄåOp√ß√£o ScreenView Quando for marcar uma tela que aparece e desaparece, √© preciso adicionar um componente com a propriedade screenAnalyticsEvent com o seguinte atributo:\n ScreenName: nome da tela que ir√° aparecer.  Segue abaixo um exemplo de evento de ScreenView com a tela marcada:\nBACKEND - BFF ANDROID IOS { \"_beagleType_\": \"beagle:component:screencomponent\", \"child\": { \"_beagleType_\": \"beagle:component:button\", \"text\": \"Test\" }, \"screenAnalyticsEvent\": { \"screenName\": \"ScreenName\" } }  Screen( child = Button(\"test\"), screenAnalyticsEvent = ScreenEvent( screenName = \"ScreenName\" ) )  Screen( child: Button(text: \"Test\"), screenAnalyticsEvent: : .init( screenName: \"ScreenName\" ) )  ","excerpt":" Analytics Como a maioria dos projetos usam alguma forma de ‚Ä¶","ref":"/docs-beagle/pt/docs/api/analytics/","title":"Analytics"},{"body":" What is Touchable? Touchable defines clickable areas in your application in widgets that are not clickable by default.\nSee how the structure is represented:\n   Attribute  Type  Required Definition      onPress \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e ‚úì Defines one or more actions to be performed when a child component is clicked.\n\n   click\nAnalytics\nEvent\n \u003cb\u003e\u003c/b\u003eAnalytics\u003cb\u003e\u003c/b\u003e\n\u003cb\u003e\u003c/b\u003eClick\u003cb\u003e\u003c/b\u003e\n  Click event that will be triggered if an analytics service was implemented.   child \u003cb\u003e\u003c/b\u003eServer\u003cb\u003e\u003c/b\u003e\n\u003cb\u003e\u003c/b\u003eDrivenComponent\u003cb\u003e\u003c/b\u003e\n ‚úì Defines a widget that will trigger the onPress attribute.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:touchable\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"This is a touchable!\" } ], \"child\": { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/KWwTSWB/1029209-200.png\" }, \"accessibility\": { \"accessibilityLabel\": \"Touchable image\", \"accessible\": true } } }  Touchable(onPress = listOf( Alert(title = \"Image\", message = \"Clicked on Message\")), child = Image(path = ImagePath.Local.justMobile(\"name\")) )  üëâ Test this example in the Web Playground ","excerpt":" What is Touchable? Touchable defines clickable areas in your ‚Ä¶","ref":"/docs-beagle/docs/api/components/touchable/","title":"Touchable"},{"body":" O ServerDrivenComponent √© o pai de todos os componentes do Beagle. Componentes como widgets, formul√°rios e navega√ß√£o ser√£o implementados por meio do ServerDrivenComponent.\nQualquer componente visual √© obrigado a estender de uma classe espec√≠fica para funcionar no Beagle. Alguns componentes visuais j√° s√£o implementados pelo Beagle como por exemplo o Button, Text e Image.\nVoc√™ pode ter outros componentes visuais tamb√©m, e ainda pode criar componentes customizados que devem estender da classe widget de acordo com sua plataforma (Android ou iOS).\nO Beagle possui 14 componentes atualmente divididos em 5 categorias:\nLayout Formul√°rios UI  Container List View PageView PageIndicator ScrollView    Validator Simple Form Text Input     Button Image Tab Bar Tab View Text Web View   ","excerpt":" O ServerDrivenComponent √© o pai de todos os componentes do Beagle. ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/","title":"Componentes"},{"body":" What is Lazy? The Lazy Component is used when a BFF asynchronous request is made.\nSee how the structure is represented:\n   Attribute Type Required Definition     path String ‚úì URL that makes the request.   initialState ServerDrivenComponent ‚úì Server-driven component that is showed when there is an asynchronous request being done.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:lazycomponent\", \"path\": \"/listview.json\", \"initialState\": { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Carregando conte√∫do, aguarde...\" } }  LazyComponent( path = \"/listview.json\", initialState = Text(\"Carregando conte√∫do, aguarde...\") )  üëâ Test this component in the Web Playground ","excerpt":" What is Lazy? The Lazy Component is used when a BFF asynchronous ‚Ä¶","ref":"/docs-beagle/docs/api/components/lazy/","title":"Lazy"},{"body":" O Beagle possui alguns componentes (UI) j√° prontos para facilitar o processo de desenvolvimento de uma aplica√ß√£o, n√£o sendo necess√°rio criar um componente customizado sempre que for utilizar um componente. os Componentes de UI s√£o um grupo de componentes b√°sicos usados para construir as interfaces do usu√°rio ou interfaces m√≥veis com foco no usu√°rio.\nTamb√©m podemos chama-los de Widgets.\nEssa categoria possui 6 widgets:\n","excerpt":" O Beagle possui alguns componentes (UI) j√° prontos para facilitar o ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/","title":"UI"},{"body":" Layout component can be defined with a group of 7 subcomponents: Container, Horizontal, Page View, List View, Scroll View, Stack and Vertical.\nYou will find the description of every Layout attribute:\n","excerpt":" Layout component can be defined with a group of 7 subcomponents: ‚Ä¶","ref":"/docs-beagle/docs/api/components/layout/","title":"Layout"},{"body":" O que √©? O widget Button √© respons√°vel por definir um bot√£o nativo usando informa√ß√µes server driven por meio do Beagle.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributos  Tipo  Obrigat√≥rio Defini√ß√£o      text String ou\nBinding  ‚úì Texto no bot√£o. T√≠tulo do bot√£o   styleId String ou\nBinding   Este atributo referencia um estilo nativo a ser aplicado no bot√£o. Se n√£o for informado, o estilo padr√£o de bot√£o da sua aplica√ß√£o ser√° aplicado ao bot√£o.   onPress List \u003cAction\u003e  Array de a√ß√µes que esse bot√£o pode disparar quando clicado. √â poss√≠vel definir uma A√ß√£o customizada ou qualquer a√ß√£o j√° dispon√≠vel na interface, como por exemplo uma a√ß√£o que mostra uma mensagem de alerta(Alert). Este atributo √© opcional, mas se uma a√ß√£o for definida aqui ela precisa estar configurada no frontend. Para criar uma a√ß√£o no frontend veja o exemplo: Criando uma a√ß√£o customizada    clickAnalyticsEvent ClickEvent   Evento de clique que ser√° disparado caso tenha sido implementado um servi√ßo de analytics. Para saber mais sobre analytics e os eventos suportados, veja o exemplo: Analytics.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Faz um Alert\", \"styleId\" : \"DesignSystem.MeuEstiloDeBot√£oNativo\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:alert\", \"message\" : \"Eu sou a mensagem de um Alerta\" } ] }  Button( text = \"Faz um Alert\", styleId = \"DesignSystem.MeuEstiloDeBot√£oNativo\", onPress = listOf( Alert( message = \"Eu sou a mensagem de um Alerta\" ) ) )  üëâ Teste esse componente no Web Playground ","excerpt":" O que √©? O widget Button √© respons√°vel por definir um bot√£o nativo ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/button/","title":"Button"},{"body":" What is it? Container is a component that contains other components inside it.\nSee how the structure is represented:\n   Attribute Type Required Definition     children List \u003cServerDriven Component\u003e ‚úì Defines the component list that it is part of the container.   context ContextData  It is the context in this widget.   onInit List\u003cAction\u003e  It is a parameter that allows you to define a list of actions to be performed when the Widget is displayed.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"@{myContext.value}\" } ], \"context\": { \"id\": \"myContext\", \"value\": \"Hello world!\" } }  Container( children = listOf( Text(text = \"@{myContext.value}\") ), context = ContextData( id = \"myContext\", value = \"Hello World!\" ) )  üëâ Test this component in the Web Playground ","excerpt":" What is it? Container is a component that contains other components ‚Ä¶","ref":"/docs-beagle/docs/api/components/layout/container/","title":"Container"},{"body":" O que √©? O widget de Imagem define uma imagem nativa usando informa√ß√µes server-driven recebidas por meio do Beagle.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     path ImagePath ou Binding ‚úì Refer√™ncia de uma imagem local ou url de uma imagem remota a ser exibida.   mode ImageContentMode  √â respons√°vel por controlar como a imagem ser√° controlada internamente.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", { \"_beagleImagePath_\": \"remote\", \"url\": \"/imagePath.png\", \"placeholder\": \"imagePath\" } }, \"mode\": \"CENTER\" }  Image( path = ImagePath.Remote( url = \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", placeholder = ImagePath.Local(mobileId = \"imagePath\", webUrl = \"/imagePath.png\") ), mode = ImageContentMode.CENTER )  üëâ Teste esse exemplo no Web Playground ","excerpt":" O que √©? O widget de Imagem define uma imagem nativa usando ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/image/","title":"Image"},{"body":" What is it? The ListView component is responsible for defining a list of recyclable items natively. These items can be any server driven components. The use of ListView is recommended for situations where there is repetition of components, but with different data.\nFrom version 1.5.0, we started to support the use of context and cell recycling in ListView, with that we provide two ways to build the component. The depreciated version was maintained only to keep backward compatibility, upgrade to the new version of the component if possible for better performance.  See how the structure is represented:\nListView    Atributo Tipo Obrigat√≥rio Defini√ß√£o     direction ListDirection  Sets the direction in which list items are displayed.   context ContextData  Defines the context of the component.   onInit List\u003cAction\u003e  List of actions to be performed as soon as the component is displayed.   dataSource Bind\u003cList\u003cAny\u003e\u003e ‚úì Expression that points to a list of values used to populate the component.   template ServerDrivenComponent ‚úì It represents each cell in the list through a ServerDrivenComponent.   onScrollEnd List\u003cAction\u003e  List of actions taken when the list ends.   scrollEndThreshold Int  Defines the percentage scrolled from the list to trigger onScrollEnd.   iteratorName String  It is the context identifier for each cell.   key String  Points to a unique value present in each item of the dataSource to be used as a suffix in the ids of the template components.    ListDirection It is an ENUM, the values are:\n   Values Definition     VERTICAL When itens are displayed in LINES.   HORIZONTAL When itens are displayed in COLUMNS.    Default value is ListDirection.VERTICAL  Deprecated ListView    Attribute Type Required Descriptioon     children List\u003cServerDrivenComponent\u003e ‚úì \nDefines the item list view. They can be configured like a ServerDrivenComponents or like views.    direction \u003cb\u003e\u003c/b\u003eListDirection\u003cb\u003e\u003c/b\u003e  Defines the preview list direction.    How to use it? ListView JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:listView\", \"direction\": \"VERTICAL\", \"dataSource\": [ { \"name\": \"Kelsier\", \"race\": \"Half-skaa\", \"planet\": \"Scadrial\", \"isMistborn\": true, \"age\": 38, \"sex\": \"male\" }, { \"name\": \"Vin\", \"race\": \"Half-skaa\", \"planet\": \"Scadrial\", \"isMistborn\": true, \"age\": 20, \"sex\": \"female\" }, { \"name\": \"TenSoon\", \"race\": \"Kandra\", \"planet\": \"Scadrial\", \"isMistborn\": false, \"age\": 40, \"sex\": \"male\" } ], \"template\": { \"_beagleComponent_\": \"beagle:container\", \"style\": { \"margin\": { \"bottom\": { \"value\": 20, \"type\": \"REAL\" } } }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Name: @{item.name}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Race: @{item.race}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Mistborn: @{item.isMistborn}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Planet: @{item.planet}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"sex: @{item.sex}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"age: @{item.age}\" } ] } }  ListView( dataSource = listOf( Person( name = \"Kelsier\", race = \"Half-skaa\", planet = \"Scadrial\", isMistborn = true, age = 38, sex = Sex.MALE ), Person( name = \"Vin\", race = \"Half-skaa\", planet = \"Scadrial\", isMistborn = true, age = 20, sex = Sex.FEMALE ), Person( name = \"TenSoon\", race = \"Kandra\", planet = \"Scadrial\", isMistborn = false, age = 40, sex = Sex.MALE ), ), template = Container( children = listOf( Text(\"Name: @{item.name}\"), Text(\"Race: @{item.race}\"), Text(\"Mistborn: @{item.isMistborn}\"), Text(\"Planet: @{item.planet}\"), Text(\"sex: @{item.sex}\"), Text(\"age: @{item.age}\"), ) ).applyStyle( Style( margin = EdgeValue(bottom = 20.unitReal()) ) ) )  üëâ Test the ListView in the Web Playground‚Äã Deprecated ListView JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:listView\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#FF0000\", \"alignment\": \"CENTER\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#00FF00\", \"alignment\": \"CENTER\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#0000FF\", \"alignment\": \"CENTER\" } ], \"direction\": \"HORIZONTAL\" }  ListView( direction = ListDirection.HORIZONTAL, children = listOf( Text( text = \"Beagle Text list\", textColor = \"#FF0000\", alignment = TextAlignment.CENTER ), Text( text = \"Beagle Text list\", textColor = \"#00FF00\", alignment = TextAlignment.CENTER ), Text( text = \"Beagle Text list\", textColor = \"#0000FF\", alignment = TextAlignment.CENTER ) ) )  üëâ Test the Deprecated ListView in the Web Playground‚Äã ","excerpt":" What is it? The ListView component is responsible for defining a list ‚Ä¶","ref":"/docs-beagle/docs/api/components/layout/listview/","title":"Listview"},{"body":" √â uma classe ENUM respons√°vel por definir como a imagem declarada ser√° visualizada na UI.\nKotlin DSL  enum class ImageContentMode { FIT_XY, FIT_CENTER, CENTER_CROP, CENTER }  Ele pode ser configurado como FIT_XY, FIT_CENTER, CENTER_CROP e CENTER:\n FIT_XY: Considera a escala X e Y de forma que a imagem de origem d√™ match com as dimens√µes previstas para visualiza√ß√£o no UI. Isso pode alterar a propor√ß√£o da imagem. FIT_CENTER: Considera a escala computada que ir√° manter a propor√ß√£o original da imagem e ainda garantir que ela encaixe inteiramente no espa√ßo destinado no UI. Pelo menos um dos eixos (X ou Y) ir√° servir. O resultado √© centralizado j√° no local da imagem. CENTER_CROP: Considera a escala uniforme (mantendo a propor√ß√£o da imagem) de forma que ambas as dimens√µes (largura e altura) da imagem que ser√° igual ou maior √† dimens√£o correspondente na visualiza√ß√£o no UI. CENTER: imagem de centro que pode ser visualizada, mas n√£o redimensionada.  ","excerpt":" √â uma classe ENUM respons√°vel por definir como a imagem declarada ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/image/imagecontentmode/","title":"Imagecontentmode"},{"body":" What is it? PageView component is a container that present pages that it will be horizontally displayed. They can be any server driven object.\nO Page View refers to its view size on mobile devices (Android or iOS). The page view size is determined by the father that it is in, meaning that, the width and the height will be defined by the component father.\nFor example, a Page View can be declared inside of a Container and the width and the height will define the page view size.\n See how the structure is represented:\n   Attribute Type Required Definition     children List\u003cServerDrivenComponent\u003e ‚úì \nDefines the visual components list (server-driven) in the PageView.\n   context ContextData\u003cb\u003e\u003c/b\u003e  It is the context contained by this Widget.   onPageChange List\u003cAction\u003e  Action list that runs when the selected page is altered.   currentPage Int  Identifier where the page is seletected.   showArrow Boolean  This attribute is specific for the web platform. It enables arrows to change pages.    How to use it? On the example below you will see a PageView that contains three pages where each one of them has a Text defined by the Context. Every time there is a change the context page is redefined:\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:pageView\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 1\", \"alignment\":\"CENTER\" }, { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 2\", \"alignment\":\"CENTER\" }, { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 3\", \"alignment\":\"CENTER\" } ], \"onPageChange\":[ { \"_beagleAction_\":\"beagle:setContext\", \"contextId\":\"context\", \"value\":\"@{onPageChange}\" } ], \"currentPage\":\"@{context}\" }, { \"_beagleComponent_\":\"beagle:pageIndicator\", \"selectedColor\":\"#000000\", \"unselectedColor\":\"#888888\", \"numberOfPages\":3, \"currentPage\":\"@{context}\" } ], \"context\":{ \"id\":\"context\", \"value\":0 } }  Container( children = listOf( PageView( children = (1..3).map { Text( text = \"Page $it\", alignment = TextAlignment.CENTER ) }, onPageChange = listOf(SetContext(\"context\", \"@{onPageChange}\")), currentPage = expressionOf(\"@{context}\") ), PageIndicator( numberOfPages = 3, selectedColor = BLACK, unselectedColor = LIGHT_GREY, currentPage = expressionOf(\"@{context}\") ) ), context = ContextData( id = \"context\", value = 0 ) )  üëâ Test this component in the Web Playground ","excerpt":" What is it? PageView component is a container that present pages that ‚Ä¶","ref":"/docs-beagle/docs/api/components/layout/pageview/","title":"Pageview"},{"body":" O que √©? O ImagePath permite que voc√™ defina como uma imagem ser√° carregada, podendo ser local ou remote.\nComo usar? ImagePath.Local A sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Defini√ß√£o     webUrl String Caminho absoluto ou relativo da imagem a ser baixada.   mobileId String Identificador da imagem que foi previamente cadastrada nas plataformas mobile.    Ir√° referenciar uma imagem que j√° est√° nos assets locais.\nJSON Kotlin DSL { \"_beagleImagePath_\": \"local\", \"url\": \"/imagemlocal.png\", \"mobileId\": \"imagemlocal\" }  ImagePath.Local( webUrl = \"/imagePath.png\", mobileId = \"imagePath\" )  ImagePath.Remote A sua estrutura √© representada como mostrado abaixo:\n   Atributos Tipo Obrigat√≥rio Defini√ß√£o     remoteUrl String ‚úì Caminho absoluto ou relativo da imagem a ser baixada.   placeholder ImagePath.Local  √â poss√≠vel passar um asset local no aplicativo que ser√° mostrado enquanto a URL remota √© carregada.    Ir√° referenciar uma imagem que esteja hospedada em outro host ou relativo no pr√≥prio server.\nJSON Kotlin DSL { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", \"placeholder\": { \"_beagleImagePath_\": \"local\", \"url\": \"/imagemlocal.png\", \"mobileId\": \"imagemlocal\" } }  ImagePath.Remote( remoteUrl = \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", placeHolder = ImagePath.Local( webUrl = \"/imagePath.png\", mobileId = \"imagePath\" ) )  ","excerpt":" O que √©? O ImagePath permite que voc√™ defina como uma imagem ser√° ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/image/imagepath/","title":"Imagepath"},{"body":" What is it? PageIndicatorComponent is a component that indicates the amount of pages and which one is the current PageView.\n   Attribute Type Required Definition     selectedColor String ‚úì Hexadecimal value to represent the color when selected.   unselectedColor String ‚úì Hexadecimal value to represent the color when it is not selected.   numberOfPages Int  Indicates the amount of pages.   currentPage Bind\u003cInt\u003e  Indicates the page.    How to use it? An example on how to use PageIndicator can be foun on PageView.\nüëâ Test this component in the Web Playground‚Äã ``\n","excerpt":" What is it? PageIndicatorComponent is a component that indicates the ‚Ä¶","ref":"/docs-beagle/docs/api/components/layout/pageindicator/","title":"Pageindicator"},{"body":" What is it? Scroll View is a container that shows the preview components by layout scroll.\nSee how the structure is represented:\n   Attribute  Type  Required Definition      children List \u003cServerDriven\u003cb\u003e\u003c/b\u003e\n\u003cb\u003e\u003c/b\u003eComponent\u003e\n ‚úì Defines the attributes list to be displayed in the layout view.\n\n    scrollDirection ScrollAxis  Defines the scroll direction on the screen. It can be modify according to the ScrollAxis class. By default, it has the VERTICAL value.   scrollBarEnabled Boolean  Sets if the scroll bar will be displayed or not. This configuration is true by default.   context \u003cb\u003e\u003c/b\u003eContextData\u003cb\u003e\u003c/b\u003e  Sets a context to scroll view.    ScrollAxis It is an ENUM, the values are:\n   Values Definition     VERTICAL Defines the scroll as vertical.   HORIZONTAL Defines the scroll as horizontal.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"style\": { \"flex\": { \"alignItems\": \"CENTER\", \"justifyContent\": \"CENTER\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:scrollView\", \"children\": [ { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\" } }, { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/LCKYdCT/742px-Example-en-svg.png\" } } ] } ] }  ScrollView(scrollDirection = ScrollAxis.VERTICAL, children = listOf( Text(\"Vertical ScrollView\"), Text(\"Vertical ScrollView\"), Text(\"Vertical ScrollView\") ) )  üëâ Test this component in the Web Playground‚Äã ","excerpt":" What is it? Scroll View is a container that shows the preview ‚Ä¶","ref":"/docs-beagle/docs/api/components/layout/scroll-view/","title":"Scroll View"},{"body":" O que √© o Tab Bar? O componente Tab Bar √© respons√°vel por definir uma tabela que permite a navega√ß√£o entre views. Ele exibe tabs correspondentes a diferentes visualiza√ß√µes que podem ser acessadas por meio dela.\nA estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     items TabBarItem ‚úì Recebe uma lista de TabBarItems que v√£o definir as Tabs na tabBar   styleId String  Id do estilo a ser aplicado na TabBar   currentTab Bind\u003cInt\u003e  N√∫mero que representa a Tab selecionada.   onTabSelection List\u003cAction\u003e  Lista de a√ß√µes que s√£o executadas quando um TabBarItem √© selecionado. Pode ser utilizado para carregar views de acordo com o TabItem selecionado.    O que √© o TabBarItem? Componente corresponde a itens do Tab View e possui a seguinte estrutura:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     title String  Exibe o texto no item do Tab View. Se ele n√£o for declarado ou se for configurado com o valor nulo, n√£o ir√° aparecer na tela.   icon Path  Exibe uma imagem local como √≠cone no item do Tab View. Se ele n√£o for declarado ou for configurado com o valor nulo, n√£o ir√° aparecer na tela.    Se o t√≠tulo e √≠cone n√£o forem declarados no Tab Item, o espa√ßo vazio permanecer√°. Caso voc√™ precise de uma navega√ß√£o entre visualizadores sem a interface Tab, o recomendado √© que voc√™ utilize os componentes de navega√ß√£o.  Como usar? No exemplo a seguir, s√£o utilizados outros componentes para explicar o TabBar: o PageView e o Contexto.\nO Page View √© utilizado para renderizar as p√°ginas que se quer exibir de acordo com cada aba, ou seja, ele vai criar a visualiza√ß√£o de cada uma delas. √â nele que voc√™ vai definir os componentes que quer exibir ao clicar em cada aba.\nOs componentes ser√£o renderizados de acordo com a sua posi√ß√£o na lista. Isso significa que, se em nossa lista temos 2 componentes de texto - o TAB 1 e TAB 2 -, o primeiro tem posi√ß√£o ZERO = 0, enquanto que o segundo tem posi√ß√£o UM = 1. O atributo currentTab √© quem define qual componente √© exibido de acordo com o valor definido nele.\nJ√° o Contexto √© utilizado para guardar o indicador (posi√ß√£o) da aba selecionada e inform√°-lo ao PageView, que coordena qual elemento ir√° apresentar.\nExemplo JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:screenComponent\", \"child\": { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:tabBar\", \"items\": [ {\"title\": \"Tab 1\"}, {\"title\": \"Tab 2\"} ], \"styleId\": \"TabBarStyle\", \"onTabSelection\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"contestTabId\", \"value\": \"@{onTabSelection}\" } ] }, { \"_beagleComponent_\": \"beagle:pageView\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Tab 1\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Tab 2\" } ], \"currentPage\": \"@{contestTabid}\" } ], \"context\": { \"id\": \"contestTabid\", \"value\": 0 } } }  Screen( child = Container( context = ContextData(\"contestTabid\", 0), children = listOf( TabBar( onTabSelection = listOf( SetContext( \"contestTabId\", \"@{onTabSelection}\" ) ), items = listOf( TabBarItem(\"Tab 1\"), TabBarItem(\"Tab 2\") ), styleId = \"TabBarStyle\" ), PageView( currentPage = expressionOf(\"@{contestTabid}\"), children = listOf( Text( \"Tab 1\" ), Text( \"Tab 2\" ) ) ) ) ) )     Tab Bar         üëâ Teste esse componente no Web Playground Este exemplo n√£o existe no playground, mas voc√™ pode copiar e colar o c√≥digo JSON acima e testa-lo no playground. Esta sec√ß√£o contem mais informa√ß√µes sobre esse exemplo abaixo.  ","excerpt":" O que √© o Tab Bar? O componente Tab Bar √© respons√°vel por definir uma ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/tabbar/","title":"Tabbar"},{"body":" Este componente foi depreciado na vers√£o 1.1.0 do Beagle e ser√° removido em uma vers√£o futura. Utilize o componente TabBar no lugar do Tab View  O que √© Tab View? O componente Tab View √© respons√°vel pela navega√ß√£o entre views. Ele exibe tabs correspondentes a diferentes visualiza√ß√µes que podem ser acessadas por meio dela.\nA estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     children List\u003cTabItem\u003e ‚úì Uma lista de tab itens dispon√≠veis no componente Tab View. O Tab Item em si n√£o √© um widget, mas seu conte√∫do √© um componente server driven recebido por meio do Beagle.   styleId String  Recebe uma chave que √© registrada no Design System de cada plataforma para fazer customiza√ß√£o no componente.   context ContextData  Adiciona um contexto para o Tab View.    O que √© Tab Item? Componente corresponde a itens do Tab View e possui a seguinte estrutura:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     title String  Exibe o texto no item do Tab View. Se ele n√£o for declarado ou se for configurado com o valor nulo, n√£o ir√° aparecer na tela.   icon Path  Exibe uma imagem local como √≠cone no item do Tab View. Se ele n√£o for declarado ou for configurado com o valor nulo, n√£o ir√° aparecer na tela.   child Component ‚úì Obrigat√≥rio. Define qual view ser√° inflada no Tab Item de acordo com o tab clicado. Qualquer componente server-driven pode pode ser um item em uma Tab View.    Se o t√≠tulo e √≠cone n√£o forem declarados no Tab Item, o espa√ßo vazio permanecer√°. Caso voc√™ precise de uma navega√ß√£o entre visualizadores sem a interface Tab, o recomendado √© que voc√™ utilize os componentes de navega√ß√£o.  Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:tabview\", \"children\": [ { \"title\": \"Tab 1\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\":\"First Tab Content\" } }, { \"title\": \"Tab 2\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\":\"Second Tab Content\" } } ] } ] }  Screen( child = Container( children = listOf( TabView(children = listOf( TabItem(\"Tab 1\", Image(ImagePath.Remote(\"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\") ) ), TabItem(\"Tab 2\", Image(ImagePath.Remote(\"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\") ) ) ) ) ) ) )     Tab View tela inteira Tab View dividindo tela          üëâ Teste esse componente no Web Playground ","excerpt":" Este componente foi depreciado na vers√£o 1.1.0 do Beagle e ser√° ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/tabview/","title":"Tabview"},{"body":" form is structured by a group of components that defines how the information will be submitted and validated.\nYou will find below a description of all Form‚Äôs attributes in a mobile or web application:\n","excerpt":" form is structured by a group of components that defines how the ‚Ä¶","ref":"/docs-beagle/docs/api/components/forms/","title":"Forms"},{"body":" O que √©? O componente Text √© respons√°vel por definir o texto nativamente usando informa√ß√µes server-driven.\nA estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     text String ou Binding ‚úì Define o conte√∫do em texto a ser exibido.   styleId String  Referencia o estilo configurado localmente a ser aplicado no texto.   textColor String  Define a cor do texto em hexadecimal.   alignment TextAlignment  Define o alinhamento do conte√∫do do texto.    TextAlignment    Atributo Defini√ß√£o     LEFT conte√∫do alinhado √† esquerda dentro do visualizador de texto.   CENTER conte√∫do alinhado no centro dentro do visualizador de texto.   RIGHT conte√∫do alinhado √† direita dentro do visualizador de texto.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Hello World!\" }  Text(text = \"Hello World!\")  üëâ Teste esse componente no Web Playground ","excerpt":" O que √©? O componente Text √© respons√°vel por definir o texto ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/text/","title":"Text"},{"body":" This component is deprecated! It is recomended to use Simple Form.  The component represents a way to build user input and send these values to your backend.\nThe structured is represented below:\n   Attribute Type Required Definition     \nonSubmit\n List \u003cAction\u003e  Array of actions that this button can trigger when a form is sent.   child ServerDrivenComponent  ‚úì Defines the visual components list (server-driven).   group String  Only used to forms with multiple pages, which is an identifier to manipulate data.   additionalData Map\u003cString, String\u003e  Values without validation that the user doesn't insert.   shouldStoreFields Boolean  Indicates if must save theadditionalData.    ","excerpt":" This component is deprecated! It is recomended to use Simple Form. ‚Ä¶","ref":"/docs-beagle/docs/api/components/forms/form/","title":"Form"},{"body":" O que √©? O Input √© um componente respons√°vel por exibir uma √°rea de texto edit√°vel para o usu√°rio. Esses campos de textos s√£o usados para coletar entradas que um usu√°rio insere utilizando o teclado.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo  Tipo  Obrigat√≥rio Defini√ß√£o      value String ou\nBinding\u003cb\u003e\u003c/b\u003e\n  Item referente ao valor de entrada que ser√° digitado na √°rea de texto edit√°vel do componente Text Input.   placeholder String ou\n\u003cb\u003e\u003c/b\u003eBinding\u003cb\u003e\u003c/b\u003e\n  Texto que √© exibido quando nada foi inserido no campo de texto edit√°vel.   disabled Boolean  Propriedade para habilitar ou desabilitar o campo.   readOnly Boolean  Propriedade para determinar se o campo ser√° edit√°vel ou somente leitura.   hidden Boolean  Propriedade que determina se o campo ser√° escondido.   type TextInputType ou Binding\u003cb\u003e\u003c/b\u003e  Esse atributo identifica o tipo de texto que iremos receber na √°rea de texto edit√°vel. No Android e no iOS, esse campo tamb√©m atribui o tipo de teclado que ser√° exibido pro usu√°rio.   styleId String  Recebe uma chave que √© registrada no Design System de cada plataforma para fazer customiza√ß√£o no componente.   onChange List \u003cAction\u003e  Array de a√ß√µes que esse campo pode disparar quando seu valor for alterado. √â poss√≠vel definir uma a√ß√£o customizada ou qualquer a√ß√£o j√° dispon√≠vel na interface, como por exemplo uma a√ß√£o que mostra uma mensagem de alerta(Alert).\n\nEste atributo √© opcional, mas se uma a√ß√£o for definida aqui ela precisa estar configurada no frontend.\n   onBlur List \u003cAction\u003e  Array de a√ß√µes que esse campo pode disparar quando seu foco √© retirado. √â poss√≠vel definir uma a√ß√£o customizada ou qualquer a√ß√£o j√° dispon√≠vel na interface como, por exemplo, uma a√ß√£o que mostra uma mensagem de alerta(Alert).\n\nEste atributo √© opcional, mas se uma a√ß√£o for definida aqui ela precisa estar configurada no frontend.\n   onFocus List \u003cAction\u003e  Array de a√ß√µes que esse campo pode disparar quando √© colocado em foco. √â poss√≠vel definir uma a√ß√£o customizada ou qualquer a√ß√£o j√° dispon√≠vel na interface como, por exemplo, uma a√ß√£o que mostra uma mensagem de alerta(Alert).\n\nEste atributo √© opcional, mas se uma a√ß√£o for definida aqui ela precisa estar configurada no frontend.\n    TextInputType √â um ENUM respons√°vel por definir qual o tipo de entrada de texto.\n   Tipo Defini√ß√£o     DATE Entrada de dados √© uma data.   EMAIL Entrada de dados √© um email.   PASSWORD Entrada de dados √© uma senha.   NUMBER Entrada de dados somente com n√∫meros.   TEXT Entrada de dados √© um texto.    Como usar? Segue abaixo um exemplo de entrada de texto do tipo senha:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"my value\", \"placeholder\": \"user@test.com.br\", \"type\": \"email\", \"onChange\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"Changing input\" } ] }  TextInput( value = \"my value\", placeholder = \"password\", type = TextInputType.PASSWORD, styleId = \"test.input.style\", onChange = listOf( Alert( message = \"Text value changed.\" ) ) )  üëâ Teste esse componente no Web Playground O exemplo no link acima √© de um formul√°rio que cont√©m um componente do tipo text input. Mas voc√™ pode selecionar o c√≥digo de exemplo acima, copi√°-lo e col√°-lo no playground e ver como ele funciona.  ","excerpt":" O que √©? O Input √© um componente respons√°vel por exibir uma √°rea de ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/textinput/","title":"Textinput"},{"body":" The validator component is an interface that informs to the Form when to enable the FormSubmit button. It is based on the observability concept, which FormInput will validate the submitted information and then send them to the Validator.\nThere are two ways to use Form Validator:\n Clicking on FormSubmit Calling the notifyObservers method inside the FormInput.  Aten√ß√£o: Validator ‚â†FormValidation\nDespite the similar names, it‚Äôs important to mention that Validator is different of the FormValidation, the first one authenticates the filled form and the second returns error messages in case of failed information in the form.\n ","excerpt":" The validator component is an interface that informs to the Form when ‚Ä¶","ref":"/docs-beagle/docs/api/components/forms/validator/","title":"Validator"},{"body":" O que √©? O componente Web View define uma web view nativamente e usa informa√ß√µes server-driven.\nA estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     url String ou Binding ‚úì Define a p√°gina inicial que o Web View ir√° carregar. Ele deve ser declarado e n√£o pode ser configurado como valor nulo.    Ao abrir um link n√£o seguro (http): √â importante observar que este componente abrir√° SOMENTE links seguros do tipo https e N√ÉO exibir√° nenhum link n√£o seguro do tipo http.  Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:webView\", \"url\": \"https://maps.google.com/\" }  WebView(url: \"https://docs.usebeagle.io/\")  üëâ Teste esse componente no Web Playground‚Äã ","excerpt":" O que √©? O componente Web View define uma web view nativamente e usa ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/ui/webview/","title":"Webview"},{"body":" What is it? The simpleForm is responsible for rendering a form on the screen.\nIts structure is represented as shown below:\n   Attribute Type Required Definition     ‚ÄãonSubmit List \u003cAction\u003e ‚úì Action array that this button can trigger when a form is sent.   children List\u003cServerDrivenComponent\u003e ‚úì Defines the visual components list (server driven).   context ‚ÄãContextData‚Äã ‚Äã Adds a context to the simple form    How to use? When creating a form it is important to understand two steps respectively\n The relationship and update between fields And what happens when the Submit button is pressed.  Updating the fields The TextInput component is the field in which the user or the system will fill in some information, and it is important to know its attributes in order to better use it. Here we will use one of its elements, which is the onChange function.\nFor more information on this component go to the details of TextInput.  OnChange This function is part of the TextInput and it observes the changes made within its field, that is, whenever the value is modified, something is typed, deleted, etc, this function is called and activates a list of other actions to happen whenever the value changes. It is in this list that we add a SetContext action to set the Context value of the form and update the values ‚Äã‚Äãthat are shown in the field.\nCheck our example below on how we implemented a SimpleForm\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:simpleForm\", \"context\":{ \"id\":\"myContext\", \"value\":\"\" }, \"onSubmit\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"Data submited\", \"message\":\"The password is @{myContext}\" } ], \"children\":[ { \"_beagleComponent_\":\"beagle:textInput\", \"value\":\"@{myContext}\", \"placeholder\":\"Type in your password\", \"onChange\":[ { \"_beagleAction_\":\"beagle:setContext\", \"contextId\":\"myContext\", \"value\":\"@{onChange.value}\" } ] }, { \"_beagleComponent_\":\"beagle:button\", \"text\":\"Click to Submit\", \"onPress\":[ { \"_beagleAction_\":\"beagle:submitForm\" } ] } ] }  SimpleForm( context = ContextData(id = \"myContext\", value = \"\"), children = listOf( TextInput( value = \"@{myContext}\", placeholder = \"Type in your password\", onChange = listOf( SetContext( contextId = \"myContext\", value = \"@{onChange.value}\" ) ) ), Button(text = \"Click to Submit\", onPress = listOf(SubmitForm())) ), onSubmit = listOf( Alert( title = \"Data submited\", message = \"The password is \" + \"@{myContext}\" ) ) )  onSubmit It is a function of a simple form that performs a list of actions. It is called when the form is submitted.\nTo submit a form, you must use the SubmitForm action and call it, just implement it in a Button that is part of a simple form, that is, that is in your list of children.\nWhen you click this button, the onSubmit is activated and the list of actions will be performed. It is this list of actions that will define what should happen with the information in this form, if they will be sent to a backend (through the sendRequest action), etc.\nüëâ Test this component in the Web Playground ","excerpt":" What is it? The simpleForm is responsible for rendering a form on the ‚Ä¶","ref":"/docs-beagle/docs/api/components/forms/simple-form/","title":"Simple Form"},{"body":" O que √©? O Touchable √© respons√°vel por definir as √°reas clic√°veis dentro da aplica√ß√£o em componentes que n√£o s√£o clic√°veis nativamente.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo  Tipo  Obrigat√≥rio Defini√ß√£o      onPress Action  ‚úì Define uma ou mais a√ß√µes a serem executadas quando um componente child √© clicado.   click\nAnalytics\nEvent\n Analytics Click   \nEvento do clique que ser√° disparado caso tenha sido implementado um servi√ßo de analytics.\n   child Server DrivenComponent  ‚úì Define o widget que ser√° o gatilho do atributo onPress.       Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:touchable\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"This is a touchable!\" } ], \"child\": { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/KWwTSWB/1029209-200.png\" }, \"accessibility\": { \"accessibilityLabel\": \"Touchable image\", \"accessible\": true } } }  Touchable(onPress = listOf( Alert(title = \"Image\", message = \"Clicked on Message\")), child = Image(path = ImagePath.Local.justMobile(\"name\")) )  üëâ Teste esse componente no Web Playground ","excerpt":" O que √©? O Touchable √© respons√°vel por definir as √°reas clic√°veis ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/touchable/","title":"Touchable"},{"body":" What is it? Context is a variable of any type, including a map that defines a set of key/value pairs. Through bindings, the value of a context can be accessed by any component or action on your scope.\nThe table below shows the main attributes of the context;\nA tabela abaixo demonstra os principais atributos do contexto:\n   Attribute Type Required Defini√ß√£o     id String ‚úì Context identifier   value Any ‚úì Context value    The context id can only contain letter, numbers and the character ‚Äú_‚Äù and it must be UNIQUE on the screen.  When to use it? Context can be used when you want to fill values in a different moment from the one you received JSONs components.\nOn the example below, you can see a context with data of a user and it‚Äôs showed some information in a Text:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"myData\", \"value\": { \"id\": \"0000\", \"name\": \"User\", \"age\": \"18\" }, }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"value\": \"Name: @{myData.name}\" }, { \"_beagleComponent_\": \"beagle:text\", \"value\": \"Age: @{myData.age}\" } ] }  Container( context = ContextData( id = \"myData\", value = User( id = \"0000\" name = \"User\", age = \"18\" ) ), children = listOf( Text(\"Name: @{myData.name}\"), Text(\"Age: @{myData.age}\") ) )  Notice the context was declared and its values were defined and used to fill the texts, however it is possible to define these values after using a SetContext() method.\nThis way, you can fill the component‚Äôs data that weren‚Äôt yet in the JSON.\nThe context is only useful if the value is accessed in any JSON part. You will need to use bindings for this to happen.  How to use it? There are two ways to use context: explicit and implicit context. The main difference between them is the scope of the context, it can be defined inside the JSON or the declarative structure you are using.\nContext scope The scope of a context is a component where it and its descendants were defined. It‚Äôs impossible to access a declared context in another tree branch.\nA context can be stablished in any Beagle component that implements a ContextComponent, that is a context propriety that can be specified by the following components:\n Container Screen ScrollView PageView TabView Custom Components that implements a ContextComponent  1. Explicit Context When there is a defined scope to the context inside your JSON or your declarative structure.\nSee the example below on how it works:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{myText}\" } ], \"context\" : { \"id\" : \"myText\", \"value\" : \"Hello Beagle\" } }  Container( context = ContextData( id = \"myData\", value = User( id = \"0000\" name = \"User\", age = \"18\" ) ), children = listOf( Text(\"Name: @{myData.name}\"), Text(\"Age: @{myData.age}\") ) )  Notice the context was declared and its values were defined and used to fill the texts, however it is possible to define these values using the SetContext() method later. You can fill the component‚Äôs with data that wasn‚Äôt in the JSON.\n2. Implicit context When there isn‚Äôt a context scope defined inside a JSON or the declarative structure of your screen, but it can be accessed through bindings.\nThat means that this type of context is created only through events.\nBesides that, the scope on this type of context is defined only by an action or a set of action related to the created event in the context.\n In some cases, it‚Äôs necessary to access a particular information about an event that triggered an action. An example is the onChange event, that is launched by any component and allows the data input.\nIf the value of an input component changes and the actions to be launched depend on this value, it is fundamental that you have access to the new component value.\nThe other implicit context characteristic is that it always have the same id as the event name created it. If it the onChangeevent, for example, the context scope will have id onChange and the binding will be: { value: newValue }, where newValue is the field you can include a new value to be used.\nCheck out on the following example that used the onBlur event, it works the same way as onChange, but makes a request when the input component lost its focus:\n{ \"_beagleComponent_\": \"beagle:textinput\", \"label\": \"CEP\", \"onBlur\": [ { \"_beagleAction_\": \"beagle:sendRequest\", \"url\": \"https://viacep.com.br/ws/@{onBlur.value}/json\", \"method\": \"GET\" } ] } Besides the onBlur context had never been declared on the example above, you can use it because it was created in an implicit way by the onBlur event.\nThe JSON defines a view where the focus lost on the CEP (zip code) field runs an action to search the address based on the typed value. The request result could be used to define the value for the other fields on an address form.\nYou can check an example of implicit context of Beagle Web on Beagle Playground.  Examples of events that create an implicit context:\n onChange onFocus onBlur onSuccess onError onFinish.  The first three events are part of a beagle:textinputcomponent contract while the last three are part of beagle:sendRequest action.\nBindings Bindings are the string in a special format that identifies a value inside a context. Without it is not possible to create implicit or explicit contexts.\nDuring Beagle‚Äôs render process, bindings can be replaced by values referred to them.\nA binding is identified by a prefix @{ and a suffix }. Meaning that everything between the symbols @{ and } identify the context value by which the binding must be replaced when you render a screen.\nSee the example below on how it works:\nJSON kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{myText}\" } ], \"context\" : { \"id\" : \"myText\", \"value\" : \"Hello Beagle\" } }  Container( children = listOf( Text(\"@{myText}\") ), context = ContextData( id = \"myText\", value = \"Hello Beagle\" ) )  To access the ‚ÄúHello Beagle‚Äù text through a binding, it has to specify the context id: @{myText}.\nOn the example above, the context value is a simple string, but you can see on the next topic how to access values in contexts that are maps or arrays.\nTypes of bindings Multi-valued binding (key/value maps) It is the binding type which the context value it will be generally, a key/value of a map.\nIn these cases, bindings must be used to access substructures. As it happens in most of programming languages, Beagle uses points to make this kind of access, as you can see on the context example below:\n To access the CPF, use the @{user.cpf} binding. To access the phone number, use the @{user.phoneNumber.cellphone} binding.  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{user.phoneNumber.cellphone}\" } ], \"context\" : { \"id\" : \"user\", \"value\" : { \"cpf\" : \"014.225.235-12\", \"phoneNumber\" : { \"cellphone\" : \"(34) 98856-8563\", \"telephone\" : \"(34) 3214-5588\" } } } }  No Kotlin √© necessario que se crie algumas classes para gerenciar os contextos multivalorados\nContainer( children = listOf( Text(\"@{user.phoneNumber.cellphone}\") ), context = ContextData( id = \"user\", value = User( cpf = \"014.225.235-12\", phoneNumber = PhoneNumber( cellphone = \"(34) 98856-8563\", telephone = \"(34) 3214-5588\" ) ) ) ) data class User(val cpf: String, val phoneNumber:PhoneNumber) data class PhoneNumber(val cellphone:String, val telephone:String)  Binding with vectors (arrays) It is the type of binding which the context value will be generally vectors (arrays).\nIf a vector is used on a context value, to access a specific position, you have to use the [ e ] characters when you‚Äôre building the binding.\nSee how on the context example below:\n To access the second film title (‚ÄúContact‚Äù), use the @{movies.titles[1].title}binding.  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{movies.titles[1].title}\" } ], \"context\" : { \"id\" : \"movies\", \"value\" : { \"genre\" : \"sci-fi\", \"titles\" : [ { \"title\" : \"Inception\", \"year\" : \"2010\", \"rating\" : \"8.8\" }, { \"title\" : \"Contact\", \"year\" : \"1997\", \"rating\" : \"7.4\" } ] } } }  No Kotlin √© necessario que se crie algumas classes para gerenciar os contextos multivalorados\nContainer( children = listOf( Text(\"@{movies.titles[1].title}\") ), context = ContextData( id = \"movies\", value = Movie( genre = \"sci-fi\", titles = listOf( Title( title = \"Inception\", year = \"2010\", rating = \"8.8\" ), Title( title = \"Contact\", year = \"1997\", rating = \"7.4\" ) ) ) ) ) class Movie(val genre: String, val titles:List\u003cTitle\u003e) class Title(val title:String, val year:String, val rating:String)  What happens if I attribute a binding to a variable that doesn‚Äôt exist? Bindings that refer to a non existent or invalid contexts cannot be updated and it will appear on the screen as they were typed (in case the received attribute is a string).\nFor example, if we use @{client.name} and the \"client\" context is not accessible (declared), this binding will be not replaced by any value. The same would happen if the ‚Äúclient‚Äù context doesn‚Äôt exist, but has a ‚Äúname‚Äù propriety.\nMultiples bindings in strings It‚Äôs possible to use more than one binding in a unique string and event mix statics texts with bindings. See how on the following example:\nExample: \"Hello @{person.name}. Your score is @{score.value}.\"\nAdding a support for bindings in your custom components In each system, the binding must be declared like:\n Android: All the attributes receive an expression that must be declared as Bind. iOS: The attributes that receives a binding must be declared asExpression to have the same Android‚Äôs effect. Web: It‚Äôs not necessary to deal with bindings in a special way, which means that nothing should be done on your components.  Examples for each operational system:\nAndroid iOS data class MyComponent( val text: Bind\u003cString\u003e ) : WidgetView() { override fun buildView(rootView: RootView): View { val view = MyView(rootView.getContext()) // To make bind works you have to call the observeBindChanges method  // passing a rootView and the attribute that has a bind  observeBindChanges(rootView, text) { view.setText(it) } return view } }  public struct MyComponent: Widget { public var widgetProperties: WidgetProperties public let text: Expression\u003cString\u003e public func toView(renderer: BeagleRenderer) -\u003e UIView { let textView = UITextView() // To make bind works you have to call the observeBindChanges method // passing a rootView and the attribute that has a bind renderer.observe(text, andUpdate: \\.text, in: textView) return textView } }  The way to refer an expression on Kotlin‚Äôs DSL must be like this:\nKotlin DSL  MyComponent( text = expressionOf(\"@{myContext.hello}\") )  However, in case you have to pass a hardcoded value, you must use this way:\nKotlin DSL  MyComponent( text = valueOf(\"hello\") )  üëâ See some examples in the Playground ","excerpt":" What is it? Context is a variable of any type, including a map that ‚Ä¶","ref":"/docs-beagle/docs/api/context/","title":"Context"},{"body":" O que √©? O Lazy Component √© usado para carregar de forma ass√≠ncrona algum componente do BFF.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     path String ‚úì A URL que realiza a requisi√ß√£o.   initialState ServerDrivenComponent ‚úì Componente server driven que √© apresentado enquanto uma requisi√ß√£o ass√≠ncrona est√° sendo feita.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:lazycomponent\", \"path\": \"/listview.json\", \"initialState\": { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Carregando conte√∫do, aguarde...\" } }  LazyComponent( path = \"/listview.json\", initialState = Text(\"Carregando conte√∫do, aguarde...\") )  üëâ Teste esse componente no Web Playground ","excerpt":" O que √©? O Lazy Component √© usado para carregar de forma ass√≠ncrona ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/lazy/","title":"Lazy"},{"body":" O componente de Layout pode ser definido a partir de 7 grupos de subcomponentes: Container, Horizontal, Page View, List View, Scroll View, Stack e Vertical.\nAbaixo, voc√™ encontra uma descri√ß√£o completa dos atributos que fazem parte de um Layout dentro de uma aplica√ß√£o mobile ou web.\n","excerpt":" O componente de Layout pode ser definido a partir de 7 grupos de ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/layout/","title":"Layout"},{"body":" What is it? The operations allow you to create application with more complex screens through your backend and with basic operations like addition, equals, etc. This way, the components don‚Äôt need this kind of logic inside them.\nHow to use it? The operations can be used when you want to modify the values of a component through logic and operations in a different moment from the one it received the components with the JSON.\nOn Beagle, you have some default operators and you can also create your own.\nSee below all the operators available on Beagle:\n","excerpt":" What is it? The operations allow you to create application with more ‚Ä¶","ref":"/docs-beagle/docs/api/context/operations/","title":"Operations"},{"body":" What are they?    Operators Example Action     sum ‚Äú@{sum(3,3)}‚Äù Addition operator for the elements type Int and Double.   subtract ‚Äú@{subtract(4,3)}‚Äù Subtraction operator for the elements type Int and Double.   multiply ‚Äú@{multiply(3,3)}‚Äù Multiplication operator for the elements type Int and Double.   divide ‚Äú@{divide(3,3)}‚Äù Division operator for the elements type Int and Double.    Example See an example below of a counter where two buttons increment and decrement, both with SetContext actions that modifies the context value that has an id counter, altering the value with addition and subtraction operations, increasing or decresing the value of 1 to the text value:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar( title = \"Operations\", showBackButton = true ), child = Container( context = ContextData(\"counter\", 2), children = listOf( Text(expressionOf(\"Sum of 2 + 1 = @{sum(2, 1)}\")), Text(expressionOf(\"Counter: @{counter}\")), Button( text = \"increment\", onPress = listOf( SetContext(\"counter\", \"@{sum(counter, 1)}\")) ), Button( text = \"decrement\", onPress = listOf( SetContext(\"counter\", \"@{subtract(counter, 1)}\")) ) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Sum of 2 + 1 = @{sum(2, 1)}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Counter: @{counter}\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"increment\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"counter\", \"value\" : \"@{sum(counter, 1)}\" } ] }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"decrement\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"counter\", \"value\" : \"@{subtract(counter, 1)}\" } ] } ], \"context\" : { \"id\" : \"counter\", \"value\" : 2 } } }  ","excerpt":" What are they?    Operators Example Action     sum ‚Äú@{sum(3,3)}‚Äù ‚Ä¶","ref":"/docs-beagle/docs/api/context/arithmetic-operator/","title":"Arithmetic operator"},{"body":" O que √©? O Container √© um componente respons√°vel por conter outros componentes dentro de si.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     children List \u003cServerDriven Component\u003e ‚úì Define a lista de componentes que fazem parte do container   context ContextData  √â o contexto contido por este Widget.   onInit List\u003cAction\u003e  Um par√¢metro que te possibilita definir uma lista de a√ß√µes a serem executadas assim que esse Widget seja exibido.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"@{myContext.value}\" } ], \"context\": { \"id\": \"myContext\", \"value\": \"Hello world!\" } }  Container( children = listOf( Text(text = \"@{myContext.value}\") ), context = ContextData( id = \"myContext\", value = \"Hello World!\" ) )  üëâ Teste esse componente no Web Playground‚Äã ","excerpt":" O que √©? O Container √© um componente respons√°vel por conter outros ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/layout/container/","title":"Container"},{"body":" O que √©? O componente ListView √© respons√°vel por definir uma lista de itens recicl√°veis nativamente. Esses itens podem ser quaisquer componentes server driven. O uso do ListView √© recomendado para situa√ß√µes onde h√° repeti√ß√£o de componentes, por√©m com dados diferentes.\nA partir da vers√£o 1.5.0 passamos a suportar o uso de contexto e reciclagem de celulas no ListView, com isso disponibilizamos duas formas de construir o componente. A vers√£o depreciada foi mantida somente para manter retrocompatibilidade, se poss√≠vel atualize para a nova vers√£o do componente para melhor desempenho.  A sua estrutura √© representada como mostrado abaixo:\nListView    Atributo Tipo Obrigat√≥rio Defini√ß√£o     direction ListDirection  Define o direcionamento em que os items da lista s√£o exibidos.   context ContextData  Define o contexto do componente.   onInit List\u003cAction\u003e  Lista de a√ß√µes a serem executadas assim que o componente √© exibido.   dataSource Bind\u003cList\u003cAny\u003e\u003e ‚úì Express√£o que aponta para uma lista de valores usados para popular o componete.   template ServerDrivenComponent ‚úì Representa cada celula na lista atrav√©s de um ServerDrivenComponent.   onScrollEnd List\u003cAction\u003e  Lista de a√ß√µes executadas quando a lista chega ao fim.   scrollEndThreshold Int  Define a porcentagem rolada da lista para disparar o onScrollEnd.   iteratorName String  √â o identificador do contexto de cada c√©lula.   key String  Aponta para um valor √∫nico presente em cada item do dataSource para ser usado como um sufixo nos ids dos componentes do template.    ListDirection √â um ENUM, cujos valores s√£o:\n   Valor Defini√ß√£o     VERTICAL Quando os items s√£o exibidos em LINHAS.   HORIZONTAL Quando os itens s√£o exibidos em COLUNAS.    Valor default √© ListDirection.VERTICAL  ListView Depreciado    Atributo Tipo Obrigat√≥rio Defini√ß√£o     children List\u003cServerDrivenComponent\u003e ‚úì \nDefine os itens da lista de visualiza√ß√£o. Eles podem ser configurados como uma lista de ServerDrivenComponents ou como views.    direction ListDirection   Define o direcionamento da lista de visualiza√ß√£o.    Como usar? ListView JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:listView\", \"direction\": \"VERTICAL\", \"dataSource\": [ { \"name\": \"Kelsier\", \"race\": \"Half-skaa\", \"planet\": \"Scadrial\", \"isMistborn\": true, \"age\": 38, \"sex\": \"male\" }, { \"name\": \"Vin\", \"race\": \"Half-skaa\", \"planet\": \"Scadrial\", \"isMistborn\": true, \"age\": 20, \"sex\": \"female\" }, { \"name\": \"TenSoon\", \"race\": \"Kandra\", \"planet\": \"Scadrial\", \"isMistborn\": false, \"age\": 40, \"sex\": \"male\" } ], \"template\": { \"_beagleComponent_\": \"beagle:container\", \"style\": { \"margin\": { \"bottom\": { \"value\": 20, \"type\": \"REAL\" } } }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Name: @{item.name}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Race: @{item.race}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Mistborn: @{item.isMistborn}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Planet: @{item.planet}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"sex: @{item.sex}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"age: @{item.age}\" } ] } }  ListView( dataSource = listOf( Person( name = \"Kelsier\", race = \"Half-skaa\", planet = \"Scadrial\", isMistborn = true, age = 38, sex = Sex.MALE ), Person( name = \"Vin\", race = \"Half-skaa\", planet = \"Scadrial\", isMistborn = true, age = 20, sex = Sex.FEMALE ), Person( name = \"TenSoon\", race = \"Kandra\", planet = \"Scadrial\", isMistborn = false, age = 40, sex = Sex.MALE ), ), template = Container( children = listOf( Text(\"Name: @{item.name}\"), Text(\"Race: @{item.race}\"), Text(\"Mistborn: @{item.isMistborn}\"), Text(\"Planet: @{item.planet}\"), Text(\"sex: @{item.sex}\"), Text(\"age: @{item.age}\"), ) ).applyStyle( Style( margin = EdgeValue(bottom = 20.unitReal()) ) ) )  üëâ Teste o ListView no Web Playground‚Äã ListView Depreciado JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:listView\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#FF0000\", \"alignment\": \"CENTER\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#00FF00\", \"alignment\": \"CENTER\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#0000FF\", \"alignment\": \"CENTER\" } ], \"direction\": \"HORIZONTAL\" }  ListView( direction = ListDirection.HORIZONTAL, children = listOf( Text( text = \"Beagle Text list\", textColor = \"#FF0000\", alignment = TextAlignment.CENTER ), Text( text = \"Beagle Text list\", textColor = \"#00FF00\", alignment = TextAlignment.CENTER ), Text( text = \"Beagle Text list\", textColor = \"#0000FF\", alignment = TextAlignment.CENTER ) ) )  üëâ Teste o ListView depreciado no Web Playground‚Äã ","excerpt":" O que √©? O componente ListView √© respons√°vel por definir uma lista de ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/layout/listview/","title":"Listview"},{"body":" What are they?    Operators Example Action     condition ‚Äú@{condition()}‚Äù Conditional operator that evaluates two elements and verifies which condition is true.   not ‚Äú@{not()}‚Äù negation operator that has as input only one value and its function is invert this value.   and ‚Äú@{and()}‚Äù Operator that receives two inputs and it has a TRUE value, if the two values of the operation inputs are TRUE, if not the result is FALSE.   or ‚Äú@{or()}‚Äù Operator that receives two inputs and it the result it a TRUE value. If only ONE of the two input values are TRUE, if not the result is FALSE.    Example Here is an example of a screen that uses two logical operation condition and or, if the result of the condition or is true, the text of the component text becomes true, if it is false it attibutes the value false to the text:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar(title = \"Operations\", showBackButton = true), child = Container( children = listOf( Text(text = \"The text in green bellow will show if the result of `TRUE OR FALSE\"), Text( expressionOf(\"@{condition(or(true, false), 'true', 'false')}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text in green bellow will show if the result of `TRUE OR FALSE\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(or(true, false), 'true', 'false')}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" What are they?    Operators Example Action     condition ‚Ä¶","ref":"/docs-beagle/docs/api/context/logic-operator/","title":"Logic operator"},{"body":" What are they?    Operators Example Action     gt\n(greater)\n \"@{gt(3,4)} Operator that receives two inputs and the result is true if the first value is greater than the second one.   gte\n(greater than or equal to)\n \"@{gte(3,4)}\" Operator that receives two inputs and the result is true if the first value is greater than or equal to the second one.   lt\n(less than)\n @{lt(3,4)}\" Operator that receives two inputs and the result is true if the first value is less than the second one.   lte\n(less then or equal to)\n \"@{lte(3,4)}\" Operator that receives two inputs and the result is true if the first value is less then or equal to the second one.   eq\n(Equal to)\n \"@{eq(4,4)}\" Operator that receives two inputs and the result is true if the two values are equal.    Example Here, the example is a screen that uses the comparison operation It, that verifies if the addition value of the counter is:\n If the result of the condition or is true, the text component Text becomes true; If it is false, it attributes the text the value false;  Kotlin JSON fun screen() = Screen( navigationBar = NavigationBar( title = \"Operations\", showBackButton = true ), child = Container( children = listOf( Text(text = \"The text bellow will show if 4 is below 5 or not\"), Text(expressionOf( \"@{condition(lt(4, 5), 'less then 5', 'greater then 5')}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text bellow will show if 4 is below 5 or not\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(lt(4, 5), 'less then 5', 'greater then 5')}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" What are they?    Operators Example Action     gt\n(greater) ‚Ä¶","ref":"/docs-beagle/docs/api/context/comparison-operator/","title":"Comparison operator"},{"body":" O que √©? O componente PageView √© um container especializado em apresentar p√°ginas que s√£o exibidas na horizontal e podem conter um indicador de p√°ginas. Essas p√°ginas podem ser qualquer objeto server-driven.\nO Page View se refere ao seu tamanho quando visualizado em dispositivos Mobile (Android e iOS). O tamanho dele √© determinado pelo elemento pai em que est√° contido, ou seja, a largura (width) e a altura (height) ser√° definida pelo componente pai.\nPor exemplo, um PageView pode ser declarado dentro de um Container e sua largura e altura s√£o respons√°veis por determinar o tamanho do Page View.\n A sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     children List\u003cServerDrivenComponent\u003e ‚úì \nDefine a lista de componentes visuais (server-driven) contidos naPageView.\n   context \u003cb\u003e\u003c/b\u003eContextData\u003cb\u003e\u003c/b\u003e  √â o contexto contido neste Widget   onPageChange List\u003cAction\u003e  Lista de a√ß√£o que √© executada quando a pagina selecionada √© alterada   currentPage Int  Identificador de qual pagina est√° selecionada   showArrow Boolean  Esse atributo √© especifico para plataforma web. Ele habilita setas para mudan√ßa de p√°gina.    Como usar? No exemplo abaixo segue um PageView contendo tr√™s p√°ginas onde cada uma delas tem um Text que √© definido por Contexto. Toda vez que h√° mudan√ßa de p√°gina o contexto √© redefinido.\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:pageView\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 1\", \"alignment\":\"CENTER\" }, { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 2\", \"alignment\":\"CENTER\" }, { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 3\", \"alignment\":\"CENTER\" } ], \"onPageChange\":[ { \"_beagleAction_\":\"beagle:setContext\", \"contextId\":\"context\", \"value\":\"@{onPageChange}\" } ], \"currentPage\":\"@{context}\" }, { \"_beagleComponent_\":\"beagle:pageIndicator\", \"selectedColor\":\"#000000\", \"unselectedColor\":\"#888888\", \"numberOfPages\":3, \"currentPage\":\"@{context}\" } ], \"context\":{ \"id\":\"context\", \"value\":0 } }  Container( children = listOf( PageView( children = (1..3).map { Text( text = \"Page $it\", alignment = TextAlignment.CENTER ) }, onPageChange = listOf(SetContext(\"context\", \"@{onPageChange}\")), currentPage = expressionOf(\"@{context}\") ), PageIndicator( numberOfPages = 3, selectedColor = BLACK, unselectedColor = LIGHT_GREY, currentPage = expressionOf(\"@{context}\") ) ), context = ContextData( id = \"context\", value = 0 ) )  üëâ Teste esse componente no Web Playground‚Äã ","excerpt":" O que √©? O componente PageView √© um container especializado em ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/layout/pageview/","title":"Pageview"},{"body":" O que √©? O PageIndicator √© um componente que tem como funcionalidade indicar a quantidade de p√°ginas e qual √© a atual do PageView.\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     selectedColor String ‚úì Valor em hexadecimal para representar a cor quando selecionado.   unselectedColor String ‚úì Valor em hexadecimal para representar a cor quando n√£o selecionado.   numberOfPages Int  Indica a quantidade de paginas.   currentPage Bind\u003cInt\u003e  Indica a p√°gina.    Como usar? Um exemplo completo de como usar o PageIndicator est√° em PageView.\nüëâ Teste esse componente no Web Playground‚Äã ","excerpt":" O que √©? O PageIndicator √© um componente que tem como funcionalidade ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/layout/pageindicator/","title":"Pageindicator"},{"body":" What are they?    Operators Example Action     concat ‚Äú@{concat(‚Äúcachorro‚Äù, ‚Äúquente‚Äù)}‚Äù Operator that concatenates the strings that are as input.   capitalize ‚Äú@{capitalize(brasil)}‚Äù Operator that changes the first string letter into a capital letter.   uppercase ‚Äú@{uppercase(brasil)}‚Äù Operator that changes all letter of a string into uppercases.   lowercase ‚Äú@{lowecase(BRASIL)}‚Äù Operator that changes all letters of a string into lowercases.   substr ‚Äú@{substr(brasil, 3)}‚Äù Operator that returns a substring of a input string. This operation may have 2 or 3 inputs, where the first parameter is the string and the second and third ones are the string limit.    Example This example, a screen has a text with the substring operation, which the sentence is ‚ÄòThe book is on the table‚Äô and the parameters is 4,11 determine the threshold of this substring, which it will turn the following string ‚Äòbook is on':\nKotlin JSON fun screen() = Screen(child = Container( children = listOf( Text(text = \"The text bellow is a substring of `The book is on the table`.\"), Text( expressionOf(\"@{substr('The book is on the table', 4, 11)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\") ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text bellow is a substring of `The book is on the table`.\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{substr('The book is on the table', 4, 11)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" What are they?    Operators Example Action     concat ‚Ä¶","ref":"/docs-beagle/docs/api/context/string-manipulation-operator/","title":"String manipulation operator"},{"body":" What are they?    Operadores Exemplo A√ß√£o     insert ‚Äú@{insert(array, 5)}‚Äù Operators that receives two inputs, where the first parameter is an array and the second is the element that you want to insert in this array.   remove ‚Äú@{remove(array, 1)}‚Äù Operators that receives two inputs, where the first parameter is an array and the second is the element that you want to remove this array.   removeIndex ‚Äú@{removeIndex(array, 2)}‚Äù Operators that receives two inputs, where the first parameter is an array and the second is the index that you want to remove this array.   contains ‚Äú@{contains(array, 3)}‚Äù Operators that receives two inputs, where the first parameter is an array and the second is the element that you want to verify if it contains in this array.    Example See the example of a screen where the a context was declared with numbersArray id with the values [0, 1, 2, 3, 4], this context is used in the removeIndex operation in the text component text, where it removes the element of index 2.\nKotlin JSON fun screen() = Screen(child = Container( context = ContextData(id = \"numbersArray\", value = arrayOf(0,1,2,3,4)), children = listOf( Text(text = \"Array was [0, 1, 2, 3, 4] and after removing index 2 now is: \"), Text( expressionOf(\"@{removeIndex(numbersArray, 2)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Array was [0, 1, 2, 3, 4] and after removing index 2 now is: \" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{removeIndex(numbersArray, 2)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ], \"context\" : { \"id\" : \"numbersArray\", \"value\" : [ 0, 1, 2, 3, 4 ] } } }  ","excerpt":" What are they?    Operadores Exemplo A√ß√£o     insert ‚Äú@{insert(array, ‚Ä¶","ref":"/docs-beagle/docs/api/context/arrays-manipulation-operator/","title":"Arrays manipulation operator"},{"body":" O que √©? O componente Scroll View √© um container especializado que exibe os componentes em visualiza√ß√£o por scroll no layout.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo  Tipo  Obrigat√≥rio Defini√ß√£o      children List \u003cServerDriven Component\u003e\n ‚úì Define a lista de atributos a ser exibida na visualiza√ß√£o do layout. \n    scrollDirection ScrollAxis  Define a dire√ß√£o da rolagem em scroll na tela.\nA dire√ß√£o do scroll pode ser modificada de acordo com a classe ScrollAxis definida logo abaixo. Por default, tem o valor deVERTICAL.\n   scrollBarEnabled Boolean  Determina se a barra de rolagem vai ser exibida ou n√£o. Essa configura√ß√£o √© verdadeira por default.   context ContextData   Dita um contexto para a scroll view.    ScrollAxis √â um ENUM, cujos valores s√£o:\n   Valor Defini√ß√£o     VERTICAL Para definir o scroll como vertical.   HORIZONTAL Para definir o scroll como horizontal.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"style\": { \"flex\": { \"alignItems\": \"CENTER\", \"justifyContent\": \"CENTER\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:scrollView\", \"children\": [ { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\" } }, { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/LCKYdCT/742px-Example-en-svg.png\" } } ] } ] }  ScrollView(scrollDirection = ScrollAxis.VERTICAL, children = listOf( Text(\"Vertical ScrollView\"), Text(\"Vertical ScrollView\"), Text(\"Vertical ScrollView\")))  üëâ Teste esse componente no Web Playground‚Äã ","excerpt":" O que √©? O componente Scroll View √© um container especializado que ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/layout/scrollview/","title":"Scrollview"},{"body":" What are they?    Operadores Exemplo A√ß√£o     isNull ‚Äú@{isNull(context)}‚Äù Operator that verifies if the parameter is null.   isEmpty ‚Äú@{isEmpty(\")}‚Äù Operator that receives an input and verify if it is empty.   length ‚Äú@{length(tamanho)}‚Äù Operator that receives an input and returns its size.    Example A context with numbersArray id that has [0, 1, 2, 3, 4] as value and the operation length was used in one component Text to get the size of this array, see below:\nKotlin JSON fun screen() = Screen(child = Container( context = ContextData(id = \"numbersArray\", value = arrayOf(0,1,2,3,4)), children = listOf( Text(text = \"Array [0, 1, 2, 3, 4] has size: \"), Text( expressionOf(\"@{length(numbersArray)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Array [0, 1, 2, 3, 4] has size: \" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{length(numbersArray)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ], \"context\" : { \"id\" : \"numbersArray\", \"value\" : [ 0, 1, 2, 3, 4 ] } } }  ","excerpt":" What are they?    Operadores Exemplo A√ß√£o     isNull ‚Ä¶","ref":"/docs-beagle/docs/api/context/other-operators/","title":"Other operators"},{"body":" O form (Formul√°rio) √© estruturado como um grupos de componentes que definem como as informa√ß√µes ser√£o submetidas e validadas.\nAbaixo voc√™ encontra uma descri√ß√£o completa dos atributos que fazem parte de um Formul√°rio dentro de uma aplica√ß√£o mobile ou web.\n","excerpt":" O form (Formul√°rio) √© estruturado como um grupos de componentes que ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/formul%C3%A1rios/","title":"Formul√°rios"},{"body":" After you‚Äôve seen it is possible to make addition, subtraction and other operations using context, you can also create your own operation in the platform you want:\niOS  The registration of an operation on iOS is through OperationsProviderprotocol, see below:\npublic protocol OperationsProvider { func register(operationId: String, handler: @escaping OperationHandler) func evaluate(with operation: Operation, in view: UIView) -\u003e DynamicObject } To register your customized operation, you have to do two things:\n Provide an id for this operation; Provide to it an action that it will happen through a closure of the type OperationHandler.  The OperationHandler is a typealias of a code block that returns DynamicObject through a parameter of [DynamicObject] type.\npublic typealias OperationHandler = (_ parameters: [DynamicObject]) -\u003e DynamicObject Now, to register your new operation you have to use BeagleDependencies, where you can access the OperationsProvider, which has the register function.\nlet dependencies = BeagleDependencies() dependencies.operationsProvider.register(operationId: \"isValidCpf\") { parameters in let anyParameters = parameters.map { $0.asAny() } if let intParameters = anyParameters.first as? Int { let stringParameters = String(intParameters) return .bool(stringParameters.isValidCPF) } else if let stringParameters = anyParameters.first as? String { return .bool(stringParameters.isValidCPF) } return nil } Done! Your operation can be used now!\n Example See below an example using the isvalidCpf operation that was created above, where the text component Text will vary according the verification result, if the CPF is valid or not:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar(title = \"Custom operation\", showBackButton = true), child = Container( context = ContextData(\"cpf\", \"00000000000\"), children = listOf( Button(\"CPF atual: @{cpf}\", onPress = listOf( SetContext( contextId = \"cpf\", value = \"42249625000\" ) )), Text(text = \"@{condition(isValidCpf(cpf), 'cpf is valid', 'cpf is not valid')}\") ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Custom operation\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"CPF atual: @{cpf}\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"cpf\", \"value\" : \"42249625000\" } ] }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(isValidCpf(cpf), 'cpf is valid', 'cpf is not valid')}\" } ], \"context\" : { \"id\" : \"cpf\", \"value\" : \"00000000000\" } } }  ","excerpt":" After you‚Äôve seen it is possible to make addition, subtraction and ‚Ä¶","ref":"/docs-beagle/docs/api/context/how-to-register-a-new-operation/","title":"How to register a new operation"},{"body":" Esse componente foi depreciado! √â recomendado usar o Simple Form.  O componente representa uma maneira de compor entradas do usu√°rio e enviar esses valores ao seu backend.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     \nonSubmit\n List \u003cAction\u003e  Array de a√ß√µes que esse bot√£o pode disparar quando o formul√°rio √© enviado.   child ServerDrivenComponent  ‚úì Define a lista de componentes visuais (server-driven).   group String  Usado somente para formul√°rios multi p√°gina, o qual √© um identificador para manipular os dados.   additionalData Map\u003cString, String\u003e  Valores sem valida√ß√£o que o usu√°rio n√£o insere.   shouldStoreFields Boolean  Indica se deve salvar o additionalData.    ","excerpt":" Esse componente foi depreciado! √â recomendado usar o Simple Form.  O ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/formul%C3%A1rios/form/","title":"Form"},{"body":" What is it? A Global Context is a variable that can assume as value of any type of variable, like a map defines a subset of key/value or complex JSONs objects that defines object trees.\nIt works exactly like the Context, however in a global scope, meaning that it will exists while the application is still running (even on the background), which allows it to be accessed from any application point, being a component or an action linked to a component or even programmatically.\nHow can you access it? It can be accessed through an expression in a declarative page, for example, \"@{global.user}\" or programmatically from a GlobalContext.get() object\nThis way, it is possible to share information between the native part of the application, the server-driven part and between different server-driven screens.  How to use it? It is important to mention some information to use the Global Context:\n Global context Global ins an object and is type is __ContextData Global context can have as a VALUE, a complex JSON that can contain an object tree in it. It is a Singleton.  By default the global context ID will be always ‚Äòglobal‚Äô.  How to create a Global Context? Global context is created with the application and it is defined internally on Beagle as an object with ContextData type, that it will store any defined information on a global context.\nHow to define a Global Context? A context to be global, it can be defined in two ways:\n From a declarative component (using the SetContextaction) or Programmatically, using the set() function from the GlobalContext object.  1. Using SetContext It is possible to define or modify a global context from the SetContext action. You have to identify a global context using an ID = \"global\" in the contextId property, as you can see below:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\":\"@{global.myValue}\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Open Modal\", \"onPress\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"global\", \"path\": \"myValue\", \"value\": \"Context has changed\" } ] } ] }  Container( children = listOf( Text(text = \"@{global.myValue}\"), Button(text = \"Open Modal\", onPress = listOf( SetContext( contextId = \"global\", path = \"myValue\", value = \"Context has changed\" ) ) ) ) )  When defining a value of any context, it is important to analyse its structure. If any value is passed in the path property, the value it will be defined in the object‚Äôs roots, meaning that any other attribution done in the context will overwrite any information without a path on the object‚Äôs root.  On the example above, the JSON object created on the context‚Äôs root it would be:\n{\"myValue\" : \"Context has changed\"} 2. Using GlobalContext.set() Global context can also be defined through a set method, that can be called from the GlobalContext object.\nFor this, it is used:\nGlobalContext.set(value, path)\n   Parameters Type Required Definition     value Any ‚úì It represents an information that can be any kind, for example, other JSONs objects, an array or any other object.   path String  It represents the path that it will contain this information, like the example above, the path used was \"myValue\". The path parameter is not required, and when omitted it will define the value informed in the object‚Äôs root, overwriting any other information.    To define a global context, just like the example in this section, use the following command:\nAndroid Web iOS GlobalContext.set(\"Context has changed\", \"myValue\")  On the web global context is one of BeagleService attributes, available by library beagle-angular and beagle-react.\nNa web, o contexto global √© um dos atributos do BeagleService, que a lib do beagle-angular e beagle-react disponibilizam.\nAngular:\nTo use the global context in any component of your application, you have to inject BeagleProvider in your components' constructor and use the getBeagleUIService function to have access to beagleService's object, access the globalContext and the globalText function you want. See below the code on how to use the set function:\nimport { BeagleProvider } from '@zup-it/beagle-angular'; constructor(private beagleProvider: BeagleProvider) ... const beagleService = this.beagleProvider.getBeagleUIService() beagleService?.globalContext.set(value, path) React:\nTo use global context in a React application, use the available context by beagle-react through useContext of the React and to have access to beagleService and through it access the globalContext and the function you want. See below the set function being used:\nimport context from '@zup-it/beagle-react/provider' ... const beagleService = useContext(context) beagleService?.globalContext.set(value, path)  In iOS the Global Context is a Beagle Dependencies attribute.\nTo use it in anywhere of your application you must to use the BeagleDependencies instance of your project as the example below:\ndependencies.globalContext.setValue(value: \"Context has changed\", path: \"myValue\") The context value is a DynamicObject, therefore it can take on any kind of value.\n  Recovering a Global Context Global context can be recovered in two ways:\n Using expressions (just like any other context) or get function, called from the GlobalContext object.  1. Using the ‚Äú@{global}‚Äù expression To recover the value assigned to a global context, you have to use the ‚Äú@{global}‚Äù expression.\nThe example on this section, the global context value was assigned using a \"myValue\" path, in order to recover it, you have to use the expression \"@{global.myValue}\" that it will return a ‚ÄúContext has changed‚Äù string.\n If you only use the \"@{global}\" expression, the value will return a whole JSON object:  {‚ÄúmyValue‚Äù : ‚ÄúContext has changed‚Äù}    This expression are observed by the context and are updated when the context changes, however they need to be in a declarative screen.  2. Using a GlobalContext.get() Global context also can be recovered through a get method and it can be called from the GlobalContext object.\nFor this, it is used:\nGlobalContext.get(path)\n   Parameters Type Definition     path String Represents the path that it will contain the information, on the example above, the path used was \"myValue\". The path parameter is optional and if every value is passed, the global context will be returned.    Consider the previous example, to recover a Global context that is in the ‚ÄúmyValue‚Äù path, use the following command:\nAndroid Web iOS GlobalContext.get(\"myValue\")  The example above you could see all configuration to use set. The config to get is the same, however you have to change the globalContext method that it will be access:\nbeagleService?.globalContext.get(\"myValue\")  As the set method it is necessary to use the BeagleDependencies to call any Global Context method, follow the example below:\ndependencies.globalContext.get(path: \"myValue\")   The same way when using GlobalContext.get() without a path parameter, this method will return a whole JSON object -\u003e {\"myValue\" : \"Context has changed\"}  Removing a Global Context Global context can only be destroyed with the application closing, and even if it is empty, it can be called anywhere in the application, because it ‚Äò‚Äòexists‚Äô‚Äô while the application ‚Äò‚Äòexists‚Äô‚Äô.\nHowever, it can be reseted or it can have parts of its structure (objects inside the JSON object that represents the global context) removed, modifying the object‚Äôs structure.\nUsing GlobalContext.clear() Global context can be deleted through clear method that can be called from the GlobalContext object.\nIt is used:\nGlobalContext.clear(path)\n   Parameters Type Definition     path String Optional. Represents the path you want to remove.    1. Removing all Global Context values To remove Global context value as a whole, cleaning it, you have to use the clear command without informing a path. See below:\nAndroid Web iOS GlobalContext.clear()  Remember that in the web the global context access is always made over the BeagleService\nbeagleService?.globalContext.clear()  Remember that in the iOS the global context access is made over the BeagleDependencies\ndependencies.globalContext.clear()  This way, the global context VALUE it will be completely erased and it will have an empty value (\"\"), if called from its GlobalContext.get() function.\n2. Removing a Global Context attribute/property Imagine, for example, a global context that has two properties, like the following ones:\nProperty 1 Property 2  GlobalContext.set(path = \"myValue1\", value = \"My Context Value1\") GlobalContext.set(path = \"myValue2\", value = \"My Context Value2\")   beagleService?.globalContext.set(\"My Context Value1\", \"myValue1\") beagleService?.globalContext.set(\"My Context Value2\", \"myValue1\")  This global context is built by Beagle as a JSON object, like this:\n{ \"myValue1\":\"My Context Value1\", \"myValue2\":\"My Context Value2\" } Using the command:\nAndroid Web iOS GlobalContext.clear(\"myValue1\")  beagleService?.globalContext.clear(\"myValue1\")  dependencies.globalContext.clear(myValue1\")  The property represented by path ‚ÄúmyValue1‚Äù will be completly removed from the glova context, that it will be:\n{ \"myValue2\":\"My Context Value2\" } ","excerpt":" What is it? A Global Context is a variable that can assume as value ‚Ä¶","ref":"/docs-beagle/docs/api/global-context/","title":"Global Context"},{"body":" O componente validator √© uma interface que informa ao formul√°rio quando habilitar o bot√£o de FormSubmit. Ele tem como base o conceito de observability, no qual o FormInput ir√° validar as informa√ß√µes submetidas e, ent√£o, envi√°-las ao validator.\nExistem duas maneiras de usar o Form Validator:\n Clicando no FormSubmit Chamando pelo m√©todo notifyObservers dentro do FormInput.  Aten√ß√£o: ``Validator ‚â† FormValidation.\nApesar dos nomes parecidos, √© importante deixar claro que o Validator √© diferente do FormValidation. Isso porque o primeiro autentica o formul√°rio preenchido, enquanto que o segundo retorna mensagens de erro em caso de falha nas informa√ß√µes do form.\n ","excerpt":" O componente validator √© uma interface que informa ao formul√°rio ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/formul%C3%A1rios/validator/","title":"Validator"},{"body":" What are events? Events are anything that can trigger actions on Beagle (Beagle Actions). In the JSON, every key is associated to a Beagle Action that represents an event.\nSee some events example:\n onPress onError onFocus onChange  An event can be part of the component contract or a Beagle action. Abutton, for example, it is a component onPress is an event that it is part of its contract. An action sendRequest, it‚Äôs an example of action where the events ‚ÄúonSuccess‚Äù, ‚ÄúonError‚Äù and ‚ÄúonFinish‚Äù are part of the contract.\nHow to use it? See the example with the event onPress button:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click to show message\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Sou um alert\", \"message\" : \"Hello Beagle\" } ] }  Button( text = \"Click to show message\", onPress = listOf( Alert( title = \"I'm an alert\", message = \"Hello Beagle\" ) ) )  The example above, associates the action ‚Äúbeagle:alert‚Äù to the event onPress of the beagle:button component. When you bress the button where the title is ‚ÄúClick to show message‚Äù, a message will be shown on the screen with the text ‚ÄúHello World!‚Äù.\nEvery event in any component or action can be associated with any Beagle Action. An alert action was used in the previous example, but any other can be used. To make a request when clicking the button, the action ‚Äúbeagle:sendRequest‚Äù could be used. For more information about all available actions, access here.\n","excerpt":" What are events? Events are anything that can trigger actions on ‚Ä¶","ref":"/docs-beagle/docs/api/events/","title":"Events"},{"body":" O que √©? OsimpleForm √© respons√°vel por renderizar um formul√°rio em tela.\nA sua estrutura √© representada como mostrado abaixo:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     onSubmit List \u003cAction\u003e ‚úì Array de a√ß√µes que esse bot√£o pode disparar quando um formul√°rio √© enviado   children List\u003cServerDrivenComponent\u003e ‚úì Define a lista de componentes visuais que compoe o formul√°rio (server-driven)   context ContextData  Adiciona um contexto para o simple form    Como usar? Ao criar um formul√°rio √© importante entender dois passos respectivamente\n A rela√ß√£o e atualiza√ß√£o entre os campos E o que acontece quando o but√£o Submit √© presionado.  Atualizando os campos O componente TextInput √© o campo em que o usuario ou o sistema preencher√° com alguma informa√ß√£o, e √© importante conhecer seus atributos para melhor utiliza-lo. Aqui utilizaremos um de seus elementos , que √© a fun√ß√£o onChange.\nPara mais informa√ß√µes sobre esse componente v√° at√© os detalhes do TextInput.  OnChange Essa fun√ß√£o √© parte do componente Text Input e observa as modifica√ß√µes feitas dentro do seu campo, ou seja, sempre que o valor for modificado, algo for digitado, apagado, etc, essa fun√ß√£o √© chamada e ativa uma lista de outras a√ß√µes para acontecer sempre que o valor mudar. √â nessa lista que adicionamos uma a√ß√£o SetContext para definir o valor do Contexto do formul√°rio e atualizar os valores que s√£o mostrados no campo.\nVeja abaixo como implementamos o nosso SimpleForm\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:simpleForm\", \"context\":{ \"id\":\"myContext\", \"value\":\"\" }, \"onSubmit\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"Data submited\", \"message\":\"The password is @{myContext}\" } ], \"children\":[ { \"_beagleComponent_\":\"beagle:textInput\", \"value\":\"@{myContext}\", \"placeholder\":\"Type in your password\", \"onChange\":[ { \"_beagleAction_\":\"beagle:setContext\", \"contextId\":\"myContext\", \"value\":\"@{onChange.value}\" } ] }, { \"_beagleComponent_\":\"beagle:button\", \"text\":\"Click to Submit\", \"onPress\":[ { \"_beagleAction_\":\"beagle:submitForm\" } ] } ] }  SimpleForm( context = ContextData(id = \"myContext\", value = \"\"), children = listOf( TextInput( value = \"@{myContext}\", placeholder = \"Type in your password\", onChange = listOf( SetContext( contextId = \"myContext\", value = \"@{onChange.value}\" ) ) ), Button(text = \"Click to Submit\", onPress = listOf(SubmitForm())) ), onSubmit = listOf( Alert( title = \"Data submited\", message = \"The password is \" + \"@{myContext}\" ) ) )  onSubmit √â uma fun√ß√£o do SimpleForm que executa uma lista de a√ß√µes. Ele √© cho quando o formu√°rio for submetido\nPara submeter um formul√°rio √© preciso utilizar a a√ß√£o SubmitForm e para chama-la basta somente implementa-la em um Bot√£o que seja parte do SimpleForm, ou seja, que esteja em sua lista de filhos.\nAo clicar nesse bot√£o, o onSubmit √© ativados e a lista de a√ß√µes ser√° executada. √â essa lista de a√ß√µes que definir√° o que deve acontecer com as informa√ß√µes so formulario, se ser√£o enviadas para um backend (atrav√©s da a√ß√£o sendRequest), etc\nüëâ Teste esse componente no Web Playground ","excerpt":" O que √©? OsimpleForm √© respons√°vel por renderizar um formul√°rio em ‚Ä¶","ref":"/docs-beagle/pt/docs/api/componentes/formul%C3%A1rios/simple-form/","title":"Simple Form"},{"body":" What is it? Your screen has attributes and components that can be used and configured. On the table below, we listed the main characteristics from each of these attributes.\n   Attribute Type Required Definition     identifier String  Attribute that globally identifies a screen in your application so you can attributes actions for it.   safe area Safe Area  Specifies a screen‚Äôs component position.   navigation bar Navigation Bar  Allows action/navigation‚Äôs bar on the screen.   child Server-Driven Component ‚úì Define screen‚Äôs elements. It can be any visual component that extends toServerDrivenComponent.   style Style  Provide visual customization options to the screen.   screen analytics event Screen Event  Configure analytics elements to your screen.   context ContextData  Screen‚Äôs context.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Beagle Screen\", \"showBackButton\" : true, \"navigationBarItems\" : [ { \"_beagleComponent_\" : \"beagle:navigationBarItem\", \"text\" : \"\", \"image\" : { \"_beagleImagePath_\" : \"local\", \"mobileId\" : \"informationImage\" }, \"action\" : { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Screen\", \"message\" : \"Some message\", \"labelOk\" : \"OK\" } } ] }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Some text\" } ] } }  Screen( navigationBar = NavigationBar( title = \"Beagle Screen\", showBackButton = true, navigationBarItems = listOf( NavigationBarItem( text = \"\", image = Local.justMobile(\"informationImage\"), action = Alert( title = \"Screen\", message = \"Some message\", labelOk = \"OK\" ) ) ) ), child = Container( children = listOf( Text(\"Some text\") ) ) )  üëâ Test this example in the Web Playground ","excerpt":" What is it? Your screen has attributes and components that can be ‚Ä¶","ref":"/docs-beagle/docs/api/screen/","title":"Screen"},{"body":" O que √©? O contexto √© uma vari√°vel de qualquer tipo, incluindo o mapa que define um conjunto de pares de chaves/valores. Por meio de bindings, o valor do contexto pode ser acessado por qualquer componente ou a√ß√£o do seu escopo.\nA tabela abaixo demonstra os principais atributos do contexto:\n   Atributo Tipo Obrigatoriedade Defini√ß√£o     id String ‚úì Identificador do contexto   value Any ‚úì Valor do contexto    No caso do contexto id, √© importante que ele tenha apenas letras, n√∫meros e o caractere ‚Äú_‚Äù e deve ser √öNICO na tela.  Quando usar? De modo geral, o contexto pode ser usado quando voc√™ quer preencher valores em um momento diferente daquele em que recebeu os componentes com o JSON.\nNo exemplo abaixo, voc√™ pode ver o contexto com dados de um usu√°rio e sendo mostrados algumas dessas informa√ß√µes em um Text :\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"myData\", \"value\": { \"id\": \"0000\", \"name\": \"User\", \"age\": \"18\" }, }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"value\": \"Name: @{myData.name}\" }, { \"_beagleComponent_\": \"beagle:text\", \"value\": \"Age: @{myData.age}\" } ] }  Container( context = ContextData( id = \"myData\", value = User( id = \"0000\" name = \"User\", age = \"18\" ) ), children = listOf( Text(\"Name: @{myData.name}\"), Text(\"Age: @{myData.age}\") ) )  Perceba que o contexto foi declarado e seus valores foram definidos e usados para preencher os textos, por√©m √© poss√≠vel definir esses valores depois usando o m√©todo SetContext() .\nDessa forma, voc√™ pode preencher os componentes com dados que ainda n√£o estavam no JSON.\nO contexto s√≥ √© √∫til se o valor for acessado em qualquer parte do JSON. Para isso acontecer, voc√™ precisa usar o bindings.  Como usar? H√° duas formas para usar contexto: contexto expl√≠cito e impl√≠cito. A principal diferen√ßa entre eles √© o escopo do contexto, que pode (ou n√£o) ser definido dentro do JSON ou da estrutura declarativa que estiver usando.\nEscopo do contexto O escopo de um contexto √© o componente no qual seus descendentes s√£o definidos. Isso torna poss√≠vel acessar o contexto declarado em uma outra branch da √°rvore.\nUm contexto pode ser estabelecido em qualquer componente do Beagle que implementa o ContextComponent, que √© a propriedade do context que pode especificar os seguintes componentes:\n Container Screen ScrollView PageView TabView Custom Components, que implementa o ContextComponent  1. Contexto expl√≠cito Quando h√° um escopo definido para o contexto dentro do seu JSON ou da sua estrutura declarativa.\nVeja o exemplo abaixo de como funciona:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{myText}\" } ], \"context\" : { \"id\" : \"myText\", \"value\" : \"Hello Beagle\" } }  Container( context = ContextData( id = \"myData\", value = User( id = \"0000\" name = \"User\", age = \"18\" ) ), children = listOf( Text(\"Name: @{myData.name}\"), Text(\"Age: @{myData.age}\") ) )  Perceba que o contexto foi declarado e seus valores foram definidos e usados para preencher os textos, por√©m √© poss√≠vel definir depois esses valores usando o m√©todo SetContext() . Dessa forma, voc√™ pode preencher os componentes com dados que ainda n√£o estavam no JSON.\n2. Contextos impl√≠citos Quando n√£o h√° um escopo de contexto definido dentro do JSON ou da estrutura declarativa da sua tela, mas que podem ser acessados por bindings.\nIsso significa que esse tipo de contexto √© criado por meio de eventos.\nAl√©m disso, o escopo desse tipo de contexto √© definido apenas por uma action ou um conjunto de a√ß√µes relacionados ao evento criado no contexto.\n Em alguns casos, √© necess√°rio acessar uma informa√ß√£o espec√≠fica sobre um evento que engatilhou uma a√ß√£o. Um exemplo comum √© o onChange event, que √© lan√ßado por qualquer componente e permite a entrada de dados.\nCaso mude o valor de uma entrada de um componente e as a√ß√µes a serem lan√ßadas dependem desse valor, √© fundamental que voc√™ tenha acesso ao novo valor do componente.\nOutra caracter√≠stica do contexto impl√≠cito √© que ele sempre possui um id igual ao nome do evento criado. Se, por exemplo, o evento √© o onCharge, o escopo do contexto ter√° id onChange e binding ficar√° dessa forma:{ value: newValue }, no qual newValue √© o campo que voc√™ pode incluir um novo valor a ser usado.\nVeja o exemplo abaixo com o evento onBlur , que funciona exatamente como o onChange, mas faz a requisi√ß√£o quando o input do componente perde o foco:\n{ \"_beagleComponent_\": \"beagle:textinput\", \"label\": \"CEP\", \"onBlur\": [ { \"_beagleAction_\": \"beagle:sendRequest\", \"url\": \"https://viacep.com.br/ws/@{onBlur.value}/json\", \"method\": \"GET\" } ] } Apesar do contexto onBlur n√£o ter sido declarado no exemplo acima, voc√™ consegue us√°-lo porque ele foi criado de uma maneira impl√≠cita pelo evento onBlur.\nO que acontece √© que o JSON define a view onde o foco se perdeu no campo de CEP e a a√ß√£o √© rodada para procurar o endere√ßo com base no valor digitado. O resultado da requisi√ß√£o pode ser usado para definir o valor de outros campos no formul√°rio de endere√ßo.\nVoc√™ pode conferir um exemplo de uso de contexto impl√≠cito no Beagle Web no Beagle Playground.  Exemplos de eventos criados com contexto impl√≠cito:\n onChange onFocus onBlur onSuccess onError onFinish  Os tr√™s primeiros eventos s√£o parte do contrato do componente beagle:textinput enquanto os tr√™s √∫ltimos s√£o parte da a√ß√£o beagle:sendRequest .\nBinding O binding √© a string em um formato especial, que identifica o valor dentro de um contexto. Sem ele, n√£o √© poss√≠vel criar contextos, sejam eles impl√≠citos ou expl√≠citos.\nDurante o processo de renderiza√ß√£o do Beagle, bindings podem ser substitu√≠dos pelos valores que s√£o referenciados a ele.\nUm binding √© identificado com o prefixo**@{** e o sufixo **}**. Isso significa que tudo entre esses s√≠mbolos serve como uma express√£o do contexto, que deve ser substitu√≠do quando voc√™ renderizar a tela.\nVeja o exemplo abaixo de como funciona:\nJSON kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{myText}\" } ], \"context\" : { \"id\" : \"myText\", \"value\" : \"Hello Beagle\" } }  Container( children = listOf( Text(\"@{myText}\") ), context = ContextData( id = \"myText\", value = \"Hello Beagle\" ) )  Para acessar o texto ‚ÄúHello Beagle‚Äù por meio de bindings, √© preciso especificar o id do contexto: @{myText}.\nNo exemplo acima, o valor do contexto √© uma simples string, mas voc√™ pode ver nos t√≥picos a seguir como acessar valores em contextos que s√£o mapas ou arrays.\nTipos de Bindings Binding multi-valorados (key/value maps) √â o tipo de binding no qual o valor do contexto ser√°, geralmente, uma chave/valor de um map (key/value map).\nNesses casos, os bindings devem ser usados para acessar subestruturas. Como acontece na maior parte de linguagens de programa√ß√£o, o Beagle usa pontos para fazer esse tipo de acesso, como voc√™ pode ver no exemplo abaixo:\n Para acessar o CPF, use o binding @{user.cpf} ; Para acessar o n√∫mero de telefone, use o binding @{user.phoneNumber.cellphone}.  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{user.phoneNumber.cellphone}\" } ], \"context\" : { \"id\" : \"user\", \"value\" : { \"cpf\" : \"014.225.235-12\", \"phoneNumber\" : { \"cellphone\" : \"(34) 98856-8563\", \"telephone\" : \"(34) 3214-5588\" } } } }  No Kotlin √© necessario que se crie algumas classes para gerenciar os contextos multivalorados\nContainer( children = listOf( Text(\"@{user.phoneNumber.cellphone}\") ), context = ContextData( id = \"user\", value = User( cpf = \"014.225.235-12\", phoneNumber = PhoneNumber( cellphone = \"(34) 98856-8563\", telephone = \"(34) 3214-5588\" ) ) ) ) data class User(val cpf: String, val phoneNumber:PhoneNumber) data class PhoneNumber(val cellphone:String, val telephone:String)  Binding com vetores (arrays) √â o tipo de binding no qual o valor do contexto ser√°, geralmente, vetores (arrays).\nSe um vetor √© usado no valor do contexto para acessar uma posi√ß√£o especifica, voc√™ deve usar o caractere [ e ] quando estiver construindo um binding.\nVeja como no exemplo abaixo:\nPara acessar o t√≠tulo do segundo filme (‚ÄúContact‚Äù), use o binding @{movies.titles[1].title}.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{movies.titles[1].title}\" } ], \"context\" : { \"id\" : \"movies\", \"value\" : { \"genre\" : \"sci-fi\", \"titles\" : [ { \"title\" : \"Inception\", \"year\" : \"2010\", \"rating\" : \"8.8\" }, { \"title\" : \"Contact\", \"year\" : \"1997\", \"rating\" : \"7.4\" } ] } } }  No Kotlin √© necess√°rio que se crie algumas classes para gerenciar os contextos multi-valorados\nContainer( children = listOf( Text(\"@{movies.titles[1].title}\") ), context = ContextData( id = \"movies\", value = Movie( genre = \"sci-fi\", titles = listOf( Title( title = \"Inception\", year = \"2010\", rating = \"8.8\" ), Title( title = \"Contact\", year = \"1997\", rating = \"7.4\" ) ) ) ) ) class Movie(val genre: String, val titles:List\u003cTitle\u003e) class Title(val title:String, val year:String, val rating:String)  O que acontece se eu atribuir um binding a uma vari√°vel que n√£o existe? Bindings que se referem a contextos n√£o existentes ou inv√°lidos n√£o podem ser atualizados e ir√£o aparecer na tela da mesma forma que a string foi definida literalmente (no caso, se o atributo recebido √© uma string).\nPor exemplo, se voc√™ usar @{client.name} e o \"client\" o contexto n√£o √© acess√≠vel (declarado), se o binding n√£o for substitu√≠do por nenhum valor. O mesmo aconteceria se o contexto ‚Äúclient‚Äù n√£o existisse, mas o tem a propriedade ‚Äúname‚Äù.\nBindings m√∫ltiplos em strings √â poss√≠vel usar mais de um binding em uma √∫nica string e eventos est√°ticos misturados com bindings.\nVeja como no exemplo abaixo:\nExemplo: \"Hello @{person.name}. Your score is @{score.value}.\"\nAdicionando suporte para bindings em componentes customizados Em cada sistema, o binding deve ser declarado de uma forma:\n Android: Todos os atributos recebem uma express√£o que deve ser declarada como Bind. iOS: Os atributos que recebem um binding devem ser declarados como Expression para fazer o mesmo efeito que no Android. Web: N√£o √© necess√°rio lidar com bindings de uma maneira especial, o que significa que nada deve ser feito em seus componentes.  Exemplos de cada sistema operacional:\nAndroid iOS data class MyComponent( val text: Bind\u003cString\u003e ) : WidgetView() { override fun buildView(rootView: RootView): View { val view = MyView(rootView.getContext()) // To make bind works you have to call the observeBindChanges method  // passing a rootView and the attribute that has a bind  observeBindChanges(rootView, text) { view.setText(it) } return view } }  public struct MyComponent: Widget { public var widgetProperties: WidgetProperties public let text: Expression\u003cString\u003e public func toView(renderer: BeagleRenderer) -\u003e UIView { let textView = UITextView() // To make bind works you have to call the observeBindChanges method // passing a rootView and the attribute that has a bind renderer.observe(text, andUpdate: \\.text, in: textView) return textView } }  A forma de referenciar uma express√£o em Kotlin DSL √©:\nKotlin DSL  MyComponent( text = expressionOf(\"@{myContext.hello}\") )  No entanto, caso voc√™ passe o valor hardcoded, voc√™ deve fazer dessa forma:\nKotlin DSL  MyComponent( text = valueOf(\"hello\") )  üëâ Veja alguns exemplos no Playground ","excerpt":" O que √©? O contexto √© uma vari√°vel de qualquer tipo, incluindo o mapa ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/","title":"Contexto"},{"body":" What is it? Class that defines a navigation bar in the top of the screen and it‚Äôs composed by the following attributes:\n   Attribute Type Required Definition     title String ‚úì Title for the action/navigation‚Äôs bar.   show back button Bool  Enables the return bottom on the action/navigation‚Äôs bar. Default is true.   style id String  Allows local customization for the action/navigation‚Äôs bar.   navigation bar items Navigation Bar Item  Defines an item‚Äôs list for the action/navigation‚Äôs bar.   back button accessibility Accessibility  Accessibility‚Äôs informations of the backButton.    What is a NavigationBarItem? Class that defines an item for Navigation's bar and and it has the following attributes:\n   Attribute Type Required Definition     text String  Title for the bar‚Äôs item.   image Image  Image for the bar‚Äôs item.   action Action  Action that can be done when you click on the navigations bar item.   accessibility Accessibility  Accessibiliy‚Äôs options for the navigation item.   id String  Component‚Äôs identifier.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\":\"beagle:screenComponent\", \"navigationBar\":{ \"title\":\"Beagle Screen\", \"showBackButton\":true, \"navigationBarItems\":[ { \"_beagleComponent_\":\"beagle:navigationBarItem\", \"text\":\"\", \"image\":{ \"_beagleImagePath_\":\"local\", \"mobileId\":\"informationImage\" }, \"action\":{ \"_beagleAction_\":\"beagle:alert\", \"title\":\"Screen\", \"message\":\"Some message\", \"labelOk\":\"OK\" } } ] }, \"child\":{ \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Some text\" } ] } }  Screen( navigationBar = NavigationBar( title = \"Beagle Screen\", navigationBarItems = listOf( NavigationBarItem( text = \"\", image = Local.justMobile(\"informationImage\"), action = Alert( title = \"Screen\", message = \"Some message\", labelOk = \"OK\" ) ) ) ), child = Container( children = listOf( Text(\"Some text\") ) ) )  ","excerpt":" What is it? Class that defines a navigation bar in the top of the ‚Ä¶","ref":"/docs-beagle/docs/api/screen/navigation-bar/","title":"Navigation Bar"},{"body":" O que √©? As opera√ß√µes permitem que voc√™ crie aplica√ß√µes com telas mais complexas por meio do seu backend com opera√ß√µes b√°sicas como condicionais, soma, igualdade, etc. Dessa forma, os componentes n√£o necessitam de ter esse tipo de l√≥gica dentro deles.\nComo usar? De modo geral, as opera√ß√µes podem ser usadas quando voc√™ quer modificar os valores de um componente por meio de l√≥gicas e opera√ß√µes em um momento diferente daquele em que recebeu os componentes com o JSON.\nNo Beagle √© disponibilizado alguns operadores padr√µes e voc√™ pode criar suas pr√≥prias opera√ß√µes.\nVeja abaixo todos os operadores padr√µes oferecidos pelo Beagle:\n","excerpt":" O que √©? As opera√ß√µes permitem que voc√™ crie aplica√ß√µes com telas ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/","title":"Opera√ß√µes"},{"body":" This attribute is exclusive for iOS platform.  What is it? Class that helps on your screen‚Äôs components area. The Safe Area guarantees that the elements from the screen stay visible to the user.\n   Attribute Type Definition     top Bool Enables a constraint of SafeArea only in top of the screen.   bottom Bool Enables a constraint de_SafeArea_ only in the bottom of the screen.   leading Bool Enables a constraint de_SafeArea_ only in the left side of the screen.   trailing Bool Enables a constraint_SafeArea_ only in the right side of the screen.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\":\"beagle:screenComponent\", \"safeArea\":{ \"top\":true, \"leading\":true, \"bottom\":true, \"trailing\":true }, \"child\":{ \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Some Text\" } ] } }   child = Container( children = listOf( Text(\"Some Text\") ) ), safeArea = SafeArea( top = true, leading = true, trailing = true, bottom = true ) )  ","excerpt":" This attribute is exclusive for iOS platform.  What is it? Class that ‚Ä¶","ref":"/docs-beagle/docs/api/screen/safe-area/","title":"Safe Area"},{"body":" Quais s√£o?    Operadores Exemplo A√ß√£o     sum ‚Äú@{sum(3,3)}‚Äù Operador de soma para elementos do tipo Int e Double.   subtract ‚Äú@{subtract(4,3)}‚Äù Operador de subtra√ß√£o para elementos do tipo Int e Double.   multiply ‚Äú@{multiply(3,3)}‚Äù Operador de multiplica√ß√£o para elementos do tipo Int e Double.   divide ‚Äú@{divide(3,3)}‚Äù Operador de divis√£o para elementos do tipo Int e Double.    Exemplo Veja um exemplo abaixo de um simples contador, onde dois bot√µes increment e decrement, ambos com a√ß√µes de SetContext que modificam o valor do contexto que possui o id counter, alterando seu valor com opera√ß√µes de soma e de subtra√ß√£o, incrementando e diminuindo o valor de 1 ao valor do texto:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar( title = \"Operations\", showBackButton = true ), child = Container( context = ContextData(\"counter\", 2), children = listOf( Text(expressionOf(\"Sum of 2 + 1 = @{sum(2, 1)}\")), Text(expressionOf(\"Counter: @{counter}\")), Button( text = \"increment\", onPress = listOf( SetContext(\"counter\", \"@{sum(counter, 1)}\")) ), Button( text = \"decrement\", onPress = listOf( SetContext(\"counter\", \"@{subtract(counter, 1)}\")) ) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Sum of 2 + 1 = @{sum(2, 1)}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Counter: @{counter}\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"increment\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"counter\", \"value\" : \"@{sum(counter, 1)}\" } ] }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"decrement\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"counter\", \"value\" : \"@{subtract(counter, 1)}\" } ] } ], \"context\" : { \"id\" : \"counter\", \"value\" : 2 } } }  ","excerpt":" Quais s√£o?    Operadores Exemplo A√ß√£o     sum ‚Äú@{sum(3,3)}‚Äù Operador ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-aritm%C3%A9ticos/","title":"Operadores aritm√©ticos"},{"body":" What is it? The Screen Request is an internal Beagle class used to request which screen you want to display. This class is used when you will need to call a Server-Driven page you want to load from an activity or a native fragment on Android.\nAt first, you will only list the URL attribute that referencing the page you want to load from BFF.\nHowever, this class has other attributes, which can be used when transitioning between screens.\n   Attributes Type Required Description     URL String ‚úì Defines the endpoint that returns the screen or component you wish to display.   method ScreenMethod ‚úì It is an ENUM class that defines which HTTP operation you wish to do. It works as a HTTP REQUEST METHOD and it is set as GET by default.   headers Map\u003cString, String\u003e  It is used when you need to send data via an HTTP header.   body String  It is set default as null and it just needs to be implemented when you need to send a HTTP messages as**body data.**    ScreenMethod It is an ENUM and the values are:\n   Value Definition     GET The GET method requests a representation of a specific resource. Requests using the method GET must return only data.   POST The POST method it is used to submit an entity to a specific resource, frenquetly causing a change in the resource state or colateral effects on the server.   PUT The PUT method replaces all the current representation of the target resources with the data of the request.   DELETE The DELETE method removes a specific resource.   HEAD The HEAD method request an answer the same way the GET method does, however without a response body.   PATCH The PATCH method is used to apply partial modifications in a resource.    How to use it? To start a new Activity, you have to use the startActivity() method from an Activity or a Fragment creating a ServerDrivenIntent passing through a ScreenRequest with the BFF‚Äôs address of the screen, like the example below:\nstartActivity( newServerDrivenIntent\u003cServerDrivenActivity\u003e( ScreenRequest(\"URL_WITH_SCREEN_ENDPOINT\") ) ) ","excerpt":" What is it? The Screen Request is an internal Beagle class used to ‚Ä¶","ref":"/docs-beagle/docs/api/screen-request/","title":"Screen Request"},{"body":" Quais s√£o?    Operadores Exemplo A√ß√£o     condition ‚Äú@{condition()}‚Äù Operador de condi√ß√£o que avalia dois elementos e verifica qual √© a condi√ß√£o verdadeira.   not ‚Äú@{not()}‚Äù Operador de nega√ß√£o que tem como entrada apenas um valor, e sua fun√ß√£o √© simplesmente inverter esse valor.   and ‚Äú@{and()}‚Äù Operador que recebe duas entradas e resulta em um valor VERDADEIRO se os dois valores de entrada da opera√ß√£o forem VERDADEIROS, caso contr√°rio o resultado √© FALSO.   or ‚Äú@{or()}‚Äù Operador que recebe duas entradas E resulta em um valor VERDADEIRO se ao menos UM dos dois valores de entrada da opera√ß√£o for VERDADEIRO, caso contr√°rio o resultado √© FALSO.    Exemplo Aqui temos o exemplo de uma tela que utiliza duas opera√ß√µes l√≥gicas, condition e or, onde caso o resultado da condi√ß√£o do or for verdadeira o texto do componente Text se torna true, caso falso ele atribui ao texto o valor de false.\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar(title = \"Operations\", showBackButton = true), child = Container( children = listOf( Text(text = \"The text in green bellow will show if the result of `TRUE OR FALSE\"), Text( expressionOf(\"@{condition(or(true, false), 'true', 'false')}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text in green bellow will show if the result of `TRUE OR FALSE\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(or(true, false), 'true', 'false')}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" Quais s√£o?    Operadores Exemplo A√ß√£o     condition ‚Äú@{condition()}‚Äù ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-l%C3%B3gicos/","title":"Operadores l√≥gicos"},{"body":" What is it? A Widget is an abstract class that allows a visual component to be referenced on Beagle. When a visual component extends from a widget, it gets 3 attributes that enables some them, with its functions in the viewed elements.\nIt is important to remember that, by default, these structures have null value.  abstract class Widget : StyleComponent, AccessibilityComponent, IdentifierComponent { override var id: String? = null override var style: Style? = null override var accessibility: Accessibility? = null } We list below all the attributes a widget can receive. But, if you want an use example and how to create a widget, see our section creating a component. \nWhich are the attributes? Widget‚Äôs attributes The main attributes of this class are:\n   Attribute Definition     id  string parameter that identifies the visual component listed by a widget.   \nstyle  This attribute is defined by a Style class that is configured to define a series of visual properties.    data class Style ( val backgroundColor: String? = null, val cornerRadius: CornerRadius? = null, val size: Size? = null, val margin: EdgeValue? = null, val padding: EdgeValue? = null, val position: EdgeValue? = null, val flex: Flex? = null, val positionType: PositionType? = null, val display: Display? = null) Style attributes The main attributes are:\n   Attribute  Description     backgroundColor  It defines with a string parameter the background color of a visual component. It is important that the color is listed with hexadecimal format, starting with #. For example: white color in a background \"FFFFFF\".   cornerRadius  Defines with a double value the rouding edge of this component.   size  Defines a size of a component with a whole value. This value must be followed by a .unitPercent() notation to define a percentage size related to the application's screen, or using the .unitReal() notation to define a size in pixels. A 80.unitPercent() value defines that a component will have a relative size of 80% of a screen. And 80.unitReal() defines a 80 pixels size.\n\n   margin  It determines the margin that will affect the spacing around the element, it will help them move according the internal limits of its father and brothers elements.\nThe margin element contributes to the total size of its father, for example, if the father element is automatically sized.\n   padding  Defines internal spaces of the component, it behaves like 'internal margin' of the element. For example, a container has two visuals elements that defines a padding value, so that internal elements aren't glued to the internal margins.   position  Attribute that adds a padding to a position. For more details about how it works, check our documentation about position attributes in component's layout.     flex  Flex attribute positions the elements on a screen. For more details about it, check our documentation aboutFlex.    positionType  \u003cb\u003e\u003c/b\u003ePosition Type attribute establishes a relation with the element's positioning and its brothers.   display  Attribute that defines if the element linked to this widget will be positioned by Flex.      Accessibility attributes The main attributes are:\n   Attribute Description     accessible Enable a boolean value with accessibility information.   accessibilityLabel Defines with a string message for accessibility.    How to use it? On the example below, we used a Container to show the widgets attributes. The class defines a visual component that must extend the widget class.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Sou um texto Server-Driven\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Sou outro texto Server-Driven\" } ], \"id\" : \"SouUmWidget\", \"style\" : { \"backgroundColor\" : \"#ff8100\", \"cornerRadius\" : { \"radius\" : 25.0 }, \"size\" : { \"width\" : { \"value\" : 70.0, \"type\" : \"PERCENT\" }, \"height\" : { \"value\" : 80.0, \"type\" : \"REAL\" } }, \"margin\" : { \"all\" : { \"value\" : 20.0, \"type\" : \"REAL\" } }, \"padding\" : { \"all\" : { \"value\" : 15.0, \"type\" : \"REAL\" } }, \"position\" : { \"left\" : { \"value\" : 0.0, \"type\" : \"REAL\" } }, \"flex\" : { \"flexDirection\" : \"ROW\" }, \"positionType\" : \"RELATIVE\", \"display\" : \"FLEX\" }, \"accessibility\" : { \"accessible\" : true, \"accessibilityLabel\" : \"Sou acess√≠vel\" } }  Container( listOf( Text(\"Sou um texto Server-Driven\"), Text(\"Sou outro texto Server-Driven\") ) ).applyStyle( Style(backgroundColor = \"#ff8100\", cornerRadius = CornerRadius(25.0), size = Size(width = 70.unitPercent(), height = 80.unitReal()), margin = EdgeValue(all = 20.unitReal()), padding = EdgeValue(all = 15.unitReal()), position = EdgeValue(0.unitReal()), flex = Flex(FlexDirection.ROW), positionType = PositionType.RELATIVE, display = Display.FLEX) ).applyAccessibility(accessibility = Accessibility( accessible = true, accessibilityLabel = \"Sou acess√≠vel\") ).setId(\"SouUmWidget\")  üëá Test this component in the Web Playground {% embed url=‚Äúhttps://beagle-playground.netlify.app/#/demo/default-components/container.json‚Äù %}}\n","excerpt":" What is it? A Widget is an abstract class that allows a visual ‚Ä¶","ref":"/docs-beagle/docs/api/widget/","title":"Widget"},{"body":" Quais s√£o?    Operadores Exemplo A√ß√£o     gt\n(Maior)\n \"@{gt(3,4)} Operador que recebe duas entradas e resulta em verdadeiro se o primeiro valor for maior que o segundo.   gte\n(Maior ou Igual)\n \"@{gte(3,4)}\" Operador que recebe duas entradas e resulta em verdadeiro se o primeiro valor for maior ou igual ao segundo.   lt\n(Menor)\n @{lt(3,4)}\" Operador que recebe duas entradas e resulta em verdadeiro se o primeiro valor for menor que o segundo.   lte\n(Menor ou igual)\n \"@{lte(3,4)}\" Operador que recebe duas entradas e resulta em verdadeiro se o primeiro valor for menor ou igual ao segundo.   eq\n(Igual)\n \"@{eq(4,4)}\" Operador que recebe duas entradas e resulta em verdadeiro se o os dois valores s√£o iguais.    Exemplo Aqui, o exemplo √© de uma tela que utiliza a opera√ß√£o de compara√ß√£o lt, que verifica se o valor da soma de counter e:\n Se o resultado da condi√ß√£o do or for verdadeira, o texto do componente Text se torna true; Caso falso ele atribui ao texto o valor de false.  Kotlin JSON fun screen() = Screen( navigationBar = NavigationBar( title = \"Operations\", showBackButton = true ), child = Container( children = listOf( Text(text = \"The text bellow will show if 4 is below 5 or not\"), Text(expressionOf( \"@{condition(lt(4, 5), 'less then 5', 'greater then 5')}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text bellow will show if 4 is below 5 or not\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(lt(4, 5), 'less then 5', 'greater then 5')}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" Quais s√£o?    Operadores Exemplo A√ß√£o     gt\n(Maior)\n \"@{gt(3,4)} ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-de-compara%C3%A7%C3%A3o/","title":"Operadores de compara√ß√£o"},{"body":" Quais s√£o?    Operadores Exemplo A√ß√£o     concat ‚Äú@{concat(‚Äúcachorro‚Äù, ‚Äúquente‚Äù)}‚Äù Operador que concatena as strings que tiver como entrada.   capitalize ‚Äú@{capitalize(brasil)}‚Äù Operador que transforma a primeira letra da string em uma letra mai√∫scula.   uppercase ‚Äú@{uppercase(brasil)}‚Äù Operador que transforma a todas as letras de uma string em letras mai√∫sculas.   lowercase ‚Äú@{lowecase(BRASIL)}‚Äù Operador que transforma a todas as letras de uma string em letras min√∫sculas.   substr ‚Äú@{substr(brasil, 3)}‚Äù Operador que retorna uma substring da string de entrada. Essa opera√ß√£o pode ter 2 ou 3 entradas, onde o primeiro par√¢metro √© a string e o segundo e terceiro par√¢metro s√£o os limitadores da string.    Exemplo Nesse exemplo, uma tela possui um texto com uma opera√ß√£o de substring, no qual sua frase √© ‚ÄòThe book is on the table‚Äô e os par√¢metros 4, 11 ditam o limite dessa substring, a tornando a seguinte string ‚Äòbook is on‚Äô:\nKotlin JSON fun screen() = Screen(child = Container( children = listOf( Text(text = \"The text bellow is a substring of `The book is on the table`.\"), Text( expressionOf(\"@{substr('The book is on the table', 4, 11)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\") ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text bellow is a substring of `The book is on the table`.\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{substr('The book is on the table', 4, 11)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" Quais s√£o?    Operadores Exemplo A√ß√£o     concat ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-para-manipula%C3%A7%C3%A3o-de-string/","title":"Operadores para manipula√ß√£o de string"},{"body":" Quais s√£o?    Operadores Exemplo A√ß√£o     insert ‚Äú@{insert(array, 5)}‚Äù Operador que recebe duas entradas onde o primeiro par√¢metro √© um array e o segundo √© o elemento que deseja inserir nesse array.   remove ‚Äú@{remove(array, 1)}‚Äù Operador que recebe duas entradas onde o primeiro par√¢metro √© um array e o segundo √© o elemento que deseja remover desse array.   removeIndex ‚Äú@{removeIndex(array, 2)}‚Äù Operador que recebe duas entradas onde o primeiro par√¢metro √© um array e o segundo √© o index do elemento que deseja remover desse array.   contains ‚Äú@{contains(array, 3)}‚Äù Operador que recebe duas entradas onde o primeiro par√¢metro √© um array e o segundo √© o elemento que deseja verificar se cont√©m no array.    Exemplo Veja o exemplo de uma tela no qual foi declarado um contexto com id numbersArray com o valor de [0, 1, 2, 3, 4], esse contexto √© usado na opera√ß√£o de removeIndexno texto do component Text, onde ele remove o elemento de index 2.\nKotlin JSON fun screen() = Screen(child = Container( context = ContextData(id = \"numbersArray\", value = arrayOf(0,1,2,3,4)), children = listOf( Text(text = \"Array was [0, 1, 2, 3, 4] and after removing index 2 now is: \"), Text( expressionOf(\"@{removeIndex(numbersArray, 2)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Array was [0, 1, 2, 3, 4] and after removing index 2 now is: \" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{removeIndex(numbersArray, 2)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ], \"context\" : { \"id\" : \"numbersArray\", \"value\" : [ 0, 1, 2, 3, 4 ] } } }  ","excerpt":" Quais s√£o?    Operadores Exemplo A√ß√£o     insert ‚Äú@{insert(array, ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-para-manipula%C3%A7%C3%A3o-de-arrays/","title":"Operadores para manipula√ß√£o de arrays"},{"body":" Quais s√£o?    Operadores Exemplo A√ß√£o     isNull ‚Äú@{isNull(context)}‚Äù Operador que verifica se o param√™tro √© nulo.   isEmpty ‚Äú@{isEmpty(\")}‚Äù Operador que recebe uma entrada e verifica se ela √© vazia.   length ‚Äú@{length(tamanho)}‚Äù Operador que recebe uma entrada e retorna o seu tamanho.    Exemplo Um contexto com id numbersArray que possui como valor [0, 1, 2, 3, 4] e a opera√ß√£o length foi utilizada em um componente Text para pegar o tamanho desse array, veja abaixo:\nKotlin JSON fun screen() = Screen(child = Container( context = ContextData(id = \"numbersArray\", value = arrayOf(0,1,2,3,4)), children = listOf( Text(text = \"Array [0, 1, 2, 3, 4] has size: \"), Text( expressionOf(\"@{length(numbersArray)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Array [0, 1, 2, 3, 4] has size: \" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{length(numbersArray)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ], \"context\" : { \"id\" : \"numbersArray\", \"value\" : [ 0, 1, 2, 3, 4 ] } } }  ","excerpt":" Quais s√£o?    Operadores Exemplo A√ß√£o     isNull ‚Äú@{isNull(context)}‚Äù ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/outros-operadores/","title":"Outros operadores"},{"body":" Depois que voc√™ viu que √© poss√≠vel realizarOpera√ß√µes do tipo soma, subtra√ß√£o, etc, utilizando o contexto, voc√™ tamb√©m pode criar a sua pr√≥pria opera√ß√£o na plataforma que voc√™ quiser:\niOS  O registro de uma opera√ß√£o no iOS √© feito atrav√©s de um protocolo chamado OperationsProvider, veja abaixo:\npublic protocol OperationsProvider { func register(operationId: String, handler: @escaping OperationHandler) func evaluate(with operation: Operation, in view: UIView) -\u003e DynamicObject } Para registrar sua opera√ß√£o customizada, voc√™ deve fazer duas coisas:\n Prover um id para essa opera√ß√£o; Prover a ela a a√ß√£o que ir√° acontecer por meio de uma closure do tipo OperationHandler.  O OperationHandler √© um typealias de um bloco de c√≥digo que retorna DynamicObject por meio de par√¢metros do tipo [DynamicObject].\npublic typealias OperationHandler = (_ parameters: [DynamicObject]) -\u003e DynamicObject Agora, para registrar a sua nova opera√ß√£o basta utilizar o BeagleDependencies, onde nele voc√™ acessa o OperationsProvider, no qual tem a fun√ß√£o de registro.\nlet dependencies = BeagleDependencies() dependencies.operationsProvider.register(operationId: \"isValidCpf\") { parameters in let anyParameters = parameters.map { $0.asAny() } if let intParameters = anyParameters.first as? Int { let stringParameters = String(intParameters) return .bool(stringParameters.isValidCPF) } else if let stringParameters = anyParameters.first as? String { return .bool(stringParameters.isValidCPF) } return nil } Pronto! Sua opera√ß√£o j√° pode ser utilizada!\n Exemplo Veja abaixo o exemplo utilizando a opera√ß√£o isValidCpf que foi criada acima, onde o texto do componente Text varia de acordo com o resultado da verifica√ß√£o se o CPF √© v√°lido ou n√£o:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar(title = \"Custom operation\", showBackButton = true), child = Container( context = ContextData(\"cpf\", \"00000000000\"), children = listOf( Button(\"CPF atual: @{cpf}\", onPress = listOf( SetContext( contextId = \"cpf\", value = \"42249625000\" ) )), Text(text = \"@{condition(isValidCpf(cpf), 'cpf is valid', 'cpf is not valid')}\") ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Custom operation\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"CPF atual: @{cpf}\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"cpf\", \"value\" : \"42249625000\" } ] }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(isValidCpf(cpf), 'cpf is valid', 'cpf is not valid')}\" } ], \"context\" : { \"id\" : \"cpf\", \"value\" : \"00000000000\" } } }  ","excerpt":" Depois que voc√™ viu que √© poss√≠vel realizarOpera√ß√µes do tipo soma, ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/como-registrar-uma-nova-opera%C3%A7%C3%A3o/","title":"Como registrar uma nova opera√ß√£o"},{"body":" O que √©? O Contexto Global √© uma vari√°vel que pode assumir como valor qualquer tipo de vari√°vel, como um mapa definindo um conjunto de pares chave/valor ou objetos JSONs complexos que definem √°rvores de objetos.\nEle funciona exatamente como o Contexto, no entanto, com um escopo global, ou seja, ele existir√° enquanto a aplica√ß√£o estiver rodando (mesmo em background), o que o permite ser acessado a partir de qualquer ponto da aplica√ß√£o, seja esse ponto um componente ou a√ß√£o vinculada a um componente ou mesmo programaticamente.\nComo acessar? Ele pode ser acessado a partir de uma express√£o em uma p√°gina declarativa, como por exemplo \"@{global.user}\" ou programaticamente, a partir de um objeto GlobalContext.get().\nDesta forma, √© poss√≠vel compartilhar informa√ß√µes entre a parte nativa da aplica√ß√£o, parte server-driven e tamb√©m entre diferentes telas server-driven.  Como utilizar? Para utilizar o Contexto Global √© importante ressaltar algumas informa√ß√µes importantes:\n O Contexto Global √© um Objeto do tipo ContextData. O Contexto Global pode ter como VALUE um Objeto JSON complexo, que pode conter uma √°rvore de objetos em si mesmo. √â um Singleton.  Por default o ID de um contexto global ser√° sempre ‚Äúglobal‚Äù.  Como criar um Contexto Global? O Contexto Global √© criado juntamente com a aplica√ß√£o. √â definido internamente no Beagle como um objeto do tipo ContextData que armazenar√° qualquer informa√ß√£o definida no contexto global.\nComo definir um Contexto Global? Um contexto que seja global pode ser definido de duas formas:\n A partir de um componente declarativo (utilizando a A√ß√£oSetContext) ou Programaticamente, utilizando a fun√ß√£o set() a partir do objeto GlobalContext  1. Usando o SetContext √â poss√≠vel definir ou modificar um contexto global a partir da A√ß√£o SetContext Para tal, basta identificar o contexto global utilizando a ID = \"global\" na propriedade contextId, como mostrado no exemplo abaixo:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\":\"@{global.myValue}\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Open Modal\", \"onPress\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"global\", \"path\": \"myValue\", \"value\": \"Context has changed\" } ] } ] }  Container( children = listOf( Text(text = \"@{global.myValue}\"), Button(text = \"Open Modal\", onPress = listOf( SetContext( contextId = \"global\", path = \"myValue\", value = \"Context has changed\" ) ) ) ) )  Ao definir o valor (value) de um contexto qualquer, √© importante analisar sua estrutura. Se nenhum valor for passado na propriedade path, o valor ser√° definido na raiz desse objeto, ou seja, qualquer outra atribui√ß√£o que seja feita ao contexto vai sobrescrever qualquer informa√ß√£o sem um path na raiz do objeto.  No exemplo acima, o objeto JSON criado na raiz do contexto seria:\n{\"myValue\" : \"Context has changed\"} 2. Usando o GlobalContext.set() O Contexto Global tamb√©m pode ser definido atrav√©s de um m√©todo set que pode ser chamado a partir do objeto GlobalContext.\nPara isso √© usado:\nGlobalContext.set(value, path)\n   Par√¢metro Tipo Obrigat√≥rio Defini√ß√£o     value Any ‚úì Representa a informa√ß√£o em si, que pode ser de qualquer tipo, como por exemplo, outros objetos JSONs, um array ou outro objeto qualquer.   path String  Representa o caminho designado que conter√° essa informa√ß√£o, no exemplo acima, o path utilizado foi \"myValue\". O par√¢metro path n√£o √© obrigat√≥rio, e quando for omitido, definir√° o valor informado na raiz do objeto, sobrescrevendo qualquer outra informa√ß√£o.    Para definir um contexto global como o do exemplo dessa se√ß√£o, utilize o comando abaixo:\nAndroid Web iOS GlobalContext.set(\"Context has changed\", \"myValue\")  Na web, o contexto global √© um dos atributos do BeagleService, que a lib do beagle-angular e beagle-react disponibilizam.\nAngular:\nPara utilizar o contexto global em qualquer componente da sua aplica√ß√£o voc√™ precisar√° injetar o BeagleProvider no construtor do seu componente, utilizar a fun√ß√£o getBeagleUIService para ter acesso ao objeto do beagleService, acessar o globalContext e a fun√ß√£o do globalContext desejada. Abaixo o c√≥digo exemplificando como utilizar a fun√ß√£o de set.\nimport { BeagleProvider } from '@zup-it/beagle-angular'; constructor(private beagleProvider: BeagleProvider) ... const beagleService = this.beagleProvider.getBeagleUIService() beagleService?.globalContext.set(value, path) React:\nPara utilizar o contexto global em uma aplica√ß√£o React, utilize o context disponibilizado pelo beagle-react atrav√©s do useContext do pr√≥prio react para ter acesso ao beagleService e atrav√©s desse beagleService, acesse o globalContext e a fun√ß√£o desejada, no exemplo abaixo, a fun√ß√£o de set √© utilizada.\nimport context from '@zup-it/beagle-react/provider' ... const beagleService = useContext(context) beagleService?.globalContext.set(value, path)  No iOS o Contexto Global √© um dos atributos do Beagle Dependencies .\nPara utilizar o contexto global em qualquer componente da sua aplica√ß√£o voc√™ precisar√° chamar o BeagleDependencies do seu projeto como no exemplo abaixo:\ndependencies.globalContext.setValue(value: \"Context has changed\", path: \"myValue\") O valor do contexto √© um DynamicObject, portanto ele pode assumir qualquer tipo de valor.\n  O contexto global pode ser recuperado de duas formas:\n Usando express√µes (assim como qualquer contexto) ou Fun√ß√£o get chamada a partir do Objeto GlobalContext.  1. Usando a express√£o ‚Äú@{global}‚Äù Para recuperar o valor atribu√≠do a um contexto global basta utilizar a express√£o ‚Äú@{global}‚Äù.\nNo exemplo utilizado nessa se√ß√£o, atribu√≠mos um valor ao contexto global utilizando o path \"myValue\" , dessa forma, para recuper√°-lo basta usar a express√£o \"@{global.myValue}\" o que retornar√° a string ‚ÄúContext has changed‚Äù.\n Caso utilize somente a express√£o \"@{global}\" , o valor retornado ser√° o objeto JSON inteiro:  {‚ÄúmyValue‚Äù : ‚ÄúContext has changed‚Äù}    Essas express√µes s√£o observadas pelo contexto e s√£o atualizadas conforme o contexto muda, no entanto elas precisam estar em uma tela declarativa.  2. Usando o GlobalContext.get() O Contexto Global tamb√©m pode ser recuperado atrav√©s de um m√©todo get que pode ser chamado a partir do objeto GlobalContext.\nPara isso √© usado:\nGlobalContext.get(path)\n   Par√¢metro Tipo Obrigat√≥rio Defini√ß√£o     path String  Representa o caminho designado que conter√° essa informa√ß√£o, no exemplo acima, o path utilizada foi \"myValue\". O par√¢metro path √© opcional e caso n√£o seja passado todo o valor do contexto global ser√° retornado.    Considerando o exemplo anterior, para recuperar o valor do Contexto Global que est√° no path ‚ÄúmyValue‚Äù, utilize o comando:\nAndroid Web iOS GlobalContext.get(\"myValue\")  Acima foram mostradas todas as configs para utiliza√ß√£o do set. A config para o get √© a mesma, por√©m mudando apenas o m√©todo do globalContext que ser√° acessado:\nbeagleService?.globalContext.get(\"myValue\")  Assim como no m√©todo set ser√° necess√°rio chamar as depend√™ncias do Beagle para utilizar o contexto global como no exemplo abaixo:\ndependencies.globalContext.get(path: \"myValue\")   Da mesma forma, ao utilizar o GlobalContext.get() sem nenhum par√¢metro como path, esse m√©todo retornar√° o objeto JSON inteiro -\u003e {\"myValue\" : \"Context has changed\"}  Removendo um Contexto Global O contexto global s√≥ √© destru√≠do com o encerramento da aplica√ß√£o, e mesmo se estiver vazio, pode ser chamado de qualquer lugar da aplica√ß√£o, pois ‚Äúexiste‚Äù enquanto a aplica√ß√£o ‚Äúexistir‚Äù.\nNo entanto, ele pode ser apagado (reset) ou ter partes de sua estrutura (Objetos dentro do objeto JSON que representa o contexto global) removidas, modificando a estrutura do objeto.\nUsando o GlobalContext.clear() O Contexto Global pode ser apagado atrav√©s do m√©todo clear que pode ser chamado a partir do objeto GlobalContext.\nPara isso √© usado:\nGlobalContext.clear(path)\n   Par√¢metro Tipo Obrigat√≥rio Defini√ß√£o     path String  Opcional. Representa o caminho que se deseja remover.    1. Removendo todos os valores do Contexto Global Para remover os valores de um Contexto Global por completo, ‚Äúlimpando-o‚Äù, devemos utilizar o comando clear sem informar um path. Veja abaixo:\nAndroid Web iOS GlobalContext.clear()  Lembre-se que na web o acesso ao contexto global sempre √© feito atr√°ves do beagleService:\nbeagleService?.globalContext.clear()  Lembre-se que no iOS o acesso ao contexto global √© feito atrav√©s do BeagleDependencies\ndependencies.globalContext.clear()  Dessa forma, o VALUE do Contexto Global ser√° apagado totalmente e ter√° um valor vazio (\"\") caso chamado a partir de sua fun√ß√£o GlobalContext.get()\n2. Removendo um atributo/propriedade do Contexto Global Por exemplo, imagine um contexto global que tenha duas propriedades definidas a seguir\nPropriedade 1 Propriedade 2  GlobalContext.set(path = \"myValue1\", value = \"My Context Value1\") GlobalContext.set(path = \"myValue2\", value = \"My Context Value2\")   beagleService?.globalContext.set(\"My Context Value1\", \"myValue1\") beagleService?.globalContext.set(\"My Context Value2\", \"myValue1\")  Esse Contexto Global √© constru√≠do pelo Beagle como o objeto JSON a seguir:\n{ \"myValue1\":\"My Context Value1\", \"myValue2\":\"My Context Value2\" } Ao utilizar o comando:\nAndroid Web iOS GlobalContext.clear(myValue1\")  beagleService?.globalContext.clear(\"myValue1\")  dependencies.globalContext.clear(myValue1\")  A propriedade representada pelo path ‚ÄúmyValue1‚Äù ser√° completamente removida contexto global, que ser√°:\n{ \"myValue2\":\"My Context Value2\" } ","excerpt":" O que √©? O Contexto Global √© uma vari√°vel que pode assumir como valor ‚Ä¶","ref":"/docs-beagle/pt/docs/api/contexto-global/","title":"Contexto Global"},{"body":" O que s√£o? Eventos s√£o tudo que podem disparar a√ß√µes do Beagle (Beagle Actions). No JSON, toda chave que √© associada a uma Beagle Action representa um evento.\nVeja alguns exemplos de eventos:\n onPress onError onFocus onChange  Um evento pode ser parte do contrato de um componente ou de uma Beagle Action. Um bot√£o, por exemplo, √© um componente e ‚ÄúonPress‚Äù √© um evento que faz parte do seu contrato. A a√ß√£o sendRequest, √© um exemplo de a√ß√£o onde os eventos ‚ÄúonSuccess‚Äù, ‚ÄúonError‚Äù e ‚ÄúonFinish‚Äù s√£o parte do contrato.\nComo usar? Veja o exemplo com o evento ‚ÄúonPress‚Äù do bot√£o:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click to show message\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Sou um alert\", \"message\" : \"Hello Beagle\" } ] }  Button( text = \"Click to show message\", onPress = listOf( Alert( title = \"I'm an alert\", message = \"Hello Beagle\" ) ) )  No exemplo acima, associa-se a a√ß√£o ‚Äúbeagle:alert‚Äù ao evento ‚ÄúonPress‚Äù do componente ‚Äúbeagle:button‚Äù. Ou seja, ao pressionar o bot√£o cujo t√≠tulo √© ‚Äúclick to show message‚Äù, uma mensagem de alerta ser√° exibida na tela com o texto ‚ÄúHello World!‚Äù.\nTodo evento em qualquer componente ou a√ß√£o pode ser associado a qualquer Beagle Action. Foi utilizada a a√ß√£o de alerta no exemplo anterior, mas qualquer outra poderia ser utilizada. Para fazer uma requisi√ß√£o ao clicar no bot√£o, a a√ß√£o ‚Äúbeagle:sendRequest‚Äù poderia ter sido usada. Para saber mais sobre a rela√ß√£o com todas a a√ß√µes dispon√≠veis, acesse a documenta√ß√£o sobre a√ß√µes.\n","excerpt":" O que s√£o? Eventos s√£o tudo que podem disparar a√ß√µes do Beagle ‚Ä¶","ref":"/docs-beagle/pt/docs/api/eventos/","title":"Eventos"},{"body":" O que √©? A sua tela possui atributos e componentes que podem ser usados e configurados. Na tabela abaixo, listamos as principais caracter√≠sticas para cada um destes atributos.\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     identifier String  Atributo que identifica a tela globalmente na sua aplica√ß√£o, de modo que seja poss√≠vel atribuir a√ß√µes a ela.   safe area Safe Area  Especifica o posicionamento dos componentes na tela.   navigation bar Navigation Bar  Permite configurar a barra de a√ß√µes/navega√ß√£o na tela.   child Server Driven Component ‚úì Define os elementos na tela. Pode ser qualquer componente visual que estenda de ServerDrivenComponent.   style Style  Fornece op√ß√µes de customiza√ß√£o visual para a Screen.   screen analytics event Screen Event  Configura elementos de an√°lise(Analytics) na sua tela.   context ContextData  Contexto da tela.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Beagle Screen\", \"showBackButton\" : true, \"navigationBarItems\" : [ { \"_beagleComponent_\" : \"beagle:navigationBarItem\", \"text\" : \"\", \"image\" : { \"_beagleImagePath_\" : \"local\", \"mobileId\" : \"informationImage\" }, \"action\" : { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Screen\", \"message\" : \"Some message\", \"labelOk\" : \"OK\" } } ] }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Some text\" } ] } }  Screen( navigationBar = NavigationBar( title = \"Beagle Screen\", showBackButton = true, navigationBarItems = listOf( NavigationBarItem( text = \"\", image = Local.justMobile(\"informationImage\"), action = Alert( title = \"Screen\", message = \"Some message\", labelOk = \"OK\" ) ) ) ), child = Container( children = listOf( Text(\"Some text\") ) ) )  üëâ Teste esse exemplo no Playground ","excerpt":" O que √©? A sua tela possui atributos e componentes que podem ser ‚Ä¶","ref":"/docs-beagle/pt/docs/api/screen/","title":"Screen"},{"body":" O que √© a NavigationBar? Classe que define a barra superior com fun√ß√£o de navega√ß√£o. √â composta pelos seguintes atributos:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     title String ‚úì T√≠tulo para a barra de a√ß√µes/navega√ß√£o.   showBackButton Boolean  Habilita o bot√£o de voltar na barra de a√ß√µes/ navega√ß√£o. Default √© true.   styleId String  Permite a customiza√ß√£o local da barra de a√ß√µes/navega√ß√£o.   navigationBarItems List\u003cNavigationBarItem\u003e  Define uma lista de itens da barra de a√ß√£o/navega√ß√£o.   backButtonAccessibility Accessibility  Informa√ß√µes de acessibilidade do backButton.    O que √© a NavigationBarItem? Classe que define o item da NavigationBar que √© composto por:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     text String ‚úì T√≠tulo do item da barra.   image Image  Imagem do item da barra.   action Action ‚úì A√ß√£o que deve ser realizada ao clicar no item da barra de navega√ß√£o.   accessibility Accessibility  Op√ß√µes de acessibilidade para o navigation item.   id String  Identificador do componente.    Como usar? Para usar uma NavigationBar √© necess√°rio declarar dentro de uma Screen. Segue um exemplo abaixo:\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:screenComponent\", \"navigationBar\":{ \"title\":\"Beagle Screen\", \"showBackButton\":true, \"navigationBarItems\":[ { \"_beagleComponent_\":\"beagle:navigationBarItem\", \"text\":\"\", \"image\":{ \"_beagleImagePath_\":\"local\", \"mobileId\":\"informationImage\" }, \"action\":{ \"_beagleAction_\":\"beagle:alert\", \"title\":\"Screen\", \"message\":\"Some message\", \"labelOk\":\"OK\" } } ] }, \"child\":{ \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Some text\" } ] } }   Screen( navigationBar = NavigationBar( title = \"Beagle Screen\", navigationBarItems = listOf( NavigationBarItem( text = \"\", image = Local.justMobile(\"informationImage\"), action = Alert( title = \"Screen\", message = \"Some message\", labelOk = \"OK\" ) ) ) ), child = Container( children = listOf( Text(\"Some text\") ) ) )  ","excerpt":" O que √© a NavigationBar? Classe que define a barra superior com ‚Ä¶","ref":"/docs-beagle/pt/docs/api/screen/navigation-bar/","title":"Navigation Bar"},{"body":" Esse atributo √© exclusivo da plataforma iOS.  O que √©? Classe que auxilia o posicionamento dos componentes na √°rea da tela. Safe Area garante que os elementos que comp√µem sua tela estejam vis√≠veis para o usu√°rio.\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     top Boolean  Habilita a constraint de SafeArea apenas no topo da tela.   bottom Boolean  Habilita a constraint de_SafeArea_ apenas na parte de baixo da tela.   leading Boolean  Habilita a constraint de_SafeArea_ apenas √† esquerda da tela.   trailing Boolean  Habilita a constraint_SafeArea_ apenas √† direita da tela.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\":\"beagle:screenComponent\", \"safeArea\":{ \"top\":true, \"leading\":true, \"bottom\":true, \"trailing\":true }, \"child\":{ \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Some Text\" } ] } }  Screen( child = Container( children = listOf( Text(\"Some Text\") ) ), safeArea = SafeArea( top = true, leading = true, trailing = true, bottom = true ) )  ","excerpt":" Esse atributo √© exclusivo da plataforma iOS.  O que √©? Classe que ‚Ä¶","ref":"/docs-beagle/pt/docs/api/screen/safe-area/","title":"Safe Area"},{"body":" O que √©? A Screen Request √© uma classe interna do Beagle utilizada para solicitar qual tela voc√™ deseja exibir. Esta classe √© utilizada quando se deseja chamar uma tela Server-Driven a partir de uma activity ou fragment nativo no Android.\nA princ√≠pio, voc√™ listar√° apenas o atributo URL referente √† p√°gina que deseja carregar vinda do BFF.\nNo entanto, essa classe possui outros atributos, que podem ser utilizados na transi√ß√£o entre telas.\n   Atributo Tipo Obrigat√≥rio Descri√ß√£o     URL String ‚úì Define o endpoint que retorna a p√°gina ou componente visual desejado   method ScreenMethod ‚úì √â um ENUM que define qual opera√ß√£o voc√™ deseja fazer. Ele funciona como um m√©todo HTTP request, mas que est√° configurado como GET, por padr√£o   headers Map\u003cString, String\u003e  √â utilizado somente quando voc√™ deseja enviar informa√ß√µes nos campos de cabe√ßalho HTTP   body String  √â definido por padr√£o como null e s√≥ precisa ser implementado caso seja necess√°rio enviar uma mensagem HTTP como body data.    ScreenMethod √â um ENUM, cujo os valores s√£o:\n   Valor Defini√ß√£o     GET O m√©todo GET solicita a representa√ß√£o de um recurso espec√≠fico. Requisi√ß√µes utilizando o m√©todo GET devem retornar apenas dados.   POST O m√©todo POST √© utilizado para submeter uma entidade a um recurso espec√≠fico, frequentemente causando uma mudan√ßa no estado do recurso ou efeitos colaterais no servidor.   PUT O m√©todo PUT substitui todas as atuais representa√ß√µes do recurso de destino pela carga de dados da requisi√ß√£o.   DELETE O m√©todo DELETE remove um recurso espec√≠fico.   HEAD O m√©todo HEAD solicita uma resposta de forma id√™ntica ao m√©todo GET, por√©m sem conter o corpo da resposta.   PATCH O m√©todo PATCH √© utilizado para aplicar modifica√ß√µes parciais em um recurso.    Como usar? Para iniciar uma nova Activity basta usar o m√©todo startActivity() a partir de uma Activity ou um Fragment criando um ServerDrivenIntent passando o ScreenRequest com o endere√ßo do BFF da tela como no exemplo abaixo:\nstartActivity( newServerDrivenIntent\u003cServerDrivenActivity\u003e( ScreenRequest(\"URL_WITH_SCREEN_ENDPOINT\") ) ) ","excerpt":" O que √©? A Screen Request √© uma classe interna do Beagle utilizada ‚Ä¶","ref":"/docs-beagle/pt/docs/api/screen-request/","title":"Screen Request"},{"body":" O que √©? O Widget √© uma classe abstrata que permite que um componente visual seja referenciado no Beagle. Quando um componente visual se estende do widget, ele herda 3 atributos que habilitam algum atributos e funcionalidades nos elementos visualizados.\n√â importante lembrar que, por default, essas estruturas s√£o colocadas como nulas.  abstract class Widget : StyleComponent, AccessibilityComponent, IdentifierComponent { override var id: String? = null override var style: Style? = null override var accessibility: Accessibility? = null } Abaixo listamos todos os atributos que um widget pode receber. Mas se quiser um exemplo de uso e como criar um widget, veja a se√ß√£o posicionamento de componentes.\nQuais seus atributos? Atributos do Widget Os principais atributos desta classe s√£o:\n   Atributo Tipo Obrigat√≥rio Defini√ß√£o     id  String  identifica o componente visual listado pelo widget.   \nstyle  Style  define uma s√©rie de propriedades visuais.   accessibility  Accessibility  define o conte√∫do textual para uso de leitor de telas.    Atributos do Style Os principais atributos s√£o:\n   Atributo  Tipo Obrigat√≥rio Defini√ß√£o     backgroundColor  String  Define a cor de fundo de um componente visual. Para isso, √© importante que a cor seja listada em formato hexadecimal, necessariamente come√ßando com #. Por exemplo: a cor branca em um background seria \"#FFFFFF   cornerRadius  CornerRadius  Define o arredondamento da borda desse componente   size  Size  Define o tamanho do componente com um valor inteiro . Este valor deve ser seguido da nota√ß√£o .unitPercent() para definir um tamanho percentual em rela√ß√£o a tela da aplica√ß√£o, ou usando a nota√ß√£o .unitReal() para definir um tamanho pontual em pixels. Um valor 80.unitPercent() define que o componente ter√° um tamanho relativo a 80% da tela. J√° 80.unitReal()define o tamanho de 80 pixels.    margin  EdgeValue  Determina a margem que afeta o espa√ßamento ao redor de um elemento, contribuindo para que ele se desloque de acordo com os limites internos do elemento pai e de seus irm√£os.\nA margem de um elemento contribui para o tamanho total de seu pai se, por exemplo, o elemento pai for dimensionado automaticamente.\n   padding  EdgeValue  Define espa√ßos internos no componente, ele se comporta como uma esp√©cie de \"margem interna\" do elemento. Por exemplo, um container que tenha dois elementos visuais define um valor para padding para que os elementos internos n√£o fiquem \"colados\" nas margens internas.   position  EdgeValue  Adiciona padding a uma posi√ß√£o. Para mais detalhes sobre seu funcionamento verifique nossa documenta√ß√£o sobre o atributo posi√ß√£o  em um layout de componentes.   flex  Flex   Respons√°vel por posicionar elementos na tela. Para mais detalhes verifique nossa documenta√ß√£o sobre o Flex.    positionType  PositionType  Respons√°vel por estabelecer a rela√ß√£o de posicionamento entre este elemento e seus irm√£os.   display  Display  Define se o elemento vinculado a esse widget ser√° posicionado pelo Flex.    Atributos do Accessibility Os principais atributos s√£o:\n   Atributos Tipo Obrigat√≥rio Defini√ß√£o     accessible Boolean  Habilita informa√ß√µes para acessibilidade   accessibilityLabel String  Define uma mensagem para acessibilidade    Como usar? No exemplo abaixo, utilizamos um Container para exemplificar os atributos de um widget. A classe que define um componente visual deve estender da classe widget.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"I'am a Server-Driven text\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"I'am another a Server-Driven text\" } ], \"id\" : \"WidgetID\", \"style\" : { \"backgroundColor\" : \"#ff8100\", \"cornerRadius\" : { \"radius\" : 25.0 }, \"size\" : { \"width\" : { \"value\" : 70.0, \"type\" : \"PERCENT\" }, \"height\" : { \"value\" : 80.0, \"type\" : \"REAL\" } }, \"margin\" : { \"all\" : { \"value\" : 20.0, \"type\" : \"REAL\" } }, \"padding\" : { \"all\" : { \"value\" : 15.0, \"type\" : \"REAL\" } }, \"position\" : { \"left\" : { \"value\" : 0.0, \"type\" : \"REAL\" } }, \"flex\" : { \"flexDirection\" : \"ROW\" }, \"positionType\" : \"RELATIVE\", \"display\" : \"FLEX\" }, \"accessibility\" : { \"accessible\" : true, \"accessibilityLabel\" : \"I have acessibility\" } }  Container( listOf( Text(\"I'am a Server-Driven text\"), Text(\"I'am another Server-Driven text\") ) ).applyStyle( Style(backgroundColor = \"#ff8100\", cornerRadius = CornerRadius(25.0), size = Size(width = 70.unitPercent(), height = 80.unitReal()), margin = EdgeValue(all = 20.unitReal()), padding = EdgeValue(all = 15.unitReal()), position = EdgeValue(0.unitReal()), flex = Flex(FlexDirection.ROW), positionType = PositionType.RELATIVE, display = Display.FLEX) ).applyAccessibility(accessibility = Accessibility( accessible = true, accessibilityLabel = \"I have acessibility\") ).setId(\"WidgetID\")  üëá Teste esse componente no Web Playground {% embed url=‚Äúhttps://beagle-playground.netlify.app/#/demo/default-components/container.json‚Äù %}}\n","excerpt":" O que √©? O Widget √© uma classe abstrata que permite que um componente ‚Ä¶","ref":"/docs-beagle/pt/docs/api/widget/","title":"Widget"},{"body":" O que √© o Beagle? O Beagle √© um Framework open source de desenvolvimento cross-platform pautado no paradigma de implementa√ß√£o de um Server-Driver UI nativamente no iOS e Android. Voc√™ pode facilmente mudar o layout e DATAda sua aplica√ß√£o mudando apenas o c√≥digo da tela no backend.\nComo o Beagle funciona? O desenvolvedor declara telas no backend e exp√µe endpoints que representam essas telas. No celular ou na web, esses endpoints s√£o chamados usando o Beagle para renderizar os componentes na tela.\nBeagle funciona como uma ‚Äúponte‚Äù entre o front e o backend possibilitando que componentes de design da aplica√ß√£o sejam parametrizado ao backend, com possibilidade de aplica√ß√£o nativa.\nA arquitetura do meu aplicativo mudar√° se eu usar o Beagle? N√£o, o Beagle √© agn√≥stico em rela√ß√£o a arquitetura e n√£o interfere na arquitetura do projeto em que √© utilizado.\nPor que usar o Beagle e n√£o o React Native ou Flutter? A solu√ß√£o do Beagle √© diferente de outras tecnologias. √â uma ferramenta para facilitar o desenvolvimento, tem o conceito de UI orientada a servidor e entrega cont√≠nua. O Beagle permite que voc√™ manipule, atrav√©s do backend, componentes nativos de sua aplica√ß√£o, modifique os layout e a exibi√ß√£o desses componentes.\n√â poss√≠vel realizar testes em telas server driven? Sim! Testes unit√°rios como testes instrumentados funcionam da mesma forma com o Beagle.\nPosso usar o Beagle em um aplicativo que j√° possui v√°rios recursos desenvolvidos? Sim! Se a sua aplica√ß√£o j√° tiver componentes desenvolvidos em um design system voc√™ poder√° utiliz√°-los no Beagle. Para tal, basta somente que eles estejam definidos de maneira componentizada e ai ser√£o facilmente registrados no Beagle.\nUm aplicativo que usa o Beagle precisa ser 100% Server Driven? N√£o, a aplica√ß√£o pode utilizar uma tela Server Driven ‚Äã‚Äãem apenas alguns fluxos do aplicativo. Voc√™ pode continuar em um fluxo Server Driven ou voltar √† tela nativa normalmente.\nPreciso usar o Beagle em todo o aplicativo? N√£o, a sua aplica√ß√£o continua a mesma e ela pode ser utilizada nativamente mesmo com o Beagle registrado nela. Voc√™ pode usar o Beagle onde e quando quiser!\nMeu aplicativo funcionar√° offline? Depende. Toda aplica√ß√£o Server Driven ao requisitar um fluxo do servidor precisa estar conectada a internet no momento da requisi√ß√£o para obter uma resposta do backend. Os fluxos Server Driven n√£o podem ser resolvidos sem uma conex√£o. Mas a sua aplica√ß√£o n√£o √© 100% Server Driven, a parte dela que n√£o precisa coletar informa√ß√µes online funcionar√° normalmente. E pode at√© ser configurada para chamar outras telas caso esteja offline.\nE se a internet cair no meio do fluxo da aplica√ß√£o? A maneira de lidar com casos de desconex√£o √© criar telas declarativas locais para fallback.\nTerei problemas para fazer o upload do aplicativo com o Beagle na App Store ou na Play Store? N√£o! De maneira alguma. Todos os componentes utilizados estar√£o definidos na aplica√ß√£o quando o upload para a loja for realizado. Embora o Beagle ofere√ßa dinamismo ao lidar com as atualiza√ß√µes, essa qualidade est√° atrelada a manipula√ß√£o do backend e n√£o oferecemos nada na configura√ß√£o do frontend que seja vol√∫vel o suficiente para justificar algum tipo de bloqueio pela Apple ou Google ao atualizar um aplicativo na loja. Uma das principais propostas do Beagle √© exatamente minimizar a necessidade de deploys na loja.\nTerei problemas de performance com o Beagle? N√£o, muito pelo contr√°rio! N√≥s fizemos um benchmark de renderiza√ß√£o com outras estrat√©gias nativas - como Auto Layout (IOS) e o Constraint Layout (Android) - e o Beagle, usando o mecanismo Yoga Layout para posicionar elementos na tela, teve a melhor resposta.\nMinha aplica√ß√£o n√£o ficar√° mais lenta com os tempos de resposta do backend? N√£o, pois o Beagle usa o mecanismo de cache para armazenar as telas adjacentes √† tela atual. Isso permite otimizar as chamadas para o backend e, portanto, n√£o precisa solicitar novamente ao backend no momento do clique do usu√°rio.\nQual a vers√£o mais atual do Beagle? A vers√£o mais atual do Beagle:undefined\nO Beagle √© gratuito? Sim! Por ser um framework de desenvolvimento open source, o Beagle √© totalmente gratuito.\nPosso criar um BFF em um linguagem diferente que n√£o seja JVM? √â poss√≠vel criar um BFF em uma linguagem diferente. Por√©m, por enquanto n√£o temos libs prontas para auxiliar neste processo. Por isso, √© necess√°rio que o programador crie algum mecanismo para que os contratos do Beagle sejam respeitados.\nQuais vantagens de usar o Beagle? Uma das principais vantagens do Beagle √© facilitar o desenvolvimento a partir do paradigma BFF.\nIsso significa que o Beagle te permite modificar os layouts das telas da sua aplica√ß√£o, os fluxos entre telas e a navega√ß√£o na sua aplica√ß√£o. Tudo isso √© feito a partir de p√°ginas criadas declarativamente no seu BFF que, a partir de uma biblioteca de componentes definidas no frontend da sua aplica√ß√£o, auxilia na altera√ß√£o da interface.\nCom isso, voc√™ pode:\n Decidir qual componente visual deve ser apresentado: quais textos, legendas ou qualquer outra informa√ß√£o visual que deva ser exibida, centralizada e abstra√≠da no servidor.  Isso evita a replica√ß√£o em cada plataforma frontend que consome essa API. O servidor aplica essa l√≥gica de neg√≥cios e usa seus resultados para montar a resposta da API JSON representando-o.\n Fazer testes A/B para mudar a ordem em que os componentes s√£o apresentados.  Posso usar o Beagle desenvolver aplicativos para Android, iOS ou Web? Sim! Por ser um framework cross-platform, Beagle te auxilia a desenvolver aplica√ß√µes nestas tr√™s plataformas utilizando o conceito de Server-Driven UI, o que torna poss√≠vel que um mesmo BFF seja utilizado para as 3 aplica√ß√µes.\nVoc√™ pode ver mais sobre como criar projetos no Beagle para as 3 plataformas em:\n Beagle for Android  Beagle for iOS Beagle for Web  Posso fazer testes unit√°rios e instrumentados em telas Server-Driven? Sim! Testes unit√°rios e instrumentais s√£o realizados normalmente quando usamos o Beagle. A estrutura do Beagle n√£o interfere em como os testes s√£o realizados.\nComo fazer testes unit√°rios usando Beagle? Testes unit√°rios t√™m o objetivo de aferir a funcionalidade do c√≥digo, em sua menor fra√ß√£o. Os testes em aplica√ß√µes que utilizam o Beagle s√£o feitos da mesma forma que em aplica√ß√µes que n√£o o utilizem. Isso significa que o Beagle n√£o interfere de maneira alguma na realiza√ß√£o dos testes.\nComo fazer testes instrumentados? Testes instrumentados s√£o feitos em aplica√ß√µes usando Beagle da mesma forma que em outras aplica√ß√µes que n√£o utilizam. No entanto, √© importante salientar que, muitas vezes, um componente server-driven pode n√£o conter um ID que geralmente a identifica em um teste instrumentado.\nPensando nisso, adicionamos ao elemento WIDGET (que referencia um componente) um atributo ID para que seja poss√≠vel identific√°-lo programaticamente.\n","excerpt":" O que √© o Beagle? O Beagle √© um Framework open source de ‚Ä¶","ref":"/docs-beagle/pt/docs/faq/","title":"FAQ"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/release-notes/","title":"Release Notes"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/search/","title":"Resultado da Pesquisa"},{"body":"","excerpt":"","ref":"/docs-beagle/search/","title":"Search Results"}]