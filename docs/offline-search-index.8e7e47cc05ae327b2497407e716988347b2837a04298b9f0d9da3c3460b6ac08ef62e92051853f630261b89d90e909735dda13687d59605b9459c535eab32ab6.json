[{"body":" What is Beagle? Beagle is an open source framework of cross-platform development based on the implementation paradigm of Server-Driven UI.\nThe main gain Beagle gives you is to allow teams to make layout and data changes directly in native mobile or web applications by changing the code on backend.  In this way, it’s possible to create, test and quickly update native application’s components without need to approve this changes on the store (App Store or Play Store).\nVersioning Beagle’s version follow the semantic versioning concept. The documentation is versioned according to the major Beagle version, meaning the main version. Between platforms, the features compatibility is by the minor version. For example, it is possible to use 1.0.0 in the backend with 1.0.1 on Android, 1.0.2 on iOS and 1.0.3 on the web react.\nBeagle’s current releases version are:\n Android: iOS: WEB:  Angular: React:   Backend   Some definitions on this documentation exists only only in some specific minors or patches. See the captions used to denote these cases:\n x.y.z: an exclusive definition of the version x.y.z; \u003e=x.y.z: existing definition from x.y.z version; \u003c=x.y.z: existing definition until the x.y.z version.  How does Beagle works? The tool works as a facilitator of BFF (Backend For Frontend). This means that Beagle, from a library of components defined in the Design System of the Android, iOS or Web application, makes the visual and behavioral change of them by returning a JSON file that indicates what and where each component should be rendered and which the action they are going to perform.\nThe reason Beagle is able to make this change from the frontend from the backend is because its architecture is structured in Server-Driven UI, where BFF constructs the data, components and actions present on the screen declaratively and forwards them in JSON format , while the front deserializes it, renders the visual components natively in addition to executing and assigning the actions present in each of them.\nBeagle’s Pillars Considering that it’s a tool based on Server-Driven, the JSON objects configured to run your application can be organized in 3 basic pillars:\n Content Visual Structure Flow (or Actions)  After defining in the frontend and backend how the visual structure of the application will be with the customized components and actions, as well as how they can be changed, the BFF will be able to communicate with the front.\nIn this way, new features, flows, customizations and combinations of visual components can be tested without the need to publish updates to the application, optimizing type A / B tests.\nWhy use Beagle? Beagle was created to optimize time and resources for development’s, design’s and business' teams to publish and keep updated their applications without need to approve it on App Store or Play Store and, also, respecting the application’s design system.  The main advantages of using Beagle on your project are:\n More flexibility at work, specially among developers and UI/UX designers when it’s necessary to make pontual changes. Easy app maintenance which enables to make constant tests to improve your application. Minor risks of duplicate code because all consumption of APIs, flows and rules will be in one place, BFF.  Another fundamental gain is that Beagle allows you to reduce user’s feedback time, once that the changes are quickly done, tested and validated.\n","excerpt":" What is Beagle? Beagle is an open source framework of cross-platform …","ref":"/docs-beagle/docs/overview/","title":"Overview"},{"body":" O que é o Beagle? O Beagle é um framework open source de desenvolvimento cross-platform pautado no paradigma de implementação de Server-Driven UI.\nO principal ganho da ferramenta é permitir que as equipes façam alterações de layout e de dados direto em aplicações nativas mobile e/ou web modificando apenas o código no backend.  Dessa forma, é possível criar, testar e atualizar rapidamente os componentes de aplicações nativas sem a necessidade de passar pela loja (App Store ou Play Store).\nVersionamento  As versões do Beagle seguem o conceito de versionamento semântico. A documentação, em si, é versionada de acordo com a versão major (maior) do Beagle, ou seja, com a versão principal. Entre as plataformas, a compatibilidade de features é pela versão minor. Por exemplo, é possível usar a 1.0.0 no backend com a 1.0.1 no Android, a 1.0.2 no iOS e a 1.0.3 no web react.\nAs versões de release atuais do Beagle são:\n Android: iOS: WEB:  Angular: React:   Backend   Algumas definições nessa documentação existem apenas em algumas minors ou patches específicas. Segue a legenda usada para denotar esses casos:\n x.y.z: designa uma definição exclusiva da versão x.y.z; \u003e=x.y.z: designa uma definição existente a partir da versão x.y.z; \u003c=x.y.z: designa uma definição existente até a versão x.y.z.  Como funciona o Beagle? A ferramenta atua como um facilitador do BFF (Backend For Frontend) Isso significa que o Beagle, a partir de uma biblioteca de componentes definidos no Design System da aplicação Android, iOS ou Web, faz a alteração visual e comportamental delas ao retornar um arquivo JSON que indica o que e onde deve ser renderizado cada componente e qual a ação que vão executar.\nO motivo pelo qual o Beagle consegue fazer essa alteração do frontend a partir do backend é porque sua arquitetura está estruturada em Server-Driven UI, onde o BFF constrói os dados, componentes e ações presentes na tela de forma declarativa e os encaminha no formato JSON, enquanto o front o desserializa, renderiza os componentes visuais de forma nativa além de executar e atribuir as ações presentes em cada um deles.\nPilares do Beagle Por se tratar de uma ferramenta pautada em Server-Driven UI, os objetos JSON configurados para rodar na sua aplicação podem ser divididos em 3 pilares básicos:\n Conteúdo Estrutura Visual Flow (ou Ações)  Depois de definido no frontend e no backend como será a estrutura visual da aplicação com os componentes e ações customizados, bem como como eles poderão ser alterados, o BFF estará apto a se comunicar com o front.\nDessa forma, novas features, fluxos, customizações e combinações de componentes visuais podem ser testados sem a necessidade de publicar atualizações no aplicativo, otimizando testes de tipo A/B.\nPor que usar o Beagle? O Beagle foi criado com objetivo de otimizar tempo e recurso das equipes de desenvolvimento, design e negócios para publicar e manter atualizados seus aplicativos sem a necessidade de passar por App Store ou Play Store e, ainda assim, respeitar o Design System da aplicação.  Sendo assim, as principais vantagens que o Beagle traz para seu projeto são:\n Maior flexibilidade de trabalho entre desenvolvedores frontend, backend e UI/UX designers no momento de realizar alterações pontuais. Facilidade de manutenção do app, além de possibilitar a realização constante de testes para melhoria da sua aplicação. Menos duplicação de códigos, pois todo o consumo das APIs, fluxos e regras estarão em um único lugar, o BFF.  Outro ganho fundamental que o Beagle traz, é a possibilidade de reduzir o tempo de feedback do usuário, já que as mudanças são rapidamente testadas e validadas.\n","excerpt":" O que é o Beagle? O Beagle é um framework open source de …","ref":"/docs-beagle/pt/docs/vis%C3%A3o-geral/","title":"Visão Geral"},{"body":" Backend For Frontend Also known as BFF, it is the server that makes it possible to send JSON objects to be rendered and, consequently, viewed on the frontend. This component allows screens and business rules to be written only once and then to be rendered natively on each platform where Beagle is present. The consumption of the APIs that provide the data for the application before executed by the fronts, is now the responsibility of BFF.\nDeclarative Views Paradigm in which layouts are built in a simplified way, since, the focus is on what the layout should be, letting Beagle solve its configuration. These declarative layouts are built using widgets both on BFF and Android written in Kotlin and on iOS in Swift.\nDesign System It is the structure that contains all the standard components and properties for a product or service. In development, it is essential that the Design System repository keep component styles, resources and themes of that application in one place.\nIn order for Beagle to work with the Design System of your application, it is necessary to have all of these styles implemented so that they can be viewed the moment the files are rendered.\nLayout Engine Tool that takes care of rendering the native visual elements of an application. When Beagle deserializes the information contained in JSON, the layout engine comes into play by rendering the components generated based on the Design System of the application. Beagle uses Yoga Layout to natively render components on Android and iOS platforms and build their respective layouts using Flexbox concepts.\nServer-Driven UI It is the concept in which a specific backend (BFF) consumes the application data and supplies it to the frontend together with their respective visual structures through one or more JSONs, that is, it not only informs the content of the screen, but also its structure , in addition to the flow of these pages if any.\n","excerpt":" Backend For Frontend Also known as BFF, it is the server that makes …","ref":"/docs-beagle/docs/key-concepts/","title":"Key concepts"},{"body":" Backend For Frontend Conhecido também como BFF, é o servidor que possibilita enviar objetos JSON para serem renderizados e, consequentemente, visualizados no frontend. Este componente permite que telas e regras de negócio sejam escritas uma única vez para, em seguida, serem renderizadas de forma nativa em cada plataforma onde o Beagle está presente. O consumo das APIs que proveem os dados para a aplicação antes executado pelos fronts, agora é de responsabilidade do BFF.\nDeclarative Views Paradigma no qual os layouts são construídos de forma simplificada, uma vez que, o foco está no quê o layout deve ser, deixando o Beagle resolver sua configuração. Esses layouts declarativos são construídos usando widgets tanto no BFF e Android escritos em Kotlin e no iOS em Swift.\nDesign System É a estrutura que contém todos os componentes e propriedades padrão para um produto ou serviço. No desenvolvimento, é essencial que o repositório Design System mantenha em um só lugar estilos de componentes, resources e temas daquela aplicação.\nPara que o Beagle possa trabalhar com o design system da sua aplicação, é necessário ter todos esses estilos implementados para que eles possam ser visualizados no momento em que os arquivos forem renderizados.\nLayout Engine Ferramenta que cuida da renderização dos elementos visuais nativos de uma aplicação. Quando o Beagle desserializa as informações contidas no JSON, o layout engine entra em ação renderizando os componentes gerados com base no Design System da aplicação. O Beagle usa oYoga Layout para renderizar nativamente os componentes nas plataformas Android e iOS e construir seus respectivos layouts através dos conceitos do Flexbox.\nServer-Driven UI É o conceito no qual um backend específico (BFF) consome os dados da aplicação e os fornece ao frontend junto com suas respectivas estruturas visuais através de um ou mais JSONs, ou seja, ele não só informa o conteúdo da tela, mas também sua estrutura, além do fluxo dessas páginas se houver.\n","excerpt":" Backend For Frontend Conhecido também como BFF, é o servidor que …","ref":"/docs-beagle/pt/docs/principais-conceitos/","title":"Principais conceitos"},{"body":" Para iniciar as configurações do Beagle na sua máquina, siga os passos para cada sistema operacional. Aqui também listamos as configurações do backend, que será o BFF:\n","excerpt":" Para iniciar as configurações do Beagle na sua máquina, siga os …","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/","title":"Instalando o Beagle"},{"body":" To start the Beagle’s configuration on your machine, follow the steps to each operational system. Here we also list the settings of the backend, which will be the BFF:\n","excerpt":" To start the Beagle’s configuration on your machine, follow the steps …","ref":"/docs-beagle/docs/get-started/installing-beagle/","title":"Installing Beagle"},{"body":" Requirements Before you start to configure Beagle for your Android system, it’s important to check out if you have installed all the current versions of the following programs: ‌\n JDK 8 language Android API level: at least 19 or higher Kotlin 1.3+  Step 1: Dependencies' configuration You have to adjust your repository’s dependencies to receive Beagle. To do so, use the following configurations to download library.\n// Add it in your root build.gradle at the end of repositories: allprojects { repositories { google() jcenter() // \u003c 1.1.0  maven { url 'https://dl.bintray.com/zupit/repo'  } // \u003e= 1.1.0  mavenCentral() } }  The above configuration must be added toallprojects{}  Step 2: Include plugins Once you made the first configuration, now you have to include the kapt and Beagle’s plugin as dependencies on your dependency manager.\nThe current release version of Beagle is\n// Add in your plugins apply plugin: 'kotlin-kapt'​ android { kotlinOptions { jvmTarget = JavaVersion.VERSION_1_8 } } // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" Insert the Beagle’s release version on the place of${beagle.version}, in other words, put the Beagle’s version highlighted in blue badge above without the v character.\nFor example: undefined-ext.beagle.version = \"0.2.8\"\nRemember to always check if you’re using the latest version of Beagle. To see this information, you just have to pass your mouse above the version number. After that, sync your machine.  Next Steps On this section, you made Beagle’s initial installation on your application!\nTo keep configuring Beagle:\n👉Go toinitial configurations to enable the use of Beagle on your Android project.\n👉 If you want to go straight to practice, access our tutorial to create a project from zero.\n","excerpt":" Requirements Before you start to configure Beagle for your Android …","ref":"/docs-beagle/docs/get-started/installing-beagle/android/","title":"Android"},{"body":" Requisitos Antes de configurar o Beagle para o seu sistema Android, é importante que você confirme as versões dos programas que estão instalados na sua máquina. Para a ferramenta funcionar, é necessário ter as seguintes versões: ‌\n JDK 8 language Android API level: pelo menos a 19 ou superior Kotlin 1.3+  Passo 1: Configurar as dependências Você precisa ajustar as dependências do seu repositório para receber o Beagle. Para isso, utilize as configurações abaixo para fazer o download da biblioteca.\n// Add it in your root build.gradle at the end of repositories: allprojects { repositories { google() jcenter() // \u003c 1.1.0  maven { url 'https://dl.bintray.com/zupit/repo'  } // \u003e= 1.1.0  mavenCentral() } }  A configuração acima deve ser adicionada emallprojects{}  Passo 2: Incluir os plugins Uma vez feita a primeira configuração, agora você precisa incluir o plugin do kapt e do Beagle como dependências dentro do seu gerenciador de dependências.\nA versão atual do Beagle\n// Add in your plugins apply plugin: 'kotlin-kapt' android { kotlinOptions { jvmTarget = JavaVersion.VERSION_1_8 } } // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" } Insira a versão de release do Beagle no lugar de ${beagle.version}, ou seja, coloque a versão do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os números de versão.\nPor exemplo: undefined-ext.beagle.version = \"0.2.8\"\nLembre de sempre verificar se você está usando a versão mais recente do Beagle. Para saber disso, basta passar o mouse por cima do número da versão. Depois disso, sincronize com sua máquina.  Próximos Passos Nesta seção, você fez a instalação inicial do Beagle na sua aplicação!\nPara continuar a configurar o Beagle:\n👉Vá para as configurações iniciais para habilitar uso do Beagle no seu projeto Android\n👉 Se quiser ir direto para prática, acesse nosso tutorial para criar um projeto do zero\n","excerpt":" Requisitos Antes de configurar o Beagle para o seu sistema Android, é …","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/android/","title":"Android"},{"body":" Requirements Before you start to configure Beagle for your iOS system, it’s important to check out if you have installed all the current versions of the following programs: ‌\n iOS 10.0+ Xcode 11.0+ Swift 5.0+  Dependencies' Management Currently, Beagle is available for integrations through Carthage and CocoaPods.\nRemember to always check if you’re using the latest version of Beagle and, mostly, check if the different platforms you’re using are integrated to the same Beagle’s version. In this way, you ensure that all the tools are correctly communicating with each other.  Installation with CocoaPods To integrate Beagle with your application through CocoaPods, you have to add the framework as a dependency of your Podfile.\nCurrent Beagle’s version**:**\nThis process must be done in the following way:\npod 'Beagle' pod 'YogaKit', :git =\u003e 'https://github.com/ZupIT/YogaKit'  In the case of YogaKit, you must use our fork because some changes are not merged yer at Facebook’s repository.  Installation with Carthage Step 1: Integrate with your application To integrate Beagle with your application through Carthage, you have to add the framework as a dependency on your Cartfile.\nThis process must be done in the following way:\ngithub \"ZupIT/beagle\" ~\u003e 1.0.1  After an important release, we’ll probably lauch versions with specific bug fixes for iOS, in which will have a version tag followed the sufix “-iOS” (e.g: “1.0.1-iOS”).  Step 2: Build on dependencies After the integration, you must follow the normal process of building with Carthage on your dependencies. The expected is that you receive some .framework files.\nIn Beagle’s case, the mandatory files to make you application work are:\n Beagle.framework BeagleSchema.framework YogaKit.framework  Other frameworks can be used only in more specific scenarios.\nNext Steps On this section, you made Beagle’s initial installation on your application!\nTo keep configuring Beagle:\n👉To keep knowing Beagle and test if everything worked with the installation, go to initial configurations and create your first Hello World!\n👉 If you want to go straight to practice, access our tutorial to create a project from zero.\n","excerpt":" Requirements Before you start to configure Beagle for your iOS …","ref":"/docs-beagle/docs/get-started/installing-beagle/ios/","title":"IOS"},{"body":" Requisitos Antes de configurar o Beagle para o seu sistema iOS, é importante que você confirme as versões dos programas que estão instalados na sua máquina. Para o Beagle funcionar, é necessário ter as seguintes versões:\n iOS 10.0+ Xcode 11.0+ Swift 5.0+  Gerenciamento de dependências Hoje o Beagle está disponível para integração através do Carthage e CocoaPods\nLembre de sempre usar a versão mais recente do Beagle e, principalmente, de checar se as diferentes plataformas estão integradas à essa mesma versão. Dessa forma, você garante que todas as ferramentas estão se comunicando corretamente.  Instalação com CocoaPods Para integrar o Beagle à sua aplicação através do CocoaPods você precisa adicionar o framework como dependência no seu Podfile.\nVersão atual do Beagle:\nEste processo pode ser feito da seguinte maneira:\npod 'Beagle' pod 'YogaKit', :git =\u003e 'https://github.com/ZupIT/YogaKit'  No caso do YogaKit, você precisa utilizar o nosso fork porque algumas modificações ainda não foram mergeadas no repositório do Facebook.  Instalação com Carthage Passo 1: Integrar com sua aplicação Para integrar o Beagle à sua aplicação através do Carthage você precisa adicinar o framework como dependência no seu Cartfile.\nO processo pode ser feito da seguinte maneira:\ngithub \"ZupIT/beagle\" ~\u003e 1.0.1-iOS  Depois de uma release importante, podemos lançar algumas versões com bug fixes específicas para o iOS, as quais estarão com a tag da versão seguida com o sufixo “-iOS” (e.g: “1.0.1-iOS”).  Passo 2: Build nas dependências Depois de integrado, você deve seguir com o processo normal de build do Carthage nas suas dependências. O esperado é que você receba alguns arquivos .framework como resultado.\nNo caso do Beagle, os arquivos obrigatórios para que a sua aplicação funcione são:\n Beagle.framework BeagleSchema.framework YogaKit.framework  Outros frameworks são utilizados apenas em cenários de uso mais específicos.\nPróximos Passos Nesta seção, você fez a instalação inicial do Beagle na sua aplicação!\nPara continuar a configurar o Beagle:\n👉Para continuar conhecendo o Beagle, e testar se deu tudo certo com a instalação, vá para as configurações iniciais e crie seu primeiro Hello Beagle!\n👉 Se quiser ir direto para prática, acesse nossotutorial para criar um projeto do zero\n","excerpt":" Requisitos Antes de configurar o Beagle para o seu sistema iOS, é …","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/ios/","title":"IOS"},{"body":" Introduction Unlike mobile application’s configurations, to install Beagle for Web does not demand previous requirements. You just have to follow the steps of Beagle’s framework installation according to the framework you use on your projects:\n Angular  React   Angular Beagle Angular’s current**:**\nStep 1: Install Beagle’s library To follow the installation process, navigate to the root of your angular project and run one of the commands below according to the package manager of your preference.\nIf you useYarn:\nyarn add @zup-it/beagle-angular If you use npm:\nnpm install --save @zup-it/beagle-angular Step 2: Verify the installation To confirm if the process worked, you simply have to use one of the commands below:\nyarn beagle help npx beagle help If the Beagle’s commands were listed as in the image below, that means that the installation worked correctly.\nWell done! Your library was installed. Now, you can see more of how to use Beagle on Angular.  React Beagle React’s current version**:**\nStep 1: Install Beagle’s library To follow the installation process, navigate to the root of your react project and run one of the commands below according to the package manager of your preference.\nIf you useYarn:\nyarn add @zup-it/beagle-react If you use npm:\nnpm install --save @zup-it/beagle-react  Well done! Your library was installed. Now, you can see more of how to use Beagle on React.  Next Steps On this section, you made Beagle’s initial installation on your application!\nTo keep configuring Beagle:\n👉Go to initial configurations to enable the use of Beagle on your Web project.\n👉 If you want to go straight to practice, access our tutorial to create a projeto from zero.\n","excerpt":" Introduction Unlike mobile application’s configurations, to install …","ref":"/docs-beagle/docs/get-started/installing-beagle/web/","title":"WEB"},{"body":" Introdução Ao contrário das configurações para aplicações mobile, o Beagle para Web não exige requisitos prévios. Basta apenas seguir com os procedimentos de instalação de acordo com o framework que estiver utilizando:\n Angular  React   Angular Versão atual do Beagle Angular:\nPasso 1: Instalar a biblioteca Beagle Para seguir com o processo de instalação, navegue até a raiz do seu projeto angular e execute um dos comandos abaixo de acordo com o gerenciador de pacotes de sua preferência.\nCaso utilize oYarn:\nyarn add @zup-it/beagle-angular Caso utilize o npm:\nnpm install --save @zup-it/beagle-angular Passo 2: Verificar a instalação Para confirmar se o processo funcionou, basta executar um dos comandos abaixo:\nyarn beagle help npx beagle help Se os comandos do Beagle forem listados como na imagem abaixo, isso significa que a instalação ocorreu corretamente.\nParabéns, a sua biblioteca está instalada! Veja agora como usar o Beagle no Angular  React Versão atual do Beagle React:\nPasso 1: Instalando a biblioteca Beagle Para seguir com o processo de instalação, navegue até a raiz do seu projeto e execute um dos comandos abaixo de acordo com o gerenciador de pacotes de sua preferência.\nCaso utilize oYarn:\nyarn add @zup-it/beagle-react Caso utilize o npm:\nnpm install --save @zup-it/beagle-react  Parabéns, a sua biblioteca está instalada! Veja agora como usar Beagle no React.  Próximos Passos Nesta seção, você fez a instalação inicial do Beagle na sua aplicação!\nPara continuar a configurar o Beagle:\n👉Vá para as configurações iniciais para habilitar uso do Beagle no seu projeto Web\n👉 Se quiser ir direto para prática, acesse nossotutorial para criar um projeto do zero\n","excerpt":" Introdução Ao contrário das configurações para aplicações mobile, o …","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/web/","title":"WEB"},{"body":" Before you get started, you must know that the steps below are for JVM languages.\nFor other languages, your server needs to serve JSON following our API. Also, check out our cache and platform specification mechanisms, which you may wish to implement as the clients already support them.\n Requirements Before you integrate Beagle to your application to run it on the backend, it’s important to check out if you have installed all the current versions of the following programs:\n JDK 8+ language (Kotlin 1.3+ is recommended) Maven 3+ Jackson 2+  If you already have updated all the programs above, then just go to the following instructions.\nInstallation Step 1: Create a micro-service When you create a micro-service, we recommend using your team’s established mechanisms. If that’s not your case, you can just follow the configurations below.\nIf your team works with micro-services using a framework other than Spring or Micronaut, see Beagle Framework instead.  For a simple setup, you can choose between 2 frameworks to create your BFF:\nMicronaut  A modern, JVM-based, full-stack framework for building modular, easily testable micro-service and serverless applications.\n Spring  Spring makes programming Java quicker, easier, and safer for everybody. Spring’s focus on speed, simplicity, and productivity has made it the world’s most popular Java framework.\n Once you choose the framework you’ll work with, proceed with the configurations below:\nMicronaut Spring Creating a micro-service Micronaut \u003c= 1.3 As described on Micronaut’s quick start, create your application through a CLI tool with this command:\n$ mn create app bff --build maven --lang kotlin This will create an executable Micronaut project using Kotlin and Maven in a directory called bff. Open this project on the chosen IDE and follow the following steps to set the dependencies.\nMicronaut \u003e= 2.0 If you want to use Micronaut 2.0, you can use the new website, very similar to Spring.\n Click on the link below to download a zip file of the project with the image’s option below: Micronaut Launch para Beagle Micronaut Starter.   This configuration uses:  Kotlin with Maven forJava 8 (compatible with this version); Junit like the unit tests library.   Unzip the file and open the extracted folder in your IDE.   Create a micro-service Use Spring’s Initializr to create a project for your micro-service. Click the following link, Spring Initializr for Beagle Spring Starter, to get recommended settings.\n These settings are:  Maven dependency manager; Kotlin with JAR packaging and Java 8+ compatibility; Spring Boot Actuator dependency.   Click GENERATE to download a zip file containing your project. Unzip the file and open the extracted folder in your IDE.   Step 2: Configure dependencies (\u003c 1.1.0) Once you created and configured the micro-services, you have to add the address of our nexus. To do so, add the following to your pom.xml, found in the root of the generated project:\n\u003crepositories\u003e \u003crepository\u003e \u003cid\u003ebintray-zupit-repo\u003c/id\u003e \u003curl\u003ehttps://dl.bintray.com/zupit/repo\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e Step 3: Include starter dependency Lastly, you have to add the dependency for the Beagle starter to your backend. In that case, the framework you chose will define the dependency’s name (artifactId) should be done.\nClick on the tab of the framework you’re using and follow the steps to continue the configuration.\nMicronaut Starter Spring Starter Additional Requirements: This starter also configures version 1.3.3 of**micronaut-runtime**module in your BFF\n To follow this requirement, you just have to add the dependency below to your pom.xml.\n The current release version of Beagle is:   \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003ebeagle-micronaut-starter\u003c/artifactId\u003e \u003cversion\u003e${beagle.version}\u003c/version\u003e \u003c/dependency\u003e  Additional Requirements: This starter also configures version 2.2.5 of**spring-boot-starter-web**module in your BFF\n To follow this requirement, you just have to add the dependency below to your pom.xml.\n To check which Beagle’s version is:  \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003ebeagle-spring-starter\u003c/artifactId\u003e \u003cversion\u003e${beagle_version}\u003c/version\u003e \u003c/dependency\u003e Insert the Beagle’s release version on the place of${beagle.version}, in other words, put the Beagle’s version highlighted in blue badge above without the v character.\nFor example:\n-ext.beagle.version = \"0.2.8\"\nRemember to always check if you’re using the latest version of Beagle. To see this information, you just have to pass your mouse above the version number. After that, sync your machine.\n Well done, your initial configuration is ready to be used!\nYou can check a screen or server-driven componentto test the BFF.\nSpring Boot has a known problem involving WebMvcConfigurationSupport. Its presence replaces other configurations, including the ones in Beagle’s Spring Starter.\nIn case you face a similar problem, we suggest you replace it forWebMvcConfigurer.\nTo see more about it, access this issue on Github.\nThe annotation@EnableWebMvccauses the same problem, which means that you should replace it.\n  Well done, your initial configuration is ready to be used!  You can see more of how to use Beagle on the backend or how to test a BFF with server-driven components.\nNext Steps On this section, you made Beagle’s initial installation on your application!\nTo keep configuring Beagle:\n👉Go to initial configurations to enable the use of Beagle on your Web project.\n👉 If you want to go straight to practice, access our tutorial to create a projeto from zero.\n","excerpt":" Before you get started, you must know that the steps below are for …","ref":"/docs-beagle/docs/get-started/installing-beagle/backend/","title":"Backend"},{"body":" Antes de iniciar a instalação, é importante você saber que as etapas abaixo são para linguagens da JVM.\nPara outras linguagens, seu servidor precisa servir o JSON seguindo nossa API. Dê uma olhada também na nossa implementação de cache e em mecanismos específicos de cada linguagem\n Requisitos Antes de integrar o Beagle à sua aplicação para rodá-lo no backend, é importante validar se sua máquina está com as versões corretas instaladas dos seguintes softwares:\n JDK 8+ language (Kotlin 1.3+ é recomendado) Maven 3+ Jackson 2+  Se você já tiver atualizado todos estes programas, basta seguir as instruções abaixo.\nInstalação Passo 1: Criar um microsserviço No momento de criar o microsserviço, recomendamos que você utilize os mesmos mecanismos estabelecidos. Caso este não seja o seu caso, então basta seguir as configurações abaixo.\nSe o seu time trabalha com microsserviços usando outros frameworks, acesse o framework do Beagle.  Para uma configuração simples, você pode escolher entre 2 modelos de frameworks para criar seu BFF:\nMicronaut   É um framework full-stack moderno baseado em JVM para construção modular. Fácil de testar em microsserviços e com aplicações sem servidor (serverless).\n Spring  É um framework que permite programação em Java mais rápida, fácil e segura para todos. É focada em velocidade, simplicidade e produtividade, o que o tornou o framework Java mais popular.\n Depois de selecionar com qual framework deseja seguir, prossiga com as configurações abaixo:\nMicronaut Spring Criando um microsserviço Micronaut \u003c= 1.3 Conforme descrito no quickstart do Micronaut, crie seu aplicativo através da ferramenta de CLI com o seguinte comando:\n$ mn create-app bff --build maven --lang kotlin Isso criará um projeto Micronaut executável usando Kotlin e Mavenem um diretório chamado bff. Abra este projeto na IDE que escolher e siga o passo 2 para configurar as dependências.\nMicronaut \u003e= 2.0 Caso queira adotar o Micronaut 2.0, pode usar o novo site de construção de projeto, semelhante ao do Spring.\n Clique no link a seguir para baixar um zip do projeto com as opções da imagem abaixo: Micronaut Launch para Beagle Micronaut Starter.   Essa configuração inicial utiliza:  Kotlin com Maven paraJava 8 (compatível com essa versão); Junit como biblioteca de testes unitários.   Descompacte o arquivo na pasta que escolher para conter seu projeto BFF e abra o seu projeto na IDE de sua preferência.   Criando um microsserviço Neste caso, usaremos o site do Spring para gerar um projeto com o microsserviço já criado:\n Clique no link a seguir e você verá a página abaixo: Spring Initializer for Beagle Spring Starter   Essa configuração inicial utiliza:  Kotlin com Maven; A ultima versão do Spring Boot Actuator dependency; Empacotamento JAR e Java 8 (compatível com essa versão).   Clique em GENERATE para fazer o download de um arquivo zip que contém o projeto Spring Boot. Descompacte o arquivo na pasta que escolher para conter seu projeto BFF e abra o seu projeto na IDE de sua preferência.   Passo 2: Configurar as dependências (\u003c 1.1.0) Uma vez criado e configurado os microsserviços, você precisa adicionar o endereço do nosso nexus. Para isso, basta adicionar o código abaixo no seu arquivo pom.xml:\n\u003crepositories\u003e \u003crepository\u003e \u003cid\u003ebintray-zupit-repo\u003c/id\u003e \u003curl\u003ehttps://dl.bintray.com/zupit/repo\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e Passo 3: Incluir requerimentos adicionais Por último, você precisa complementar algumas configurações em nosso backend. Neste caso, o framework que você tiver escolhido é que irá definir como deve ser feita a implementação.\nClique na opção de Framework que você escolheu anteriormente e siga os passos para continuar a configuração.\nMicronaut Starter Spring Starter Requerimentos adicionais: Este starter configura a versão do módulo micronaut-runtime com ele e utiliza a versão Micronaut 2.0.0.\n Para seguir com esse requerimento, basta adicionar arquivo pom à sua dependência.\n Versão atual do Beagle:  \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003ebeagle-micronaut-starter\u003c/artifactId\u003e \u003cversion\u003e${beagle.version}\u003c/version\u003e \u003c/dependency\u003e Insira a versão de release do Beagle no lugar de ${beagle.version}. Ou seja, coloque a versão do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os números de versão.\nPor exemplo: undefined-ext.beagle.version = \"0.2.8\"\nLembre de sempre verificar se você está usando a versão mais recente do Beagle. Para saber disso, basta passar o mouse por cima do número da versão. Depois disso, sincronize com sua máquina.\n  Requerimentos adicionais: Este starter configura a versão do módulo spring-boot-starter-web com ele e utiliza a versão Spring Boot 2.3.1.\n Para seguir com esse requerimento, basta adicionar o arquivo pom à sua dependência.\n Versão atual do Beagle:  \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003ebeagle-spring-starter\u003c/artifactId\u003e \u003cversion\u003e${beagle_version}\u003c/version\u003e \u003c/dependency\u003e Insira a versão de release do Beagle no lugar de ${beagle.version}. Ou seja, coloque a versão do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os números de versão.\nPor exemplo:-ext.beagle.version = \"1.0.0\"\nLembre de sempre verificar se você está usando a versão mais recente do Beagle. Para saber disso, basta passar o mouse por cima do número da versão. Depois disso, sincronize com sua máquina.\n Parabéns, a configuração inicial está pronta para uso!\nVocê pode conferir um exemplo prático de tela ou componente Server-Driven para testar o BFF\nO Spring Boot tem um problema conhecido envolvendo seu WebMvcConfigurationSupport. Sua presença substitui outras configurações do Jackson, incluindo a do Spring Starter.\nCaso haja algum em seu projeto, sugerimos substituí-lo porWebMvcConfigurer.\nPara mais detalhes, consulte esta issue no Github\nA anotação @EnableWebMvc causa o mesmo problema, o que requer que ela também seja removida.\n  Pronto, a configuração inicial está pronta para uso!  Você pode conferir um exemplo prático de como testar o Beagle no Backend ou componente Server-Driven para testar o BFF.\nPróximos Passos Nesta seção, você fez a instalação inicial do Beagle na sua aplicação!\nPara continuar a configurar o Beagle:\n👉Vá para as configurações iniciais para habilitar uso do Beagle no seu projeto Backend\n👉 Se quiser ir direto para prática, acesse nosso tutorial para criar um projeto do zero\n","excerpt":" Antes de iniciar a instalação, é importante você saber que as etapas …","ref":"/docs-beagle/pt/docs/primeiros-passos/instalando-o-beagle/backend/","title":"Backend"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/get-started/","title":"Get Started"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/primeiros-passos/","title":"Primeiros Passos"},{"body":" Depois de fazer a instalação do Beagle, é necessário realizar as configurações de uso para habilitar a ferramenta no seu projeto.\nVocê pode configurar de acordo com a plataforma que estiver utilizando:\n","excerpt":" Depois de fazer a instalação do Beagle, é necessário realizar as …","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/","title":"Usando o Beagle"},{"body":" After you done Beagle’s installation, you have to make usage configuration to enable the tool on your project.\nYou can make this configuration based on the platform you wanna use:\n","excerpt":" After you done Beagle’s installation, you have to make usage …","ref":"/docs-beagle/docs/get-started/using-beagle/","title":"Using Beagle"},{"body":" Usage configurations Once you have finished Beagle’s installation, you have to make now our tool’s usage configuration. To make this process easier, we’ll use an example of how to render a “Hello Beagle! screen with a small description.\nStep 1: Update Android Manifest In this step, you have to update your AndroidManifest and add two lines on this file:\n INTERNET’s permission so your application will be able to access internet. The attributeandroid:usesCleartextTraffic=\"true\" inside the \u003capplication\u003e tag for the local BFF communication.  For this example we will not be using a BFF, therefore this step is not necessary. However, for any and all tests that are done using Beagle Android with a BFF, this step is essential.  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication ... android:usesCleartextTraffic=\"true\" ...   The usesCleartextTraffic: Indicates with the app intends to use cleartext network traffic, HTTP. The default value for apps that target API level 27 or lower is “true”. Apps that target API level 28 or higher default to “false”. The attribute android:usesCleartextTraffic=\"true\" inside \u003capplication\u003etag is used to communicate with the local BFF. If you intent to debug the project using a local BFF you can use this as an easy configuration step. Although, if you plan to turn this example into a release application, we recomend you using the networkSecurityConfig which you can configure using the android developers page instructions.   Step 2: Create a BeagleConfig class After the update, you have to create a BeagleConfig class and configure your attributes, as you can see on the example below:\n@BeagleComponent class AppBeagleConfig : BeagleConfig { override val environment: Environment get() = Environment.DEBUG override val baseUrl: String get() = \"https://myapp.server.com/\" override val isLoggingEnabled: Boolean = true override val cache: Cache = Cache( enabled = false, maxAge = 300, size = 15 ) }    Attribute Type Definition     isLoggingEnabled Boolean Attribute that enables or disables all logs that Beagle generates.   baseUrl String Informs the base URL used in Beagle in the application.\nIf you are using the emulator, check here to define this attribute.\n   environment Environment Attribute responsible for informing Beagle about the current build status of the application.   cache Cache Object responsible for managing the cache of Beagle requests.    Make sure to note your class configuration withBeagleComponent, because Beagle expect them to have empty constructors.  Step 3: BeagleActivitiy Beagle offers a default Activity to manage all activities that have been generated through server-driven. However, you can create one or more Activities that inherit from BeagleActivity with @BeagleComponent and are customized according to server-driven flows of your application.\nYou can create BeagleActivity now, but at his moment it is possible to proceed to the next step without configuring it. For more information about it, see Custom Beagle Activity.  Step 4: Initiate the Beagle and the Design System Now it’s the moment to initiate Beagle in your application’s class. However, before you start check out if the minimum version of your SDK is above 19, as in the example:\ndefaultConfig { minSdkVersion 19 //or higher }  You can set a Design System now, at this point it is not necessary, just proceed without configuring. But, if you wanna know more about it, check this section about Design System for Android.  Step 5: Create a BeagleSetup Now you have to initialize your Application ,so Beagle can generate other configurations file that you need. When you initialize Beagle for the first time, a BeagleSetup class will be automatically created as you can see in the image below:\nStep 6: Create the Application class At this moment, you should create a Kotlin class that extends to Application class. For this example, we’ll name as AppApplication.\nThis class should be named as BeagleSetup().init(this) on onCreate method, according to the list below:\nclass AppApplication: Application() { companion object { var APPLICATION: Application? = null } override fun onCreate() { super.onCreate() APPLICATION = this BeagleSetup().init(APPLICATION!!) } }  When you create this class, press CTRL + F9 so Beagle’s generated classes are created.  Step 7: Update your Android Manifest.xml Finally, you must update again your AndroidManifest.xml and define the AppApplication we created as an application’s initialization file, as you can see in the example below:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication android:name=\".AppApplication\" .. Step 8: Manage logs You will create a class that implements BeagleLogger interface. This protocol must be defiened to ease the error management generated in the server-driven context of your application. And you must implement the methods the best way for your application. See the following example:\nprivate const val BEAGLE_TAG = \"BeagleSDK\" @BeagleComponent class BeagleLoggerDefault : BeagleLogger { override fun warning(message: String) { Log.w(BEAGLE_TAG, message) } override fun error(message: String) { Log.e(BEAGLE_TAG, message) } override fun error(message: String, throwable: Throwable) { Log.e(BEAGLE_TAG, message, throwable) } override fun info(message: String) { Log.i(BEAGLE_TAG, message) } } Step 9: Manage caches Here you will implement StoreHandler, it is a protocol that allows you to customize the way the cache is handled in the database and memory.\nFor that, you have to create two classes that will implement the LocalStore interface. This interface allows you to map the actions save, restore, delete and get all. See an example below:\ninternal object MemoryLocalStore : LocalStore { private val cache = mutableMapOf\u003cString, String\u003e() override fun save(key: String, value: String) { cache[key] = value } override fun restore(key: String): String? { return cache[key] } override fun delete(key: String) { cache.remove(key) } override fun getAll(): Map\u003cString, String\u003e { return cache.toMap() } } Now, you have to create a second class which depends on the StoreHandler creation, that it is a DatabaseLocalStore. See, this same file were declared some adjacent classes that work to this DatabaseLocalStore class, but it could be in different files, if you want. See the example:\ninternal object ScreenEntry : BaseColumns { const val TABLE_NAME = \"KeyValueCache\" const val KEY_COLUMN_NAME = \"key\" const val VALUE_COLUMN_NAME = \"value\" } internal class DatabaseLocalStore( private val contentValuesFactory: ContentValuesFactory = ContentValuesFactory(), private val database: SQLiteDatabase = BeagleDatabaseManager.getDatabase( BeagleUiSampleApplication.APPLICATION!!) ) : LocalStore { override fun save(key: String, value: String) { val values = contentValuesFactory.make().apply { put(ScreenEntry.KEY_COLUMN_NAME, key) put(ScreenEntry.VALUE_COLUMN_NAME, value) } val newRowId = database.insertWithOnConflict(ScreenEntry.TABLE_NAME, null, values, SQLiteDatabase.CONFLICT_REPLACE) if (newRowId == -1L) { BeagleMessageLogs.logDataNotInsertedOnDatabase(key, value) } } override fun restore(key: String): String? { return executeRestoreQueryForKey(key).use { cursor -\u003e if (cursor.count \u003e 0) { cursor.moveToFirst() cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.VALUE_COLUMN_NAME)) } else { null } } } override fun delete(key: String) { database.delete(ScreenEntry.TABLE_NAME, \"${ScreenEntry.KEY_COLUMN_NAME}=?\", arrayOf(key)) } override fun getAll(): Map\u003cString, String\u003e { val columnsToReturn = arrayOf(ScreenEntry.KEY_COLUMN_NAME, ScreenEntry.VALUE_COLUMN_NAME) val columnsForWhereClause = \"\" val valuesForWhereClause = arrayOf\u003cString\u003e() val cursor = database.query( ScreenEntry.TABLE_NAME, columnsToReturn, columnsForWhereClause, valuesForWhereClause, null, null, null ) val returnMap = mutableMapOf\u003cString, String\u003e() if (cursor.count \u003e 0) { cursor.moveToFirst() while (!cursor.isAfterLast) { returnMap[cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.KEY_COLUMN_NAME))] = cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.VALUE_COLUMN_NAME)) cursor.moveToNext() } } cursor.close() return returnMap } private fun executeRestoreQueryForKey(key: String): Cursor { val columnsToReturn = arrayOf(ScreenEntry.VALUE_COLUMN_NAME) val columnsForWhereClause = \"${ScreenEntry.KEY_COLUMN_NAME}=?\" val valuesForWhereClause = arrayOf(key) return database.query( ScreenEntry.TABLE_NAME, columnsToReturn, columnsForWhereClause, valuesForWhereClause, null, null, null ) } } internal class ContentValuesFactory { fun make(): ContentValues = ContentValues() } internal object BeagleDatabaseManager { private const val DATABASE_NAME = \"BeagleDefaultStore.db\" private const val DATABASE_VERSION = 2 private lateinit var database: SQLiteDatabase fun getDatabase(context: Context): SQLiteDatabase { if (!::database.isInitialized) { database = BeagleSQLiteDatabase( context, DATABASE_NAME, DATABASE_VERSION ).writableDatabase } return database } } internal open class BeagleSQLiteDatabase( context: Context, databaseName: String, databaseVersion: Int ) : SQLiteOpenHelper( context, databaseName, null, databaseVersion ) { override fun onCreate(db: SQLiteDatabase?) { val createTableQuery = \"CREATE TABLE ${ScreenEntry.TABLE_NAME}(\" + \"${BaseColumns._ID}INTEGER PRIMARY KEY,\" + \"${ScreenEntry.KEY_COLUMN_NAME}TEXT NOT NULL UNIQUE,\" + \"${ScreenEntry.VALUE_COLUMN_NAME}TEXT NOT NULL\" + \")\" db?.execSQL(createTableQuery) } override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) { val deleteTableQuery = \"DROP TABLE IF EXISTS ${ScreenEntry.TABLE_NAME}\" db?.execSQL(deleteTableQuery) onCreate(db) } } internal object BeagleMessageLogs { fun logDataNotInsertedOnDatabase(key: String, value: String) { BeagleLoggerDefault().warning( \"Error when trying to insert key=$keywith value=$valueon Beagle default database.\" ) } } The file above has some SQL Lite configuration and definition on how the cache manipulation actions will work, in case of a cache persistence on the database.\nAfter the MemoryLocalStore and DatabaseLocalStore classes definition, you can define StoreHandler. See the example below:\nimport br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.store.StoreHandler import br.com.zup.beagle.android.store.StoreType @BeagleComponent internal class StoreHandler( private val memoryLocalStore: MemoryLocalStore = MemoryLocalStore, private val databaseLocalStore: DatabaseLocalStore = DatabaseLocalStore() ) : StoreHandler { override fun save(storeType: StoreType, data: Map\u003cString, String\u003e) { data.forEach { if (storeType == StoreType.DATABASE) { databaseLocalStore.save(it.key, it.value) } else { memoryLocalStore.save(it.key, it.value) } } } override fun restore(storeType: StoreType, vararg keys: String): Map\u003cString, String?\u003e { val values = mutableMapOf\u003cString, String?\u003e() keys.forEach { val value = if (storeType == StoreType.DATABASE) { databaseLocalStore.restore(it) } else { memoryLocalStore.restore(it) } values[it] = value } return values } override fun delete(storeType: StoreType, key: String) { if (storeType == StoreType.DATABASE) { databaseLocalStore.delete(key) } else { memoryLocalStore.delete(key) } } override fun getAll(storeType: StoreType): Map\u003cString, String\u003e { return if (storeType == StoreType.DATABASE) { databaseLocalStore.getAll() } else { memoryLocalStore.getAll() } } } Now you’re ready to start using Beagle! To verify if the configuration is correct, we can simulate a Server-Driven screen to make the following test.\nUse Example How to display a Server-Driven screen Once you have already configured Beagle, every server-driven screen you build on your application’s backend will be sent to frontend through JSON.\nTo test our application, we’ll make a simulation of a server-driven screen creating a JSON that represents a screen of tour Android application.\nFollow these steps to make this exhibition:\n Open the file MainActivity.kt; State the line below onOnCreate function; Add the a command line test_content.addView(testScreen().toView(this)) Notice that doesn’t exist the test_content, because we will still name this reference.  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) test_content.addView(testScreen().toView(this)) }  To access the view test_content as the example above, it is necessary to install the plugin:\nplugins { id 'kotlin-android-extensions' }   Open the .xml layout file of Main Activity and create a Frame layout.  As a default, Android usually creates .xml files with constraint layout. You don’t need to remove it, just add a layout frame inside it and check out if the configurations are similar to the example below:\nactivity_main.xml \u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/test_content\" /\u003e Now, you just have to return to MainActivity.kt page and state the function below. It’s responsible to list JSON to test the screen.  MainActivity.kt private fun testScreen() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle!\" ).applyStyle( Style(margin = EdgeValue(top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides usage of the \" + \"Server-Driven UI concept, natively in iOS, Android and Web applications. \" + \"By using Beagle, your team could easily change application's layout and\" + \" data by just changing backend code.\" ).applyStyle( Style(margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) The function above creates a JSON structure below, that will be interpreted by Beagle:\n{ \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello Beagle!\", \"style\" : { \"margin\" : { \"top\" : { \"value\" : 16.0, \"type\" : \"REAL\" } }, \"flex\" : { \"alignSelf\" : \"CENTER\" } } }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Beagle is a cross-platform framework which provides usage of the Server-Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code.\", \"style\" : { \"margin\" : { \"left\" : { \"value\" : 16.0, \"type\" : \"REAL\" }, \"top\" : { \"value\" : 20.0, \"type\" : \"REAL\" }, \"right\" : { \"value\" : 16.0, \"type\" : \"REAL\" } } } } ] } } Click on Run app and check the emulator screen!\nYou will see this screen:  Well done, you created your first screen with Beagle!  This tutorial focused in a simple screen configuration, so you could understand the process and without worrying about screens' hierarchy.\nAdditional Information Before you use Beagle, stay tuned about: the release build configuration and ProGuard.\nEven though it’s not necessary at this moment, it’s good to have in mind that you’ll have to configure the ProGuard to activate the obfuscate code when you publish releases.\nThe annotated classes like BeagleComponent and RegisterValidator can’t implement parameters in your constructors because, on Beagle, these constructors must be empty.  ","excerpt":" Usage configurations Once you have finished Beagle’s installation, …","ref":"/docs-beagle/docs/get-started/using-beagle/android/","title":"Android"},{"body":" Configuração de uso Depois que você terminar a instalação, é preciso configurar o Beagle para o uso. Para facilitar a nossa explicação, vamos usar um exemplo de como renderizar uma tela com um título “Hello Beagle!” e uma pequena descrição.\nPasso 1: Atualizar Android Manifest Nesse passo você deve atualizar oAndroidManifest e adicionar duas linhas a este arquivo:\n A permissão de INTERNET para que sua aplicação seja capaz de acessar a internet. O atributoandroid:usesCleartextTraffic=\"true\" dentro da tag \u003capplication\u003e para comunicação com o BFF local.  Para este exemplo não iremos utilizar um BFF, consequentemente essa configuração não é necessária. Porém, para todo e qualquer teste que seja feito usando o Beagle Android com um BFF, esse passo é necessário.  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication ... android:usesCleartextTraffic=\"true\" ...    OusesCleartextTraffic: indica que o aplicativo pretende usar o tráfego de rede de texto não criptografado, HTTP. O valor padrão para aplicativos que visam o nível de API 27 ou inferior é true. Os aplicativos que têm como alvo o nível de API 28 ou superior são padronizados como false.\n  O atributo android: usesCleartextTraffic = \"true\" dentro da tag\u003capplication\u003e\né usado para se comunicar com o BFF local. Se você pretende depurar o projeto usando um BFF local, você pode usar essa configuração como uma etapa de configuração rápida.\n  No entanto, se você planeja transformar este exemplo em um aplicativo para release, recomendamos que você use o networkSecurityConfig, que você pode configurar usando as instruções na página de desenvolvedores do Android.\n   Passo 2: Criar uma classe BeagleConfig Feita a atualização, você precisa criar uma classe BeagleConfig e configurar seus todos os atributos, como mostra o exemplo abaixo:\n@BeagleComponent class AppBeagleConfig : BeagleConfig { override val environment: Environment get() = Environment.DEBUG override val baseUrl: String get() = \"https://myapp.server.com/\" override val isLoggingEnabled: Boolean = true override val cache: Cache = Cache( enabled = false, maxAge = 300, size = 15 ) }    Atributos Tipo Definição     environment Environment Atributo responsável por informar ao Beagle qual o estado de build atual da aplicação.   baseUrl String Informa a url base usada no Beagle na aplicação. Se estiver usando emulador, consulte essa página para definir esse atributo.   isLoggingEnabled Boolean Atributo que habilita ou desabilita todos os logs que o Beagle gera.   cache Cache Objeto responsável por gerenciar o cache das requisições do Beagle.    Faça a configuração das classes com bastante atenção, pois se você anotá-las comBeagleComponent, o Beagle espera que elas tenham construtores vazios.  Passo 3: BeagleActivity O Beagle fornece uma Activity default para gerenciar as Activities geradas via server-driven. Porém você pode criar uma ou maisActivities que herdem de BeagleActivity com @BeagleComponent personalizadas de acordo com os fluxos server-driven da sua aplicação.\nVocê pode criar o BeagleActivity agora, mas neste momento é possível prosseguir com os próximos passos sem configurá-la. Para saber mais, confira a seção sobreBeagle Activity Customizada.  Passo 4: Iniciar o Beagle e o Design System Agora é o momento de iniciar o Beagle na classe da sua aplicação. Porém, antes confira se a versão mínima da sua aplicação em SKD está 19 ou superior, como indicado abaixo:\ndefaultConfig { minSdkVersion 19 //or higher }  Você pode criar o Design System agora, mas neste momento é possível prosseguir com os próximos passos sem configurá-lo. Para saber mais, confira a seção sobre Design System com Beagle para Android.  Passo 5: Criar o BeagleSetup Agora você deve inicializar sua Application para que o Beagle gere os outros arquivos de configuração que necessita. Ao ser iniciado pela primeira vez o Beagle irá criar automaticamente uma classe de BeagleSetup class, como mostra a figura abaixo:\nPasso 6: Criar a classe Application Neste momento, você deve criar uma classe Kotlin que estenda a classe Application que, para este exemplo, nomeamos como AppApplication.\nEsta classe deve chamar o BeagleSetup().init(this) no método onCreate, conforme listado abaixo:\nclass AppApplication: Application() { companion object { var APPLICATION: Application? = null } override fun onCreate() { super.onCreate() APPLICATION = this BeagleSetup().init(APPLICATION!!) } }  Assim que você criar essa classe, aperte CTRL + F9 para que as classes autogeradas do Beagle sejam criadas.  Passo 7: Atualizar seu Android Manifest.xml Por fim, você deve atualizar novamente o seu AndroidManifest.xml e definir a AppApplication que foi criada como o arquivo de inicialização da aplicação, como no exemplo abaixo:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication android:name=\".AppApplication\" .. Passo 8: Gerenciar os Logs Você precisa criar uma classe que implementa a interface BeagleLogger. Esse protocolo deverá ser definido para facilitar o monitoramento dos erros gerados no contexto server driven de sua aplicação. E você deve implementar os métodos da forma mais apropriada para sua necessidade. Veja um exemplo:\nprivate const val BEAGLE_TAG = \"BeagleSDK\" @BeagleComponent class BeagleLoggerDefault : BeagleLogger { override fun warning(message: String) { Log.w(BEAGLE_TAG, message) } override fun error(message: String) { Log.e(BEAGLE_TAG, message) } override fun error(message: String, throwable: Throwable) { Log.e(BEAGLE_TAG, message, throwable) } override fun info(message: String) { Log.i(BEAGLE_TAG, message) } } Passo 9: Gerenciar os caches Aqui, você deve implementar o StoreHandler, um protocolo que permite personalizar a forma como o cache é manipulado no banco de dados e na memória.\nPara isso, é preciso criar duas classes que implementarão a interface LocalStore. Essa interface permite mapear as ações de salvar, restaurar, deletar e pegar tudo. Veja o exemplo abaixo:\ninternal object MemoryLocalStore : LocalStore { private val cache = mutableMapOf\u003cString, String\u003e() override fun save(key: String, value: String) { cache[key] = value } override fun restore(key: String): String? { return cache[key] } override fun delete(key: String) { cache.remove(key) } override fun getAll(): Map\u003cString, String\u003e { return cache.toMap() } } Agora criaremos uma segunda classe a qual dependeremos para criação do StoreHandler, que é a DatabaseLocalStore. Note que neste mesmo arquivo foram declaradas algumas classes adjacentes que servem a essa classe DatabaseLocalStore mas poderiam estar em arquivos diferentes, caso prefira. Veja um exemplo:\ninternal object ScreenEntry : BaseColumns { const val TABLE_NAME = \"KeyValueCache\" const val KEY_COLUMN_NAME = \"key\" const val VALUE_COLUMN_NAME = \"value\" } internal class DatabaseLocalStore( private val contentValuesFactory: ContentValuesFactory = ContentValuesFactory(), private val database: SQLiteDatabase = BeagleDatabaseManager.getDatabase( BeagleUiSampleApplication.APPLICATION!!) ) : LocalStore { override fun save(key: String, value: String) { val values = contentValuesFactory.make().apply { put(ScreenEntry.KEY_COLUMN_NAME, key) put(ScreenEntry.VALUE_COLUMN_NAME, value) } val newRowId = database.insertWithOnConflict(ScreenEntry.TABLE_NAME, null, values, SQLiteDatabase.CONFLICT_REPLACE) if (newRowId == -1L) { BeagleMessageLogs.logDataNotInsertedOnDatabase(key, value) } } override fun restore(key: String): String? { return executeRestoreQueryForKey(key).use { cursor -\u003e if (cursor.count \u003e 0) { cursor.moveToFirst() cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.VALUE_COLUMN_NAME)) } else { null } } } override fun delete(key: String) { database.delete(ScreenEntry.TABLE_NAME, \"${ScreenEntry.KEY_COLUMN_NAME}=?\", arrayOf(key)) } override fun getAll(): Map\u003cString, String\u003e { val columnsToReturn = arrayOf(ScreenEntry.KEY_COLUMN_NAME, ScreenEntry.VALUE_COLUMN_NAME) val columnsForWhereClause = \"\" val valuesForWhereClause = arrayOf\u003cString\u003e() val cursor = database.query( ScreenEntry.TABLE_NAME, columnsToReturn, columnsForWhereClause, valuesForWhereClause, null, null, null ) val returnMap = mutableMapOf\u003cString, String\u003e() if (cursor.count \u003e 0) { cursor.moveToFirst() while (!cursor.isAfterLast) { returnMap[cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.KEY_COLUMN_NAME))] = cursor.getString(cursor.getColumnIndexOrThrow(ScreenEntry.VALUE_COLUMN_NAME)) cursor.moveToNext() } } cursor.close() return returnMap } private fun executeRestoreQueryForKey(key: String): Cursor { val columnsToReturn = arrayOf(ScreenEntry.VALUE_COLUMN_NAME) val columnsForWhereClause = \"${ScreenEntry.KEY_COLUMN_NAME}=?\" val valuesForWhereClause = arrayOf(key) return database.query( ScreenEntry.TABLE_NAME, columnsToReturn, columnsForWhereClause, valuesForWhereClause, null, null, null ) } } internal class ContentValuesFactory { fun make(): ContentValues = ContentValues() } internal object BeagleDatabaseManager { private const val DATABASE_NAME = \"BeagleDefaultStore.db\" private const val DATABASE_VERSION = 2 private lateinit var database: SQLiteDatabase fun getDatabase(context: Context): SQLiteDatabase { if (!::database.isInitialized) { database = BeagleSQLiteDatabase( context, DATABASE_NAME, DATABASE_VERSION ).writableDatabase } return database } } internal open class BeagleSQLiteDatabase( context: Context, databaseName: String, databaseVersion: Int ) : SQLiteOpenHelper( context, databaseName, null, databaseVersion ) { override fun onCreate(db: SQLiteDatabase?) { val createTableQuery = \"CREATE TABLE ${ScreenEntry.TABLE_NAME}(\" + \"${BaseColumns._ID}INTEGER PRIMARY KEY,\" + \"${ScreenEntry.KEY_COLUMN_NAME}TEXT NOT NULL UNIQUE,\" + \"${ScreenEntry.VALUE_COLUMN_NAME}TEXT NOT NULL\" + \")\" db?.execSQL(createTableQuery) } override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) { val deleteTableQuery = \"DROP TABLE IF EXISTS ${ScreenEntry.TABLE_NAME}\" db?.execSQL(deleteTableQuery) onCreate(db) } } internal object BeagleMessageLogs { fun logDataNotInsertedOnDatabase(key: String, value: String) { BeagleLoggerDefault().warning( \"Error when trying to insert key=$keywith value=$valueon Beagle default database.\" ) } } O arquivo acima possui as configurações para o SQL Lite e também as definições de como as ações de manipulação de cache funcionarão, no caso da persistência do cache no banco de dados.\nApós a definição das classes MemoryLocalStore e DatabaseLocalStore você pode definir a StoreHandler. Veja o exemplo abaixo:\nimport br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.store.StoreHandler import br.com.zup.beagle.android.store.StoreType @BeagleComponent internal class StoreHandler( private val memoryLocalStore: MemoryLocalStore = MemoryLocalStore, private val databaseLocalStore: DatabaseLocalStore = DatabaseLocalStore() ) : StoreHandler { override fun save(storeType: StoreType, data: Map\u003cString, String\u003e) { data.forEach { if (storeType == StoreType.DATABASE) { databaseLocalStore.save(it.key, it.value) } else { memoryLocalStore.save(it.key, it.value) } } } override fun restore(storeType: StoreType, vararg keys: String): Map\u003cString, String?\u003e { val values = mutableMapOf\u003cString, String?\u003e() keys.forEach { val value = if (storeType == StoreType.DATABASE) { databaseLocalStore.restore(it) } else { memoryLocalStore.restore(it) } values[it] = value } return values } override fun delete(storeType: StoreType, key: String) { if (storeType == StoreType.DATABASE) { databaseLocalStore.delete(key) } else { memoryLocalStore.delete(key) } } override fun getAll(storeType: StoreType): Map\u003cString, String\u003e { return if (storeType == StoreType.DATABASE) { databaseLocalStore.getAll() } else { memoryLocalStore.getAll() } } } Agora você está pronto para começar a usar o Beagle! E para verificar se a configuração está correta simule uma tela Server-Driven fazendo o teste a seguir.\nExemplo prático Como exibir uma tela Server-Driven Para você testar nossa aplicação, vamos simular uma tela server-driven criando um JSON que represente uma tela na sua aplicação Android.\nSiga os passos abaixo para fazer a exibição:\n Abra o arquivo MainActivity.kt; Declare a linha abaixo na função onCreate; Adicione a linha de comando test_content.addView(testScreen().toView(this)) Perceba que o test_content ainda não existe, pois ainda vamos nomear esta referência.  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) test_content.addView(testScreen().toView(this)) }  Para acessar a view test_content como no exemplo acima, é necessário a instalar o plugin:\nplugins { id 'kotlin-android-extensions' }   Abra o arquivo de layout .xml da Main Activity e crie um frame layout.  Por padrão, o Android costuma criar os arquivos .xml com o constraint layout. Você não precisa removê-lo, apenas adicione o frame layout dentro dele e confira se as configurações estão como no exemplo abaixo:\n\u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/test_content\" /\u003e Agora, é só retornar a página MainActivity.kt e declarar a função abaixo. Ela é a responsável por listar o JSON para testarmos a tela.  private fun testScreen() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle!\" ).applyStyle( Style(margin = EdgeValue(top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides usage of the \" + \"Server-Driven UI concept, natively in iOS, Android and Web applications. \" + \"By using Beagle, your team could easily change application's layout and\" + \" data by just changing backend code.\" ).applyStyle( Style(margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) A função acima cria a estrutura JSON abaixo, que vai ser interpretada pelo Beagle:\n{ \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello Beagle!\", \"style\" : { \"margin\" : { \"top\" : { \"value\" : 16.0, \"type\" : \"REAL\" } }, \"flex\" : { \"alignSelf\" : \"CENTER\" } } }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Beagle is a cross-platform framework which provides usage of the Server-Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code.\", \"style\" : { \"margin\" : { \"left\" : { \"value\" : 16.0, \"type\" : \"REAL\" }, \"top\" : { \"value\" : 20.0, \"type\" : \"REAL\" }, \"right\" : { \"value\" : 16.0, \"type\" : \"REAL\" } } } } ] } } Clique em Run app e cheque a tela do emulador!\nVocê verá a tela a seguir:  Parabéns, você criou sua primeira tela com Beagle!  Neste tutorial, focamos em uma configuração de tela simples para você entender o processo, na prática, sem se preocupar com uma hierarquia de telas complexas. Mas, claro, você pode fazer bem mais no seu projeto com o Beagle!\nInformação adicional Antes de usar o Beagle, fique atento a configuração da build de release e o ProGuard.\nMesmo não sendo necessário neste momento, é bom ter em mente que você precisará configurar o ProGuard para ativar o ofuscamento do seu código quando estiver publicando releases.\nAs classes anotadas como BeagleComponent e RegisterValidatornão podem implementar parâmetros nos seus construtores, pois no caso do Beagle esses construtores precisam estar vazios.  ","excerpt":" Configuração de uso Depois que você terminar a instalação, é preciso …","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/android/","title":"Android"},{"body":" How to display a “Hello Beagle!” screen After you installed Beagle on your project, we’ll show how to render a screen and display your first “Hello Beagle!\".\nCheck out how to install Beagle in case you haven’t finished this step.  Currently, there are two types of approaches to render screens with Beagle: remote and declarative.\nRemote Renderization  Main approach used on Beagle because it’s based on server-driven UI concept. It allows you to build layouts dynamically, consuming the informations provided by a BFF through a remote URL.\n Declarative Renderization  Even if it’s an alternative not based on server-driven UI, this renderization is a way you can locally state componentes with Swift language. With this, you can use a local component directly or through a JSON that represents it, simulating a response from BFF.\n For this example, you will render a screen with declarative way, which means that all the processes will be done locally because, on this way, you’ll know a little bit about Beagle and, in a few steps, test if your installation worked.\nStep 1: Create a class (MyBeagleScreen) Create a class and name it as you wish. Here, we’ll call it MyBeagleScreen.\nThe class will have only one method responsible to build a Screen.\nimport Beagle import Foundation class BeagleConfig { static func config() { let dependencies = BeagleDependencies() dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"Server base URL\") ) Beagle.dependencies = dependencies } }  Notice that the Screen is being build using**Flex**. To understand better these components and your proprieties, go to the section **component’s layout**.  Step 2: Instantiate BeagleScreenViewController Now it’s time to display your first screen built using Beagle, and to do so you must:\nInstantiate a**BeagleScreenViewController** with**declarative** type that will receive a**MyBeagleScreen**.\nlet beagleViewController = Beagle.screen( .declarative( MyBeagleScreen.make() ) )  In case you want to use the **remote**type, check out how to display a server-driven screen.  Once you made it, you just have to present it as you wish.\npresent(beagleViewController, animated: true, completion: nil)  Don’t forget to add**import Beagle**.  Step 3: Run the application Now, run your application and, if everything works well, you will see a screen like this:\nCongratulations, you have created you first screen with Beagle 🎉  Next steps On this section, you saw how to create your first declarative screen using Beagle, on your simplest way, without entering on the server-driven UI concept.\n👉To understand more about how to configure Beagle and use it applying server-driven UI, check out how to create an iOS project from scratch.\n","excerpt":" How to display a “Hello Beagle!” screen After you installed Beagle on …","ref":"/docs-beagle/docs/get-started/using-beagle/ios/","title":"IOS"},{"body":" Como exibir uma tela “Hello Beagle!” Depois de ter o Beagle instalado em seu projeto, vamos te mostrar como renderizar uma tela e exibir seu primeiro “Hello Beagle!\".\nVeja como instalar o Beagle caso ainda não tenha concluído esta etapa.  Atualmente, existem dois tipos de abordagens para a renderização de telas com o Beagle: remota e declarativa.\nRenderização Remota  Principal abordagem usada no Beagle por ser fundamentada no conceito de server-driven UI. Ela permite que você construa layouts dinamicamente, consumindo as informações fornecidas por um BFF, por meio de uma URL remota.\n Renderização Declarativa  Apesar de ser uma alternativa não pautada em server-driven UI, é uma forma de renderização que permite você declarar localmente componentes pela linguagem Swift. Com isso, você pode utilizar um componente local diretamente ou passando um JSON que o representa, simulando assim a resposta de um BFF.\n Para este exemplo, você irá renderizar uma tela de forma declarativa, ou seja, tudo será feito localmente. Desta forma, você irá conhecer um pouco do Beagle e, em poucos passos, testar se sua instalação funcionou.\nPasso 1: Crie uma classe (MyBeagleScreen) Crie uma classe e a nomeie como preferir. Aqui, iremos chamá-la de MyBeagleScreen.\nA classe irá conter apenas um método, responsável por construir uma Screen.\nimport Beagle import BeagleSchema class MyBeagleScreen { static func make() -\u003e Screen { return Screen( child: Container( children: [ Text(\"Hello Beagle!\") ] ).applyFlex( Flex( justifyContent: .center, alignItems: .center, grow: 1 ) ) ) } }  Note que a Screen está sendo construída utilizando Flex. Para entender melhor esses componentes e suas propriedades, vá para a seção posicionamento de componentes.  Passo 2: Instanciar o BeagleScreenViewController Agora, para conseguir visualizar a sua primeira tela construída utilizando o Beagle, tudo que você precisa fazer é:\nInstanciar uma BeagleScreenViewController do tipo declarative que receberá a**MyBeagleScreen**.\nlet beagleViewController = Beagle.screen( .declarative( MyBeagleScreen.make() ) )  Caso queira utilizar o tipo**remote**, veja como exibir uma tela Server-Driven UI.  Feito isso, basta apresentá-la onde preferir.\npresent(beagleViewController, animated: true, completion: nil)  Não esqueça de adicionar**import Beagle**.  Passo 3: Executar a aplicação Por fim, execute a sua aplicação e, se tudo estiver certo, você deverá ver uma tela como esta:\nParabéns, você criou sua primeira tela com Beagle🎉  Próximos passos Nesta seção, você viu como criar sua primeira tela declarativa utilizando o Beagle, em sua forma mais simples, sem entrar no conceito de server-driven UI.\n👉Para entender melhor como configurar o Beagle e utilizá-lo aplicando o conceito de server-driven UI, veja como criar um projeto iOS do zero.\n","excerpt":" Como exibir uma tela “Hello Beagle!” Depois de ter o Beagle instalado …","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/ios/","title":"IOS"},{"body":" Once you have finished Beagle’s installation, now you can make usage configuration according to the framework you’re using:\nIf you wanto to use a BFF, it’s necessary to have a configured CORS. See how to do this on use configurations for backend.  ","excerpt":" Once you have finished Beagle’s installation, now you can make usage …","ref":"/docs-beagle/docs/get-started/using-beagle/web/","title":"WEB"},{"body":" No caso do Beagle para Web, é necessário fazer as configurações de uso de acordo com o framework que estiver utilizando:\nCaso queira utilizar um BFF, é necessário ter um CORS configurado. Veja como fazer isso nas configurações de uso para backend.  ","excerpt":" No caso do Beagle para Web, é necessário fazer as configurações de …","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/web/","title":"WEB"},{"body":" Usage configurations After you finished the installation, you need to make Beagle’s usage configuration for Angular’s framework. To do so, you just have to follow these steps:\nStep 1: Configure using an automatic configuration Type one of the commands below to generate the files that will be used on Beagle’s library. It’s possible to execute the command according to your package manager:\nyarn beagle init npx beagle init Once you made it, Beagle will return some questions. To answer them, follow the orientations below:\nQuestion 1: Would you like to use yarn or npm?\nIn this case, type the option that will be used as manager. In our example, we will use yarn, so type yarnand press enter.\nQuestion 2: Path to the beagle module (press enter to use default)\nIn this case, type the module path that will be used for Beagle. Considering we’re creating this project from zero e and there is no module, you just have to press enter without informing anything.\nQuestion 3: Path to the module with the components to use with beagle (press enter to use default)\nIn this case, type the module path that will be used for Beagle’s components. Considering we don’t have any module yet, you just have to press enter without informing anything.\nQuestion 4: What’s the base url of the backend providing your beagle JSONs? (press enter to use default)\nIn this case, type the backend’s basis URL that will be used to rescue JSON files. For our example, we’ll use a JSON, so just type: http://localhost:4200/assets\nAt the end of this process, two files will be generate on your project:\n beagle-components.module.ts beagle.module.ts.  Open the file app.module.ts and, then, import Beagle’s module that was just generated:\n... import { Beagle } from './beagle.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, Beagle ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Step 2: Create a JSON to be rendered Now, you just have to create a JSON to render the components. Usually, this process would be made by an external server that would return de JSON, but for this example we’ll create a local file to be accessed for the test.\nOn your angular project, navigate to the src/assets file and create a new file named payload.json. Open this new file you just created and copy the content below:\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\": \"Beagle is a cross-platform framework which provides usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] }  The Beagle’s library comes with many pre-defined components ready to be used in their project.\nThe code above creates a JSON with two os these components: container e text.\n After you created your JSON, open the file beagle.module.ts we generated in the previous step and add as a baseUrl the path: http://localhost:4200/assets\nimport { BeagleModule } from '@zup-it/beagle-angular' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, }) export class Beagle {} Well done, your configuration is ready! Now, we’ll see how to render mapped components on JSON.\nStep 3: Use beagle-remote-view After creating the JSON, you need to tell Angular where to render the Beagle components. To do this, our lib provides the component \u003cbeagle-remote-view\u003e.\nOpen the file app.component.html and replace all the content with this code:\n\u003cbeagle-remote-view route=\"/payload.json\"\u003e\u003c/beagle-remote-view\u003e route in the code above states which route will be loaded. The URL specified here is relative to the baseUrl declared in the configuration.\nThe parameter route is only valid for versions 1.3 and above. For previous versions, you should use loadParams instead. loadParams is an object and the equivalent to this configuration would be { path: '/payload.json' }.  Example Testing the application Before we test if our configuration worked, you have to run one of the commands below to initialize the application.\nWhen you run the application, you can’t use use the ng serve command because it will initialize the application without Beagle. To make the Beagle’s initialization, it’s necessary to run one of the commands indicated for those who use npm or yarn.  If you use npm:\nnpm run serve If you use yarn:\nyarn serve  It’s important to clarify here that the command used to restart the application is fundamental make work the changes you intend to make in Beagle’s configurations files.\nThis process also must be done for any change made on @Input() proprieties of your mapped components. Beagle’s team is constantly developing solutions to improve this.\n After finished this commands, access the local: http://localhost:4200\nYou will see this screen:\nWell done, you created your first screen with Beagle!  ","excerpt":" Usage configurations After you finished the installation, you need to …","ref":"/docs-beagle/docs/get-started/using-beagle/web/angular/","title":"Angular"},{"body":" Configurações de uso Depois que você terminar a instalação, é preciso configurar o Beagle para o uso no framework do Angular. Para isso, basta realizar os seguintes passos:\nPasso 1: Configuração automática Execute um dos comandos abaixo para gerar os arquivos que serão usados pela biblioteca Beagle. É possível executar o comando de acordo com seu gerenciador de pacotes:\nyarn beagle init npx beagle init Feito isso, o Beagle irá retornar algumas perguntas. Para respondê-las, siga as orientações abaixo:\nPergunta 1: Would you like to use yarn or npm?\nVocê gostaria de usar yarn ou npm?\nNeste caso, digite a opção que irá utilizar como gerenciador. No nosso exemplo, usaremos o yarn, logo digite yarne aperte enter.\nPergunta 2: Path to the beagle module (press enter to use default)\nCaminho para o modulo do Beagle (pressione enter para usar o default)\nNeste caso, digite qual o caminho do módulo que será usado para o beagle. Como estamos criamos o projeto do zero e não temos nenhum módulo, é só dar enter sem informar nada.\nPergunta 3: Path to the module with the components to use with beagle (press enter to use default)\nCaminho para usar o módulo com componentes para usar o Beagle (pressione enter para usar default)\nNeste caso, digite qual o caminho do módulo que será usado para os components do beagle. Como ainda não temos nenhum módulo, é só dar enter sem informar nada.\nPergunta 4: What’s the base url of the backend providing your beagle JSONs? (press enter to use default)\nQual a base url do backend que providencia o seu JSONs ao Beagle? (pressione enter para usar o default)\nNeste caso, digite qual será a URL base do backend que será utilizada para resgatar os arquivos JSON. Para o nosso exemplo, usaremos um JSON, logo é só digitar: http://localhost:4200/assets\nAo final deste processo, serão gerados dois novos arquivos em seu projeto:\n beagle-components.module.ts beagle.module.ts.  Abra o arquivo app.module.ts e, em seguida, importe o módulo Beagle que acabou de ser gerado:\n... import { Beagle } from './beagle.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, Beagle ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Passo 2: Criação do JSON de definição do layout Agora, você precisa criar um arquivo JSON que definirá os componentes que serão renderizados. Geralmente, esse arquivo seria obtido por um servidor externo, mas neste exemplo criaremos um arquivo local para ser acessado como teste.\nNo seu projeto angular, navegue até a pasta src/assets e crie um novo arquivo com o nome payload.json. Abra este novo arquivo que foi criado e copie o conteúdo abaixo:\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle is a cross-platform framework which provides usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] }  A biblioteca Beagle já vem com diversos componentes pré-definidos e prontos para serem usados em seu projeto.\nO código acima cria um JSON com dois desses componentes: container e text.\n Depois de criado o seu JSON, abra o arquivo beagle.module.ts gerado no passo anterior e adicione como baseUrl o caminho: http://localhost:4200/assets\nimport { BeagleModule } from '@zup-it/beagle-angular' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, }) export class Beagle {} Pronto, a configuração está finalizada agora vamos aprender como renderizar os componentes mapeados no JSON.\nPasso 3: Usando o beagle-remote-view Depois de criado o JSON, você precisa especificar, dentro da aplicação, o local em que os componentes serão renderizados. Para realizar essa ação, a biblioteca do Beagle fornece o componente \u003cbeagle-remote-view\u003e.\nAbra o arquivo app.component.html e substitua todo o conteúdo pelo código a seguir:\n\u003cbeagle-remote-view route=\"/payload.json\"\u003e\u003c/beagle-remote-view\u003e route no código acima diz qual a rota será carregada. A URL especificada aqui é relativa à baseUrl declarada na configuração.\nO parâmetro route é válido apenas para a versão 1.3 ou superior. Para versões anteriores, loadParams deve ser usado. loadParamsé um objeto e o valor equivalente ao desse exemplo seria{ path: '/payload.json' }.  Exemplo Testando a aplicação Para testarmos se a nossa configuração funcionou, você precisa rodar um dos comandos abaixo para inicializar a aplicação.\nAo executar a aplicação, você não deve utilizar o comando ng serve porque ela será iniciada sem compilar os arquivos do Beagle. Para que o Beagle seja inicializado corretamente, é necessário utilizar um dos comandos abaixo de acordo com seu gerenciador de pacotes.  Caso utilize npm:\nnpm run serve Caso utilize yarn:\nyarn serve  É importante deixar claro que o comando para reiniciar a aplicação é fundamental para que as alterações que você fez nos arquivos de configuração do Beagle funcionem.\nEste processo também deve ser feito para qualquer alteração feita nas propriedades @Input() de seus componentes mapeados. A equipe Beagle está constantemente desenvolvendo soluções para melhorar isso.\n Depois de finalizado o comando acesse a aplicação em: http://localhost:4200\nVocê deverá ver a tela a seguir:\nParabéns, você criou sua primeira tela com Beagle!  ","excerpt":" Configurações de uso Depois que você terminar a instalação, é preciso …","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/web/angular/","title":"Angular"},{"body":" Usage configurations After you finished the installation, you need to make Beagle’s usage configuration for React’s framework. To do so, you just have to follow these steps:\nStep 1: Create a JSON to be rendered On your React project, on the public folder, create a file named payload.json and copy the code below. This file will map the components that will be rendered by Beagle. Generally, it would be returned by a external server, but on this example, we’ll make a local JSON file to be rendered with Beagle’s library. .\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle is a cross-platform framework which provides usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] }  Beagle’s library comes with many pre-defined components ready to be used in their project.\nThe code above creates a JSON with two os these components: container e text.\n Step 2: Create a configuration file After you add the JSON on your project, create another file in the path /src, but this time with the name Beagle. Inside it, name a new file as beagle-service.ts.\nOnce you made it, your structure must be similar to the image below:\nNow open the beagle-service.ts file and copy this code:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} }) At this point of the configuration, you can add, for example, a path to Beagle’s external server. The most indicated is to let the baseUrl propriety without value because we’ll use a local file (payload.json) for this example.\nIt’s important to reinforce that, for this example, we’re using typescript with the project. In case you don’t have this tool, we highly recommend you to install it, otherwise, please, ignore all the typing information.  Step 3: Using BeagleRemoteView Now you need to specify inside the application, the place where the components will be rendered. For that, open Beagle’s library that provides BeagleRemoteView and BeagleProvider. Open the component file where you want the JSON to be rendered and change it as in the example below:\nimport React from 'react'; import './App.css'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView route={'/payload.json'} /\u003e \u003c/BeagleProvider\u003e ); } export default App; When we make this note, we indicate to Beagle that our defined layout will be rendered on payload.json file. In this case, two components are provided on the library:\n \u003cBeagleProvider\u003e: Responsible to provide a valuepropriety as beagle-service created on the previous step and contains the initial configurations; \u003cBeagleRemoteView\u003e: Responsible to receive a path propriety, which is the path to our JSON file.  See that here we added ' / ‘ because this value will be associated to the definedbaseUrl on the file beagle-service.ts  route in the BeagleRemoteView is only valid for versions 1.3.0 and above. For earlier versions, please, use path instead.  Use Example Testing the project Before we test if our configuration worked, you have to run one of the commands below to initialize the application:\nyarn start npm run start After finished this commands, access the local: localhost:3000\nYou will see this screen:\nWell done, you created your first screen with Beagle!  ","excerpt":" Usage configurations After you finished the installation, you need to …","ref":"/docs-beagle/docs/get-started/using-beagle/web/react/","title":"React"},{"body":" Configurações de uso Depois que você terminar a instalação, é preciso configurar o Beagle para o uso no framework do React. Para isso, basta realizar os seguintes passos:\nPasso 1: Criação do JSON de definição do layout Dentro do seu projeto React na pasta public, crie um arquivo chamado payload.json com o código abaixo. Este arquivo mapeará os componentes que serão renderizados pelo Beagle. Geralmente, ele seria retornado por um servidor externo, mas neste exemplo criaremos localmente no projeto.\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle is a cross-platform framework which provides usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] }  A biblioteca Beagle já vem com diversos componentes pré-definidos e prontos para serem usados em seu projeto.\nO código acima cria um JSON com dois desses componentes: container e text.\n Passo 2: Configuração do Beagle Service Depois de adicionar o arquivo payload.json no seu projeto, crie uma pasta no caminho /srccom nome beagle. Dentro dela, adicione um novo arquivo com o nome beagle-service.ts.\nFeito isso, a sua estrutura deve estar parecida com a imagem a seguir:\nAbra agora o arquivo criadobeagle-service.ts e insira o código abaixo:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} }) Neste ponto da configuração podemos definir a baseUrl do servidor externo do Beagle. Para este exemplo, deixaremos esta propriedade sem valor pois usaremos um arquivo local (payload.json).\nÉ importante ressaltar que, para este exemplo, estamos usando otypescript junto ao projeto. Caso você não tenha na sua máquina, será preciso instalar.  Passo 3: Usando o BeagleRemoteView Agora você precisa especificar, dentro da aplicação, o local em que os componentes serão renderizados. Para isso, a biblioteca do Beagle fornece o BeagleRemoteView e o BeagleProvider. Abra o arquivo do componente que você deseja renderizar o layout e altere para ficar como o exemplo a seguir:\nimport React from 'react'; import './App.css'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView route={'/payload.json'} /\u003e \u003c/BeagleProvider\u003e ); } export default App;  \u003cBeagleProvider\u003e: Responsável por prover para nossa aplicação o beagle-service criado no passo anterior contendo as configurações iniciais. Este é especificado na propriedade value; \u003cBeagleRemoteView\u003e: Responsável por renderizar o layout definido pelo JSON especificado pela propriedade route.  Note aqui que adicionamos ' / ‘ pois esse valor será associado ao baseUrl definido no arquivo beagle-service.ts  route no BeagleRemoteView só é válido para as versões 1.3 e superior. Para versões anteriores, por favor, use path.  Exemplo prático Testando o projeto Para testarmos se a nossa configuração funcionou, você precisa executar um dos comandos abaixo para inicializar a aplicação:\nyarn start npm run start Depois de finalizar o comando, acesse: localhost:3000. Você deverá ver a tela a seguir:\nParabéns, você criou sua primeira tela com Beagle!  ","excerpt":" Configurações de uso Depois que você terminar a instalação, é preciso …","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/web/react/","title":"React"},{"body":" Use configuration Once you have finishedBeagle’s installation, your BFF is fully configured for usage, with default settings.\nCORS Required configuration only to use your BFF with front-end web.  This process it is done according to your backend technology and, for that, we recommend you to check the tool’s documentation you have chosen.\nIf you are using one of our starters, check out the following links with both framework’s documentations about CORS:\n Micronaut Spring  We provided a constant BEAGLE_EXPOSED_HEADERS, that contains a list of headers names that Beagle needs to expose in your CORS configuration.\nA practical BFF example Step 1: Create a service Micronaut SpringBoot First, you should create a class to configure a Service . The process is pretty simple, you just have to:\n Create a class and name it as MyService; Note it with @Singleton, because this will be responsible to create your objects.  The example below, you can see the result that must appear on your screen:\nimport javax.inject.Singleton @Service class MyService { fun createAction(): Action = Alert( title = \"My Dialog\", message = \"This is a native popup!\", labelOk= \"Close\" ) fun createScreen(): Screen = Screen(child = this.createWidget()) fun createScreenBuilder(): ScreenBuilder = MyScreenBuilder(this.createWidget()) fun createWidget(): Widget = Text( text = \"Hello, world!\", alignment = TextAlignment.CENTER, textColor = \"#505050\" ) } private class MyScreenBuilder( private val component: ServerDrivenComponent ) : ScreenBuilder { override fun build() = Screen(child = this.component) }  To start, you should create a class to configure a Service . The process is pretty simple, you just have to:\n Create a class and name it as MyService; Note it with @Service , because this will be responsible to create your objects.  import javax.inject.Singleton @Service class MyService { fun createAction(): Action = Alert( title = \"My Dialog\", message = \"This is a native popup!\", labelOk= \"Close\" ) fun createScreen(): Screen = Screen(child = this.createWidget()) fun createScreenBuilder(): ScreenBuilder = MyScreenBuilder(this.createWidget()) fun createWidget(): Widget = Text( text = \"Hello, world!\", alignment = TextAlignment.CENTER, textColor = \"#505050\" ) } private class MyScreenBuilder( private val component: ServerDrivenComponent ) : ScreenBuilder { override fun build() = Screen(child = this.component) }  Step 2: Create a controller Micronaut SpringBoot The next step is to create a Controllerclass to expose our components through REST API. This class will be noted as @Controller.\nThis class receives a MyService through a primary constructor, so Micronaut can automatically make a dependency injection for you.\nThe endpoints are configured as notes according to HTTP method (for example, @Get to HTTP GET). They still receive a string that defines your path.\nTo configure your class, follow the example below. Remember to name the file asMyController so you can simply copy and paste this example.\nimport io.micronaut.http.annotation.Controller import io.micronaut.http.annotation.Get @Controller class MyController(private val myService: MyService) { @Get(\"/action\") fun getAction() = myService.createAction() @Get(\"/screen\") fun getScreen() = myService.createScreen() @Get(\"/builder\") fun getScreenBuilder() = myService.createScreenBuilder() @Get(\"/widget\") fun getWidget() = myService.createWidget() }  Once you made it, the next step is create a Controller class to expose our components through REST API. This class must be noted as@RestController\nThis class also must receive MyService through a primary constructor so Spring can automatically makes a dependency injection for you.\nThe endpoints are configured with notes according to HTTP method (for example @Get to HTTP GET). They receive a string that defines your path.\nTo configure this class, follow the example below. Remember to name the file asMyController so you can simply copy and paste this example.\nimport org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController @RestController class MyController(private val myService: MyService) { @GetMapping(\"/action\") fun getAction() = myService.createAction() @GetMapping(\"/screen\") fun getScreen() = myService.createScreen() @GetMapping(\"/builder\") fun getScreenBuilder() = myService.createScreenBuilder() @GetMapping(\"/widget\") fun getWidget() = myService.createWidget() }  Step 3: Configure your BFF You can configure cache and serialization using the lines below, by adding them to your application.properties.\nMicronaut SpringBoot The cache is configured to include /screen and /widget endpoints. The TTL for the /screen endpoint is configured to 50 seconds.\nbeagle.cache.endpoint.include=/screen,/widget beagle.cache.endpoint.ttl./screen=50s jackson.serializationInclusion=NON_NULL jackson.serialization.indentOutput=true  Cache is configured to exclude the /action endpoint\nbeagle.cache.endpoint.exclude=/action spring.jackson.default-property-inclusion=NON_NULL spring.jackson.serialization.indent-output=true  Serialization is configured to skip values that are not null and format the JSONs to make them easier to read.\nStep 4: Configure CORS Required configuration only to use your BFF with web front-end.  Micronaut SpringBoot You can configure CORS with the lines below, adding them in your application.properties.\nCORS is enabled here with default values to several details, and it will make them permissive. The cache header is exposed.\nmicronaut.server.cors.enabled=true micronaut.server.cors.configurations.beagle.exposedHeaders=beagle-hash  You can configure CORS with the classes below, that needs to implement Spring’s WebMvcConfigurerinterface, overlapping the addCorsMappings method.\nCORS is configured here to all endpoints with default values to several details, letting them very permissive. Our cache header is exposed using the constant.\nimport org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration open class CorsConfig : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(\"/**\").exposedHeaders(*BEAGLE_EXPOSED_HEADERS) } }  Use a permissive configuration like this one, only in local development environment. It eliminates CORS’s security benefits  We have an enabled CORS withmeusite.com.br like the permitted origin: GET, PUT, POST like the allowed methods Cache-control like an allowed header; and beagle-hash, x-meu1 like exposed header.\nMicronaut SpringBoot micronaut.server.cors.enabled=true micronaut.server.cors.configurations.meu.allowedOrigins=meusite.com.br micronaut.server.cors.configurations.meu.allowedMethods=GET,PUT,POST micronaut.server.cors.configurations.meu.allowedHeaders=Cache-Control micronaut.server.cors.configurations.meu.exposedHeaders=beagle-hash,x-meu1  import org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration open class CorsConfig : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(\"/**\") .allowedOrigins(\"meusite.com.br\") .allowedMethods(\"GET,PUT,POST\") .allowedHeaders(\"Cache-Control\") .exposedHeaders(*(BEAGLE_EXPOSED_HEADERS + \"x-meu1\")) } }  Step 5: Start your BFF After you have done the configuration above, you can start your BFF. Just run the command below in your project, a reminder, it needs to starts the server on port 8080 in your localhost.\nMicronaut SpringBoot $ mvn compile exec:exec  $ mvn spring-boot:run  Now that the BFF is running, to see the resulting JSON, insert the URL http://localhost:8080/action directly on your navigator. You should get the result below.\n{ \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"My Dialog\", \"message\" : \"This is a native popup!\", \"labelOk\" : \"Close\" } ","excerpt":" Use configuration Once you have finishedBeagle’s installation, your …","ref":"/docs-beagle/docs/get-started/using-beagle/backend/","title":"Backend"},{"body":" Configurações de uso Quando você finalizar a instalação do Beagle, seu BFF estará com a configuração padrão de uso.\nCORS Configuração obrigatória apenas para usar seu BFF com front-end web.  Este processo é feito de acordo com sua tecnologia de backend e, por isso, recomendamos que você cheque a documentação da ferramenta escolhida para ver que diz a respeito disso.\nSe você estiver usando um de nossos starters, segue os links das documentações dos frameworks sobre o CORS:\n Micronaut Spring  Disponibilizamos uma constante, BEAGLE_EXPOSED_HEADERS, contendo uma lista dos nomes das headers que o próprio Beagle precisa para poder expor na sua configuração de CORS.\nUm exemplo prático de BFF Passo 1: Criar um serviço Micronaut SpringBoot Para começar, você deve criar uma classe para configurar um serviço. O processo é bem simples basta:\n Criar uma classe e nomeá-la como MyService Anotá-la com o @Singleton  No exemplo abaixo, você confere o resultado que deve aparecer na sua tela:\nimport javax.inject.Singleton @Singleton class MyService { fun createAction(): Action = Alert( title = \"My Dialog\", message = \"This is a native popup!\", labelOk= \"Close\" ) fun createScreen(): Screen = Screen(child = this.createWidget()) fun createScreenBuilder(): ScreenBuilder = MyScreenBuilder(this.createWidget()) fun createWidget(): Widget = Text( text = \"Hello, world!\", alignment = TextAlignment.CENTER, textColor = \"#505050\" ) } private class MyScreenBuilder( private val component: ServerDrivenComponent ) : ScreenBuilder { override fun build() = Screen(child = this.component) }  Para começar, você deve criar uma classe para configurar um serviço. O processo é bem simples basta:\n Criar uma classe e nomeá-la como MyService Anotá-la com o @Service  No exemplo abaixo, você confere o resultado que deve aparecer na sua tela:\nimport javax.inject.Singleton @Service class MyService { fun createAction(): Action = Alert( title = \"My Dialog\", message = \"This is a native popup!\", labelOk= \"Close\" ) fun createScreen(): Screen = Screen(child = this.createWidget()) fun createScreenBuilder(): ScreenBuilder = MyScreenBuilder(this.createWidget()) fun createWidget(): Widget = Text( text = \"Hello, world!\", alignment = TextAlignment.CENTER, textColor = \"#505050\" ) } private class MyScreenBuilder( private val component: ServerDrivenComponent ) : ScreenBuilder { override fun build() = Screen(child = this.component) }  Passo 2: Criar um Controller Micronaut SpringBoot O próximo passo é criar uma classe Controller para expor nossos componentes via REST API. Esta classe ser anotada com @Controller.\nAlém disso, a classe também deve receber um MyService via construtor primário para que o Micronaut faça automaticamente a injeção da dependência para você.\nOs endpoints são configurados com anotações seguindo o método HTTP (por exemplo, @Get para HTTP GET). Eles recebem ainda uma string que define o seu path.\nPara configurar sua classe, siga o exemplo abaixo. Lembre de nomear o arquivo como MyController para que você possa simplesmente copiar e colar este exemplo.\n{% code title=\"\" %}}\nimport io.micronaut.http.annotation.Controller import io.micronaut.http.annotation.Get @Controller class MyController(private val myService: MyService) { @Get(\"/action\") fun getAction() = myService.createAction() @Get(\"/screen\") fun getScreen() = myService.createScreen() @Get(\"/builder\") fun getScreenBuilder() = myService.createScreenBuilder() @Get(\"/widget\") fun getWidget() = myService.createWidget() }  Feito isso, o próximo passo é criar uma classe Controller para expor nossos componentes via REST API. Esta classe ser anotada com @RestController.\nAlém disso, ela também deve receber MyService via um construtor primário para que o Spring automaticamente faça a injeção de dependência para você.\nOs endpoints são configurados com anotações seguindo o método HTTP (por exemplo @Get para HTTP GET). Eles recebem uma string que define o seu path.\nPara configurar sua classe, siga o exemplo abaixo. Lembre de nomear o arquivo como MyController para que você possa simplesmente copiar e colar este exemplo:\nimport org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController @RestController class MyController(private val myService: MyService) { @GetMapping(\"/action\") fun getAction() = myService.createAction() @GetMapping(\"/screen\") fun getScreen() = myService.createScreen() @GetMapping(\"/builder\") fun getScreenBuilder() = myService.createScreenBuilder() @GetMapping(\"/widget\") fun getWidget() = myService.createWidget() }  Passo 3: Configurar o BFF Você pode configurar cache e serialização com as linhas abaixo, adicionando elas no seu application.properties.\nMicronaut SpringBoot O cache é configurado para incluir os endpoints /screen e /widget. O TTL para o endpoint /screen é configurado para 50 segundos.\nbeagle.cache.endpoint.include=/screen,/widget beagle.cache.endpoint.ttl./screen=50s jackson.serializationInclusion=NON_NULL jackson.serialization.indentOutput=true  O cache é configurado para excluir o endpoint /action.\nbeagle.cache.endpoint.exclude=/action spring.jackson.default-property-inclusion=NON_NULL spring.jackson.serialization.indent-output=true  A serialização é configurada para ignorar valores que são null e formatar o JSON para facilitar leitura.\nPasso 4: Configurar o CORS Configuração obrigatória apenas para usar o BFF com frontend web  Micronaut SpringBoot Você pode configurar CORS com as linhas abaixo, adicionando elas no seu application.properties.\nAqui CORS é habilitado com valores padrões para vários detalhes, deixando-os muito permissivos. Nossa header de cache é exposta.\nmicronaut.server.cors.enabled=true micronaut.server.cors.configurations.beagle.exposedHeaders=beagle-hash  Você pode configurar CORS com as classes abaixo, que precisam implementar a interface WebMvcConfigurer do Spring, sobrepondo o método addCorsMappings.\nAqui CORS é configurado para todos os endpoints com valores padrões para vários detalhes, deixando-os muito permissivos. Nossa header de cache é exposta usando a constante.\nimport org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration open class CorsConfig : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(\"/**\").exposedHeaders(*BEAGLE_EXPOSED_HEADERS) } }  Use uma configuração permissiva como essa apenas em ambiente local de desenvolvimento. Ela elimina todos os benefícios de segurança do CORS.  Configurando mais granularmente, temos aqui CORS habilitado com meusite.com.br como origem permitida; GET, PUT, POST como métodos permitidos; Cache-control como header permitida; e beagle-hash, x-meu1 como header expostas.\nMicronaut SpringBoot micronaut.server.cors.enabled=true micronaut.server.cors.configurations.meu.allowedOrigins=meusite.com.br micronaut.server.cors.configurations.meu.allowedMethods=GET,PUT,POST micronaut.server.cors.configurations.meu.allowedHeaders=Cache-Control micronaut.server.cors.configurations.meu.exposedHeaders=beagle-hash,x-meu1  import org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration open class CorsConfig : WebMvcConfigurer { override fun addCorsMappings(registry: CorsRegistry) { registry.addMapping(\"/**\") .allowedOrigins(\"mywebsite.com\") .allowedMethods(\"GET,PUT,POST\") .allowedHeaders(\"Cache-Control\") .exposedHeaders(*(BEAGLE_EXPOSED_HEADERS + \"x-meu1\")) } }  Passo 5: Iniciar o BFF Depois de realizar as configurações acima, você já pode iniciar seu BFF. Para isso, basta usar o comando abaixo em seu projeto, lembrando que ele deve começar o servidor na porta 8080 em seu localhost.\nMicronaut SpringBoot $ mvn compile exec:exec  $ mvn spring-boot:run  Agora que seu BFF está executando, para ver o JSON resultante, insira a URL http://localhost:8080/action direto no seu navegador e deve obter o resultado abaixo.\n{ \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"My Dialog\", \"message\" : \"This is a native popup!\", \"labelOk\" : \"Close\" } ","excerpt":" Configurações de uso Quando você finalizar a instalação do Beagle, …","ref":"/docs-beagle/pt/docs/primeiros-passos/usando-o-beagle/backend/","title":"Backend"},{"body":" You can see blow some practical cases to you use Beagle on your project:\n","excerpt":" You can see blow some practical cases to you use Beagle on your …","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/","title":"Creating a project from scratch"},{"body":" Confira abaixo quais cases práticos você pode usar no seu projeto com Beagle:\n","excerpt":" Confira abaixo quais cases práticos você pode usar no seu projeto com …","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/","title":"Criando um projeto do zero"},{"body":" Starting an Android project For this practical example, we’ll use Android Studio IDE. In case you still don’t have it installed, just access on official Android website and follow the instructions.\nAfter you installed the program, follow the steps below:\nStep 1: Open Android Studio and click on Start a new Android Studio project.\nStep 2: Choose the Empty Activity option and click on next.\nStep 3️: On this page, we should list some important informations:\n Inform your project’s name. On this example, we’ll call BeagleApp. Choose which language you’ll use. For Beagle, we should go withKotlin. Choose SDK minimum 19, because a lower SDK won’t be compatible. Define a package and a Save location according to your preference. Click on Next.  Step 4️: After you made the previous configurations, Android will take some time to build the project because it will be synchronizing all the initials dependencies to initialize the project\nOnce the initialization is done, you will see this page:\nWell done, your project was created on Android! Now, you will need to configure Beagle following the next steps.  Configuring Beagle Step 1: Define the dependencies To start, you have to configure Beagle’s dependencies on your repository. This can be done using the configurations below and downloading Beagle’s library.\n Open your project on Android Studio. Search for Graddle scripts file on the project. On this file, there are two files gradle name. Open the first one named.build.graddle(project:Beagle). Search for allprojects code block and configure Maven credentials as you see in the list below:  // Add it in your root build.gradle at the end of repositories: allprojects { repositories { google() jcenter() // \u003c 1.1.0  maven { url 'https://dl.bintray.com/zupit/repo'  } // \u003e= 1.1.0  mavenCentral() } }  Close build.graddle(project:Beagle) file.  Once you made it, we should include kapt plugin and Beagle as dependencies on dependency manager. To do so, follow these instructions:\n Open thebuild.graddle(Module:app) file  Notice that some plugins are already listed on the file’s beginning arquivo as it shows the image below:\n Then, add the line_apply plugin: 'kotlin-kapt'_  After that, you need to add some dependencies:\n Search for this file that is moving in dependencies { }code block. Add a ext.beagle_version variable on the top (in this case, out of) the dependencies scope  The current release version of Beagle is:    Copy and paste the lines below inside your dependencies:\n implementation “br.com.zup.beagle:android:$beagle_version” kapt “br.com.zup.beagle:android-processor:$beagle_version”  // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" }  Insert the Beagle’s release version on the place of${beagle.version}, in other words, put the Beagle’s version highlighted in blue badge above without the v caracter.\nFor example: undefined-ext.beagle.version = \"0.2.8\"\n At the end of these configurations, your file must be like this:\nStep 2: Configure the Android Manifest file The next step is to update your Android Manifest project by adding a few lines to the file:\n INTERNET’s permission so your application can be able to access internet. \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e  If you find difficulties to find this or another file, just use Android Studios search bar.\nTo enable it, press**SHIFT**button twice and the search interface will appear. Once you made it, just just have to type AndroidManifest and Android Studio will find it.\n \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication ... android:usesCleartextTraffic=\"true\" ... Let this file open because we’ll use it again in another moment.\n The usesCleartextTraffic: Indicates with the app intends to use cleartext network traffic, HTTP. The default value for apps that target API level 27 or lower is “true”. Apps that target API level 28 or higher default to “false”. The attribute android:usesCleartextTraffic=\"true\" inside \u003capplication\u003etag is used to communicate with the local BFF. Them if you intent to debug the project using a local BFF you can use this as an easy configuration step. Although, if you plan to turn this example into a release application, we recomend you using the networkSecurityConfig which you can configure using android developers page instructions.   Passo 3: Create an AppBeagleConfig For the next steps, you should create a AppBeagleConfig class, that is part of Beagle’s installation and it’s responsible to register some important configurations.\nWhen you create the call, we should guarantee that it’s configured in this way:\n Noted with @BeagleComponent And extending BeagleConfigclass.  To create AppBeagleConfig, follow these steps:\n First, we create a package with all configurations' files. Then, click with the right button on the main package of your project and click on new \u003e package __like in the image below:  Even though you can name the file as you want to, we’ll recommend for this tutorial that you use the namebeagle.\n3. Click with the right button on beagle's package and click on **new\u0026gt;Kotlin File/Class**  __4. __Name it as AppBeagleConfig and then press ENTER\nCopy and paste the configurations below on AppBeagleConfig file you just created. Notice that it will implement two attributes: baseUrl and environment.   The baseUrl returns the basis URL of your environment. The**environment** returns the _current build state_ of your application. **isLoggingEnabled**returns the application’s log view The cache manager configuration.  import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.setup.BeagleConfig import br.com.zup.beagle.android.setup.Cache import br.com.zup.beagle.android.setup.Environment @BeagleComponent class AppBeagleConfig : BeagleConfig { override val baseUrl: String get() = \"http://10.0.2.2:8080\" // return the base url based on your environment  override val environment: Environment get() = Environment.DEBUG // return the current build state of your app  override val isLoggingEnabled: Boolean = true override val cache: Cache get() = Cache( enabled = true, // If true, we will cache data on disk and memory.  maxAge = 300, // Time in seconds that memory cache will live.  memoryMaximumCapacity = 15 // Memory LRU cache size. It represents number of screens that will be in memory.  ) // Cache management configuration }  At this tutorial point, we will test our Server-Driven screens on local host because it’s important that our baseURL be local.\nNow, Beagle expects that your@BeagleComponent classes must have only empty constructors.\n Step 4: Create AppBeagleActivity You will have to deal with the activities that will be generated through server-driven. That’s the reason why it’s necessary to implement an Activity to manage them. For this example, we’ll name it asAppBeagleActivity.\nThis file is part of Beagle’s usage configuration and must be implemented, at least once, so Beagle can normally work.\nWhen you create AppBeagleActivity, remember to note it as BeagleComponent and to extend it toBeagleActivity class.\nIt’s very important to ensure that this activity is registered on Android Manifest. Make it right after you create the activity.  Follow the steps below to create AppBeagleActivity, including .xml file:\n Click with the right button on Beagle’s package and click on New\u003eActivity\u003eEmpty Activity  Name it as AppBeagleActivity for the Activity and click on finish.  From now on, Beagle will use this activity every time to load the screen’s informations received from backend on your application’s frontend.  We left a configuration example below so you just copy and paste.\n First, find this activity layout. It’s probably onRES \u003e LAYOUT \u003e with the name of activity_app_beagle.xml Copy and paste the .xml content below removing any previous content:  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/custom_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cFrameLayout android:id=\"@+id/server_driven_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_gravity=\"center\" android:visibility=\"gone\"/\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e  Now open AppBeagleActitivity.kt file and configure as it shows below:  @BeagleComponent class AppBeagleActivity : BeagleActivity() { private val progressBar: ProgressBar by lazy { findViewById\u003cProgressBar\u003e(R.id.progress_bar) } private val mToolbar: Toolbar by lazy { findViewById\u003cToolbar\u003e(R.id.custom_toolbar) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_app_beagle) } override fun getServerDrivenContainerId(): Int = R.id.server_driven_container override fun getToolbar(): Toolbar = mToolbar override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { when (state) { is ServerDrivenState.Started -\u003e { progressBar.visibility = View.VISIBLE } is ServerDrivenState.Finished -\u003e { progressBar.visibility = View.GONE } is ServerDrivenState.Error -\u003e { Toast.makeText(this, \"Error\", Toast.LENGTH_LONG).show() } } } }  At this point, it’s essential that you remove theActionBar pattern of this activity because, from now on, Beagle will manage the ActionBar/Toolbar.  To make this configuration, you must change your BeagleActivity’s theme. Go to Resources folder on your Android Studio’s application and open theSTYLE file. Then, just change your AppTheme like the example below:\n\u003cresources\u003e \u003c!-- Beagle Activity theme. --\u003e \u003cstyle name=\"MyTheme\" parent=\"Theme.AppCompat.NoActionBar\"\u003e Step 5: Initialize Beagle and the Design System What is Design System?\nFor more information, see section Design System with Beagle Android.\n É o design system que guarda os registros dos componentes de estilo criados no frontend e é assim que sua aplicação Android “saberá” qual componente de estilo deve aplicar a cada elemento de uma tela Server-Driven. É na tela server driven que os elementos visuais (views) são utilizados na construção da sua tela.\nEmbora você possa criá-lo agora se quiser, não é necessário para as configurações iniciais, para que você possa testar logo o Beagle! Você pode prosseguir sem configurá-lo. Para mais informações sobre Design System no Beagle para Android.\n Now , you must initialize your Application so Beagle can manage the other configuration’s files. To do so, just click onMake project (HAMMER symbol) or use the command CTRL + F9.\nWhen it’s initialized, Beagle will automatically create a BeagleSetup file that will be in the folder with the generated files, like in the image below:\nStep 6: Create an AppApplication class On this step, you need to create aKOTLIN class that extends to the Applicationclass. For this example, we’ll name it asAppApplication.\nIt’s necessary to make some configurations on this folder so it can BeagleSetup().init(this) function on your onCreate method. Follow these steps:\n Click with the right button on your project’s main package (beagleapp) and choose:  new \u003e Kotlin file/class Name the file as AppApplication and press enter Configure the file as in the example below:    class AppApplication: Application() { override fun onCreate() { super.onCreate() BeagleSetup().init(this) } } To finish this configuration, you must state the class on the AndroidManifest we created in the beginning.  The name of yourapplication now it’s the same of the class you created. Update the Android Manifest as it’s indicated below:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication android:name=\".AppApplication\" ...  Well done, your Android application is configured and ready to use Beagle!  All you have to do now is set up a backend to answer your application’s requests. Once you made this configuration, start your application and you’ll see your first server-driven screen!\nStep 7: Display your Server-Driven Screen It’s very simple to show a Server-Driven screen. Now that all Beagle’s configuration is done, you just have to follow these steps:\n Open the file MainActivity.kt State the intent as listed below. It will define the address of screen’s informations on the backend you configured. Copy and paste the intent listed below on onCreate method.  val intent = this.newServerDrivenIntent\u003cAppBeagleActivity\u003e(ScreenRequest(\"/screen\")) startActivity(intent) finish()  YourMainActivity.kt must be like this:  Now you just have to click on Run app and check out your emulator’s screen!\nYou will see this screen:\nWell done, you created your first screen with Beagle! 🎉  ","excerpt":" Starting an Android project For this practical example, we’ll use …","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/case-android/","title":"Case Android"},{"body":" Iniciando um projeto Android Para este exemplo prático, utilizaremos o Android Studio IDE. Caso você ainda não o tenha instalado, basta acessar no site oficial do Android e seguir as instruções.\nDepois de ter instalado o programa, siga os passos abaixo:\nPasso 1: Abra o Android Studio e clique em Start a new Android Studio project.\nPasso 2: Selecione a opção Empty Activity e clique em next.\nPasso 3️: Nesta página, devemos listar algumas informações importantes:\n Informe o nome do seu projeto. Neste exemplo, chamaremos de BeagleApp. Selecione qual linguagem utilizará. Para o Beagle, devemos utilizar oKotlin. Selecione o SDK mínimo 19, já que qualquer SDK menor que este não será compatível. Defina o package e a Save location de acordo com sua preferência. Clique em Next.  Passo 4️: Feitas as configurações anteriores, o Android levará um tempo pra construir o projeto porque estará sincronizando todas as dependências inicias para inicializar o projeto\nQuando a inicialização for concluída, você verá esta página:\nParabéns, seu projeto foi criado no Android! Agora, você precisará configurar o Beagle, de acordo com os passos a seguir.  Configurando o Beagle Passo 1: Definir as dependências Para começar, você precisa configurar as dependências do Beagle no seu repositório. Isso pode ser feito utilizando as configurações abaixo e fazendo o download da biblioteca do Beagle.\n Abra o seu projeto no Android Studio. Localize o arquivo Graddle scripts no projeto. Nele existem dois arquivos do com o nome gradle. Abra o primeiro cujo nome é build.graddle(project:Beagle) Procure o bloco de código allprojects e configure as credenciais do Maven como listadas abaixo.  // Add it in your root build.gradle at the end of repositories: allprojects { repositories { google() jcenter() // \u003c 1.1.0  maven { url 'https://dl.bintray.com/zupit/repo'  } // \u003e= 1.1.0  mavenCentral() } }  Feche o arquivo build.graddle(project:Beagle)  Feito isso, devemos incluir o kapt plugin e o Beagle como dependências no dependency manager. Para isso, siga estas instruções:\n Abra o arquivo build.graddle(Module:app)  Perceba que alguns plugins já estão listados no começo desse arquivo como mostrado na figura abaixo\n Em seguida, adicione a linha_apply plugin: 'kotlin-kapt'_  Depois disso, você precisa adicionar algumas dependências. Para isso:\n Procure neste arquivo que está mexendo o bloco de código dependencies { }: Adicione a variável ext.beagle_version logo acima (no caso, fora) do escopo das dependências  Versão atual do Beagle    Copie e cole as linhas abaixo dentro das dependências :\n implementation “br.com.zup.beagle:android:$beagle_version” kapt “br.com.zup.beagle:android-processor:$beagle_version”  // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" }  Insira a versão de release do Beagle no lugar de ${beagle.version}, ou seja, coloque a versão do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os números de versão.\nPor exemplo: undefined-ext.beagle.version = \"0.2.8\"\n Ao final destas configurações, o seu arquivo deverá estar assim:\n Passo 2: Configurar o Android Manifest O próximo passo é atualizar o seu projeto no Android Manifest adicionando algumas linhas a este arquivo:\n A permissão de INTERNET para que sua aplicação seja capaz de acessar a internet. \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e  Se você tiver dificuldade para encontrar este ou qualquer arquivo, basta usar a ferramenta de busca do Android Studio.\nPara habilitá-la, aperte o botão**SHIFT**do seu teclado duas vezes e a interface de busca aparecerá . Feito isso, é só digitar AndroidManifest e o Android Studio o localizará.\n \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication ... android:usesCleartextTraffic=\"true\" ... Uma dica é deixar este arquivo aberto porque vamos usá-lo de novo em outro momento.\n O**usesCleartextTraffic:** indica que o aplicativo pretende usar o tráfego de rede de texto não criptografado, HTTP. O valor padrão para aplicativos que visam o nível de API 27 ou inferior é **true**. Os aplicativos que têm como alvo o nível de API 28 ou superior são padronizados como **false**. O atributo android: usesCleartextTraffic = \"true\" dentro da tag \u003capplication\u003e é usado para se comunicar com o BFF local. Se você pretende depurar o projeto usando um BFF local, você pode usar essa configuração como uma etapa de configuração rápida. No entanto, se você planeja transformar este exemplo em um aplicativo para release, recomendamos que você use o networkSecurityConfig, que você pode configurar usando as instruções na página de desenvolvedores do Android.   Passo 3: Criar o AppBeagleConfig Em um próximo passos, você deve criar uma classe chamada AppBeagleConfig. Ela faz parte das configurações iniciais do Beagle e é nela que vamos registrar algumas configurações importantes.\nAo criá-la, devemos garantir que ela esteja configurada da seguinte forma:\n Anotada com o @BeagleComponent E deve estender (extend) da classeBeagleConfig  Para criar o AppBeagleConfig, siga estes passos:\n Primeiro vamos criar o pacote que conterá nossos arquivos de configuração. Clique com botão direito do mouse no pacote principal do seu projeto e click em new \u003e package __conforme a figura abaixo:  Embora você possa nomeá-lo como preferir, sugerimos que para este tutorial você use o nomebeagle\n3. Clique com o botão direito do mouse no pacote beagle e clique em **new\u0026gt;Kotlin File/Class**  __4. __Nomeie como AppBeagleConfig e pressione ENTER\nCopie e cole as configurações abaixo no arquivo AppBeagleConfig que acabou de criar. Perceba que ele implementará os atributos: baseUrl, environment, isLoggingEnabled, cache.   O baseUrl retorna a URL base do seu ambiente. O**environment** retorna o _current build state_ da sua aplicação. O **isLoggingEnabled**retorna a visualização de log da aplicação. O cache configuração de gerenciamento de cache.  import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.setup.BeagleConfig import br.com.zup.beagle.android.setup.Cache import br.com.zup.beagle.android.setup.Environment @BeagleComponent class AppBeagleConfig : BeagleConfig { override val baseUrl: String get() = \"http://10.0.2.2:8080\" // return the base url based on your environment  override val environment: Environment get() = Environment.DEBUG // return the current build state of your app  override val isLoggingEnabled: Boolean = true override val cache: Cache get() = Cache( enabled = true, // If true, we will cache data on disk and memory.  maxAge = 300, // Time in seconds that memory cache will live.  memoryMaximumCapacity = 15 // Memory LRU cache size. It represents number of screens that will be in memory.  ) // Cache management configuration }  A partir deste ponto do tutorial, iremos testar nossas telas Server-Driven usando o local host. Por isso, é importante que nossa**baseURL** seja o seu local host.\nOutro ponto de atenção é que, neste momento, o Beagle espera que classes anotadas com @BeagleComponent tenham seus construtores vazios.\n Passo 4: Criar o AppBeagleActivity Você precisará lidar com as activities que serão geradas via server-driven. Por isso, é necessário implementar uma Activity para gerenciá-las. Para este exemplo, vamos nomeá-la AppBeagleActivity.\nEste arquivo faz parte da configuração de uso do Beagle e deve ser implementado pelo menos uma vez para que ela opere normalmente.\nQuando for criar o AppBeagleActivity, lembre-se de anotá-la com BeagleComponent e estendê-la para classeBeagleActivity.\nVale lembrar que é muito importante garantir que essa activity esteja registrada no Android Manifest. Faça isso assim que criá-la.  Siga os passos abaixo para criar o AppBeagleActivity, incluindo o arquivo .xml:\n Clique com o botão direito do mouse no pacote Beagle e clique em New\u003eActivity\u003eEmpty Activity  Dê o nome de AppBeagleActivity para a Activity e clique em finish.  A partir daí, o Beagle irá utilizar esta activity sempre que carregar as informações das tela recebidas do backend no frontend da sua aplicação.  Deixamos um exemplo abaixo já configurado para você copiar e colar.\n Primeiro localize o layout dessa activity. Ela provavelmente estará emRES \u003e LAYOUT \u003e com o nome de activity_app_beagle.xml Copie e cole o conteúdo abaixo .xml removendo qualquer conteúdo anterior:  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/custom_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cFrameLayout android:id=\"@+id/server_driven_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_gravity=\"center\" android:visibility=\"gone\"/\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e  Agora abra o arquivo AppBeagleActitivity.kt e configure como definido abaixo:  @BeagleComponent class AppBeagleActivity : BeagleActivity() { private val progressBar: ProgressBar by lazy { findViewById\u003cProgressBar\u003e(R.id.progress_bar) } private val mToolbar: Toolbar by lazy { findViewById\u003cToolbar\u003e(R.id.custom_toolbar) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_app_beagle) } override fun getServerDrivenContainerId(): Int = R.id.server_driven_container override fun getToolbar(): Toolbar = mToolbar override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { when (state) { is ServerDrivenState.Started -\u003e { progressBar.visibility = View.VISIBLE } is ServerDrivenState.Finished -\u003e { progressBar.visibility = View.GONE } is ServerDrivenState.Error -\u003e { Toast.makeText(this, \"Error\", Toast.LENGTH_LONG).show() } } } }  Neste ponto do tutorial, é essencial que você remova aActionBar padrão dessa activity porque, a partir deste momento, será o Beagle que irá gerenciar ActionBar/Toolbar.  Para realizar esta configuração, você deve mudar o seu BeagleActivity's theme. Vá até a pasta Resources na sua aplicação do Android Studio e abra o arquivo STYLE . Depois, é só Modificar o seu AppTheme como no exemplo abaixo:\n\u003cresources\u003e \u003c!-- Beagle Activity theme. --\u003e \u003cstyle name=\"MyTheme\" parent=\"Theme.AppCompat.NoActionBar\"\u003e Passo 5: Inicializar o Beagle e o Design System Importante! O que é o Design System?\nÉ o design system que guarda os registros dos componentes de estilo criados no frontend e é assim que sua aplicação Android “saberá” qual componente de estilo deve aplicar a cada elemento de uma tela Server-Driven. É na tela server driven que os elementos visuais (views) são utilizados na construção da sua tela.\nEmbora você possa criá-lo agora se quiser, não é necessário para as configurações iniciais, para que você possa testar logo o Beagle! Você pode prosseguir sem configurá-lo. Mas saiba que o Design System é o pulmão da aplicação server-driven!\nDesign System no Beagle para Android.\n Agora, você deve inicializar sua Application para que o Beagle gere os outros arquivos de configuração que necessita. Para isso, basta clicar emMake project (símbolo de MARTELO) ou use o comando CTRL + F9.\nAo ser inicializado, o Beagle irá criar automaticamente o arquivo BeagleSetup, que estará na pasta de arquivos gerados como mostrado na figura abaixo:\nPasso 6: Criar a classe AppApplication Nesta etapa, você precisa criar uma classeKOTLIN que estenda da classe Application. Neste exemplo, vamos nomeá-la de AppApplication.\nÉ preciso realizar algumas configurações para que a pasta cumpra seu papel de chamar a função BeagleSetup().init(this) em seu método onCreate. Siga os passos abaixo:\n Clique com o botão direito do mouse no pacote principal do seu projeto (beagleapp) e selecione:  new \u003e Kotlin file/class Nomeie o arquivo como AppApplication e aperte enter Configure-a como no exemplo abaixo:    class AppApplication: Application() { override fun onCreate() { super.onCreate() BeagleSetup().init(this) } } Para finalizar a implementação, você deve declarar a classe no Android Manifest que criamos no começo e que já está aberto.  O nome da suaapplication agora é o nome desta classe que você criou. Faça o update do Android Manifest como indicado abaixo:\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.beagleexamples\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e \u003capplication android:name=\".beagle.AppApplication\" ...  Pronto, a sua aplicação Android está configurada e preparada para usar o Beagle!  Tudo o que você precisa agora é configurar um backend para responder as requisições da sua aplicação. Feita esta configuração, inicie a sua aplicação e você verá sua primeira tela server-driven!\nPasso 7: Exibir sua Tela Server-Driven É muito simples exibir uma tela Server-Driven. Agora que toda a configuração do Beagle está pronta, você precisa seguir estes passos:\n Abra o arquivo MainActivity.kt Declare o intent como listado abaixo. Ele vai definir o endereço que tem as informações da sua tela no backend que você configurou. Copie e cole o intent listado abaixo no método onCreate.  val intent = this.newServerDrivenIntent\u003cAppBeagleActivity\u003e(ScreenRequest(\"/screen\")) startActivity(intent) finish()  SuaMainActivity.kt deve ficar assim:  Agora basta somente clicar em Run app e checar sua tela no emulador!\nVocê verá esta tela:\nParabéns, você criou sua primeira tela com Beagle! 🎉  ","excerpt":" Iniciando um projeto Android Para este exemplo prático, utilizaremos …","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-android/","title":"Case Android"},{"body":" Criando um Design System No exemplo prático da página “Criando um projeto com Beagle para Android”, você pode conferir como fazer a implementação do Beagle para criar uma tela server-driven simples, com apenas 2 textos: 1 título e 1 parágrafo.\nNeste tutorial, a ideia é avançar a partir do projeto anterior para criar um Design System na sua biblioteca do Beagle. Os exemplos que ilustrarão o passo a passo estão nestes sample codes que você encontra no nosso repositório.\nO Design System que iremos configurar vai permitir que você customize alguns componentes do Beagle, como por exemplo:\n Text Button Toolbar TabBar Entre outros.  Além disso, será possível customizar os 2 componentes de textos que criamos na primeira tela feita no tutorial anterior.\nContexto Com o Design System deste tutorial, você poderá registrar estilos (styles) como fontes, cores, tamanhos de fonte e componentes customizados.\nDe modo geral, define-se o design system de uma aplicação ao criar uma classe que implemente a sua interface. A partir dela, implementa-se todos os métodos que sobrescrevem as funções responsável por aplicar “estilos” aos componentes. É possível declarar, dentro de uma função, N estilos ou mesmo nenhum (salvo algumas exceções).\nNo caso do Beagle, cada estilo deve ser referenciado de forma que cada um tenha um nome para ser facilmente identificado.\nExemplo No exemplo abaixo, temos o método image que está registrando várias imagens que estão sendo utilizadas para construir uma página a partir do backend.\nPerceba que nela utilizamos um operador when para designar os estilos, ou seja, o primeiro valor é listado como uma string que identifica o componente de estilo no Beagle (semelhante a uma relação de chave/valor) e com umaArrow Function -\u003e listamos o estilo do componente (id do estilo no Android). A lógica aqui se assemelha a um par “chave/valor”.\nCom a função estabelecida desta forma, o operador else conterá um estilo “default”, como demonstrado no código abaixo.\nO trecho em amarelo mostra o “nome do estilo” declarado no backend e recuperado no front end (Android). Já o trecho em laranja mostra o estilo criado no Android que será executado quando “Nome do estilo” for lido no JSON informado pelo backend\nComeçando Vamos à parte prática! Primeiro, você deve localizar a pasta de estilos “Style” em sua IDE Android . Para fazer isso no Android Studio, clique em res \u003e values \u003e styles.\nFeito essa parte, abra o arquivo de estilos (styles) e você verá uma tela semelhante a abaixo. É neste arquivo que listaremos os estilos que serão aplicados nos componentes Android.\nSugerimos manter este arquivo aberto, pois vamos utilizá-lo mais à frente.\nDividimos a criação do design system em 3 passos que serão vistos a seguir:\nPasso 1: Configurar o Design System no Android O primeiro passo na criação de um design system é criar uma classe para representá-lo.\nVale reforçar que o design system que criaremos faz parte do projeto que mencionamos no início do tutorial.  Com o projeto aberto, clique na pasta beagle com o botão direito do mouse e clique em new \u003e kotlin file/class. Feito isso, siga as instruções abaixo:\n Dê o nome de AppDesignSystem ao arquivo (ou outro nome que você preferir). Indique que esta classe deve estender de uma open class do Beagle chamada DesignSystem. Use a anotação @BeagleComponent acima do nome da classe AppDesignSystem.  Ao fazer estes passos, já podemos chamar métodos em que vamos registrar componentes que são criados no BFF. Cada método é responsável por aplicar “estilos” aos componentes.\nNeste exemplo, vamos chamar o método textStyle.\n@BeagleComponent class AppDesignSystem: DesignSystem() { override fun textStyle(id: String): Int? { return super.textStyle(id) } } Desta forma, o open classeDesignSystem tem ao menos seis métodos, onde cada um deles representa um tipo de componente. Cada método deverá então aplicar estilos aos componentes visuais que serão ali registrados.\nDemonstraremos mais adiante como esses componentes e seus estilos são listados e organizados dentro desses métodos. Por ora, vamos entender o que cada método faz:\n O método buttonStyle é responsável por aplicar estilo a componentes do tipo Botão (Button). O método image é responsável registrar uma imagem para que ela possa ser referenciada em um tela server-driven. O método tabBarStyle é responsável por aplicar estilos nos componentes do tipo TabBar. O método textStyle aplica estilos nos componentes do tipo Text… (perceba que usamos o plural ao falar de componentes… logo logo você saberá o porquê). E o método toolbarStyle responsável por aplicar estilo no componenteToolbar. O método inputTextStyle responsavel por aplicar estilo no componente InputText.  Passo 2: Customizar o componente Este momento é o ponto em que o ocorre o BFF, quando frontend se conecta ao backend.\nPara isso, você terá de configurar o frontend do Android e o backend do Intellij. Caso não o tenha pronto, é só baixar o exemplo de configuração do backend e rodá-lo.\nPara o nosso backend aqui, criamos uma pagina server-driven com 2 textos, sendo um título e um parágrafo. Ela deve ficar assim quando for renderizada no frontend:\nPerceba que nossa tela é praticamente a estrutura e conteúdo somente. O tamanho do texto é padrão e a forma carece de um estilo.\nPara atribuir um estilo a esses textos vamos recorrer a nossa tela configurada lá no BFF:\n Abra o projeto de BFF e localize o arquivo FirstScreenBeagleBuilder.  Esse é o arquivo que contém o código da sua primeira tela server driven, que deve estar configurada como na imagem logo abaixo.\nNela você deve perceber que construímos uma hierarquia de componentes com uma SCREEN e dois componentes do tipo TEXT.\nPara este momento do tutorial, preocupe-se apenas no que deve ser feito para que possamos aplicar um estilo aos nossos componentes.  Para adicionar um estilo a um elemento de texto, você deve listar o nome do estilo dentro do componente texto, conforme mostrado baixo. Não se esqueça de separar os componentes por uma vírgula.\nSegure o botão Ctrl e coloque o mouse sobre o componente Text e você verá a lista de atributos que esse componente pode receber aqui no back-end. Por ora, utilizaremos apenas o Style\n 2. Coloque uma virgula após o atributo text = \"Hello Beagle\", e escreva o outro atributo que quer definir, que é o `styleId` 3. Digite a string `“Title.Text.Orange”` e pronto! O estilo está definido para esse componente de texto.  Text( text = \"Hello Beagle\", styleId = \"Title.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( top = 16.unitReal() ), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Por enquanto, não se preocupe com os outros elementos, como .applyStyle e demais configurações. Apenas garanta que nada mais seja modificado no exemplo e procure mantê-lo como mostramos agora.\nRepita este processo para o outro componente Text que é um paragrafo, com a diferença de que, aqui, nomeie-o como “Description.Text.Orange”  Isto é tudo que faremos no back-end nesse momento. Você pode rodar sua aplicação backend para que o serviço fique disponível e, em breve, você verá sua tela com estilo no Android.\nCaso tenha algum problema, recomendamos que faça o tutorial para implementar a instalação desse backend.   4. Primeiro, vamos registrar três cores no arquivo color no android.   Acesse o pacote res \u003e values \u003e colors Adicione as 3 cores dentro da Tag \u003cresources\u003e\u003c/resources\u003e da seguinte forma. Digite o código abaixo, assim criando as cores branca, preta e laranja na sua paleta de cores.  \u003ccolor name=\"colorWhite\"\u003e#FFFFFF\u003c/color\u003e \u003ccolor name=\"colorBlack\"\u003e#000000\u003c/color\u003e \u003ccolor name=\"colorOrange\"\u003e#FFA500\u003c/color\u003e Para encerrar esta etapa, crie no Android os estilos com os nomes que acabamos de atribuir aos textos lá na tela server-driven. acesse arquivo de estilos no pacote res \u003e values \u003e styles\nVocê pode fazer isso adicionando a configuração de estilo dentro da tag \u003cresources\u003e\u003c/resources\u003e como listado abaixo. Perceba que você já tem alguns elementos de estilo definidos e deve adicionar mais esse. Copie e cole o código abaixo para o texto que queremos que seja o Título.\n\u003cstyle name=\"Title.Text.Orange\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorOrange\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"textAllCaps\"\u003etrue\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e Repare que você pode definir muito mais aspectos dentro do estilo. Isso porque todas as opções que o Android permite podem ser configuradas nele.\n A primeira linha, define o nome do estilo como “Title.Text.Orange” A segunda define a cor laranja para o texto, como listado acima A terceira define o tamanho do texto como: 20 sp A quarta define que o texto deve ser exibe todo em letras maiúsculas A quinta linha define que o texto será em negrito  Devemos fazer o mesmo processo com o texto do parágrafo. Para ele, criaremos o seguinte estilo: Description.Text.Orange\n\u003cstyle name=\"Description.Text.Orange\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorOrange\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e16sp\u003c/item\u003e \u003citem name=\"textAllCaps\"\u003etrue\u003c/item\u003e \u003c/style\u003e  É uma boa prática definirmos um estilo default. No caso deste tutorial, vamos definir um para ser aplicado a textos normais.\nO objetivo é que este valor seja aplicado no texto que chegar do backend que não tiver nenhum estilo pré-definido.\n \u003cstyle name=\"Design.System.Text.Default\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e12sp\u003c/item\u003e \u003c/style\u003e E pronto! Nossos componentes estão customizados! Agora vamos à etapa final.\nPasso 3: Registrar o componente no Design System Uma vez que você já tem todos os estilos criados, é o momento de registrá-los na nossa classe AppDesignSystem, pois é lá onde Beagle aplica os estilos definidos no Android Studio nas telas server-driven que você receber do backend.\nPara isso, siga estes passos:\n Abra a classeAppDesignSystem e vá ao métodotextStyle. Dentro deste método, crie um operador when. Dentro dele, vamos listar todos os estilos de texto que queremos utilizar agora e depois.  Em caso de dúvida, veja aqui como utilizar o When.   Informe os nomes dos \"styles\" que referenciamos no backend (BFF) e o estilo criado no Android, ligando-os programaticamente.\n  No else , devemos listar o estilo o default que criamos. Siga o exemplo do codigo abaixo:\n  override fun textStyle(id: String): Int? { return when (id) { \"Title.Text.Orange\" -\u003e R.style.Title_Text_Orange \"Description.Text.Orange\" -\u003e R.style.Description_Text_Orange else -\u003e R.style.Design_System_Text_Default } } Perceba que o método textAppearance recebe uma string como parâmetro name, que vem da nossa tela server-driven.\nNo primeiro registro, listamos o nome criado para o estilo do título que foi:\n “Title.Text.Orange” Com uma arrow function -\u003e listamos o endereço do estilo no Android, ou seja, a ID do estilo criado como normalmente fazemos no Android Studio, que é : R.style.Title_Text_Orange.  Faça o mesmo processo no segundo registro, pois agora estamos registrando o estilo que queremos usar para parágrafos com a descrição que criamos na nossa página server-driven. O segundo registro deve ser:\n “Description.Text.Orange” -\u003e R.style.Description_Text_Orange.  E, por fim, no parâmetro else de nosso operador when, devemos informar o valor default que criamos para o texto. Isso significa que qualquer requisição de estilo por uma página server-driven que não tenha um estilo definido aqui, terá o estilo default aplicado sobre si.\n Nestes casos, o parâmetro else deve retornar -\u003e R.style.Design_System_Text_Default.  Com os elementos listados desta forma, você pode preparar um Design System com diversas opções de tamanhos de textos, cores, margens. Lembrando que estes estilos podem ser criados para usar agora ou em outro momento.\nParabéns, o seu DesignSystem está pronto!\nAgora, basta executar sua aplicação Android e sua tela apresentará a os estilos customizados que definimos.\n O que fazer depois de pronto? Agora que você já criou o seu Design System, é possível alterar o tamanho, cor ou testar os estilos que preferir.\nUma das grandes vantagens em utilizar uma página server-driven é poder trabalhar com um design system maduro. Ou seja, se você altera o modo como os componentes estão posicionados no backend, é possível “mudar sua tela” da maneira que quiser, tudo por meio do backend.\nNeste exemplo, utilizamos elementos simples de estilo para explicar o Design system, mas perceba o número de funções nesta classe e, a partir daí, veja o quão amplo um design system pode ser.\n","excerpt":" Criando um Design System No exemplo prático da página “Criando um …","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-android/design-system-com-beagle-android/","title":"Design System com Beagle Android"},{"body":" Creating a Design System On the use example of the page creating an Android project with Beagle , you saw how to implement Beagle to create a simple server-driven screen with only 2 texts: 1 title and 1 paragraph.\nIn this tutorial, the idea is to get deeper from the previous project to create a Design System on Beagle’s library. To better illustrate the explanation, we’ll use these sample codes that you can find out in our repository.\nThe Design System we will configure, it will allow you to customize some Beagle’s components, such as:\n Text Button Toolbar TabBar  Besides, it will be possible to customize the other 2 text components we created on the screen from the previous tutorial.\nContext With this Design System, you’ll be able to register stylesas fonts, colors, font size and customized components.\nGenerally, we define as an application’s design system a class that implements your interface. From her, we can implement all the methods that overwrite the responsible functions to apply “styles” on the components. Inside a function, it’s possible to state N styles or even none (except in some cases).\nOn Beagle, each style must be referenced in a way that each one has a name to be easily identified.\nExample On the example below, we have a image method that’s registering many images that are been used to build a page from backend.\nNotice that, on her, we can use the when operator to design styles, that is the first value is listed as a string that identifies Beagle’s component syle (on a similar relation key/value) and with aArrow Function -\u003e where we list the component’s style (id style on Android). Again, the logic here is similar to a pair “key/value”.\nWith the function already stablished, the else operator will contain a “default” style, like we demonstrate on the code below:\nThe yellow highlight shows the “style name” stated on backend and rescued on frontend (Android) while the orange highlight shows the style created on Android and that will be executed when the JSON from backend reads the “Style name”.\nGetting start Let’s go to practice! First, you have to look for a style folder named “Style” on your IDE Android. To do so on Android Studio, just click on res \u003e values \u003e styles.\nOnce you made this part, open the style’s file (styles) and you’ll see a screen similar to the example below. This is the file where we’ll list all the styles we’re intending to apply on Android’s components.\nWe suggest you to keep this file open, because we’ll use it some steps ahead.\nWe divided the design system creation in 4 steps, as we’ll see now.\nStep 1: Configure the Design System for Android The first step on design system creation is to create a class to represent it.\nJust remember that the design system we’re about to create is part of the project we mentioned in the beginning.  With the project opened, click on beagle’s folder and, with the right button, click on new \u003e kotlin file/class. Once you made it, follow these instructions:\n Name your file as AppDesignSystem (or another name of your preference). Indicate that this class should extends a Beagle’s interface called DesignSystem. Use the @BeagleComponent note above the AppDesignSystemclass name.  When you follow these steps, Android will request that some functions must be implemented to be responsible to apply “styles” to the components. After you agree to implement these methods, your screen must be like the example below:\nWith this way, the AppDesignSystem will overwrite, at least, six methods in which each one represents one component’s type. Each method will apply styles to visual components that will be registered.\nWe’ll demonstrate further how these components and their styles are listed and organized inside these methods. For now, let’s understand what each method does:\n The theme method applies a theme that can be similar to the native platform. It’s the only mandatory method when we create a design system class. The buttonStyle method is responsible to apply style to Button components. The image method is responsible to register a image so that can be referenced on a server-driven screen. The tabBarStyle method is responsible to apply styles to TabBar components. The textAppearance method applies to Text components. And the toolbarStyle method responsible to apply style to Toolbar components.  When you create a Design System class, it’s necessary to have, at least, one theme method stated. The other methods can be left without implementation, as you can see in the image above.\nStep 2: Create a theme The next step is create a theme component so our Beagle’s application can use when renders our server-driven screens.\n First, let’s register three colors on the color file on Android.   Access the package res \u003e values \u003e colors Addd three colors inside the \u003cresources\u003e\u003c/resources\u003e tag. Type the code below so you can create the white, black and orange colors on your color palette.  \u003ccolor name=\"colorWhite\"\u003e#FFFFFF\u003c/color\u003e \u003ccolor name=\"colorBlack\"\u003e#000000\u003c/color\u003e \u003ccolor name=\"colorOrange\"\u003e#FFA500\u003c/color\u003e Then, let’s access the style file, like we saw before.  In case you have closed the file, you can find it inside the values package. You’ll have to access the package because we’re going to create a style to our server-driven theme. To do so, click on _res \u003e values \u003e styles. _  Copy and paste the code below using the \u003cresources\u003e\u003c/resources\u003e tag.\n\u003cstyle name=\"AppThemeServerDriven\" parent=\"Theme.AppCompat.NoActionBar\"\u003e \u003c!-- Customize your theme here. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAcent\u003c/item\u003e \u003citem name=\"android:windowBackground\"\u003e@color/colorWhite\u003c/item\u003e \u003c/style\u003e Two important changes happen to this file:\nChange 1: A new theme style was created with the name AppThemeServerDriven.\nNotice that in this style , the parent must be Theme.AppCompat.NoAction bar. This detail is very important because Beagle particularly treats an action bar and controls its behavior with other method on the design system called toolbarStyle.\n__Change 2: New colors were listed inside the new esteem.\nNotice how they correspond to the items colorPrimary, colorPrimaryDark normally referenced in this way on the Android’s application pattern theme. We’re suggesting here a similar theme, but you can define how you want to. For now, let’s just keep this way.\nNow, we need to access the AppDesignSystem class, that we recently created, to register the Design System style. Considering we only have one theme, you can follow these instructions:\n Copy and paste the line and replace the theme function onAppDesignSystem class and we’re done. Your theme is configured and registered on Beagle.  override fun theme(): Int = R.style.AppThemeServerDriven Step 3: Customize a component This is the moment that occurs the BFF, when frontend connects to backend.\nTo do so, you’ll have to configure Android’s frontend and Intellij’s backend. In case you haven’t this configuration done, just follow the backend’s configuration and run it.\nFor our backend here, we created a server-driven page with 2 texts: 1 title and 1 paragraph. It should be like this when rendered on frontend:\nNotice that our screen is basically structure and content. The text is on standard size and the layout doesn’t have a style.\nTo attribute a style to these texts, we’ll recorrer a nossa tela configurada lá no BFF:\n Open the BFF project and look for the FirstScreenBeagleBuilderfile.  This is the file that contains the code of your server-driven screen, that has to be configured as it shows in the image below.\nOn that image, you’ll see that we built a component’s hierarchy with one SCREEN and two types of TEXT component.\nFor this point on the tutorial, just focus on what must be done to apply one style to our components.  To add a style and a text element, you should list the style’s name inside the text component, as indicated in the image below. Don’t forget to separate the components by one comma.\nHold the Ctrl button and put your mouse on the Text component so you’ll see the attribute’s list that this component can receive from backend. For now, we’ll only use the Style\n 2. Put a comma after the text attribute = \"Hello Beagle\", and write the another attribute you want to define, which in this case is the `style` 3. Type a `“HelloBeagle.Text.Title”` string e we're done! The style was defined to this text component.  Text( text = \"Hello Beagle\", style = “HelloBeagle.Text.Title” ).applyFlex( Flex( margin = EdgeValue( top = 16.unitRal(Real) ), alignSelf = Alignment.CENTER ) ), For now, don’t worry about the other elements, like .applyFlex, and other configurations. Just make sure that there’s nothing else to be changed on the example, let’s keep it this way now.\nRepeat this process to the other Text component - the paragraph -, with the difference that, here, you will name it as “Design.System.Text.Description”  This all we’re gonna do on the backend for now. You can run your backend’s application so the service be available and, soon, you’ll see your styled screen on Android.\nIn case you have any problem, we recommend you to follow this tutorial to implement the backend.   2. Return to Android Studio and access again the style's file on the package **res \u0026gt; values \u0026gt; styles**.  To finish this stage, you have to create on Android the styles and names we just attributed to the texts on the server-driven screen.\nYou can do this by adding the style’s configuration inside the \u003cresources\u003e\u003c/resources\u003e tag, as its listed below. Notice that you already have some defined styles' elements and must add this one more. Copy and paste the code below with the text that we want to be our Title.\n\u003cstyle name=\"Design.System.Text.Title\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorOrange\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"textAllCaps\"\u003eTrue\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e Notice that you can define many more aspects inside the style because all the options available on Android can be configured on it.\n The first line defines the style’s name like “HelloBealge.Text.Title” The second defines the text’s orange color, as listed above. The third defines the text’s size, like 20 sp. The fourth defines that the text must be exhibited on caps lock. The fifth linha defines that the text will be on bold.  We should make the same process with the paragraph text. In this case, we’ll create this style: Design.System.Text.Description\nIt’s a good practice to define a default style. For this tutorial, we’ll define one to be applied on normal texts.\nThe objective is that this value be applied on a text that came from backend without a predefined style.\n And done! Our components are customized! Now let’s get to the final stage.\nStep 4: Register a component on Design System Once you have already all the styles created, it’s the moment to register them in our AppDesignSystem class because it’s there where Beagle applies all the defined styles on Android Studio on server-driven screens that came from backend.\nTo do so, follow these steps:\n Open the AppDesignSystem class and go to the textAppearance method. Inside this method, create a when operator. Inside it, we’ll list all the text styles that we want to use now and later.  If you have any trouble on making this configuration, check out how to use When.   Infor the \"styles\" names we referenced on backend (BFF) and the style created on Android, programmatically connecting them.\n  On else , we should list the default style we created. Follow the example on the image below:\n  Notice that the textAppearance method receives a string as a nameparameter, that comes from our server-driven screen.\nOn the first register, we list the name created for the title style:\n “HelloBeagle.Text.Title” With a arrow function -\u003e we listed the address of the Android’s style, that is the style ID created in the same way we do on Android Studio: R.style.Design_System_Text_Title.  Repeat the same process for the second register because now we’re registering the style we want to use for the paragraphs with a description we created on our server-driven page. The second register must be:\n “Beagle.Text.Description” -\u003e R.style.Design_System_Text_Description.  And, finally, the else parameter of our when operator, we should inform the default we created for the text. That means that any style request for a server-driven page that doesn’t come with a predefined style, the default style will be automatically applied.\n In these cases, the else parameter must return -\u003e R.style.Design_System_Text_Default.  With the elements listed on this way, you can prepare a Design System with many options of text sizes, colors and margins. Just remember that these styles can be created to use now or in another moment.\nWell done, your Design System is ready!\nNow, you just have to execute your Android application and your screen will show the customized styles we just defined.\n What’s next? Now that you already created your Design System, it’s possible to change the size, color or even test the styles as you wish.\nOne of the biggest advantages on using a server-driven page is that you can work on a mature design system. That means if you can change the way components are positioned on the backend, it’s possible to “change your screen” in the way you want to, all through backend.\nOn this example, we used simple elements to explain design system, but as you could see on the number of functions on this class, the design system can be very broad.\n","excerpt":" Creating a Design System On the use example of the page creating an …","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/case-android/design-system-with-beagle-android/","title":"Design System with Beagle Android"},{"body":" Starting an iOS project To create an iOS project for Beagle, you will need a Macbook with Xcode installed. In case you don’t have it yet, download Xcode on the Apple Store.\nBefore you start, first it’s necessary to create a project on Xcode. To do so, your just have to open the program and name a project. For this example, we’ll call as Beagle Sample.\nAfter you created the project, we’ll need to add the dependencies and, for that, we’ll use CocoaPods' manager.\nIf you wanna know more about how to use Cocoa Pods, check out their documentation.  Step 1: Configure Cocoa Pods You’ll use the terminal to install CocoaPods, so open your terminal and type sudo gem install cocoapods\nsudo gem install cocoapods To configure it, go to your folder through the terminal and type: pod init\npod init Then, open your project’s folder using the open command.\nopen . Once you made it, you must choose the podfile file the same way as it’s shown in the image:\nOpen the file and add the following dependencies:\ntarget 'Beagle Sample' do pod 'BeagleUI' pod 'YogaKit', :git =\u003e 'https://github.com/ZupIT/YogaKit' end Open the terminal again and type the pod install command so your dependencies can be installed.\npod install After the installation, you should open a file with a**workspace.** extension. For this example, we’ll name it asBeagle Sample.workspace\nStep 2: Configure Beagle Now that your project was created, you must make Beagle’s configuration. To do so, follow the steps below:\n Create a class calledBeagleConfig .  This class will be responsible to contain part of Beagle’s initial configuration. On her, we’ll implement a config static function to apply these configurations.\n2. On this function, create a constant called **`dependency`** that must be**`BeagleDependencies`**type.  We’ll attribute to this constant some project’s configurations like, for example, the list of basis URL that lists the JSON that will be used to build the the server-driven screen. To configure this constant, use the example below:\nimport Beagle import Foundation class BeagleConfig { static func config() { let dependencies = BeagleDependencies() dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"http://localhost\") ) Beagle.dependencies = dependencies } } Now, we’ll configure the**SceneDelegate** class so it can be used to initialize our application with Beagle from a screen through BFF:\n Create a**beagleScreen** constant, that will receive the server-driven screen. The init URL argument must contain the relative URL address that will be created on backend (BFF). For this example, we’ll call it “/screen”  Follow the example below:\nlet beagleScreen = Beagle.screen(.remote(.init(url: \"/screen\"))) window = UIWindow(frame: UIScreen.main.bounds) window?.windowScene = windowScene window?.rootViewController = beagleScreen window?.makeKeyAndVisible() At the end of this process, the**SceneDelegate** class should be like this:\nStep 3: Configure Xcode Usually, the Xcode’s proprieties are configured so your application can be initialized through main.storyboard. Now that will be done by Beagle and, for this configuration works, we must change the proprieties deleting the references related to main.storyboard.\nThese references are in the main project file, on**Info tab**, and are organized like this:\nThe first stays in the session:\nCustom iOS Target Properties \u003e\nMain storyboard file base name\nThe second stays in the session:\nApplication Scene Manifest\u003e\nScene Configuration\u003e\nApplication Session Role \u003e\nItem 0 (Default Configuration)\u003e\nStoryboard name.\nOn the GIF below, you can see better how to remove these references:\nWell done, now Beagle is configured for your iOS application! All you have to do is set up a backend to answer to your server-driven applications’s requests.\nOnce you finished the configuration, start your application and you’ll have your first server-driven screen!\nYou will see this screen:\n","excerpt":" Starting an iOS project To create an iOS project for Beagle, you will …","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/case-ios/","title":"Case ios"},{"body":" Iniciando um projeto iOS Para criar um projeto iOS no Beagle, você primeiro precisa ter o Xcode instalado. Caso ainda não o tenha instalado ainda, faça o download na Mac App Store.\nAntes de começar, você primeiro precisar criar um projeto no Xcode. Para isso, basta abrir o programa e nomear o seu projeto. Para este exemplo, colocaremos como Beagle Sample.\nApós criar o seu projeto, precisaremos adicionar as dependências. Para isso, usaremos o gerenciador CocoaPods.\nSe você tem alguma dúvida sobre como usar este gerenciador, sugerimos checar a documentação oficial do Cocoa Pods.  Passo 1: Configurar o Cocoa Pods Você usará o terminal para instalar o CocoaPods, para isto abra o terminal e digite sudo gem install cocoapods\nsudo gem install cocoapods Para configurá-lo, navegue até sua pasta pelo terminal e digite o comando: pod init\npod init Depois, abra o folder do projeto usando o comando: open .\nopen . Feito isso, você deve selecionar o arquivo podfile assim como apresentado na imagem abaixo:\nAbra o arquivo e adicione as seguintes dependências:\ntarget 'Beagle Sample' do pod 'Beagle' pod 'YogaKit', :git =\u003e 'https://github.com/ZupIT/YogaKit' end Abra novamente o terminal e digite o comando: pod install para que as dependências sejam instaladas.\npod install Depois da instalação, você deve abrir o arquivo que possui a extensão workspace. Neste exemplo, nós o chamaremos de Beagle Sample.workspace\nPasso 2: Configurar o Beagle Agora que seu projeto está criado, você deve fazer as configurações do Beagle. Para isso, siga os passos abaixo:\n Crie uma classe chamadaBeagleConfig .  Esta classe será responsável por conter parte da configuração inicial do Beagle. Nela, implementaremos uma função estática config para aplicar essas configurações.\n2. Nesta função crie uma constante chamada **`dependency`** que deve ser do tipo**`BeagleDependencies`**.  A esta constante serão atribuídas algumas configurações do projeto, como por exemplo, listar a URL base que lista oJSON a ser utilizado na construção de uma tela server-driven. Para configurar esta constante, use o exemplo abaixo:\nimport Beagle import Foundation class BeagleConfig { static func config() { let dependencies = BeagleDependencies() dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"http://localhost\") ) Beagle.dependencies = dependencies } } Agora, vamos configurar a classe**SceneDelegate** para que possamos inicializar nossa aplicação com o Beagle a partir de uma tela via BFF:\n Crie a constante beagleScreen, que irá receber a tela server-driven. O argumento init URL deve conter o endereço da URL relativa que será criada no backend (BFF). No nosso exemplo a chamaremos de “/screen”  Siga o exemplo abaixo:\nlet beagleScreen = Beagle.screen(.remote(.init(url: \"/screen\"))) window = UIWindow(frame: UIScreen.main.bounds) window?.windowScene = windowScene window?.rootViewController = beagleScreen window?.makeKeyAndVisible() Ao final, a classe**SceneDelegate** deve ficar assim:\nPasso 3: Configurar o Xcode Inicialmente, as propriedades do Xcode estão configuradas para que sua aplicação seja iniciada via main.storyboard. No entanto, agora quem deve iniciar a aplicação é o Beagle e, para que isso ocorra, devemos mudar essas propriedades apagando as referências ligadas ao main.storyboard.\nEstas referências estão no main project file, na**Info tab**, e estão assim organizadas:\nA primeira fica na sessão:\nCustom iOS Target Properties \u003e\nMain storyboard file base name\nA segunda fica na sessão:\nApplication Scene Manifest\u003e\nScene Configuration\u003e\nApplication Session Role \u003e\nItem 0 (Default Configuration)\u003e\nStoryboard name.\nNo GIF abaixo, você vê melhor como remover as referências:\nFeito! O Beagle está configurado na sua aplicação iOS. Agora, tudo o que você precisa é configurar um backend para responder as requisições do seu aplicativo server-driven.\nFeita essa configuração, inicie a sua aplicação e você terá sua primeira tela server-driven!\nVocê verá a tela a seguir:\n","excerpt":" Iniciando um projeto iOS Para criar um projeto iOS no Beagle, você …","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-ios/","title":"Case ios"},{"body":" Criando estilos para o Beagle iOS No exemplo prático da página “Criando um projeto com Beagle para iOS”, você pode conferir como fazer a implementação do Beagle e criar sua primeira tela server-driven.\nNeste tutorial, a ideia é avançar a partir do projeto anterior para criar um Design System na sua biblioteca do Beagle. Os exemplos que ilustrarão o passo a passo estão nestessample codes que você encontra no nosso repositório.\nA ideia aqui é configurar alguns estilos no iOS para que você possa customizar componentes como:\n Text. Button. Navigation Bar Tab View Entre outros.  Além disso, vamos aplicar estilos de texto nos 2 componentes textuais.\nPara tal, criaremos uma espécie de Design System, ou seja, um arquivo para reunir um conjunto desses estilos guardando os registros dos componentes de estilo criados no frontend.\nÉ dessa forma que sua aplicação iOS “saberá” qual componente de estilo deverá renderizar ao receber uma tela server-driven. Vale lembrar que, no caso da tela server-driven, estarão relacionados os elementos visuais (views) utilizados na construção da sua tela.\nPasso 1: Criar um arquivo Swift Crie um arquivo Swift. No nosso exemplo, vamos chamar de Styles. Nele, você deve importar o UIKit e o BeagleUI e criar uma Struct com nome Stylesassim como fizemos no exemplo abaixo:\nimport UIKit import Beagle struct Styles { } Essa struct irá conter todos os estilos que serão acessados pelo Beagle. Aqui, estará listada a lógica que permite ao Beagle aplicar os estilos definidos no iOS a uma tela server-driven.\nPasso 2: Criar um estilo para um texto Uma vez que você gerou seu arquivo, você deve agora criar função estática para definir e retornar um estilo de texto. Como, no caso deste exemplo, teremos um estilo para título e outro para parágrafo, criaremos duas funções.\nO retorno desta função irá utilizar a classe BeagleStyle,que é uma classe interna do Beagle que fica acessível quando você importa a classe beagleUI.\nÉ neste retorno que estará definido o estilo criado para o componente text . Siga o passo abaixo para criar cada função:\nO estilo do título irá retornar a fonte Courier com tamanho 20 e com a cor laranja. Implemente-o como no exemplo abaixo.\nstatic func titleTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 20) ?? UIFont.systemFont(ofSize: 20), color: .orange ) }  Caso a fonte não seja encontrada, o Beagle irá definir como default a fonte do sistema com tamanho 20.  Realize o mesmo processo para criar o estilo do nosso parágrafo. Exemplo abaixo:\nstatic func descriptionTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 15) ?? UIFont.systemFont(ofSize: 15), color: .orange ) } Depois de implementar estes dois estilos, o seu arquivo Styles deverá estar assim:\nimport UIKit import Beagle struct Styles { static func titleTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 20) ?? UIFont.systemFont(ofSize: 20), color: .orange ) } static func descriptionTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 15) ?? UIFont.systemFont(ofSize: 15), color: .orange ) } } Passo 3: Registrar o estilo no Beagle Config Agora é necessário registrar os estilo no Beagle, é importante para que ele seja capaz de aplicar esses estilos nas telas server-driven.\n Abra o arquivo BeagleConfig . Registre uma constante com o nome theme É na constante theme que será listado todos os estilos. Essa constante irá receber o AppTheme que é onde os estilos são registrados. Crie o bloco de informações abaixo dentro da função static func config Crie o bloco de informações abaixo dentro da função static func config  let theme = AppTheme(styles: []) Para registrar, liste o nome do estilo, declarado no backend, e indique a qual estilo deve ser aplicado. Cada estilo deverá ser registrado assim:  \"Title.Text.Orange\": Styles.titleTextStyle  \"Title.Text.Organge\" é o nome do estilo definido para o componente text na tela server-driven.  Styles.titleTextStyle é a função criada logo no início desse tutorial. Ela retorna o estilo que está definido nela para que o Beagle Config saiba renderizar o estilo correto em cada componente visual, nesse caso o text que será o título.  A constante theme com os dois estilos registrados deve estar assim:\nlet theme = AppTheme(styles: [ \"Title.Text.Orange\": Styles.titleTextStyle, \"Description.Text.Orange\": Styles.descriptionTextStyle ]) Ainda no BeagleConfig devemos referenciar o theme que criamos no BeagleDependencies.\nSiga o exemplo abaixo e finalize a configuração do BeagleConfig como mostrado abaixo:\nimport Beagle import Foundation class BeagleConfig { static func config() { let theme = AppTheme(styles: [ \"Title.Text.Orange\": Styles.titleTextStyle, \"Description.Text.Orange\": Styles.descriptionTextStyle ]) let dependencies = BeagleDependencies() dependencies.theme = theme dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"http://localhost:8080\") ) Beagle.dependencies = dependencies } } Assim, o front-end está configurado e os estilos definidos.\nPasso 4: Definir estilos no backend No tutorial de configuração do backend, uma pagina server driven foi criada com 2 textos, um título e um parágrafo.\nA página era assim quando renderizada no frontend:\nPara atribuir um estilo a esses textos siga as instruções:\n Abra o projeto de backend (BFF) e localize o arquivo FirstScreenBeagleBuilder. Esse é o arquivo que contém o código da sua primeira tela server driven. Ela deve estar configurada como na foto abaixo. Nela você deve perceber que foi construída uma hierarquia de componentes com uma screen (tela) e dois componentes do tipo text.  class FirstScreenBuilder : ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle\", styleId = \"Title.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( top = 16.unitReal() ), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides \" + \"usage of the Server-Driven UI concept, natively in \" + \"iOS, Android and Web applications. By using Beagle, \" + \"your team could easily change application's layout \" + \"and data by just changing backend code.\", styleId = \"Description.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) Para adicionar um estilo a um elemento de texto, você deve listar o nome do estilo dentro do componente texto, conforme mostrado baixo. Não se esqueça de separar os componentes por uma vírgula. Segure o botão Ctrl e coloque o mouse sobre o componente Text e você verá a lista de atributos que esse componente pode receber aqui no backend. Por hora, utilizaremos apenas o Style\n 1. Coloque uma virgula após o atributo text = \"Hello Beagle\", e escreva o outro atributo que quer definir, que é o `styleId` 2. Digite a string `“Title.Text.Orange”` e pronto! O estilo está definido para esse componente de texto.  Text( text = \"Hello Beagle\" styleId = \"Title.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), E pronto, isso é tudo que faremos no backend nesse momento.\n Faça o mesmo para o outro componente Text que é um parágrafo, mas nomeie-o como “Description.Text.Orange”  Você pode rodar sua aplicação backend para que o serviço fique disponível.\nCaso tenha algum problema, recomendamos que faça o tutorial para implementação desse backend.  O que fazer depois de pronto? Depois de executar o backend, agora execute o Xcode.\nE o resultado será esse:\nAgora que está pronto, teste um pouco, mude os tamanhos, mude as cores, e teste os estilos que quiser!\nNeste exemplo foi utilizado elementos de estilo simples para explicar o Design system, mas o número de funções nessa classe mostra como ela pode ser ampla. Você pode desenvolver toolBars diferentes, botões e todo o tipo de componentes, inclusive componentes customizados (que abordaremos em outro codeLab) e utilizá-los no Beagle.\n","excerpt":" Criando estilos para o Beagle iOS No exemplo prático da página …","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-ios/definindo-os-estilos-no-beagle-ios/","title":"Definindo os estilos no Beagle ios"},{"body":" Creating styles for Beagle iOS On the first use example, you saw how to implement Beagle and create your first server-driven screen.\nIn this tutorial, the idea is to get deeper from the previous project to create a Design System on Beagle’s library. To better illustrate the explanation, we’ll use these sample codes that you can find out in our repository.\nThe idea is to configure some styles on iOS to allow you to customize some components, such as:\n Text. Button. Navigation Bar Tab View Entre outros.  Besides, we’ll apply text styles to 2 texts' components.\nTo do so, we’ll create a kind of Design System, which is a file with a set of styles in where we’ll keep the styles' components registers created on frontend.\nThis way, your iOS application “will know” which style component must be rendered in a server-driven screen. Just remember that the server-driven screen case, the visual components (views) will be related and it will be used to build the screen.\nStep 1: Create a Swift file Create a Swift file. On our example, let’s call it Styles. On this file, you must import the UIKit and the BeagleUI and also create a Struct with the name Styles, just like the image below:\nimport UIKit import Beagle struct Styles { } This struct will contain all the styles Beagle will access. Here, it will be listed the logic that allows Beagle to apply defined styles on iOS into a server-driven screen.\nStep 2: Create a text style Once you have created your file, now you must create a static function to define and return a text style. For this example, we’ll have one style for a title and another one for the paragraph, so we’ll create two different functions.\nThis function return will use the BeagleStyle class, which is a Beagle’s intern class that’s available when you import the beagleUI class.\nIt’s on these return that’s defined the style created for the text component. Follow the instructions below to create each function:\nThe title text style will return Courier font with size 20 and orange color. Implement it like in the example below:\nstatic func titleTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 20) ?? UIFont.systemFont(ofSize: 20), color: .orange ) }  If you can’t find the text font, Beagle will define a system default font with size 20.  Repeat the same process to create our paragraph style, like in the example below:\nstatic func descriptionTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 15) ?? UIFont.systemFont(ofSize: 15), color: .orange ) } After you implement both styles, your Styles file must be like this:\nimport UIKit import Beagle struct Styles { static func titleTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 20) ?? UIFont.systemFont(ofSize: 20), color: .orange ) } static func descriptionTextStyle() -\u003e (UITextView?) -\u003e Void { return BeagleStyle.text( font: UIFont.init(name: \"Courier\", size: 15) ?? UIFont.systemFont(ofSize: 15), color: .orange ) } } Step 3: Register a style on Beagle Config Now it’s necessary to register Beagle’s styles, which is important so Beagle can be able to apply these styles in server-driven screens.\n  Open the BeagleConfig file. Register a constante called theme\n  It’s on the theme constant where the styles will be listed.\n  This constant will receive the AppTheme , which is where the styles are registered.\n  Create the information block below inside the**static func config** function.\n  Create the information block below inside the**static func config** function.\nlet theme = AppTheme(styles: []) To register, list the style name stated on backend and, then, indicate which style must be applied. Each style must be registered like this:    \"Title.Text.Orange\": Styles.titleTextStyle  \"Title.Text.Organge\" is the defined style name text component on the server-driven screen.  Styles.titleTextStyle is the function created in the beginning of this tutorial. She returns the defined style so Beagle Config can be able to render the correct style of each visual component, in our case is the text that must be rendered as a title.  The theme constant with two registered styles must be like this:\nlet theme = AppTheme(styles: [ \"Title.Text.Orange\": Styles.titleTextStyle, \"Description.Text.Orange\": Styles.descriptionTextStyle ]) Still on BeagleConfig, we should refer the theme we created on BeagleDependencies.\nFollow the example below and finish the BeagleConfig’s setup as the example below shows:\nimport Beagle import Foundation class BeagleConfig { static func config() { let theme = AppTheme(styles: [ \"Title.Text.Orange\": Styles.titleTextStyle, \"Description.Text.Orange\": Styles.descriptionTextStyle ]) let dependencies = BeagleDependencies() dependencies.theme = theme dependencies.urlBuilder = UrlBuilder( baseUrl: URL(string: \"http://localhost:8080\") ) Beagle.dependencies = dependencies } } In this way, the frontend is configured and the styles are defined.\nStep 4: Define styles on backend On the backend’s configuration tutorial, we created a server-driven page with 2 texts: 1 title and 1 paragraph.\nThis page was like that when rendered on frontend:\nTo attribute a style to these texts, follow these instructions:\n Open the backend project (BFF) and look for the FirstScreenBeagleBuilderfile. This is the file that contains the code of your first server-driven screen. She must be configured like in the image below. On her, you will notice that it was built a hierarchy’s screen components and two text types components.  class FirstScreenBuilder : ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle\", styleId = \"Title.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( top = 16.unitReal() ), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides \" + \"usage of the Server-Driven UI concept, natively in \" + \"iOS, Android and Web applications. By using Beagle, \" + \"your team could easily change application's layout \" + \"and data by just changing backend code.\", styleId = \"Description.Text.Orange\" ).applyStyle( Style( margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) To add a style to a text element, you must list the style name within the text component, as shown below. Don’t forget to separate the components with a comma. Hold the Ctrl button and place the mouse over the Text component and will see the list of attributes that this component can receive here on the backend. For now, we will only use Style.\n 1. Put a comma after the text attribute = \"Hello Beagle\", and write another attribute you want to define, in our case it's `styleId` 2. Type a `“Title.Text.Orange”` string and done! Your style is defined for this text component.  Text( text = \"Hello Beagle\", styleId = “Tille.Text.Organge” ).applyFlex( Flex( margin = EdgeValue( top = 16.unitRal(Real) ), alignSelf = Alignment.CENTER ) ), And done, that’s all we’re gonna do on our backend so far.\n Repeat the same process with the otherText component - the paragraph -, but name it as “Description.Text.Orange”  You can run your backend’s application so the service can be available.\nIn case you have any problem, we recommend you to make our backend’s implementation tutorial.  What’s next? After you execute the backend, you now have to execute the Xcode.\nThis should be your result:\nNow that is ready, test a little more, try to change sizes, colors and whatever style you want to!\nFor this example, we used simple style’s elements to explain Design System, but the number of functions is quite big. That means you can develop different toolBars, buttons and all kinds of components, including customized components to use on Beagle.\n","excerpt":" Creating styles for Beagle iOS On the first use example, you saw how …","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/case-ios/defining-styles-on-beagle-ios/","title":"Defining styles on Beagle ios"},{"body":" Starting a Web project Requirements To create a Beagle’s project for, check out if have installed the following programs:\n Angular CLI Node 10.16 + Yarn or npm  You must have Visual Studio Code to start your project. In case you don’t have installed it yet, you can find more information about it.\nAfter the installation, follow the steps according to framework you chose:\nAngular React Step 1: Open the terminal and use the command below:\nng new caseAngular Wait until the CLI finishes to create the project.\nStep 2: Go to the cd caseAngulargenerated project’s folder, add Beagle Angular to your repository with one of the commands below, according to your package manager:\nnpm install --save @zup-it/beagle-angular yarn add @zup-it/beagle-angular Now, wait for the installation.\nStep 3: Type one of these commands and press enter:\nyarn beagle init npx beagle init   On the question ‘Would you like to use yarn or npm?’, type the option you chose to use as a manager. For example, if you chose yarn, then type yarnand press enter.\n  On the question ‘Path to the beagle module (press enter to use default)', type which module path you’re using for Beagle. Considering the project was just created, and there aren’t any modules, press enter without informing anything.\n  On the question ‘Path to the module with the components to use with beagle (press enter to use default)', type which module path will be used for Beagle. Considering the project was just created, and there aren’t any modules, press enter without informing anything.\n  On the question ‘What’s the base url of the backend providing your beagle JSONs? (press enter to use default)', type which will be the backend’s basis URL that will be used to rescue the JSONs. Here, we’ll use mockyio, so type https://www.mocky.io/v2/and press enter. Then wait until the configuration finishes:\n   At the end, two files were created on your project:beagle-components.module.ts andbeagle.module.ts.   Step 1: Open the terminal and use the command below:\nnpx create-react-app case-react --template typescript yarn create react-app case-react --template typescript Step 2: Acess the cd case-react project’s file and add Beagle React to your repository. On your terminal, type:\nnpm install --save @zup-it/beagle-react or\nyarn add @zup-it/beagle-react And wait until the installation finishes.\n Configuration Now it’s time to configure Beagle’s files inside your application, following these instructions:\nAngular React Open the app.module.ts file and import Beagle’s module that was just generated:\n... import { Beagle } from './beagle.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, Beagle ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Open the beagle.module.ts file and put the baseUrl path\nimport { BeagleModule } from '@zup-it/beagle-angular' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, }) export class Beagle {}  On the /src path, create another folder named beagle and, inside it, create a new file calledbeagle-service.ts. Its structure should be similar to the image below:\nNow, open the beagle-service.ts created file and copy this code:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} })  Creating a JSON to be rendered Now you need a JSON to render the components. Usually, this call is made by an external server that would return the JSON, but for this example we’ll use a local file that will be created for this test:\nAngular React On your angular project, navigate to the src/assets folder and create a new file named payload.json. Insert this new file on the JSON content below.\n On your react project, navigate to the /public folder and create a new file named payload.json. Insert on the new file the JSON content below:\n { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle ís a cross-platform framework which provices usage of the server Driven UI concept,natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] } Rendering components Now it’s necessary to add on your application the local where the components will be rendered through JSON. The Beagle’s library provides a component with this functionality: beagle remote view. To configure this component, follow these steps:\nAngular React Open the app.component.html file and replace all the content with this code:\n\u003cbeagle-remote-view route=\"/payload.json\"\u003e\u003c/beagle-remote-view\u003e route in the code above states which route will be loaded. The URL specified here is relative to the baseUrl declared in the configuration.\nThe parameter route is only valid for versions 1.3 and above. For previous versions, you should use loadParams instead. loadParams is an object and the equivalent to this configuration would be { path: ‘/payload.json’ }.\n  Open the App.tsx file where the JSON will be rendered and change it until it looks like the example below:\nimport React from 'react'; import './App.css'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView route={'/payload.json'} /\u003e \u003c/BeagleProvider\u003e ); } export default App; On this step, we point where our layout defined with payload.json file should be rendered. Here, we have two componentes provided by Beagle:\n\u003cBeagleProvider\u003e: Receives the value propriety as the beagle-service created on the previous step and that contains the initials configurations.\n\u003cBeagleRemoteView\u003e: Receives theroute propriety that’s the path for our JSON file. Notice here that we add ' / ‘ because this value will be associated to a definedbaseUrl onbeagle-service.ts file.\nroute in the BeagleRemoteView is only valid for versions 1.3.0 and above. For earlier versions, please, use path instead.\n  Testing your application Once you have finished the project’s basic configuration, now you have to run one of the commands below to initialize your application:\nIf you use npm:\nnpm run serve If you use yarn:\nyarn serve After you finish these commands, access your application’s address on your navigator. If a screen with components would be rendered, that means that’s correctly working.\n","excerpt":" Starting a Web project Requirements To create a Beagle’s project for, …","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/case-web/","title":"Case Web"},{"body":" Iniciando um projeto Web Pré-Requisitos Para criar um projeto com Beagle para Web, confirme se você tem instalado os seguintes programas:\n Angular CLI Node 10.16 + Yarn ou npm  Para iniciar o projeto é preciso utilizar o Visual Studio Code. Caso ainda não o tenha instalado, você pode baixá-lo no site oficial da ferramenta.\nApós a instalação, siga os passos de acordo com o framework escolhido:\nAngular React Passo 1: abra o terminal e use o comando abaixo:\nng new caseAngular Aguarde o CLI terminar a criação do projeto.\nPasso 2: entre na pasta do projeto gerado cd caseAngular, adicione o Beagle Angular ao seu repositório com um dos comandos abaixo de acordo com seu gerenciador de pacotes:\nnpm install --save @zup-it/beagle-angular yarn add @zup-it/beagle-angular Agora, aguarde a instalação.\nPasso 3: digite um desses comandos e aperte o enter:\nyarn beagle init npx beagle init  Na pergunta ‘Would you like to use yarn or npm?' Digite a opção que você escolheu para usar como gerenciador, no exemplo será o yarn, portanto digite yarne aperte enter. Na pergunta ‘Path to the beagle module (press enter to use default)’ - digite qual o caminho do módulo que será usado para o Beagle, como o projeto foi criado agora, não há módulos ainda, portanto aperte enter sem informar nada. Na pergunta ‘Path to the module with the components to use with beagle (press enter to use default)’ - digite qual o caminho do módulo que será usado para o Beagle, como o projeto foi criado agora, não há módulos ainda, portanto aperte enter sem informar nada. Na pergunta ‘What’s the base url of the backend providing your beagle JSONs? (press enter to use default)’ - digite qual será a URL base do backend que será utilizada para resgatar os JSONs, aqui será usada o mockyio, então digite https://www.mocky.io/v2/e aperte enter. Aguarde a configuração terminar:   Foram criados dois arquivos em seu projeto beagle-components.module.ts e beagle.module.ts.   Passo 1: abra o terminal e digite um dos comandos abaixo:\nnpx create-react-app case-react --template typescript ou\nyarn create react-app case-react --template typescript Passo 2: acesse a pasta do projeto cd case-react e adicione o Beagle React ao seu repositório. No terminal digite:\nnpm install --save @zup-it/beagle-react ou\nyarn add @zup-it/beagle-react e aguarde a instalação finalizar.\n Configuração Agora é hora de configurar os arquivos do Beagle dentro da sua aplicação, siga as instruções:\nAngular React Abra o arquivo app.module.ts e importe o módulo Beagle que acabou de ser gerado:\n... import { Beagle } from './beagle.module'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, Beagle ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Abra o arquivo beagle.module.ts e coloque o caminho baseUrl\nimport { BeagleModule } from '@zup-it/beagle-angular' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, }) export class Beagle {}  No caminho /src crie uma outra pasta com o nome beagle e dentro dela um novo arquivo chamado beagle-service.tsSua estrutura deve estar parecida com a imagem a seguir:\nAgora, abra o arquivo criado beagle-service.ts e copie o código:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} })  Criando o JSON para ser renderizado Agora é preciso um JSON para renderizar os componentes, normalmente a chamada seria feita para um servidor externo que retornaria o JSON, mas neste exemplo um arquivo local será criado para ser acessado como teste:\nAngular React No seu projeto angular navegue até a pasta src/assets e crie um novo arquivo com o nome payload.json. Insira neste arquivo o conteúdo do JSON abaixo.\n No seu projeto react navegue até a pasta /publice crie um novo arquivo com o nome payload.json. Insira neste arquivo o conteúdo do JSON abaixo:\n { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Hello Beagle\" }, { \"_beagleComponent_\":\"beagle:text\", \"style\":{ \"padding\":{ \"top\":{ \"value\":10, \"type\": \"REAL\" } } }, \"text\":\"Beagle is a cross-platform framework which provides usage of the server Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code\" } ] } Renderizando os componentes Agora é necessário adicionar na aplicação o local onde os componentes serão renderizados via JSON. A biblioteca Beagle fornece um componente com essa funcionalidade o Beagle remote view, siga os passos para configurar:\nAngular React Abra o arquivo app.component.html e substitua todo o conteúdo pelo código a seguir:\n\u003cbeagle-remote-view route=\"/payload.json\"\u003e\u003c/beagle-remote-view\u003e route no código acima diz qual a rota será carregada. A URL especificada aqui é relativa à baseUrl declarada na configuração.\nO parâmetro route é válido apenas para a versão 1.3 ou superior. Para versões anteriores, loadParams deve ser usado. loadParamsé um objeto e o valor equivalente ao desse exemplo seria{ path: ‘/payload.json’ }.\n  Abra o arquivo App.tsx onde o JSON será renderizado e altere para ficar como o exemplo a seguir:\nimport React from 'react'; import './App.css'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView route={'/payload.json'} /\u003e \u003c/BeagleProvider\u003e ); } export default App; Neste passo apontamos onde queremos renderizar nosso layout definidos no arquivo payload.json. Temos aqui dois componentes fornecidos pela biblioteca beagle:\n\u003cBeagleProvider\u003e Recebe uma propriedade value com o beagle-service criado no passo anterior que contém as configurações iniciais\n\u003cBeagleRemoteView\u003e Recebe uma propriedade route que é o caminho do nosso arquivo JSON, note aqui que adicionamos ' / ‘ pois esse valor será concatenado com o baseUrl definido no arquivo beagle-service.ts.\nroute no BeagleRemoteView só é válido para as versões 1.3 e superior. Para versões anteriores, por favor, use path.\n  Testando a aplicação Depois de finalizar a configuração básica do projeto, agora é preciso rodar um dos comandos abaixo para inicializar a aplicação:\nAngular React Se você usa o npm:\nnpm run serve Se você usa o yarn:\nyarn serve  Se você usa o npm:\nnpm run start Se você usa o yarn:\nyarn start  Depois de finalizados os comando acesse no navegador o endereço da sua aplicação. Se uma tela com os componentes for renderizada tudo está funcionando corretamente.\n","excerpt":" Iniciando um projeto Web Pré-Requisitos Para criar um projeto com …","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-web/","title":"Case Web"},{"body":" Starting a Backend project In this tutorial, the Backend will be implemented with Beagle so that it can respond to requests from your server-driven application, be it on Android, iOS or WEB.\nRequirements To create a Beagle project for backend, it is necessary:\n IDE Intelij IDE Community  Step 1: Configure using Spring initializr The first step to configure your backend is to access Spring website.\nIt will create aMaven project that will help your project’s configuration.\nSpring configuration\n Choose Maven as your project option; Check kotlin as a language; Choose the initial version bigger than 2.1. Group is the name it will be used as a hierarchy in the beginning. For this example, it can be com.example; Artifact is the project’s name. You will name it BFF; Description contain a simple description of the project; Packaging must be checked as JAR; Java must be chosen as the java version of your system; Click on generate and it will download your project as.zip; Extract the file in your chosen folder.  Step 2: Import your project to Intellij Follow the steps below to import the project you have created. First, open intellij and click on Import project.\n Choose the file where you put yourSpring project and click ok. Click on Import projects from external model and choose Maven and then, click finish.  Configuring Beagle Step 1: Configure the project As a starting point, follow this step by step to install the backend\nStep 2: Define the structure The second step is to create some packages to better organize the project. They will be named: builder,service and controller\n Click src\u003e main\u003e kotlin until you find the name of your project. Right-click new\u003e package Name it builder and press enter. Repeat the process creating the other two packages, naming them service and controller After creating the packages, your screen should look like this:  Step 3: ‌ Create the application service The first class that we will create is the Builder. It is in this file that the Server-Driven screen must be structured:\n Right-click the builder package and click new\u003e Kotlin File / Class and name it ScreenBeagleBuilder This class must extend from ScreenBuilder (which is an internal Beagle class). Note that it will replace the build method and this is where the Server-Driven screen will be implemented. In this step, you can copy and paste the code below into your class:  import br.com.zup.beagle.core.Style import br.com.zup.beagle.ext.applyStyle import br.com.zup.beagle.ext.unitReal import br.com.zup.beagle.widget.Widget import br.com.zup.beagle.widget.action.Alert import br.com.zup.beagle.widget.core.AlignSelf import br.com.zup.beagle.widget.core.EdgeValue import br.com.zup.beagle.widget.core.Flex import br.com.zup.beagle.widget.core.TextAlignment import br.com.zup.beagle.widget.layout.Container import br.com.zup.beagle.widget.layout.Screen import br.com.zup.beagle.widget.layout.ScreenBuilder import br.com.zup.beagle.widget.ui.ImagePath import br.com.zup.beagle.widget.ui.Text object ScreenBeagleBuilder : ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle!\" ).applyStyle( Style(margin = EdgeValue(top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides usage of the \" + \"Server-Driven UI concept, natively in iOS, Android and Web applications. \" + \"By using Beagle, your team could easily change application's layout and\" + \" data by just changing backend code.\" ).applyStyle( Style(margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) } The next class we will create is**Service**:\n Right-click the service package and click New\u003e Kotlin File / Class. Name it ScreenBeagleService. This class must be annotated with @Service, which is a Spring annotation Implement a method called createScreenBeagle that returns the ScreenBeagleBuilder class:  import com.example.bff.builder.ScreenBeagleBuilder import org.springframework.stereotype.Service @Service class ScreenBeagleService { fun createScreenBeagle() = ScreenBeagleBuilder } And then the Controller class.\n In the controller package, create a class and name it ScreenController. It must be annotated with @RestController to expose its components through the Rest API. He will receive a ScreenBeagleService through his main builder, so Spring can inject it for you. Create your class as in the example below:  import com.example.bff.service.ScreenBeagleService import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController @RestController class ScreenController( private val screenBeagleService: ScreenBeagleService ) { @GetMapping(\"/screen\") fun getFirstScreen() = screenBeagleService.createScreenBeagle() }  The @RestController annotation defines this class as a controller class The screenBeagleService parameter must have its type defined as: ScreenBeagleService The getScreen method needs to annotate @ GetMapping (\"/ screen\") to create the \"/ screen\" path in the application’s URL and receive the result of the createScreenBeagle function  The backend is ready to serve as the BFF of your Server-Driven application.\nInitializing the application Now it’s time to start your application, follow the next steps:\nStep 1: Run the project Click on the green triangle named run, or press and hold SHIFT + F10 to run your back-end application.\nYour screen should look like this:\nStep 2: Make a request Open your browser and type: localhost: 8080 / screen\nA JSON structure must appear on your screen similar to the structure below:\n{ \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello Beagle!\", \"style\" : { \"margin\" : { \"top\" : { \"value\" : 16.0, \"type\" : \"REAL\" } }, \"flex\" : { \"alignSelf\" : \"CENTER\" } } }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Beagle is a cross-platform framework which provides usage of the Server-Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code.\", \"style\" : { \"margin\" : { \"left\" : { \"value\" : 16.0, \"type\" : \"REAL\" }, \"top\" : { \"value\" : 20.0, \"type\" : \"REAL\" }, \"right\" : { \"value\" : 16.0, \"type\" : \"REAL\" } } } } ] } } Step 3: Check the process If that is not the answer you had, it is necessary to check the configuration process again. Go back to the previous steps and start with the classes that have the biggest mistakes when configured for the first time.\nOr, if you prefer, take the finished project from our repository and compare it with yours. You can access the repository here. \nIn order to use the backend service, you must have the front end prepared for Beagle, whether Android, iOS or Web. Everything will work using a JSON from the Backend.  To learn more about configuring your frontend environment, see more at:\n👉 Beagle implementation tutorial for Android.\n👉Beagle implementation tutorial for iOS.\n👉Beagle implementation tutorial for Web.\n","excerpt":" Starting a Backend project In this tutorial, the Backend will be …","ref":"/docs-beagle/docs/get-started/creating-a-project-from-scratch/case-backend/","title":"Case Backend"},{"body":" Iniciando um projeto Backend Nesse tutorial será implementado o Backend com o Beagle para que ele possa responder a requisições de sua aplicação server-driven, seja ela em Android, iOS ou WEB.\nPré-requisitos Para criar um projeto com o Beagle para o backend, é preciso:\n IDE Intelij IDE Community  Passo 1: Iniciar o projeto usando Spring initializr O primeiro passo para configurar seu backend é acessar o site do Spring\nEle criará o projeto Maven que facilitará a configuração do seu projeto.\nConfiguração do Spring\n Escolha o Maven como o sua opção de projeto; Marque kotlin como a linguagem; Marque a versão de inicialização maior que 2.1. Group é o nome que será usado como a hierarquia do começo. Para esse exemplo, você pode deixar como com.example; Artifact é o nome do projeto. Você nomeá-lo como BFF; Description contém a simples descrição do projeto; Packaging deve ser marcado como JAR; Java deve ser marcado como a versão java do seu sistema; Clique em generate e você irá fazer o download do seu projeto no formato .zip; Extraia o arquivo na pasta de sua preferencia.  Passo 2: Importar seu projeto para o Intelij Siga os passos abaixo para importar o projeto que você criou. Primeiro, abra o intellij e clique emImport project.\n  Escolha o arquivo onde você colocou o seuSpring project\ne clique em ok.\n  Clique em Import projects from external model e escolha Maven e depois, clique em finish.\n  Configurando o Beagle Passo 1: Configurar o projeto Como ponto de partida, siga nosso passo a passo para instalar o backend.\nPasso 2: Definir a Estrutura O segundo passo é criar alguns pacotes para organizar melhor o projeto. Eles serão nomeados: builder, service e controller\n Clique em src \u003e main \u003e kotlin até encontra o nome do seu projeto. Clique com o botão direito do mouse em new \u003e package Nomeie builder e aperte enter. Repita o processo criando os dois outros pacotes, nomeando-os service e controller Após a criação dos pacotes, a sua tela deverá estar assim:  Passo 3:‌ Criar o serviço da aplicação A primeira classe que iremos criar é a Builder . É nesse arquivo que a tela Server-Driven deve ser estruturada:\n Clique no pacote builder com o botão direito do mouse e clique em new \u003e Kotlin File / Class e coloque o nome como ScreenBeagleBuilder Essa classe deve estender de ScreenBuilder (que é uma classe interna do Beagle). Observe que ele substituirá o método de build e é aqui que será implementado a primeira tela Server-Driven. Nesta etapa, você pode copiar e colar o código abaixo em sua classe.  import br.com.zup.beagle.core.Style import br.com.zup.beagle.ext.applyStyle import br.com.zup.beagle.ext.unitReal import br.com.zup.beagle.widget.Widget import br.com.zup.beagle.widget.action.Alert import br.com.zup.beagle.widget.core.AlignSelf import br.com.zup.beagle.widget.core.EdgeValue import br.com.zup.beagle.widget.core.Flex import br.com.zup.beagle.widget.core.TextAlignment import br.com.zup.beagle.widget.layout.Container import br.com.zup.beagle.widget.layout.Screen import br.com.zup.beagle.widget.layout.ScreenBuilder import br.com.zup.beagle.widget.ui.ImagePath import br.com.zup.beagle.widget.ui.Text object ScreenBeagleBuilder : ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text( text = \"Hello Beagle!\" ).applyStyle( Style(margin = EdgeValue(top = 16.unitReal()), flex = Flex(alignSelf = AlignSelf.CENTER) ) ), Text( text = \"Beagle is a cross-platform framework which provides usage of the \" + \"Server-Driven UI concept, natively in iOS, Android and Web applications. \" + \"By using Beagle, your team could easily change application's layout and\" + \" data by just changing backend code.\" ).applyStyle( Style(margin = EdgeValue( left = 16.unitReal(), right = 16.unitReal(), top = 20.unitReal() ) ) ) ) ) ) } A próxima classe a ser criada é a Service:\n Clique com o botão direito do mouse no pacote service e clique em New\u003e Kotlin File / Class. Nomeie-a como ScreenBeagleService. Essa classe deve ser anotada com @Service que é uma anotação do Spring Implemente um método chamado de createScreenBeagleque tem como retorno a classe ScreenBeagleBuilder:  import com.example.bff.builder.ScreenBeagleBuilder import org.springframework.stereotype.Service @Service class ScreenBeagleService { fun createScreenBeagle() = ScreenBeagleBuilder } E por fim a classe Controller .\n No pacote controllercrie uma classe e nomeia como ScreenController . Ela deve ser anotada com @RestController para que assim exponha seus componentes por meio da API Rest. Ele receberá um ScreenBeagleService por meio de seu construtor principal, para que o Spring possa injetá-la para você. Crie sua classe como no exemplo abaixo:  import com.example.bff.service.ScreenBeagleService import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController @RestController class ScreenController( private val screenBeagleService: ScreenBeagleService ) { @GetMapping(\"/screen\") fun getFirstScreen() = screenBeagleService.createScreenBeagle() }  A anotação @RestController define esta classe como uma controller O parâmetro screenBeagleService precisa ter seu tipo definido como :ScreenBeagleService O método getScreen precisa anotar@GetMapping(\"/screen\") para criar o caminho “/screen” na URL da aplicação e receber o resultado da função createScreenBeagle  O backend está pronto para servir como BFF de sua aplicação Server-Driven.\nInicializando a aplicação Agora é hora de inicializar a sua aplicação, siga os passos:\nPasso 1: Rodar o projeto Clique no triângulo verde chamado**run**, ou aperte e segure SHIFT + F10 para rodar sua aplicação back-end.\nA sua tela estará assim:\nPasso 2: Fazer uma requisição Abra o seu browser e digite: localhost:8080/screen\nUma estrutura JSON tem que aparecer na sua tela similar a estrutura abaixo:\n{ \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello Beagle!\", \"style\" : { \"margin\" : { \"top\" : { \"value\" : 16.0, \"type\" : \"REAL\" } }, \"flex\" : { \"alignSelf\" : \"CENTER\" } } }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Beagle is a cross-platform framework which provides usage of the Server-Driven UI concept, natively in iOS, Android and Web applications. By using Beagle, your team could easily change application's layout and data by just changing backend code.\", \"style\" : { \"margin\" : { \"left\" : { \"value\" : 16.0, \"type\" : \"REAL\" }, \"top\" : { \"value\" : 20.0, \"type\" : \"REAL\" }, \"right\" : { \"value\" : 16.0, \"type\" : \"REAL\" } } } } ] } } Passo 3: Checar o processo Se essa não for a resposta que você teve é necessário checar o processo de configuração novamente. Volte os passos anteriores e comece pelas classes que são as que apresentam maiores equívocos quando configuradas pela primeira vez.\nOu, se preferir, pegue o projeto pronto no nosso repositório e compare com o seu. Você pode acessar o repositório aqui. \nPara que o serviço de backend seja consumido, você deve ter o front-end preparado para o Beagle, seja Android, iOS ou Web. Tudo irá funcionar usando o mesmo JSON do backend.  Para saber mais sobre como configurar o seu ambiente frontend, veja mais em:\n👉 Tutorial do Beagle para Android.\n👉Tutorial do Beagle para iOS.\n👉Tutorial do Beagle para Web.\n","excerpt":" Iniciando um projeto Backend Nesse tutorial será implementado o …","ref":"/docs-beagle/pt/docs/primeiros-passos/criando-um-projeto-do-zero/case-backend/","title":"Case Backend"},{"body":" Currently, there are two cache labels on Beagle:\n A volatile layer. A persistent layer.  The volatile layer today depends on the persistent layer, meaning that only curly items on the persistent layer are candidates to the volatile cache.\nCache’s layers Volatile cache It’s the cache that lays on the frontend application’s memory and it’s used to reduce the number of backend’s calls.\nThe entries on this cache layer has time duration defined by cache general configurations of each client’s platform.\nYou can check out how to configure the cache according to your frontend’s platform on the following links:\n Configuring Cache  Persistent cache On this cache layer, there are two types of localization:\n On backend’s memory; On frontend’s storage.  This cache is used to optimize BFF’s response - in terms of time and size -, in cases where there is no changes. The entries of this cache lasts until the server redeploy or the client is reinstalled.\nThe premisse to this cache works is that it has to always return the same JSON to the same request. To guarantee that, it’s necessary that this cache is the same according to its endpoint and specific platform as we can see in component’s platform specification.\nIn other words, we say that an endpoint can return a static element because it can only work if it returns the same JSON, independently of any other specific platform.\nIt’s important to remember that cache’s mechanism must not be used with endpoints that does not meet this premisse.  The cache can be activated or disabled on BFF by endpoint or for an entire BFF. You can check out how to configure a cache. \nHow does the cache protocol works? The protocol acts in the beagle-hash header. BFF validates the received hashes and send a complete response or just the status HTTP 304 Not Modified (without the body).\nWhen BFF responds with the status 304, the application loads the element in cache. If this does not happen, it stores the hash and render the received elements.\nNext Steps 👉 See how to configure cache according to each platform (Android, iOS, Web e Backend).\n👉Check out how cache works according to its types (reliable and unreliable).\n","excerpt":" Currently, there are two cache labels on Beagle:\n A volatile layer. A …","ref":"/docs-beagle/docs/resources/cache/","title":"Cache"},{"body":" Atualmente, existem duas camadas de cache no Beagle:\n Uma camada volátil Uma camada persistente.  A camada volátil hoje depende da camada persistente, no sentido que apenas itens cacheadas na camada persistente são candidatos para o cache volátil.\nCamadas de cache Cache volátil É o cache que fica na memória da aplicação frontend e que é usado para reduzir a quantidade de chamadas ao backend.\nAs entradas nesta camada do cache têm duração por tempo, definida nas configurações gerais de cache de cada plataforma de cliente.\nVocê pode checar como configurar o cache de acordo com sua plataforma, no link abaixo:\n Configurando o cache  Cache persistente Nesta camada de cache, existem duas localizações. São elas:\n Na memória do backend; No armazenamento do frontend.  Este cache é usado para otimizar a resposta do BFF - tanto em tempo quanto em tamanho -, em casos que não há mudança. As entradas neste cache duram até o servidor refazer o deploy ou o cliente ser reinstalado.\nA premissa para que este cache funcione é que ele deve sempre retornar o mesmo JSON para a mesma requisição. Para que uma requisição seja considerada igual, é necessário que tenha o mesmo endpoint e a mesma plataforma especificada como mostra nossa especificação de plataformas.\nÉ importante destacar que o mecanismo de cache não deve ser utilizado em endpoints que não atendam a essa premissa. Ele pode ser ativado ou desativado no BFF por endpoint ou para o BFF inteiro.  Como o protocolo de cache funciona? O protocolo atua no cabeçalho beagle-hash. O BFF, por sua vez, valida os hashes recebidos e envia uma resposta completa ou apenas o status HTTP 304 Not Modified (sem um corpo).\nQuando o BFF responde com o status 304, o aplicativo carrega do elemento em cache. Caso isto não aconteça, ele armazena os dados recebidos (hash e JSON) e renderiza os elementos.\nPróximos passos 👉 Veja como fazer as configurações de cache de acordo com cada plataforma (Android, iOS, Web e Backend).\n👉Confira o funcionamento do cache de acordo com seus tipos (confiável e não confiável)\n","excerpt":" Atualmente, existem duas camadas de cache no Beagle:\n Uma camada …","ref":"/docs-beagle/pt/docs/recursos/cache/","title":"Cache"},{"body":" Como funciona o cache? O cache padrão é controlado pelo backend com a tag cache-control e beagle-hash que são informações que devem ser fornecidas através do header das requisições, onde o beagle-hash é responsável por fornecer o hash referente a tela que está sendo baixada e o cache-controlo tempo de vida deste cache como sendo confiável.\nCache confiável Um cache é dito confiável quando o seu tempo de vida ainda não expirou.\nNeste caso ao verificar que existe um cache no front e ele é confiável, a tela é renderizada sem sequer confirmar com o servidor. Isso poupa tempo, banda e provê uma experiência fluida para o usuário.\nO cache confiável fica salvo em memória.\nCache não confiável Já que temos o cache confiável, também temos o não confiável, isso quer dizer que o tempo de vida dele já expirou.\nUm cache ser não confiável significa que ao ser identificado ele precisa ser revalidado com o backend para aquela rota pelo seu hash.\nNeste momento ele deixa de estar salvo na memória e fica salvo de maneira persistente no disco.\nTempo de vida O tempo de vida do cache pode ser parametrizado através de configuração pela aplicação. Na implementação padrão do cache o tempo de vida é de 300 segundos. Este tempo também pode ser alterado caso o backend envie um tempo diferente através do header cache-control, pois ele tem prioridade nesta configuração.\nRevalidação de cache Quando um cache não confiável é encontrado ele precisa ser revalidado com o backend. Isso quer dizer que ao buscar uma tela ele envia no header da requisição o hash que possui.\nAo receber essa requisição o servidor entende que já existe uma versão desta tela salva na aplicação e compara o valor hash enviado com o valor atual salvo por ele (backend). Caso sejam iguais é enviada uma resposta com status 304 e sem corpo algum, indicando que a tela permanece a mesma e que aquele cache é confiável novamente.\nCaso o hash enviado pelo front seja diferente daquele salvo no backend, será enviada uma resposta normalmente com o novo valor do hash que deverá ser atualizado na aplicação.\nOcupação de memória e disco Para evitar sobrecarga de memória e disco ambos os caches aplicam uma política de substituição__Least Recently Used (LRU) onde a quantidade máxima de registros também pode ser configurada através da classe base de cache pela aplicação. Os valores padrões para memória e disco são 15 e 150 respectivamente.\nConfigurando e customizando o cache Existem customizações permitidas pela classe padrão existente no cache como tempo de vida e quantidade máxima de registros em memória e disco.\nCaso a abordagem padrão não resolva o problema, a aplicação tem total liberdade de substituir completamente a implementação padrão pela que melhor atender. Para isso, basta que a classe responsável pelo gerenciamento do cache esteja em conformidade com o protocolo CacheManagerProtocol.\nCada plataforma tem especificidades para configurar o cache.\nAbaixo listamos a configuração por plataforma:\nAndroid iOS Backend Web No Android, o cache é configurado quando implementamos as configurações iniciais do Beagle.\nEsta implementação acontece dentro da classe que nomeamos AppBeagleConfig, ou seja, dentro da classe de configuração do Beagle.\nO cache, em si, é uma class interna do Beagle na qual podemos definir 3 propriedades representadas pelos atributos:\n enable maxAge memoryMaximumCapacity  @BeagleComponent class AppBeagleConfig : BeagleConfig { override val isLoggingEnabled: Boolean = true override val baseUrl: String get() = \"https://myapp.server.com/\" override val environment: Environment get() = Environment.DEBUG override val cache: Cache = Cache( enabled = true, maxAge = 300, memoryMaximumCapacity = 15 ) } Atributos do cache    Atributo Definição     enable Valor booleanoque habilita ou desabilita o cache em memória e disco   maxAge Valor inteirode tempo em segundos que o cache em memória estará ativo   memoryMaximumCapacity Valor inteiro que representa o tamanho do cache de memória LRU. Representa o número de telas que vão estar na memória. Por exemplo, se você definir o número 15, significa que 15 páginas ficarão em cache.     No iOS, o cache é configurado quando implementamos as configurações das dependências do Beagle.\nÉ possível mudar a configuração default do cache criando uma instância da classe CacheManagerDefault. Nessa classe permitimos que você altere os valores de 3 propriedades:\n memoryMaximumCapacity diskMaximumCapacity cacheMaxAge  let dependencies = BeagleDependencies() let cacheManager = CacheManagerDefault( dependencies: dependencies, config: .init(memoryMaximumCapacity: 15, diskMaximumCapacity: 300, cacheMaxAge: 300)) dependencies.cacheManager = cacheManager Beagle.dependencies = dependencies Também é possível criar a sua própria classe de gerenciamento de cache e configurá-la dentro da sua instância do BeagleDependencies se você conformar essa classe com o protocolo CacheManagerProtocol.\npublic protocol CacheManagerProtocol { func addToCache(_ reference: CacheReference) func getReference(identifiedBy id: String) -\u003e CacheReference? func isValid(reference: CacheReference) -\u003e Bool } Atributos do cache    Atributo Definição     memoryMaximumCapacity Valor inteiro que representa o tamanho do cache de memória LRU. Representa o número de telas que vão estar na memória. Por exemplo. Se definirmos o número 15 quer dizer que 15 páginas ficarão em cache.   diskMaximumCapacity Valor inteiro que representa o tamanho do cache de disco LRU. Representa o número de telas que vão estar no disco. Por exemplo. Se definirmos o número 150 quer dizer que 150 páginas ficarão em cache.   cacheMaxAge Valor inteirode tempo em segundos que o cache em memória estará ativo     No backend, as configurações desta funcionalidade são suportadas apenas para quem utiliza a biblioteca starter.\nO cache é criado para otimizar a resposta de uma requisição tanto em tamanho quanto em tempo do BFF quando o retorno é igual ao anterior a ela. As entradas nesse cache duram até o servidor ser “redeployado” ou o cliente ser reinstalado.‌\nPara realizar a configuração de cache:\n Dentro da pasta src/main/resources, procure pelo arquivo application.properties Caso não tenha o arquivo, você pode criá-lo agora.  Se a chave não estiver listada no seu arquivo, significa que a configuração padrão será aplicada automaticamente.\nbeagle.cache.endpoint.include=/image,/context/.* beagle.cache.enabled=false​ #Micronuat beagle.cache.endpoint.ttl./endpoint1=10s beagle.cache.endpoint.ttl./endpoint2=1m #Spring (precisa de [] para escapar os /) beagle.cache.endpoint.ttl.[/endpoint1]=10s beagle.cache.endpoint.ttl.[/endpoint2]=1m Na lista abaixo, você confere quais são as propriedades disponíveis e as configurações que podem ser alteradas.\n   Chave Descrição Valor Padrão     beagle.cache.enabled  Flag indicando se o mecanismo de cache está habilitado (ou não). true    beagle.cache.endpoint.include  Lista de endpoints a serem cacheados. Aceita expressões regulares conforme java.util.regex.Pattern por meio do kotlin.text.Regex. Todos (\u003c=1.0.2)\nNenhum (\u003e=1.1.0)\n   beagle.cache.endpoint.exclude  Lista de endpoints a não serem cacheados. Aceita expressões regulares conforme java.util.regex.Pattern por meio do kotlin.text.Regex. A exclusão é prioridade em cima da inclusão. Nenhum   beagle.cache.endpoint.ttl (\u003e=1.1.0)\n Pares de chave valor, onde a chave é um endpoint como String e o valor é uma duração.\n\nA duração é um número seguido da unidade abreviada (s, m, h, etc.) para popular o valor da headerCache-control: max-age para esse endpoint.\n\nO endpoint precisa estar incluído. Endpoints inclusos têm duração de 30s por padrão. Durações menores que um segundo viram zero, pela definição do Cache-control: max-age.\n Nenhum     Na web, o cache é configurado quando definimos as configurações iniciais do Beagle Web no parâmetro strategy, que é um dos parâmetros do BeagleModule (se você estiver usando Angular) ou createBeagleUIService(se você estiver usando React).\nPor padrão, o cache vem habilitado com a estratégia**beagle-with-fallback-to-cache**, porém a estratégiabeagle-cache-only também pode ser utilizada para implementar oprotocolo de cache do Beagle.\nLembre de deixar o CORS habilitado no backend sempre que for utilizar a estratégia de cache do Beagle para Web.\n Abaixo, exemplos de como foi alterado do beagle-with-fallback-to-cache, que é o padrão, para o beagle-cache-only.\nExemplo de configuração para o Angular:\n@BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, strategy: 'beagle-cache-only' }) export class Beagle { } Exemplo de configuração para o React:\nexport default createBeagleUIService({ baseUrl: \"\", components: {}, strategy: 'beagle-cache-only' })  ","excerpt":" Como funciona o cache? O cache padrão é controlado pelo backend com a …","ref":"/docs-beagle/pt/docs/recursos/cache/configurando-o-cache/","title":"Configurando o cache"},{"body":" How does cache work? As in other platforms the pattern cache is controlled by the backend with the tag cache-control and beagle-hash, they are information that must be provided through request header, where beagle-hash is responsible for providing this hash related to the screen that has been downloaded and cache-control for the life time of this cache as reliable.\nReliable cache A reliable cache is when its life time has not expired yet.\nIn this case, when verifying if there is a cache in the front and it is reliable, the screen is rendered without confirming with the server. This saves time, bandwidth and provides a fluid experience to the user.\nReliable cache its saved in the memory.\nUnreliable cache We also have the unreliable cache, that means its life time has already expired.\nA unreliable cache means that when it is identified it needs to be validaded with a backend to the route with its hash.\nThis moment it stops being saved in the memory and it is saved in a persistent way in the disk.\nLife time The cache’s life time can have a parameter through the application’s configuration. In the standard cache implementation the life time is 300 seconds. This time can be altered if the backend sends a different time through the cache-control header, because it has priority in this configuration.\nCache re validation When an unreliable cache is found, it must be validated with the backend. That means when searching a screen, it sends a request in the header the hash it has.\nWhen receiving the request, the server understands that already has a version of this screen saved in the application and compares the hash value sent with the current one saved by the backend. In case they are the same, a response is sent with 304 status and without a body, indicating that the screen remains the same and that cache is reliable again.\nIf the hash sent by the front it is different from the one saved in the backend, a response will be sent normally with a new hash value that it must be updated in the application.\nMemory and disk occupation To avoid a memory and disk overload, both caches apply a replacement policity Least Recently Used (LRU) where the maximum quantity of the records can be also configured through the base cache class by the application. The standard values for memory and disk are 15 and 150, respectively.\nConfiguring and customizing the cache There are allowed customization allowed by pattern class that exists in the cache, like life time and maximum quantity of records in memory and disk.\nIn case the pattern approach does not solve the problem, the applicantion is free to replace the pattern implementation to another one that fits better. For that, the class responsible for the cache management needs to be in accordance with the CacheManagerProtocol protocol.\nEvery platform has different specifications to configure the cache.\nWe listed below, see:\nAndroid iOS Backend Web In Android, the cache is configured when you implement the first Beagle’s configuration.\nThis implementation happens inside the class named AppBeagleConfig, meaning that it is inside the Beagle’s configuration class.\nThe cache, is a Beagle’s internal class where we can define 3 properties, represented by the attributes below:\n enable maxAge memoryMaximumCapacity  @BeagleComponent class AppBeagleConfig : BeagleConfig { override val isLoggingEnabled: Boolean = true override val baseUrl: String get() = \"https://myapp.server.com/\" override val environment: Environment get() = Environment.DEBUG override val cache: Cache = Cache( enabled = true, maxAge = 300, memoryMaximumCapacity = 15 //  ) } Cache’s attributes    Attribute Definition     enable boolean value that enables or disables the cache in disk and memory.   maxAge int value of time in seconds that a memory cache will be active.   memoryMaximumCapacity Int value that represents the memory cache LRU size. It is the number of screens that will be in the memory, for example, if you define a number 15, it means 15 pages that will be in cache.     In iOS, the cache is configured when you first configure Beagle’s dependencies.\nWe allow you to change the default configuration of cache by creating a instance of a class named CacheManagerDefault. Inside this class you can define the value of 3 properties:\n memoryMaximumCapacity diskMaximumCapacity cacheMaxAge  let dependencies = BeagleDependencies() let cacheManager = CacheManagerDefault( dependencies: dependencies, config: .init(memoryMaximumCapacity: 15, diskMaximumCapacity: 300, cacheMaxAge: 300)) dependencies.cacheManager = cacheManager Beagle.dependencies = dependencies It is also possible to create your own cache manager and set it to BeagleDependencies if you conform to the protocol CacheManagerProtocol.\npublic protocol CacheManagerProtocol { func addToCache(_ reference: CacheReference) func getReference(identifiedBy id: String) -\u003e CacheReference? func isValid(reference: CacheReference) -\u003e Bool } Cache’s attributes    Attribute Definition     memoryMaximumCapacity whole value that represents the mamory cache LRU size. It is the number of screens that will be in memory. For example, if you define a number 15, it means 15 pages that will be in cache.   diskMaximumCapacity Whole value that represents the memory cache LRU size. It is the number of screens that will be in the memory. For example, if you define a number 15, it means 15 pages that will be in cache.   cacheMaxAge whole time value in seconds that the memory cache is active.     In the backend this functionality is only supported if you use the started library\nThe cache was created to optimize the response of a request in terms of size and BFF’s time, when the return is the same as the previous one. The input in this cache last until the server is redeployed or the client installed again.\nTo make this configuration:\n Search inside the ‌src/main/resources folder for the fileapplication.properties If you don’t have it, you can install now.  In case the key is not listed in your file, it means that the standard configuration will be applied automatically.\nbeagle.cache.endpoint.exclude=/imagebeagle.cache.enabled=false​ In the list below, you will find what are the available properties and which configuration can be altered.\n   Key Description Default     beagle.cache.enabled  Flag indicating if the cache mechanism is enabled or not. true    beagle.cache.endpoint.include  Endpoints list to be cached. It accepts regular expressions according to java.util.regex.Pattern throughkotlin.text.Regex. All (\u003c=1.0.2)\nNone (\u003e=1.1.0)\n   beagle.cache.endpoint.exclude  Endpoints list to not be cached. It accepts regular expressions according tojava.util.regex.Pattern. through kotlin.text.Regex. The exclusion is a priority. None   beagle.cache.endpoint.ttl (\u003e=1.1.0)\n Key values pair, where the key is an endpoint like a string and a value is the duration.\n\nThe duration is a number following the abbreviated unit (s, m, h, etc) to populate the header valueCache-control: max-age to this endpoint.\n\nThe endpoint needs to be included. Included enpoints have a 30s duration by default.\nDurations shorter than a second will be zero, by the\nCache-control: max-age definition.\n None     On web, the cache is configured when it’s defined the initials configurations of Beagle Web on the strategy parameter, which is one of BeagleModule parametes (if you’re using Angular) orcreateBeagleUIService(if you’re using React).\nBy default, the cache comes enabled with**beagle-with-fallback-to-cache** strategy, however the beagle-cache-only strategy can also be used to implement Beagle’s cache protocol.\nRemember to set CORS enabled for backend when you want to use cache’s strategy for Beagle on Web.\n Below, you can see examples on how to changebeagle-with-fallback-to-cache, which is default forbeagle-cache-only.\nExample of configuration for Angular:\n@BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, strategy: 'beagle-cache-only' }) export class Beagle { } Example of configuration for React:\nexport default createBeagleUIService({ baseUrl: \"\", components: {}, strategy: 'beagle-cache-only' })  ","excerpt":" How does cache work? As in other platforms the pattern cache is …","ref":"/docs-beagle/docs/resources/cache/how-to-configure-cache/","title":"How to configure cache"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/recursos/","title":"Recursos"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/resources/","title":"Resources"},{"body":" Availability: Beagle 1.0+  Introduction Beagle will use a dependency called Yoga Layout to position components on your application screen. To do this, Yoga calculates the position the elements are, and after that, it does its rendering.\nAbout Yoga Layout Yoga is framework developed by Facebook to position views using the Flexbox concept in Android and iOS applications.\nFlexbox is a CSS concept that organizes elements in containers dynamically so that, regardless of your application dimensions, you can maintain a flexible layout.\nHere follows some key concepts about Flexbox:\n Main Axis Cross Axis Main Size  For Main Size, it is possible to set 3 types of dimensions:\n Cross Size: The size of a cross axis. Main Start and Main The Start and End point in a main axis. Cross Start and Cross End: Start and end in a cross axis.  ‌These axis values will depend on what is defined at the Flex-direction property.\nIf it is defined as:\n row ou row-reverse: The main axis will be horizontal and the cross axis will be vertical.   column ou column-reverse: The main axis will be vertical and the cross axis will be horizontal.  Important! The default orientation on Beagle will be a column, meaning the the elements are displayed in a column.  Properties The following atributes willl define specific properties that the Yoga Layout sets.\nUnitValue The Basis, Size, Margin, Padding and Position attributes described above receive a UnitValue that expects a Double value and a UnitType, which is an enum with the following options:\n   UnitType Definition     REAL Apply a Doublevalue   PERCENT Apply a Double value as percentage of the parent size   AUTO Follows the parent’s value. Except when it has its own size    For the attributes listed below, on the Web, the default isUnitType.AUTO.\nThe UnitType.AUTO can be used on iOS, Android and Web fronts according to the table below:\n   Attributes  iOS\n  Android\n  Web\n     Basis  ✔ ✔ ✔   Size    ✔   Margin    ✔   Padding    ✔   Position    ✔    ","excerpt":" Availability: Beagle 1.0+  Introduction Beagle will use a dependency …","ref":"/docs-beagle/docs/resources/components-positioning/","title":"Component's Positioning"},{"body":" Disponibilidade: Beagle 1.0+  Introdução No Beagle, você terá de usar uma dependência chamadaYoga Layout para posicionar os componentes na tela da sua aplicação.\nPara fazer isso, o Yoga faz os cálculos necessários para posicionar os elementos e, depois disso, faz a sua renderização.\nSobre o Yoga Layout O Yoga é um framework Android e iOS desenvolvido pelo Facebook para posicionar views usando o conceito do Flexbox.\nO Flexbox organiza os elementos dentro de containers de forma dinâmica para que, independente das dimensões da sua aplicação, você possa manter um layout flexível.\nAlguns conceitos chave para entender o Flexbox são:\n Main Axis: eixo horizontal Cross Axis: eixo vertical Main Size: tamanho da dimensão dos eixos.  No caso do Main Size, é possível ter 3 tipos diferentes de dimensões:\n Cross Size: Tamanho da dimensão cross axis. Main Start and Main End: Começo e o fim do main axis. Cross Start and Cross End: Começo e o fim do cross axis.  ‌Estes eixos dependem do valor atribuído à propriedade flex-direction para definir a orientação dos elementos em tela.\nSe esta propriedade receber o valor:\n row ou row-reverse: o main axis do container será o horizontal e o cross axis será vertical.   column ou column-reverse: o main axis do container será vertical e o cross axis será horizontal.  Importante ressaltar que o default do Beagle é o valor columnou seja, os elementos serão dispostos em colunas por padrão.  Propriedades disponíveis A partir do Yoga Layout, você pode utilizar as seguintes propriedades para inserir, alterar ou eliminar componentes em tela:\nUnitValue As propriedades Basis, Size, Margin, Padding e Position descritas acima recebem um UnitValue que espera um valorDoublee um UnitType, que é um enumcom as seguintes opções:\n   UnitType Definição     REAL Aplica o valor Double   PERCENT Aplica o valor Double em forma de percentual do tamanho do pai   AUTO Segue o valor do pai. Exceto quando possui tamanho próprio    Para as propriedades listadas abaixo, na Web, o default é UnitType.AUTO.\nO UnitType.AUTO pode ser usado nas frentes iOS, Android e Web de acordo com a tabela abaixo:\n   Propriedade  iOS\n  Android\n  Web\n     Basis  ✔ ✔ ✔   Size    ✔   Margin    ✔   Padding    ✔   Position    ✔    ","excerpt":" Disponibilidade: Beagle 1.0+  Introdução No Beagle, você terá de usar …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/","title":"Posicionamento de componentes"},{"body":" Flex Direction The flex-direction property is applied to a container and defines the display axis / flow in which the elements will be organized. This property has the following attributes:row, row-reverse, column, column-reverse.\nThe examples where the function createText was used, returned a text component with an applied style. But this configuration is not required.  See below the components' behaviour examples for each attribute:\nRow Items are organized in a line form from left to right:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Row Reverse Items are organized in a line form from right to left:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.rowReverse) ) ) ) }  Column (Default) Items are organized from top to bottom:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) ) ) ) }  Column Reverse Items are organized from bottom to top:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.columnReverse) ) ) ) }  For more information about PositionType, check out the Yoga Layout documentation\n","excerpt":" Flex Direction The flex-direction property is applied to a container …","ref":"/docs-beagle/docs/resources/components-positioning/flex-direction/","title":"Flex Direction"},{"body":" Flex Direction A propriedade flex-direction é aplicada a um container e define o eixo/fluxo de exibição em que os elementos serão organizados. Essa propriedade tem os seguintes atributos: row, row-reverse, column, column-reverse.\nNos exemplos abaixo, foi utilizada função createText com intuito de retornar um componente de texto com um estilo aplicado. Mas essa configuração não é obrigatória.  Confira abaixo os exemplos de comportamento dos elementos para cada atributo:\nRow Os itens são organizados em forma de linha exibindo seus elementos da esquerda para a direita:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Row Reverse Os itens são organizados em forma de linha, exibindo seus elementos da direita para a esquerda:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.rowReverse) ) ) ) }  Column (Padrão) Os itens são organizados em forma de colunas e são posicionados de cima para baixo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) ) ) ) }  Column Reverse Os itens são organizados em forma de colunas e são posicionados de baixo para cima:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.columnReverse) ) ) ) }  Para saber o Flex Direction, acesse a documentação no Yoga Layout  ","excerpt":" Flex Direction A propriedade flex-direction é aplicada a um container …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/flex-direction/","title":"Flex Direction"},{"body":" Grow This property defines the proportion that an item should grow when necessary. Its value is 0 by default and that indicates that the item should not grow. This attribute accepts only Double positive values\nExample 1 The grow applied has value 0 and the container size did not change\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyStyle( Style( backgroundColor = \"#000000\", flex = Flex(grow = 0.0) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) ) ) ) }  Example 2 Grow 1.0 has been applied and the container size has grown until it meets the screen limits:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyStyle( Style( backgroundColor = \"#000000\", flex = Flex(grow = 1.0) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) ) ) ) }  For more information about Grow, check out the Yoga Layout documentation.\n","excerpt":" Grow This property defines the proportion that an item should grow …","ref":"/docs-beagle/docs/resources/components-positioning/grow/","title":"Grow"},{"body":" Grow Esta propriedade define a proporção que um item deve crescer, quando necessário. Seu valor é 0, por padrão e o que indica que o item não deve crescer. Esse atributo aceita apenas valores numéricos Doublepositivo.\nExemplo 1 O grow foi aplicado com valor 0, e o container ficou do mesmo tamanho do conteúdo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyStyle( Style( backgroundColor = \"#000000\", flex = Flex(grow = 0.0) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) ) ) ) }  Exemplo 2 O grow = 1.0 foi aplicado e o container ficou com o tamanho da tela:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyStyle( Style( backgroundColor = \"#000000\", flex = Flex(grow = 1.0) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) ) ) ) }  Para saber o Grow, acesse a documentação no Yoga Layout  ","excerpt":" Grow Esta propriedade define a proporção que um item deve crescer, …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/grow/","title":"Grow"},{"body":" Justify Content Justify-content defines the alignment of items along the main axis (horizontally) and has the following attributes:flex-start, flex-end, center, space-between, space-around e space-Evenly.\nThe size of a container can interfere on this property behaviour. The elements when are positioned, they can be set in a column instead a line, like the example below. If the container does not have enough height to contain all the stacked elements, this property won’t be able to show the element in a column,  Flex Start (Default) Items are aligned at the beginning of the main axis; lined up at the screen top\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.flexStart) ) ) ) }  Flex End Items are aligned from the end of the main axis; aligned at screen the bottom\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.flexEnd) ) ) ) }  Center Items are aligned at the center of the main axis; in the center of the screen:\nKotlin Swift {% code title=\"\" %}}\nprivate fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.center) ) ) ) }  Space Between The first item is moved to main axis start, the last is moved to the main axis end and the rest are evenly distributed making the space between them is equal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_BETWEEN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceBetween) ) ) ) }  Space Around Items are evenly distributed along the main axis. Equal margins are assigned at main axis start and endd (or left and right, depending on the direction of the main axis). For this reason, the first and last items are not sticked at the edges.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_AROUND ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceAround) ) ) ) }  Space Evenly Items are evenly distributed along the main axis:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceEvenly) ) ) ) }  For more information about Justify Content, check out the Yoga Layout documentation\n","excerpt":" Justify Content Justify-content defines the alignment of items along …","ref":"/docs-beagle/docs/resources/components-positioning/justify-content/","title":"Justify Content"},{"body":" Justify Content O justify-content define o alinhamento dos itens ao longo do eixo principal do container (horizontalmente) e tem os seguintes atributos: flex-start, flex-end, center, space-between, space-around e space-Evenly.\nO tamanho do container pode interferir no comportamento dessa propriedade. Isso significa que, quando os elementos são posicionados, podem ser dispostos em uma coluna em vez de uma linha, como no exemplo abaixo.\nNesse momento, se o container não possuir uma altura suficiente para conter os elementos empilhados, essa propriedade não conseguirá mostrar os elementos em uma coluna.\n Flex Start (padrão) Os itens são alinhados a partir do início do eixo principal; alinhados em cima, no começo da tela:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.flexStart) ) ) ) }  Flex End Os itens são alinhados a partir do fim do eixo principal; alinhados em baixo, no fim da tela:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.flexEnd) ) ) ) }  Center Os itens são alinhados ao centro do eixo principal; no centro da tela:\nKotlin Swift {% code title=\"\" %}}\nprivate fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.center) ) ) ) }  Space Between O primeiro item é deslocado para o início do eixo principal, o último é deslocado para o fim do eixo principal e os demais são distribuídos uniformemente; o espaço entre eles é igual:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_BETWEEN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceBetween) ) ) ) }  Space Around Os itens são uniformemente distribuídos ao longo do eixo principal. Aqui, são atribuídas margens iguais acima e abaixo (ou à esquerda e à direita, dependendo da direção do eixo principal). Por isso o primeiro e o último item não ficam “colados” nas bordas do container:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_AROUND ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceAround) ) ) ) }  Space Evenly Os itens são uniformemente distribuídos ao longo do eixo principal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(0) .justifyContent(.spaceEvenly) ) ) ) }  Para saber o Justify Content, acesse a documentação no Yoga Layout  ","excerpt":" Justify Content O justify-content define o alinhamento dos itens ao …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/justify-content/","title":"Justify Content"},{"body":" Align Content This property defines how the lines are distributed along the cross axis (vertical)and has the following attributes:flex-start, flex-end, center, space-between, space-around e stretch.\nStretch Lines are evenly distributed along the cross axis and take up all the available space:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.STRETCH ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.stretch) ) ) ) }  Flex Start (default) Lines are distributed at the beginning of the cross axis:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.flexStart) ) ) ) }  Flex End Lines are distributed at the end of the cross axis\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.flexEnd) ) ) ) }  Center Lines are kept in center of the cross axis:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.center) ) ) ) }  Space Between The first line is moved to the beginning of the cross axis, and the last one to the end. The rest are evenly distributed between:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.SPACE_BETWEEN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.spaceBetween) ) ) ) }  Space Around Lines are evenly distributed along the cross axis. Margins are assigned equally to the left and right (or above and below, depending on the direction of the cross axis). That is why the first and last lines are not sticked to the edges\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.SPACE_AROUND ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.spaceAround) ) ) ) }  For more information about Align Content, check out the Yoga Layout documentation.\n","excerpt":" Align Content This property defines how the lines are distributed …","ref":"/docs-beagle/docs/resources/components-positioning/align-content/","title":"Align Content"},{"body":" Align Content Essa propriedade define como as linhas são distribuídas ao longo do eixo transversal (vertical) do container e tem os seguintes atributos: flex-start, flex-end, center, space-between, space-around e stretch.\nStretch As linhas são distribuídas uniformemente ao longo do eixo transversal e ocupa todo o espaço disponível:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.STRETCH ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.stretch) ) ) ) }  Flex Start (padrão) As linhas são distribuídas no início do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.flexStart) ) ) ) }  Flex End As linhas são distribuídas no fim do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.flexEnd) ) ) ) }  Center As linhas são mantidas no centro do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.center) ) ) ) }  Space Between A primeira linha é deslocada para o início do eixo transversal, a última para o final e as demais são distribuídas uniformemente entre eles:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.SPACE_BETWEEN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.spaceBetween) ) ) ) }  Space Around As linhas são uniformemente distribuídas ao longo do eixo transversal. As margens são atribuídas igualmente à esquerda e à direita (ou acima e abaixo, dependendo da direção do eixo transversal). Por isso a primeira e a última linha não ficam “coladas” nas bordas do container:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\"), createText(backgroundColor = \"#142850\", text = \"texto 10\"), createText(backgroundColor = \"#dd7631\", text = \"texto 11\"), createText(backgroundColor = \"#649d66\", text = \"texto 12\"), createText(backgroundColor = \"#142850\", text = \"texto 13\"), createText(backgroundColor = \"#dd7631\", text = \"texto 14\"), createText(backgroundColor = \"#649d66\", text = \"texto 15\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP, alignContent = AlignContent.SPACE_AROUND ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), createText(backgroundColor: \"#142850\",text: \"10\"), createText(backgroundColor: \"#dd7631\",text: \"11\"), createText(backgroundColor: \"#649d66\",text: \"12\"), createText(backgroundColor: \"#142850\",text: \"13\"), createText(backgroundColor: \"#dd7631\",text: \"14\"), createText(backgroundColor: \"#649d66\",text: \"15\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .flexWrap(.wrap) .alignContent(.spaceAround) ) ) ) }  Para saber o Align Content, acesse a documentação no Yoga Layout.  ","excerpt":" Align Content Essa propriedade define como as linhas são distribuídas …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/align-content/","title":"Align Content"},{"body":" Align Items This property defines how items are distributed along the container’s transversal axis and has the following attributes:flex-start, flex-end, center, baseline e stretch.\nStretch Items will be expanded to fill the entire dimension of the cross axis (height or width).\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.STRETCH ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.stretch) ) ) ) }  Flex Start Items are shifted to the cross axis start:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.flexStart) ) ) ) }  Flex End Items are shifted to the cross axis end:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.flexEnd) ) ) ) }  Center Items are centered on the cross axis:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  Baseline Items are aligned acording to the firt text line in each element.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.BASELINE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(70).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(40).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(100).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .grow(1) .justifyContent(.spaceEvenly) .alignItems(.baseline) ) ) ) }  For more information about Align Itens, check out the Yoga Layout documentation.\n","excerpt":" Align Items This property defines how items are distributed along the …","ref":"/docs-beagle/docs/resources/components-positioning/align-items/","title":"Align Items"},{"body":" Align Items Essa propriedade define como os itens são distribuídos ao longo do eixo transversal do container e tem os seguintes atributos: flex-start, flex-end, center, baseline e stretch.\nStretch Os itens serão expandidos para preencher toda a dimensão do eixo transversal (altura ou largura) da tela:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.STRETCH ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.stretch) ) ) ) }  Flex Start Os itens são deslocadas para o início do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.FLEX_START ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.flexStart) ) ) ) }  Flex End Os itens são deslocadas para o final do eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.FLEX_END ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.flexEnd) ) ) ) }  Center Os itens são centralizados no eixo transversal:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(300).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(200).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(150).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  Baseline Os itens são alinhados a partir da base da primeira linha de texto de cada um:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\") .applyFlex( flex = Flex( size = Size( width = 300.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#dd7631\", text = \"texto 2\") .applyFlex( flex = Flex( size = Size( width = 200.unitReal(), height = 100.unitReal() ) ) ), createText(backgroundColor = \"#649d66\", text = \"texto 3\") .applyFlex( flex = Flex( size = Size( width = 150.unitReal(), height = 100.unitReal() ) ) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.BASELINE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(70).height(100))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(40).height(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().width(100).height(100))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .grow(1) .justifyContent(.spaceEvenly) .alignItems(.baseline) ) ) ) }  Para saber mais sobre o Align Items, acesse a documentação no Yoga Layout.  ","excerpt":" Align Items Essa propriedade define como os itens são distribuídos ao …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/align-items/","title":"Align Items"},{"body":" Align Self This property will override the behavior defined by the align-items property. It has the following attributes:flex-start, flex-end, center, auto, baseline e stretch.\nAlign self is set to each component and not to a container.  Each number above represents one property:\n1 = auto: Will follow positioning set by the align-items property;\n2 = stretch: Items will streach until the fill the whole cross axis;\n3 = flex-start: Items displays at the cross axis begining;\n4 = flex-end: Items displays at the cross axis end;\n5 = center: Items displays at the cross axis center;\n6 = baseline: Items are aligned acording to the firt text line in each element..\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(alignSelf = AlignSelf.AUTO) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( flex = Flex(alignSelf = AlignSelf.STRETCH) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( flex = Flex(alignSelf = AlignSelf.FLEX_START) ), createText(backgroundColor = \"#dd7631\", text = \"4\").applyFlex( flex = Flex(alignSelf = AlignSelf.FLEX_END) ), createText(backgroundColor = \"#649d66\", text = \"5\").applyFlex( flex = Flex(alignSelf = AlignSelf.CENTER) ), createText(backgroundColor = \"#dd7631\", text = \"6\").applyFlex( flex = Flex(alignSelf = AlignSelf.BASELINE) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().alignSelf(.auto)), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().alignSelf(.stretch)), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().alignSelf(.flexStart)), createText(backgroundColor: \"#142850\",text: \"4\").applyFlex( Flex().alignSelf(.flexEnd)), createText(backgroundColor: \"#dd7631\",text: \"5\").applyFlex( Flex().alignSelf(.center)), createText(backgroundColor: \"#649d66\",text: \"6\").applyFlex( Flex().alignSelf(.baseline)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .grow(1) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  For more information about Align Self, check out the Yoga Layout documentation\n","excerpt":" Align Self This property will override the behavior defined by the …","ref":"/docs-beagle/docs/resources/components-positioning/align-self/","title":"Align Self"},{"body":" Align Self Permite que o item sobrescreva o comportamento definido pela propriedade align-items. Ela tem os seguintes atributos:flex-start, flex-end, center, auto, baseline e stretch.\nO align self é aplicado em cada componente e não no container.  Cada um dos números acima representa um atributo:\n1 = auto: Respeita o comportamento definido no container por meio do align-items;\n2 = stretch: O item será esticado para preencher toda a dimensão do eixo transversal (altura ou largura);\n3 = flex-start: O item é deslocado para o início do eixo transversal;\n4 = flex-end: O item é deslocado para o final do eixo transversal;\n5 = center: O item é centralizado no eixo transversal;\n6 = baseline: O item é alinhado a partir da base da primeira linha de texto dos demais.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(alignSelf = AlignSelf.AUTO) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( flex = Flex(alignSelf = AlignSelf.STRETCH) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( flex = Flex(alignSelf = AlignSelf.FLEX_START) ), createText(backgroundColor = \"#dd7631\", text = \"4\").applyFlex( flex = Flex(alignSelf = AlignSelf.FLEX_END) ), createText(backgroundColor = \"#649d66\", text = \"5\").applyFlex( flex = Flex(alignSelf = AlignSelf.CENTER) ), createText(backgroundColor = \"#dd7631\", text = \"6\").applyFlex( flex = Flex(alignSelf = AlignSelf.BASELINE) ) ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.SPACE_EVENLY, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().alignSelf(.auto)), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().alignSelf(.stretch)), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().alignSelf(.flexStart)), createText(backgroundColor: \"#142850\",text: \"4\").applyFlex( Flex().alignSelf(.flexEnd)), createText(backgroundColor: \"#dd7631\",text: \"5\").applyFlex( Flex().alignSelf(.center)), createText(backgroundColor: \"#649d66\",text: \"6\").applyFlex( Flex().alignSelf(.baseline)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .grow(1) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  Para saber mais sobre o align self, acesse a documentação no Yoga Layout.  ","excerpt":" Align Self Permite que o item sobrescreva o comportamento definido …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/align-self/","title":"Align Self"},{"body":" Flex Wrap By default, items in a container will try to fit in a single line, but this will only happen when their original width can be adjusted.\nThe flex-wrap property changes this behavior and “wraps” items. It has the following attributes: nowrap, wrap, wrap-reverse.\nNo Wrap (default) Items displays in one single line:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.NO_WRAP ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.noWrap) ) ) ) }  Wrap A break line will occur and the rightmost items will drop one line:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.wrap) ) ) ) }  Wrap Reverse The break line will upline the rightmost items:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.wrapReverse) ) ) ) }  For more information about Flex Wrap, check out the Yoga Layout documentation.\n","excerpt":" Flex Wrap By default, items in a container will try to fit in a …","ref":"/docs-beagle/docs/resources/components-positioning/flex-wrap/","title":"Flex Wrap"},{"body":" Flex Wrap Por padrão os itens do container tentarão se ajustar em uma única linha dentro do container, mas para que isso ocorra a sua largura original pode ser ajustada. A propriedade flex-wrap altera esse comportamento e faz a “quebra de linha” nos itens, e ela tem os seguintes atributos: nowrap, wrap, wrap-reverse.\nNo Wrap (padrão) Todos os itens serão dispostos em uma linha:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.NO_WRAP ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.noWrap) ) ) ) }  Wrap A quebra de linha irá acontecer e os itens mais à direita serão deslocados para a linha de baixo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.wrap) ) ) ) }  Wrap Reverse A quebra de linha irá acontecer e os itens mais à direita serão deslocados para a linha acima:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"texto 1\"), createText(backgroundColor = \"#dd7631\", text = \"texto 2\"), createText(backgroundColor = \"#649d66\", text = \"texto 3\"), createText(backgroundColor = \"#142850\", text = \"texto 4\"), createText(backgroundColor = \"#dd7631\", text = \"texto 5\"), createText(backgroundColor = \"#649d66\", text = \"texto 6\"), createText(backgroundColor = \"#142850\", text = \"texto 7\"), createText(backgroundColor = \"#dd7631\", text = \"texto 8\"), createText(backgroundColor = \"#649d66\", text = \"texto 9\") ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP_REVERSE ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), createText(backgroundColor: \"#142850\",text: \"7\"), createText(backgroundColor: \"#dd7631\",text: \"8\"), createText(backgroundColor: \"#649d66\",text: \"9\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .flexWrap(.wrapReverse) ) ) ) }  Para saber mais sobre o Flex wrap, acesse a documentação no Yoga Layout.  ","excerpt":" Flex Wrap Por padrão os itens do container tentarão se ajustar em uma …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/flex-wrap/","title":"Flex Wrap"},{"body":" Margin Margin will apply some space outboarding the elements: all, bottom, end, horizontal, left, right, start, top, vertical\nAtributes All Defines some space around the element in all directions:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(all = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().margin(EdgeValue().all(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Bottom Defines some space at the element bottom:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(bottom = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().bottom(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) .justifyContent(.flexStart) .grow(1) ) ) ) }  Left Defines some space at the element left side:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(left = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().left(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Right Defines some space at the element right side:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(right = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().right(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Top Defines some space at the element top:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(top = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().top(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Horizontal Defines some horizontal space at the element sides:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(horizontal = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().horizontal(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Vertical Defines some vertical space at the element top and botton sides:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(vertical = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().vertical(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) .justifyContent(.flexStart) .grow(1) ) ) ) }  For more information about Margin, check out theYoga Layout documentation\n","excerpt":" Margin Margin will apply some space outboarding the elements: all, …","ref":"/docs-beagle/docs/resources/components-positioning/margin/","title":"Margin"},{"body":" Margin Margin aplica um espaçamento no elemento filho, e tem os seguintes atributos: all, bottom, end, horizontal, left, right, start, top, vertical\nPropriedades All Define um espaçamento em todos os lados do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(all = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().margin(EdgeValue().all(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Bottom Define um espaçamento na parte inferior do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(bottom = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().bottom(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) .justifyContent(.flexStart) .grow(1) ) ) ) }  Left Define um espaçamento no lado esquerdo do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(left = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().left(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Right Define um espaçamento no lado direito do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(right = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().right(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Top Define um espaçamento na parte superior do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(top = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().top(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Horizontal Define um espaçamento no eixo horizontal do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(horizontal = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().horizontal(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .justifyContent(.flexStart) .grow(1) ) ) ) }  Vertical Define um espaçamento no eixo vertical do elemento:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( flex = Flex(margin = EdgeValue(vertical = 10.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, justifyContent = JustifyContent.FLEX_START, flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().height(50).width(50)) .margin(EdgeValue().vertical(10))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) .justifyContent(.flexStart) .grow(1) ) ) ) }  Para saber mais, acesse Margin ou uma seção completa na documentação do Yoga Layout.  ","excerpt":" Margin Margin aplica um espaçamento no elemento filho, e tem os …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/margin/","title":"Margin"},{"body":" Padding This property allows spacing inside an element. Within Padding, you will also find the following atributes:\nall, bottom, end, horizontal, left, right, start, top, vertical\nAtributes All Defines some space inside the element in all directions:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(all = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().all(20) flex: Flex().flexDirection(.row) ) ) ) ) }   Bottom Defines some space at the bottom inside a element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) )applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(bottom = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().bottom(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Left Defines some space inside the element, at the left side:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(left = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().left(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Right Defines some space inside the element, at the right side:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(right = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().right(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Top Defines some space inside the element, at the top:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(top = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().top(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Horizontal Defines some horizontal space inside the element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(horizontal = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().horizontal(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Vertical Defines some vertical space inside the element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(vertical = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().vertical(20) flex: Flex().flexDirection(.row) ) ) ) ) }  For more information about Padding, check out the Yoga Layout documentation\n","excerpt":" Padding This property allows spacing inside an element. Within …","ref":"/docs-beagle/docs/resources/components-positioning/padding/","title":"Padding"},{"body":" Padding Esta propriedade permite aplicar um espaçamento no elemento pai. Dessa forma, todo elemento filho que for criado depois dessa configuração já virá com espaçamento pré-definido.\nDentro do Padding, você encontra ainda as seguintes propriedades:\nall, bottom, end, horizontal, left, right, start, top, vertical\nPropriedades All É ele quem define um espaçamento em todos os lados do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(all = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().all(20) flex: Flex().flexDirection(.row) ) ) ) ) }   Bottom É ele quem define um espaçamento na parte inferior do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) )applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(bottom = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().bottom(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Left É ele quem define um espaçamento no lado esquerdo do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(left = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().left(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Right É ele quem define um espaçamento no lado direito do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(right = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().right(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Top É ele quem define um espaçamento na parte superior do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(top = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().top(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Horizontal É ele quem define um espaçamento no eixo horizontal do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(horizontal = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().horizontal(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Vertical É ele quem define um espaçamento no eixo vertical do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\"), createText(backgroundColor = \"#142850\", text = \"4\"), createText(backgroundColor = \"#dd7631\", text = \"5\"), createText(backgroundColor = \"#649d66\", text = \"6\") ) ).applyStyle( Style( backgroundColor = \"#0000000\", flex = Flex(flexDirection = FlexDirection.ROW), padding = EdgeValue(vertical = 20.unitReal() ) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\"), createText(backgroundColor: \"#142850\",text: \"4\"), createText(backgroundColor: \"#dd7631\",text: \"5\"), createText(backgroundColor: \"#649d66\",text: \"6\"), ],widgetProperties: WidgetProperties( style: Style( backgroundColor: \"#000000\", padding: EdgeValue().vertical(20) flex: Flex().flexDirection(.row) ) ) ) ) }  Para saber mais sobre Padding, acesse a documentação do Yoga Layout  ","excerpt":" Padding Esta propriedade permite aplicar um espaçamento no elemento …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/padding/","title":"Padding"},{"body":" Position This property defines an elements position on screen and its values are: top, right, bottom,left\nThey behave according to the Position Type (defined after this one ) of this element. The element inside the Position can have 2 types of positioning\n Relative: Elements move in a specific direction respecting each other bondaries. Absolute: The elements move in the same direction defined by the parent element.  It will be more clear when we address this property ahead.  Propriedades All It sets the same value for all positions:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(all = 50.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().all(50))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Bottom It sets a spacing at the bottom of an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(bottom = 50.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().bottom(50))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Left It defines a spacing on the left side of an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(left = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().left(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Right It defines a spacing on the right side of an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(right = 100.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().right(100))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Top It defines a spacing on the top of an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(top = 100.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().top(100))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Horizontal It defines horizontal spacing at an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(horizontal = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().horizontal(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Vertical It defines vertical spacing at an element:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(vertical = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().vertical(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  For more information about Position, check out the Yoga Layout documentation\n","excerpt":" Position This property defines an elements position on screen and its …","ref":"/docs-beagle/docs/resources/components-positioning/position/","title":"Position"},{"body":" Position Esta propriedade determina a posição de um assume em tela e os seus valores top, right, bottom, left se comportam de acordo com o Position Type deste elemento.\nO elemento dentro do Position pode ter diferentes tipos de deslocamento se forem:\n Relative: os elementos se deslocam em uma direção específica Absolute: os elementos se deslocam na mesma direção definida para o elemento pai.  Propriedades All É ele quem define o mesmo valor para todas posições. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(all = 50.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().all(50))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Bottom É ele quem define um espaçamento na parte inferior do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(bottom = 50.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().bottom(50))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Left É ele quem define um espaçamento no lado esquerdo do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(left = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().left(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Right É ele quem define um espaçamento no lado direito do elemento. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(right = 100.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().right(100))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Top É ele quem define o posicionamento do top. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(top = 100.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().top(100))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Horizontal É ele quem define um valor horizontal adicionando valor no left e right. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(horizontal = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().horizontal(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Vertical É ele quem define um valor vertical adicionando valor no top e bottom. Exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( size = Size(width = 50.unitReal(),height = 50.unitReal()), position = EdgeValue(vertical = 150.unitReal()) ) ), createText(backgroundColor = \"#dd7631\", text = \"2\"), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex( grow = 1.0, flexDirection = FlexDirection.ROW, justifyContent = JustifyContent.CENTER, alignItems = AlignItems.CENTER ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex() .size(Size().width(50).height(50)) .position(EdgeValue().vertical(150))), createText(backgroundColor: \"#dd7631\",text: \"2\"), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) ) ) ) }  Para saber mais sobre Position, acesse a documentação do Yoga Layout.  ","excerpt":" Position Esta propriedade determina a posição de um assume em tela e …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/position/","title":"Position"},{"body":" PositionType This property defines the position of an element within the parent and whether it should be used as Relative or Absolute\nRelative (default) This property positions the element in relation to the other elements in the same flow, causing them to move respecting the limits on their sibling elements.\nThis is how it displays\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 130.unitReal(),height = 130.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 100.unitReal(),height = 100.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),height = 70.unitReal())) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().height(130).width(130))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().height(100).width(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().height(70).width(70))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Absolute This element when you wish that an element “escape” the normal flow on the layout. He will ignore other elements and displays acording to its father parent.\nCheck how it works:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 130.unitReal(),height = 130.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 100.unitReal(),height = 100.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),height = 70.unitReal()), positionType = FlexPositionType.ABSOLUTE) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().height(130).width(130))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().height(100).width(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .positionType(.absolute) .size(Size().height(70).width(70))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  For more information about PositionType, check out the Yoga Layout documentation.\n","excerpt":" PositionType This property defines the position of an element within …","ref":"/docs-beagle/docs/resources/components-positioning/positiontype/","title":"Positiontype"},{"body":" PositionType É a propriedade que define qual a posição do elemento dentro do pai e ainda se ele deve ser usado como Relativo ou Absoluto.\nRelativo (Padrão) Por padrão, esta propriedade posiciona o elemento em relação aos demais elementos no mesmo fluxo, fazendo com que eles se desloquem respeitando os limites de seus elementos irmãos.\nVeja como funciona neste exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 130.unitReal(),height = 130.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 100.unitReal(),height = 100.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),height = 70.unitReal())) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().height(130).width(130))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().height(100).width(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().size(Size().height(70).width(70))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Absoluto Por padrão, você usa este elemento quando quiser que um elemento não participe do fluxo normal do layout. Em vez disso, ele é apresentado independentemente de seus irmãos.\nVeja como funciona neste exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 130.unitReal(),height = 130.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 100.unitReal(),height = 100.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),height = 70.unitReal()), positionType = FlexPositionType.ABSOLUTE) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().height(130).width(130))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().height(100).width(100))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .positionType(.absolute) .size(Size().height(70).width(70))), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  Para saber mais sobre Position Type, acesse a documentação do Yoga Layout.  ","excerpt":" PositionType É a propriedade que define qual a posição do elemento …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/positiontype/","title":"Positiontype"},{"body":" Basis This property defines the standard size of an item along the main axis. It could change according to the element caracteristics, which means that:\n If the father element has a Flex value set as: FlexDirection: row.The basis will define the screen width; If the father element has a Flex Value set as: FlexDirection: column.The basis defines the screen height.  How is it used FlexDirection: row Here the flexDirection: row is used to set the screen width size:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( Text(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ), Text(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ), Text(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#dd7631\",text: \"2\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#649d66\",text: \"3\") .applyFlex(Flex().basis(100)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }  FlexDirection Column Here the flexDirection: column is used to set the screen height size\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = 100.unitReal() ) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = 100.unitReal() ) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = 100.unitReal() ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#dd7631\",text: \"2\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#649d66\",text: \"3\") .applyFlex(Flex().basis(100)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) ) ) ) }  Basis with UnitType.AUTO It is also possible to put UnitValue (0.0, UnitType.AUTO) when using the basis. In this case, the value 0.0 is not relevant, because using UnitType.AUTO the main axis will be adjusted according to the size of the content. Unless a size fix value is also set for the component in the same direction as the main axis.\nKotlin  private fun screen() :Widget{ return Container( children = listOf( Text(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ), Text(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ), Text(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  For more information about Basis, check out the Yoga Layout documentation.  ","excerpt":" Basis This property defines the standard size of an item along the …","ref":"/docs-beagle/docs/resources/components-positioning/basis/","title":"Basis"},{"body":" Basis Esta propriedade define o tamanho padrão de um item ao longo do eixo principal. É possível que ele mude de acordo com o elemento, o que significa dizer que:\n Se o pai tiver o valor flexDirection: row o basis define o valor da largura (width); Se o pai tiver o contêiner flexDirection: column, basis define o valor da altura (height).  Exemplos de uso FlexDirection: Row Neste exemplo, você vê como a aplicação usando o flexDirection: row para manipular o tamanho da largura da tela.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( Text(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ), Text(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ), Text(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = UnitValue(100.0, UnitType.REAL) ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#dd7631\",text: \"2\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#649d66\",text: \"3\") .applyFlex(Flex().basis(100)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) ) ) ) }   FlexDirection Column Já neste exemplo, você vê como fica a aplicação usando o flexDirection: column para manipular o tamanho da altura da tela.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = 100.unitReal() ) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = 100.unitReal() ) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = 100.unitReal() ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.COLUMN ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#dd7631\",text: \"2\") .applyFlex(Flex().basis(100)), createText(backgroundColor: \"#649d66\",text: \"3\") .applyFlex(Flex().basis(100)), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.column) ) ) ) }  Basis com UnitType.AUTO É possível também passar UnitValue(0.0, UnitType.AUTO) quando utilizar basis. Neste caso o valor 0.0 não é relevante, pois usando UnitType.AUTO o eixo principal será ajustado de acordo com tamanho do conteúdo. Exceto se um valor de sizefixo também for definido para o componente no mesmo sentido do eixo principal.\nKotlin  private fun screen() :Widget{ return Container( children = listOf( Text(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ), Text(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ), Text(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex( basis = UnitValue(0.0, UnitType.AUTO) ) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW ) ) }  Para saber mais sobre Basis, acesse a documentação do Yoga Layout.  ","excerpt":" Basis Esta propriedade define o tamanho padrão de um item ao longo do …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/basis/","title":"Basis"},{"body":" Shrink This atribute defines an item’s ability to shrink, reducing child elements along the main axis. The reduction of the elements is done in a way that the total size of all the shrunk children does not exceed the size of the main container.\nWith Shrink, the element receives a double value, which will decrease the element according to the space at the container:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal()), shrink = 3.0) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, size = Size(width = 300.unitReal(),height = 300.unitReal()) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(150).height(150))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(150).height(150))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .size(Size().width(150).height(150)) .shrink(0.3) ), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .size(Size().width(300).height(300)) ) ) ) }  For more information about Shrink, check out the Yoga Layout documentation.\n","excerpt":" Shrink This atribute defines an item’s ability to shrink, reducing …","ref":"/docs-beagle/docs/resources/components-positioning/shrink/","title":"Shrink"},{"body":" Shrink Esta propriedade define a capacidade de um item encolher, reduzindo os elementos filhos ao longo do eixo principal.\nA diminuição dos elementos é feita de uma forma que o tamanho total de todos os filhos encolhidos não ultrapasse o tamanho do container principal.\nCom o Shrink, o elemento recebe um valor double, que irá diminuir o elemento de acordo com espaço do container. Veja no exemplo:\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 150.unitReal(),height = 150.unitReal()), shrink = 3.0) ) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, size = Size(width = 300.unitReal(),height = 300.unitReal()) ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size().width(150).height(150))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size().width(150).height(150))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .size(Size().width(150).height(150)) .shrink(0.3) ), ],widgetProperties: WidgetProperties( flex: Flex() .flexDirection(.row) .size(Size().width(300).height(300)) ) ) ) }  Para saber mais sobre Shrink, acesse a documentação do Yoga Layout.  ","excerpt":" Shrink Esta propriedade define a capacidade de um item encolher, …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/shrink/","title":"Shrink"},{"body":" Size These atributes handles the item’s sizes on screen.\nSize has the following atributes: width, heigth, maxWidth,maxHeight, minWidth, minHeigh, aspectRatio\nAtributos: Width Defines the item width\nHeight Defines the item height\nMaxWidth Defines a maximum width an item can fill up to.\nMaxHeight Defines a maximum height an item can fill up to.\nMinWidth Defines a minimum width an item can shrink down to.\nMinHeight Defines a minimum heght an item can shrink down to.\nAspectRatio This property created by Yoga Layout defines the width ratio according to the item’s height, following a logic of a double\u003e 0 value.\nFor example, if you apply a height of 100dp to a component and the aspectRatio of 2, the width will be 2 times the height where it will have the value of 200dp.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 50.unitReal(),height = 50.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(maxWidth = 70.unitReal(),maxHeight = 70.unitReal(), minWidth = 30.unitReal(),minHeight = 30.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),aspectRatio = 2.0)) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size() .width(50).height(50))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size() .maxWidth(70).maxHeight(70) .minWidth(30).minHeight(30))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .size(Size().width(70).aspectRatio(2.0)) ), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  For more information about Size, check out the Yoga Layout documentation.\n","excerpt":" Size These atributes handles the item’s sizes on screen.\nSize has the …","ref":"/docs-beagle/docs/resources/components-positioning/size/","title":"Size"},{"body":" Size Esta propriedade manipula toda parte de tamanho do item em tela. O Size conta com os seguintes atributos:\nwidth, heigth, maxWidth,maxHeight, minWidth, minHeigh, aspectRatio\nAtributos: Width Define o tamanho da largura do item\nHeight Define o tamanho da altura do item.\nMaxWidth Define uma largura máxima.\nMaxHeight Define uma altura máxima.\nMinWidth Define uma largura mínima.\nMinHeight Define uma altura mínima.\nAspectRatio É uma propriedade criada pelo Yoga Layout que define a proporção de largura de acordo com altura do item, seguindo uma lógica de valor double \u003e 0.\nIsso significa dizer que, por exemplo, se você aplicar uma altura de 100dp em um componente e o aspectRatio de 2, a largura será 2 vezes a altura onde terá o valor de 200dp.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex( Flex(size = Size(width = 50.unitReal(),height = 50.unitReal())) ), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(size = Size(maxWidth = 70.unitReal(),maxHeight = 70.unitReal(), minWidth = 30.unitReal(),minHeight = 30.unitReal())) ), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex( Flex(size = Size(width = 70.unitReal(),aspectRatio = 2.0)) ) ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().size(Size() .width(50).height(50))), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().size(Size() .maxWidth(70).maxHeight(70) .minWidth(30).minHeight(30))), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex() .size(Size().width(70).aspectRatio(2.0)) ), ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.spaceEvenly) .alignItems(.center) ) ) ) }  Para saber mais sobre Size, acesse a documentação do Yoga Layout.  ","excerpt":" Size Esta propriedade manipula toda parte de tamanho do item em tela. …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/size/","title":"Size"},{"body":" Display This property defines how this component displays.That allows a container to be flexible or blocked according to the value defined. The Display also provides a flexible context for all of its direct child elements.\nIn this property, we have two attributes:\n Flex None  Flex When this value is set the elements inside this container turns into Flexbox elements.\nNone When this value is set, the elements won’t shown on the screen, thus having their height and width 0.\n Kotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(display = FlexDisplay.NONE) ), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW, alignItems = AlignItems.CENTER, justifyContent = JustifyContent.CENTER, grow = 1.0 ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().display(.none)), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) .alignItems(.center) ) ) ) }  For more information about Display Margin, check out the Yoga Layout documentation.\n","excerpt":" Display This property defines how this component displays.That allows …","ref":"/docs-beagle/docs/resources/components-positioning/display/","title":"Display"},{"body":" Display Esta propriedade define o tipo de exibição deste componente, o que permite um container ser flexível ou bloqueado de acordo com o valor passado.\nO Display possibilita ainda um contexto flexível para todos os seus elementos filhos diretos. Nesta propriedade, temos dois atributos:\n Flex None  Flex Quando esse valor for definido permite que os elementos ficam flexível.\nNone Quando esse valor for definido permite que os elementos não sejam mostrado na tela, assim tendo sua altura e largura com valor 0.\n Kotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\"), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex( Flex(display = FlexDisplay.NONE) ), createText(backgroundColor = \"#649d66\", text = \"3\") ) ).applyFlex( Flex(flexDirection = FlexDirection.ROW, alignItems = AlignItems.CENTER, justifyContent = JustifyContent.CENTER, grow = 1.0 ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\"), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().display(.none)), createText(backgroundColor: \"#649d66\",text: \"3\") ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) .flexDirection(.row) .justifyContent(.center) .alignItems(.center) .alignItems(.center) ) ) ) }  ","excerpt":" Display Esta propriedade define o tipo de exibição deste componente, …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/display/","title":"Display"},{"body":" Flex This property defines how items will be filled according to the space available along the main axis. Flex sets values ​​applied to each child’s property.\nThus, it takes the values ​​of all the child elements and makes the following calculation: they add and then divide by each value of the flex property applied to the child. The result should be the child’s filled space in the container.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex(Flex(flex = 1.0)), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex(Flex(flex = 2.0)), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex(Flex(flex = 3.0)) ) ).applyFlex( Flex( grow = 1.0 ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().flex(1)), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().flex(2)), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().flex(3)) ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) ) ) ) }  For more information about Flex Margin, check out the Yoga Layout documentation.\n","excerpt":" Flex This property defines how items will be filled according to the …","ref":"/docs-beagle/docs/resources/components-positioning/flex/","title":"Flex"},{"body":" Flex Esta propriedade define como os itens do container serão preenchidos de acordo com o espaço disponível ao longo do eixo principal.\nPara isso, o Flex estabelece os valores aplicados na propriedade de cada filho. Assim, ele pega os valores de todos os elementos filhos e fazem o seguinte cálculo: somam e depois divide por cada valor da propriedade flex aplicado no filho. O resultado deve ser o espaço preenchido do filho no container.\nKotlin Swift private fun screen() :Widget{ return Container( children = listOf( createText(backgroundColor = \"#142850\", text = \"1\").applyFlex(Flex(flex = 1.0)), createText(backgroundColor = \"#dd7631\", text = \"2\").applyFlex(Flex(flex = 2.0)), createText(backgroundColor = \"#649d66\", text = \"3\").applyFlex(Flex(flex = 3.0)) ) ).applyFlex( Flex( grow = 1.0 ) ) }  private func screen() -\u003e Screen { return Screen( navigationBar: NavigationBar(title: \"Flex\"), child: Container(children: [ createText(backgroundColor: \"#142850\",text: \"1\").applyFlex( Flex().flex(1)), createText(backgroundColor: \"#dd7631\",text: \"2\").applyFlex( Flex().flex(2)), createText(backgroundColor: \"#649d66\",text: \"3\").applyFlex( Flex().flex(3)) ],widgetProperties: WidgetProperties( flex: Flex() .grow(1) ) ) ) }  ","excerpt":" Flex Esta propriedade define como os itens do container serão …","ref":"/docs-beagle/pt/docs/recursos/posicionamento-de-componentes/flex/","title":"Flex"},{"body":" Confira abaixo quais configurações é possível fazer com os componentes do Beagle:\n","excerpt":" Confira abaixo quais configurações é possível fazer com os …","ref":"/docs-beagle/pt/docs/recursos/componentes/","title":"Componentes"},{"body":" ","excerpt":" ","ref":"/docs-beagle/docs/resources/components/","title":"Components"},{"body":" O ContextComponent é uma interface precisa ser implementada em componentes que usam o Contexto, porque é onde está o atributo context.\nComponentes do Beagle com contexto:  Container SimpleForm PageView ScrollView TabView  Componente customizado com contexto Segue abaixo um exemplo de componente customizado com o contexto:\nAndroid BFF iOS @RegisterWidget data class CustomComponent( val otherAttribute: String override val context: ContextData? = null ): WidgetView(), ContextComponent  @RegisterWidget data class CustomComponent( val otherAttribute: String override val context: ContextData? = null ): Widget(), ContextComponent  public struct CustomComponent: RawComponent, HasContext { public var context: Context? public var otherAttribute: String }  Se você quiser criar componentes customizados no iOS, é necessário registrá-lo! Veja como registrar aqui.  ","excerpt":" O ContextComponent é uma interface precisa ser implementada em …","ref":"/docs-beagle/pt/docs/recursos/componentes/componente-com-contexto/","title":"Componente com contexto"},{"body":" Availability: Beagle1.0+ ComposedComponent helps with organization, maintenance and code reuse.\nclass MyScreenComponent : ComposeComponent { override fun build(): ServerDrivenComponent { //todo  } }  ComposedComponent doesn’t have a functionality, it is a backend exclusive resource.  Use case If you have, for example, a component structure that repeats constantly , just like the image below:\nIn this case, if you build a layout using DSL, the code would be like this:\nval style = Style( size = Size( width = UnitValue( 33.0, type = UnitType.PERCENT ) ) ) Screen( navigationBar = NavigationBar( title = \"Title\", showBackButton = true ), child = Container( children = listOf( // 1  Text(\"Nome:\").applyStyle(style = style), Text(\"Maria\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 2  Text(\"Idade:\").applyStyle(style = style), Text(\"10\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 3  Text(\"Cidade\").applyStyle(style = style), Text(\"Uberlândia\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 4  Text(\"País:\").applyStyle(style = style), Text(\"Brasil\").applyStyle(style = style), Text(\"Desatualizado\").applyStyle(style = style) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP ) ) ) As you can see, there is code repetition, to solve this problem you can use ComposedComponent. See below how it’s possible:\nEncapsulate this code in this single component like this:\nclass MyComposeComponent( private val field: String, private val value: String, private val status: String ): ComposeComponent { private val style = Style( size = Size( width = UnitValue( 33.0, type = UnitType.PERCENT ) ) ) override fun build() = Container( children = listOf( createText(field), createText(value), createText(status) ) ) private fun createText(text: String) = Text(text).applyStyle(style = style) } Now you can use it this way:\nScreen( navigationBar = NavigationBar( title = \"Title\", showBackButton = true ), child = Container( children = listOf( MyComposeComponent( field = \"Nome:\", value = \"Maria\", status = \"Atualizado\" ), MyComposeComponent( field = \"Idade:\", value = \"10\", status = \"Atualizado\" ), MyComposeComponent( field = \"Cidade:\", value = \"Uberlândia\", status = \"Atualizado\" ), MyComposeComponent( field = \"País:\", value = \"Brasil\", status = \"Desatualizado\" ) ) ).applyFlex(Flex(flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP)) The code is clearer and makes the code maintenance easier.\nTo build this component, it was not necessary to create a new one or a behaviour in the frontend.\n","excerpt":" Availability: Beagle1.0+ ComposedComponent helps with organization, …","ref":"/docs-beagle/docs/resources/components/composedcomponent/","title":"Composedcomponent"},{"body":" O ComposedComponent facilita a organização, manutenção e reaproveitamento de código. Ele não tem funcionalidade própria e é exclusivo do backend.\nclass MyScreenComponent : ComposeComponent { override fun build(): ServerDrivenComponent { //todo  } } Caso de uso Se você tem, por exemplo, uma estrutura de componentes que se repete constantemente, como na imagem abaixo:\nNeste caso, se você construir este layout utilizando o DSL, o código ficaria da seguinte forma:\nval style = Style( size = Size( width = UnitValue( 33.0, type = UnitType.PERCENT ) ) ) Screen( navigationBar = NavigationBar( title = \"Title\", showBackButton = true ), child = Container( children = listOf( // 1  Text(\"Nome:\").applyStyle(style = style), Text(\"Maria\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 2  Text(\"Idade:\").applyStyle(style = style), Text(\"10\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 3  Text(\"Cidade\").applyStyle(style = style), Text(\"Uberlândia\").applyStyle(style = style), Text(\"Atualizado\").applyStyle(style = style), // 4  Text(\"País:\").applyStyle(style = style), Text(\"Brasil\").applyStyle(style = style), Text(\"Desatualizado\").applyStyle(style = style) ) ).applyFlex( Flex( flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP ) ) ) Existe muita repetição de código, o que dificulta sua manutenção. Para resolver este problema, você pode utilizar o ComposedComponent.\nVeja abaixo como isso é possível:\n Encapsule este código em um componente único como abaixo:  class MyComposeComponent( private val field: String, private val value: String, private val status: String ): ComposeComponent { private val style = Style( size = Size( width = UnitValue( 33.0, type = UnitType.PERCENT ) ) ) override fun build() = Container( children = listOf( createText(field), createText(value), createText(status) ) ) private fun createText(text: String) = Text(text).applyStyle(style = style) }  2. Agora você pode usá-lo assim:  Screen( navigationBar = NavigationBar( title = \"Title\", showBackButton = true ), child = Container( children = listOf( MyComposeComponent( field = \"Nome:\", value = \"Maria\", status = \"Atualizado\" ), MyComposeComponent( field = \"Idade:\", value = \"10\", status = \"Atualizado\" ), MyComposeComponent( field = \"Cidade:\", value = \"Uberlândia\", status = \"Atualizado\" ), MyComposeComponent( field = \"País:\", value = \"Brasil\", status = \"Desatualizado\" ) ) ).applyFlex(Flex(flexDirection = FlexDirection.ROW, flexWrap = FlexWrap.WRAP)) O código fica bem mais claro e facilita a manutenção!\nPara a construção deste componente, não foi necessário a criação de nenhum outro novo ou comportamento no frontend.\n","excerpt":" O ComposedComponent facilita a organização, manutenção e …","ref":"/docs-beagle/pt/docs/recursos/componentes/componente-composto/","title":"Componente Composto"},{"body":" ContextComponent is an interface that it is necessary to be implemented in components that use Context, because it contains the context attribute.\nBeagle’s components with context:  Container SimpleForm PageView ScrollView TabView  Customized components with context See below an example with customized components with context:\nAndroid BFF iOS @RegisterWidget data class CustomComponent( val otherAttribute: String override val context: ContextData? = null ): WidgetView(), ContextComponent  @RegisterWidget data class CustomComponent( val otherAttribute: String override val context: ContextData? = null ): Widget(), ContextComponent  public struct CustomComponent: RawComponent, HasContext { public var context: Context? public var otherAttribute: String }  If you want to create customized components on iOS, it is necessary to register it. See how to do it here  ","excerpt":" ContextComponent is an interface that it is necessary to be …","ref":"/docs-beagle/docs/resources/components/components-with-context/","title":"Components with context"},{"body":" Alguns elementos fornecidos pelo Beagle podem ser mais direcionados à uma plataforma e, talvez, não fazer tanto sentido para outra. Por exemplo, o uso do ScrollView funciona melhor na plataforma Mobile, mas não é necessário na Web.\nIsso acontece porque o Beagle possui a funcionalidade de Especificação de Plataforma, que te permite ter controle de quais elementos são enviados pelo BFF e quais plataformas serão usadas.\nComo funciona? O Beagle faz uso de um cabeçalho personalizado, beagle-platform, com os possíveis valores:\n ALL; MOBILE; ANDROID; IOS; WEB;  Dessa forma, a resposta do BFF é interceptada e os elementos filtrados de acordo com a plataforma para qual ela está sendo enviada.\nComo acessar? Você pode acessar esse controle de duas maneiras:\n Por meio de estruturas de controle de fluxo em seu código, que verifica qual plataforma seu cliente usou para realizar uma requisição.  Veja no exemplo a seguir:\nfun createComponentPlatformDependent(beaglePlatform: BeaglePlatform) = when { this.beaglePlatform.isMobilePlatform() -\u003e { ScrollView( children = listOf( Text(\"Mobile platform\") ) ) } this.beaglePlatform == BeaglePlatform.WEB -\u003e { Text(\"Web platform\") } else -\u003e { ScrollView( children = listOf( Text(\"Mobile platform\"), Text(\"Web platform\") ) ) } } Especificando a plataforma para qual o elemento é destinado e, com isso, o Beagle faz a filtragem dos elementos corretos.  Veja no exemplo a seguir:\nButton(text = \"mobile only text\").forPlatform(BeaglePlatform.MOBILE), Button(text = \"web only text\").forPlatform(BeaglePlatform.WEB), Button(text = \"ios only text\").forPlatform(BeaglePlatform.IOS), Button(text = \"android only text\").forPlatform(BeaglePlatform.ANDROID), Button(text = \"text free for all\") Se quiser saber como configurar esta funcionalidade, veja na seção de customização do Beagle.\nCaso utilize um dos Beagle starters, não é necessário realizar a configuração da funcionalidade manualmente, pois ela já vem pré-configurada.  ","excerpt":" Alguns elementos fornecidos pelo Beagle podem ser mais direcionados à …","ref":"/docs-beagle/pt/docs/recursos/componentes/especifica%C3%A7%C3%A3o-de-componentes-por-plataforma/","title":"Especificação de componentes por plataforma"},{"body":" Some elements provided by Beagle can be better used in some platforms than other, for example, ScrollView works better in mobile and it is not needed for web.\nBeagle has a platform specification functionality, so it is able to control which elements are sent by BFF and which platforms will be used.\nHow does it work? Beagle uses a customized header beagle-platform with the possible values:\n ALL; MOBILE; ANDROID; IOS; WEB;  This way, the BFF response is intercepted according to the platform which it is being sent.\nHow can you access it? There are two way you can access this control:\n Through flow control structure in your code that verifies which platform your client used to make a request:  fun createComponentPlatformDependent(beaglePlatform: BeaglePlatform) = when { this.beaglePlatform.isMobilePlatform() -\u003e { ScrollView( children = listOf( Text(\"Mobile platform\") ) ) } this.beaglePlatform == BeaglePlatform.WEB -\u003e { Text(\"Web platform\") } else -\u003e { ScrollView( children = listOf( Text(\"Mobile platform\"), Text(\"Web platform\") ) ) } } You can specify which platform the element will use and then Beagle will filter the correct elements:  Button(text = \"mobile only text\").forPlatform(BeaglePlatform.MOBILE), Button(text = \"web only text\").forPlatform(BeaglePlatform.WEB), Button(text = \"ios only text\").forPlatform(BeaglePlatform.IOS), Button(text = \"android only text\").forPlatform(BeaglePlatform.ANDROID), Button(text = \"text free for all\") You can check how to configure this functionality here.\nIf you use Beagle starters, it is not necessary to configure this functionality manually, because it is already configured.  ","excerpt":" Some elements provided by Beagle can be better used in some platforms …","ref":"/docs-beagle/docs/resources/components/platform-sorting/","title":"Platform sorting"},{"body":" Beagle has in its library some customization. You can check the process of each one in the links below:\n","excerpt":" Beagle has in its library some customization. You can check the …","ref":"/docs-beagle/docs/resources/customization/","title":"Customization"},{"body":" O Beagle disponibiliza na sua biblioteca algumas customizações. Você pode conhecer melhor o processo para cada biblioteca nas próximas páginas:\n","excerpt":" O Beagle disponibiliza na sua biblioteca algumas customizações. Você …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/","title":"Customização"},{"body":" These are Beagle for Android classes:\n","excerpt":" These are Beagle for Android classes:\n","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/","title":"Beagle for Android"},{"body":" O Beagle para Android possui estas principais classes:\n","excerpt":" O Beagle para Android possui estas principais classes:\n","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/","title":"Beagle para Android"},{"body":" Introdução Uma ação (Action) é um componente do Beagle que pode ser chamado por meio de eventos que são disparados por outros componentes (inclusive outras ações).\nO Beagle já possui algumas ações pré-definidas, no entanto é possível criar novas ações personalizadas.\nÉ obrigatória a adição da tag @Transient para todos os atributos presentes nas classes que representarão as ações para que não sejam levados em conta na serialização e desserialização do componente.  ","excerpt":" Introdução Uma ação (Action) é um componente do Beagle que pode ser …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/a%C3%A7%C3%B5es-customizadas/","title":"Ações customizadas"},{"body":" Introduction CustomAction is a Beagle’s component that can be called through events triggered by other components, including actions.\nBeagle already has some predefined actions, however it is possible to create custom actions.\nIt is mandatory to add the @Transient tag for all attributes present in the classes that will represent the actions so that they are not taken into account in the component serialization and deserialization.  ","excerpt":" Introduction CustomAction is a Beagle’s component that can be called …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-action/","title":"Custom Action"},{"body":" Para criar sua ação personalizada siga os seguintes os passos:\n Criar uma classe anotada com @RegisterAction que implemente a interface Action; Depois disso, a interface solicitará que o método execute seja implementado; Agora, declare o resultado da action.  O atributo value é um exemplo de parâmetro que pode ser declarado no construtor dessa classe, você pode usar quantos precisar. O exemplo a seguir mostra uma ação com Toast recebendo um texto como parâmetro:\n@RegisterAction data class CustomActionAndroid( val value: String ) : Action { override fun execute(rootView: RootView) { Toast.makeText( rootView.getContext(), value, Toast.LENGTH_SHORT ).show() } } Veja abaixo um exemplo de Action em um componente do tipo Botão:\nButton( text = text, styleId = styleId, onPress = listOf( CustomActionAndroid(\"Sou uma ação customizada\") ) ) ","excerpt":" Para criar sua ação personalizada siga os seguintes os passos:\n Criar …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/a%C3%A7%C3%B5es-customizadas/a%C3%A7%C3%A3o-customizada-simples/","title":"Ação Customizada Simples"},{"body":" To create your custom action, follow the next steps:\n Create an annotated class with @RegisterAction that implements an Action interface; After that, the interface will request to implement the execute method; Now, declare the action result.  The value attribute is a parameter example that can be declared in this class constructor. The following example shows an action with Toast receiving a text with a parameter:\n@RegisterAction data class CustomActionAndroid( val value: String ) : Action { override fun execute(rootView: RootView) { Toast.makeText( rootView.getContext(), value, Toast.LENGTH_LONG).show() } }  See below an action example in a button type component:  Button( text = text, styleId = styleId, onPress = listOf(CustomActionAndroid(\"I'm a customized action\")) ) ","excerpt":" To create your custom action, follow the next steps:\n Create an …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-action/simple-custom-action/","title":"Simple Custom Action"},{"body":" To create a custom action in Beagle whose execution is asynchronous such as consuming an API or accessing a database, just create an action as usual as the previous example detailed and implement the AsyncAction interface.\nWith the action created, just link the AsyncAction interface and delegate its implementation to the AsyncActionImpl class that Beagle already provides.\nWe recommend using this class, as it implements the onActionStarted and onActionFinished exposing its state in a reactive and standardized way in the framework.  @RegisterAction data class CustomActionAndroid( val value: String ) : Action, AsyncAction by AsyncActionImpl() { override fun execute(rootView: RootView) { // Do asynchronous work  } } Now, with the action ready to execute asynchronously, we have to MANDATORILY notify when its execution is finished through the onActionFinished method.\n@RegisterAction data class CustomActionAndroid( val value: String ) : Action, AsyncAction by AsyncActionImpl() { override fun execute(rootView: RootView) { // Do asynchronous work  onActionFinished() } } It’s done! Your action is now configured to run any job asynchronously!\nIt is mandatory to implement the AsyncAction interface for any custom action that is inserted within the ListView component.  ","excerpt":" To create a custom action in Beagle whose execution is asynchronous …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-action/async-custom-action/","title":"Async Custom Action"},{"body":" Para criar uma ação customizada no Beagle cuja execução seja assíncrona como o consumo de uma API ou acesso a um banco de dados, basta criar uma action normalmente como o exemplo anterior detalhou e implementar a interface AsyncAction.\nCom a action criada, basta vincular a interface AsyncAction e delegar sua implementação para a classe AsyncActionImpl que o Beagle já fornece.\nRecomendamos o uso dessa classe, pois ela implementa os onActionStarted e onActionFinished expondo seu estado de forma reativa e padronizado no framework.  @RegisterAction data class CustomActionAndroid( val value: String ) : Action, AsyncAction by AsyncActionImpl() { override fun execute(rootView: RootView) { // Do asynchronous work  } } Agora, com a action pronta para executar de forma assincrona, temos que OBRIGATORIAMENTE notificar quando sua execução está concluída através do método onActionFinished.\n@RegisterAction data class CustomActionAndroid( val value: String ) : Action, AsyncAction by AsyncActionImpl() { override fun execute(rootView: RootView) { // Do asynchronous work  onActionFinished() } } Pronto! Sua action agora está configurada para executar qualquer trabalho de forma assíncrona!\nÉ obrigatória a implementação da interface AsyncAction para toda ação customizada que for inserida dentro do componente ListView.  ","excerpt":" Para criar uma ação customizada no Beagle cuja execução seja …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/a%C3%A7%C3%B5es-customizadas/a%C3%A7%C3%A3o-customizada-ass%C3%ADncrona/","title":"Ação Customizada Assíncrona"},{"body":" Introdução No Beagle, a ferramenta de navegação entre telas permite que você configure ações como navegar para uma nova tela ou fechar uma tela.\nA questão é que, além de realizar estas configurações, você pode também customizar a navegação da sua aplicação.\nDe modo geral, existem duas opções de customização:\n De acordo com as animações padrões do Android A partir de transição de fragmentos fornecidas pelo próprio Beagle e que, neste caso, podem ser customizadas de acordo com a sua preferência e design system. São elas:   PushView PopView PopToView  Protocolo e customização O protocolo padrão do Beagle para casos de customização é utilizar a ferramenta nativa do Android para fazer transição de fragmentos para customizar sua animação.\nPara entender melhor como este processo funciona, leia mais na seção setCustomAnimations do Android.  A outra maneira de customizar uma animação de transição é por meio da implementação da classe BeagleActivity, na qual o Beagle utiliza o método getFragmentTransitionAnimation().\nCaso este método não seja implementado e customizado, as transições seguirão a animação padrão Beagle. O código abaixo mostra o método da BeagleActivity, que pode ser sobrescrito dessa forma:\nopen fun getFragmentTransitionAnimation() = FragmentTransitionAnimation( enter = R.anim.slide_from_right, exit = R.anim.none_animation, popEnter = R.anim.none_animation, popExit = R.anim.slide_to_right ) \u0000A animações padrão usada pelo Beagle são:\n Transição de entrada (enter) à nova tela surge da direta do aplicativo. Animação de saída da pilha (popExit), em que a tela também vai para a direita.  Como visto no código acima, para sobrescrever o método de customização você só precisa enviar como resultado uma instância da data class FragmentTransitionAnimation, como descrito abaixo:\ndata class FragmentTransitionAnimation( @AnimatorRes @AnimRes val enter: Int, @AnimatorRes @AnimRes val exit: Int, @AnimatorRes @AnimRes val popEnter: Int, @AnimatorRes @AnimRes val popExit: Int )  Vale contextualizar que esta classe possui quatro atributos, sendo eles:\n enter exit popEnter popExit  E todas elas descritas na documentação nativa do setCustomAnimations\n Depois que você sobrescrever o método getFragmentTransitionAnimation() na implementação da BeagleActivity, as transições de suas telas e fragmentos Beagle irão agora seguir sua própria animação.\nExemplo O exemplo de uso a seguir é para caso de telas que entram e saem com uma animação vertical. Para fazer esta configuração, siga os passos abaixo:\nPasso 1: Crie uma pasta com o nome anim no arquivo res da sua aplicação Android. Este será o local onde as animações serão armazenadas.\n\u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003ctranslate android:duration=\"@android:integer/config_longAnimTime\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:fromYDelta=\"100%\" android:toYDelta=\"0%\"/\u003e \u003c/set\u003e Se seguir o código acima, você indicará ao Beagle de que a animação deverá subir do ponto mínimo vertical para o ponto máximo, completando toda a tela do aplicativo. Esta animação será usada nas transições de entrada.\nPasso 2: É hora de configurar a animação de saída. Nela, você fará uma configuração para que ela se comporte como o oposto da animação de entrada, descendo toda a tela\u0000. Para fazer isso, basta copiar o código abaixo:\n\u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003ctranslate android:duration=\"@android:integer/config_longAnimTime\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:fromYDelta=\"0%\" android:toYDelta=\"100%\"/\u003e \u003c/set\u003e Passo 3: Depois de criar as animações, você pode utilizá-las sobrescritas ao método getFragmentTransition() na sua implementação da BeagleActivity, que ficará como no exemplo abaixo:\noverride fun getFragmentTransitionAnimation() = FragmentTransitionAnimation( enter = R.anim.slide_from_bottom, exit = R.anim.slide_to_bottom, popEnter = R.anim.slide_from_bottom, popExit = R.anim.slide_to_bottom )  \u0000Pronto, o Beagle agora já consegue usar as novas animações de transição!  Vale ressaltar que, para este exemplo, apenas duas animações foram criadas, sendo uma delas usada para animar as transições de enter e popEnter e a outra para exit e popExit. Porém, nada impede de você criar uma para cada ou uma para todos.\n","excerpt":" Introdução No Beagle, a ferramenta de navegação entre telas permite …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/anima%C3%A7%C3%B5es-de-navega%C3%A7%C3%A3o/","title":"Animações de navegação"},{"body":" Introduction BeagleActivity is a class that helps you manage where your server-driven components will be placed. Its structure works like an Android activity.\nIn order to Beagle understand that you’re working with an BeagleAcitivity’s class, it’s necessary to use @RegisterController annotation and implement their respective methods.\nWhat is customizable? When it comes to Beagle Activity, there are some custom components:\n Layout xml Toolbar Handling error ProgressBar  Check out the example below of how to custom an Beagle Activity:\n@RegisterController class SampleServerDrivenActivity : BeagleActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_server_driven) } override fun getToolbar(): Toolbar { TODO(\"Not yet implemented\") } override fun getServerDrivenContainerId(): Int { TODO(\"Not yet implemented\") } override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { TODO(\"Not yet implemented\") } } 1. Layout xml A xml layout file is where you host the screen component’s structure, likely you do with Android Activity. Even if you’re using Beagle to send your screen structure through server-driven, it’s still important to create this xml file to receive this content.\nSee below an example of an activity xml layout:\n\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cFrameLayout android:id=\"@+id/server_driven_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_gravity=\"center\" android:visibility=\"gone\"/\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e For the server-driven content, the xml layout needs a frame layout to load this content.\nIn the getServerDrivenContainerId()method, you must return the frame layout id.\noverride fun getServerDrivenContainerId(): Int = R.id.server_driven_container 2. Toolbar You can create a Toolbar and apply in your activity using the getToolbar() . In this method, you must return your Toolbar.\noverride fun getToolbar(): Toolbar = findViewById\u003cToolbar\u003e(R.id.toolbar) 3. Handling error You can watch the state and treat the errors from onServerDrivenContainerStateChanged()\noverride fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { if (state is ServerDrivenState.Error) { //Your error's treatment  } } 4. ProgressBar The same way that happens with error, you can handle if the server-driven container status is loading.\noverride fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { if (state is ServerDrivenState.Loading) { progressBar.visibility = if (state.loading) View.VISIBLE else View.GONE } }  You can register many activities as you wish, but you must define a default BeagleActivity using the annotation @RegisterController(id = \"ACTIVITY_IDENTIFIER\").\nThis id identify what activity the BFF will use.  ","excerpt":" Introduction BeagleActivity is a class that helps you manage where …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-beagle-activity/","title":"Custom Beagle Activity"},{"body":" Introdução O Beagle fornece uma Activity default para gerenciar as Activities geradas via server-driven. Porém você pode criar uma ou maisActivities que herdem de BeagleActivity com @BeagleComponent personalizadas de acordo com os fluxos server-driven da sua aplicação. Sua estrutura funciona parecida com o Android Activity.\nPara que o Beagle interprete essa classe como uma BeagleActivity, é necessário usar a anotação @BeagleComponent e implementar seus respectivos métodos.\nO que é customizável? Quando se trata do Beagle Activity, é possível customizar alguns componentes:\n Layout xml Toolbar Tratamento de erros ProgressBar  Confira abaixo um exemplo de código para uma Custom Beagle Activity:\n@RegisterController class SampleServerDrivenActivity : BeagleActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_server_driven) } override fun getToolbar(): Toolbar { TODO(\"Not yet implemented\") } override fun getServerDrivenContainerId(): Int { TODO(\"Not yet implemented\") } override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { TODO(\"Not yet implemented\") } } 1. Layout xml O arquivo xml é o local onde você armazena o pacote de componentes da tela, de forma semelhante ao que você faz com o Android Activity.\nMesmo usando o Beagle para enviar a estrutura da tela pelo server-driven, é importante criar este arquivo xml para receber o conteúdo.\nSegue abaixo um exemplo de um layout xml:\n\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/root_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"\u003e \u003candroidx.appcompat.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e \u003cFrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cFrameLayout android:id=\"@+id/server_driven_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /\u003e \u003cProgressBar android:id=\"@+id/progress_bar\" android:layout_width=\"42dp\" android:layout_height=\"42dp\" android:layout_gravity=\"center\" android:visibility=\"gone\"/\u003e \u003c/FrameLayout\u003e \u003c/LinearLayout\u003e Para o conteúdo server-driven ser exibido é necessário um frame layout. Sendo assim, o método getServerDrivenContainerId() precisa retornar o id do frame layout.\n2. Toolbar Você pode criar uma Toolbar e usá-la em sua activity através do métodogetToolbar() . Isso permite retornar a Toolbar desejada.\noverride fun getToolbar(): Toolbar = findViewById\u003cToolbar\u003e(R.id.toolbar) 3. Tratamento de erros Você pode observar os estados e tratar os erros a partir do onServerDrivenContainerStateChanged()``\noverride fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { if (state is ServerDrivenState.Error) { //Your error's treatment  } } 4. ProgressBar Da mesma forma que os erros, você consegue observar se o estado do container server-driven está em loading pelo ProgressBar. Veja como no trecho de código a seguir:\noverride fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { if (state is ServerDrivenState.Loading) { progressBar.visibility = if (state.loading) View.VISIBLE else View.GONE } }  É possível registrar quantas activities você precisar, porém você deve defini-las usando a anotação@RegisterController(id = \"ACTIVITY_IDENTIFIER\").\nEsse id é o que o BFF irá usar pra identificar qual activity usar.  ","excerpt":" Introdução O Beagle fornece uma Activity default para gerenciar as …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/beagle-activity-customizada/","title":"Beagle Activity customizada"},{"body":" This component does not work on 1.1.0 version and it will be removed in the future version. Use SimpleForm instead.  Introduction A validator component is used when it is necessary to validate some form information. It validates through isValidmethod that is requested when a FormSubmit or a notifyChanges() are implemented. This validator is listed as component that receives data in a form named FormInput.\nValidator context The Form component capture data informed by the user and validates and send them to BFF. This validation can happen when the user activates FormSubmit or when notifies its status to InputWidget(FormInput).\nValidator receives two generic parameters and it has only on isValid method that returns a boolean value.\ninterface Validator\u003cin I, in W\u003e { fun isValid(input: I, widget: W): Boolean }  input: represents the value inputWidget sends as data to be validated. widget: refers to InputWidget that sent the data.  Implementing a validator To implement a validator, you have to have a form that enables FormSubmit when FormInput is not empty, in this case it will receive a string with the data and then it will be validated if it is empty or not.\n The class that will validate the data is annotated as @RegisterValidator This annotation register this validator on Beagle and identify it by the name listed in parentheses.  @RegisterValidator(\"text-is-not-blank\") class TextNotBlankValidator : Validator\u003cString, ServerDrivenComponent\u003e { override fun isValid(input: String, widget: ServerDrivenComponent): Boolean { return !input.isBlank() } }  To send to InputWidget this validation, it is necessary to refer the given name to the annotation above \"text-is-not-blank\"in the component. Follow the example below:  FormInput( name = \"required-field\", required = true, validator = \"text-is-not-blank\", child = SampleTextField(placeholder = \"placeholder\") ) The follow example, the InputWidget implementation will run the Validator calling the notifyChanges() method.\n@RegisterWidget class SampleTextField(private val placeholder: String) : InputWidget() { @Transient private lateinit var textFieldView: EditText override fun getValue() = textFieldView.text.toString() override fun onErrorMessage(message: String) { textFieldView.error = message } override fun toView(context: Context) = EditText(context).apply { textFieldView = this textFieldView.hint = placeholder textFieldView.isSingleLine = true doOnTextChanged { _, _, _, _ -\u003e notifyChanges() } } }  If you want to validate the information as the user types it, the suggestion is to call the functionnotifyChanges()inside the other function doOnTextChange{}.  ","excerpt":" This component does not work on 1.1.0 version and it will be removed …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-validator/","title":"Custom Validator"},{"body":" Introdução A classe HTTPClient define como as solicitações de serviços são configuradas. Para usá-la, você precisa criar uma classe que implemente uma interface do tipo HttpClient.\nAqui, você pode adicionar cabeçalhos às suas requisições, definir os métodos request, body response, data response, executar criptografia, etc.\nCriando a classe HttpClient Para criar essa classe, siga os seguintes passos:\nPasso 1: Adicionar as dependências Localize o arquivo build.gradle(Module:app) , abra-o e role a página para baixo até encontrar o bloco de código dependencies { }.\n  Copie e cole a linha abaixo dentro das dependências:\n implementation ‘com.squareup.okhttp3:okhttp:4.5.0’  __\n  Aperte Sync now para sincronizar o Gradle novamente.\n  Essa dependência é necessária, pois a classe que implementa HttpClient vai importar algumas configurações dela.\n  Se a sua aplicação utilizar serviços do tipo Retrofit é possível que aconteça algum conflito, porque esse serviço define a dependência okhttp internamente e com isso ela irá conflitar com a dependência do HttpClient.\n  Substitua a linha:\nimplementation ‘com.squareup.okhttp3:okhttp:4.5.0’\n  Por essas duas outras linhas:\nimplementation ‘com.squareup.retrofit2:retrofit:2.7.2’\nimplementation ‘com.squareup.retrofit2:converter-gson:2.7.2\n   Passo 2: Criar a classe  Crie a classe e escolha o nome que você desejar. Nesse exemplo, foi dado o nome de HttpClientDefault. Se o Android reclamar dos imports, é só checar se as dependências não estão conflitantes. Essa configuração é bem extensa, a sugestão é que você copie e cole a classe abaixo e modifique como achar necessário:  import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.exception.BeagleApiException import br.com.zup.beagle.android.networking.HttpClient import br.com.zup.beagle.android.networking.HttpMethod import br.com.zup.beagle.android.networking.RequestCall import br.com.zup.beagle.android.networking.RequestData import br.com.zup.beagle.android.networking.ResponseData import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Job import kotlinx.coroutines.cancel import kotlinx.coroutines.launch import java.io.EOFException import java.net.HttpURLConnection typealias OnSuccess = (responseData: ResponseData) -\u003e Unit typealias OnError = (responseData: ResponseData) -\u003e Unit @BeagleComponent class HttpClientDefault : HttpClient, CoroutineScope { private val job = Job() override val coroutineContext = job + CoroutineDispatchers.IO override fun execute( request: RequestData, onSuccess: OnSuccess, onError: OnError ): RequestCall { if (getOrDeleteOrHeadHasData(request)) { onError(ResponseData(-1, data = byteArrayOf())) return createRequestCall() } launch { try { val responseData = doHttpRequest(request) onSuccess(responseData) } catch (ex: BeagleApiException) { onError(ex.responseData) } } return createRequestCall() } private fun getOrDeleteOrHeadHasData(request: RequestData): Boolean { return (request.method == HttpMethod.GET || request.method == HttpMethod.DELETE || request.method == HttpMethod.HEAD) \u0026\u0026 request.body != null } @Throws(BeagleApiException::class) private fun doHttpRequest( request: RequestData ): ResponseData { val urlConnection: HttpURLConnection try { urlConnection = request.uri.toURL().openConnection() as HttpURLConnection } catch (e: Exception) { throw BeagleApiException(ResponseData(-1, data = byteArrayOf()), request) } request.headers.forEach { urlConnection.setRequestProperty(it.key, it.value) } addRequestMethod(urlConnection, request.method) if (request.body != null) { setRequestBody(urlConnection, request) } try { return createResponseData(urlConnection) } catch (e: Exception) { throw tryFormatException(urlConnection, request) } finally { urlConnection.disconnect() } } private fun tryFormatException(urlConnection: HttpURLConnection, request: RequestData): BeagleApiException { val response = urlConnection.getSafeError() ?: byteArrayOf() val statusCode = urlConnection.getSafeResponseCode() val statusText = urlConnection.getSafeResponseMessage() val responseData = ResponseData(statusCode = statusCode, data = response, statusText = statusText) return BeagleApiException(responseData, request) } private fun addRequestMethod(urlConnection: HttpURLConnection, method: HttpMethod) { val methodValue = method.toString() if (method == HttpMethod.PATCH || method == HttpMethod.HEAD) { urlConnection.setRequestProperty(\"X-HTTP-Method-Override\", methodValue) urlConnection.requestMethod = \"POST\" } else { urlConnection.requestMethod = methodValue } } private fun setRequestBody(urlConnection: HttpURLConnection, request: RequestData) { urlConnection.setRequestProperty(\"Content-Length\", request.body?.length.toString()) try { urlConnection.outputStream.write(request.body?.toByteArray()) } catch (e: Exception) { throw BeagleApiException(ResponseData(-1, data = byteArrayOf()), request) } } private fun createResponseData(urlConnection: HttpURLConnection): ResponseData { return ResponseData( statusCode = urlConnection.responseCode, statusText = urlConnection.responseMessage, headers = urlConnection.headerFields.filter { it.key != null }.map { val headerValue = it.value.toString() .replace(\"[\", \"\") .replace(\"]\", \"\") it.key to headerValue }.toMap(), data = try { urlConnection.inputStream.readBytes() } catch (e: EOFException) { byteArrayOf() } ) } private fun createRequestCall() = object : RequestCall { override fun cancel() { this@HttpClientDefault.cancel() } } } ","excerpt":" Introdução A classe HTTPClient define como as solicitações de …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/camada-de-rede/","title":"Camada de rede"},{"body":" Introduction Beagle already has basic widgets that you can use to create components interface of your server-driven application.\nHowever, your application may need more customized components (Custom Views), and to make them ‘visible’ to Beagle, you have to create a customized widget. You can create many new components you want, since it makes your application’s Views, ‘visible’ to Beagle.\nIt is mandatory to add the @Transient tag for all attributes present in the classes that will represent the widgets so that they are not taken into account in the component serialization and deserialization.  ","excerpt":" Introduction Beagle already has basic widgets that you can use to …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-widget/","title":"Custom Widget"},{"body":" Introdução É possível observar o estado atual da tela durante as requisições server-driven em uma BeagleActivity, inclusive estados de erro.\nExemplo Ao exibir uma tela server-driven , é possível sobrescrever o método onServerDrivenContainerStateChange() para implementar suas tratativas para cada estado da tela.\nAbaixo segue um exemplo de uma BeagleActivity com o método onServerDrivenContainerStateChange()sobrescrito:\n@BeagleComponent class AppBeagleActivity : BeagleActivity() { private val progressBar: ProgressBar by lazy { findViewById\u003cProgressBar\u003e(R.id.progress_bar) } private val mToolbar: Toolbar by lazy { findViewById\u003cToolbar\u003e(R.id.custom_toolbar) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_app_beagle) } override fun getServerDrivenContainerId(): Int = R.id.server_driven_container override fun getToolbar(): Toolbar = mToolbar override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { when (state) { is ServerDrivenState.Started -\u003e { progressBar.visibility = View.VISIBLE } is ServerDrivenState.Finished -\u003e { progressBar.visibility = View.GONE } is ServerDrivenState.Error -\u003e { Toast.makeText(this, \"Error\", Toast.LENGTH_LONG).show() } } } } A partir destes estados, como mostra o exemplo anterior de implementação do loadView, é possível definir quando mostrar ou esconder o Load e definir também outras ações pertinentes aos estados ServerDrivenState: Started, Success , Finished e Error.\nsealed class ServerDrivenState { object Started : ServerDrivenState() object Finished : ServerDrivenState() object Success : ServerDrivenState() open class Error( val throwable: Throwable, val retry: BeagleRetry ) : ServerDrivenState() } Veja mais detalhes de cada estado:\n Started: Indica que uma busca de componente server-driven foi iniciada. Finished: Indica que uma busca de componente server-driven foi concluída. Success: Indica um estado de sucesso ao buscar um componente server-driven. Error: Indica um estado de erro ao buscar um componente server-driven.  ","excerpt":" Introdução É possível observar o estado atual da tela durante as …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/carregamento-e-tratamento-de-erros/","title":"Carregamento e tratamento de erros"},{"body":" How to create components (custom views) and widgets? The example below shows how a custom widget will be implemented and which component it will register. It will have a text and two buttons inside a linear layout. The buttons in this component will be responsible to increase and decrease the text’s size and the screen will be like the image:\nYou can do this using @RegisterWidget annotation and extending the WidgetView class.  Follow the next steps to create and customize a component and a widget:\nStep 1: Create widget  Create a class and name it\"CustomWidgetTitleIncrease\"; Apply the annotation@RegisterWidget ; Extend this class using WidgetView interface; This class now will request a toView method to be implemented. Change the class as listed below:  CustomWidgetTitleIncrease.kt @RegisterWidget class CustomWidgetTitleIncrease: WidgetView() { override fun buildView(rootView: RootView): View { TODO(\"not implemented\") } Step 2: Create and configure the component  Create a .XML configuration file and copy and paste the content below, it will create a layout:  title_increase_component_layout.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:orientation=\"vertical\"\u003e \u003cTextView android:id=\"@+id/tv_example_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:padding=\"20dp\" android:text=\"Example\" /\u003e \u003cLinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\"\u003e \u003cButton android:id=\"@+id/bt_increase\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:text=\"B1\" /\u003e \u003cButton android:id=\"@+id/bt_decrease\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:text=\"B2\" /\u003e \u003c/LinearLayout\u003e \u003c/LinearLayout\u003e Now, you have to create the component:\n Create a class and name it:TitleIncreaseComponent. This class will register how the component work and the business rule; Copy and paste the class below:  class TitleIncreaseComponent(context: Context) : LinearLayout(context) { init { View.inflate(context, R.layout.title_increase_component_layout, this) changeTitleSize() } fun setTitleText(title: String) { tvExampleTitle.text = title } fun setTitleButton1(titleButton:String){ btIncrease.text = titleButton } fun setTitleButton2(titleButton:String){ btDecrease.text = titleButton } private fun changeTitleSize(){ var size = tvExampleTitle.textSize tvExampleTitle.textSize = size Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() val textView = findViewById\u003cTextView\u003e(R.id.tvExampleTitle) val b1 = findViewById\u003cButton\u003e(R.id.btIncrease) val b2 = findViewById\u003cButton\u003e(R.id.btDecrease) b1.setOnClickListener { if(size \u003c 50){ size += 5f tvExampleTitle.textSize = size } Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() } b2.setOnClickListener { if(size \u003e 5){ size -= 5f tvExampleTitle.textSize = size } Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() } } } Step 3: Configure the widget The layout and the component are defined, it is necessary to finish the configuration of the customized widget.\n Check the function below and see that some text variables were added. This was chosen to demonstrate that it is possible to define the value of this variables by the widget, adding title and button names.  CustomWidgetTitleIncrease.kt @RegisterWidget class CustomWidgetTitleIncrease( private val title: String, private val buttonTitle1: String, private val buttonTitle2: String ) : WidgetView() { override fun buildView(rootView: RootView) = TitleIncreaseComponent(rootView.getContext()).apply { setTitleText(title) setTitleButton1(buttonTitle1) setTitleButton2(buttonTitle2) } } Step 4: Display the component The customized widget is now ready, the component can be displayed.\n To test the component, use the method below:  MainActivity.kt class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView( CustomWidgetTitleIncrease( \"Example Title\", \"Increase\", \"Decrease\" ).buildView(rootView = object : RootView { override fun getContext() = this@MainActivity override fun getLifecycleOwner() = this@MainActivity }) ) } } Run the aplication and your component will be displayed:  ","excerpt":" How to create components (custom views) and widgets? The example …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-widget/simple-custom-widget/","title":"Simple Custom Widget"},{"body":" Introdução Quando um método de ofuscação é usado, é necessário que algumas regras sejam implementadas para garantir que os nomes e os IDs usados internamente pelo Beagle, não sejam ofuscados ou minificados.\nExemplo Para garantir isso, você deve adicionar as seguintes regras no arquivo android-rules.pro do ProGuard:\nproguard-rules.pro # Beagle uses coroutines in network requests -keep class kotlinx.coroutines.experimental.android.AndroidExceptionPreHandler { *; } # Beagle does reflection on generic parameters -keepattributes Signature, InnerClasses, EnclosingMethod # Beagle does reflection on method and parameter annotations -keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations -dontwarn org.jetbrains.annotations.** -keep class kotlin.Metadata { *; } # Yoga is a dependency used on Beagle -keep @com.facebook.proguard.annotations.DoNotStrip class * { *; } # Customized classes for Beagle -keep @br.com.zup.beagle.annotation.** class * { *; } -keep @br.com.zup.beagle.android.annotation.** class * { *; } -keep class * extends br.com.zup.beagle.android.widget.** # Core classes in Beagle -keep class br.com.zup.beagle.android.action.** { *; } -keep class br.com.zup.beagle.android.widget.** { *; } -keep class br.com.zup.beagle.android.components.** { *; } -keep class br.com.zup.beagle.android.context.** { *; } -keep class br.com.zup.beagle.widget.** { *; } -keep class br.com.zup.beagle.core.** { *; } -keep class br.com.zup.beagle.analytics.** { *; }  Aqui, você também habilita o minifyEnable e shrinkResources no buildType declarando-os como true para testar a ofuscação do ProGuard.  Para testar o ProGuard você deve ativá-lo na sua IDE, você pode usar o Android Studio, adicione a configuração listada abaixo:\nbuildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' } } ","excerpt":" Introdução Quando um método de ofuscação é usado, é necessário que …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/configura%C3%A7%C3%A3o-do-proguard/","title":"Configuração do Proguard"},{"body":" Currently in Beagle, the Container and ListView components have the behavior of executing a list of actions as soon as they are rendered. For this, they expose the onInit property, which receives the list of actions that will be triggered.\nTo create a custom widget with the behavior of triggering a list of actions as soon as it is rendered, Beagle provides an easy way to do it using the pattern delegate by implementing the OnInitiableComponent interface.\nFor this step-by-step we will focus on linking OnInitiableComponent to the customizable widget, since its creation in detail has already been shown in the previous example.  Step 1: Link OnInitiableComponent With the customizable widget created, add the OninitiableComponent interface.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int ): WidgetView(), OnInitiableComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 2: Implement onInit property After adding the OnInitiableComponent interface to the widget, override the onInit property.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 3: Delegate implementation In addition to the onInit property, the OnInitiableComponent interface needs the implementation of the handleOnInit and markToRerunOnInit methods. To facilitate and maintain the component’s behavior pattern, Beagle already provides a ready implementation and we recommend its use, just delegating OnInitiableComponentImpl.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent by OnInitiableComponentImpl(onInit) { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 4: Execute handleOnInit Finally, with all the configuration done in the widget, only the execution of the handleOnInit method is missing so that the list of onInit actions can be executed as soon as the view is rendered.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent by OnInitiableComponentImpl(onInit) { override fun buildView(rootView: RootView): View { handleOnInit(rootView, view) } } It’s done! Your component now performs a list of actions whenever it is rendered!\nIt is mandatory to implement the OnInitiableCompoent interface for every custom widget that is inserted into the ListView component.  ","excerpt":" Currently in Beagle, the Container and ListView components have the …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-widget/oninit-custom-widget/","title":"Oninit Custom Widget"},{"body":" Introdução O DeepLinkHandler é uma interface que define como configurar a navegação entre uma Server-Driven activity e uma activity nativa.\nExemplo Criando um DeepLinkHandler Para realizar essa configuração, você deve criar uma classe que implemente a interface DeepLinkHandler e que faça a anotação com @BeagleComponent, conforme listado abaixo:\n@BeagleComponent class AppDeepLinkHandler : DeepLinkHandler { override fun getDeepLinkIntent( rootView: RootView, path: String, data: Map\u003cString, String\u003e?, shouldResetApplication: Boolean ) = Intent(\"openThisActivity\") } Feito isso, é necessário modificar o arquivo de manifesto do Android:\n Passo 1: Você deve adicionar um intent-filter na Activity para a qual deseja navegar. Passo 2: Você deve adicionar uma Action que identificará essa Activity. O nome que usamos aqui foi “openThisActivity”. Passo 3: Adicione uma tag category e a nomeie como \"android.intent.category.DEFAULT\", assim como no exemplo abaixo.  //AndroidManifest \u003cactivity android:name=\".activities.DeepLinkActivity\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"navigate.myview\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e Agora você só precisa chamar a Action Navigate com o método OpenNativeRoute como o exemplo abaixo:\n//Widget used to navigate to a native activity Button( text = \"Click to navigate!\", onPress = listOf( Navigate.OpenNativeRoute(\"openThisActivity\") ) ) ","excerpt":" Introdução O DeepLinkHandler é uma interface que define como …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/deep-link-handler/","title":"Deep Link Handler"},{"body":" To create a custom widget that uses other Beagle components, just implement the SingleChildComponent interface when there is only one child component, or MultiChildComponent for the widget that uses several other components.\nA component must implement only one of these interfaces, or SingleChildComponent, or MultiChildComponent, never both at the same time.  SingleChildComponent Custom widgets that render a single Beagle component must implement the SingleChildComponent interface.\nStep 1: Link SingleChildComponent With the custom widget created, add the SingleChildComponent interface.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 2: Implement the child property After adding the SingleChildComponent interface to the widget, override the child property.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val child: ServerDrivenComponent ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 3: Use the component To use the view generated from the child component, just consider it as a ViewConvertable and call the buildView method.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val child: ServerDrivenComponent ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { val builtChild = (child as ViewConvertable).buildView(rootView) } } MultiChildComponent Custom widgets that render one or more Beagle components must implement the MultiChildComponent interface.\nStep 1: Link MultiChildComponent With the custom widget created, add the MultiChildComponent interface.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int ): WidgetView(), MultiChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 2: Implement the children property After adding the MultiChildComponent interface to the widget, override the children property.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val children: List\u003cServerDrivenComponent\u003e ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Step 3: Use the component To use the view generated from the children component, just consider each one as ViewConvertable and call their buildView method.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val children: List\u003cServerDrivenComponent\u003e ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { children.forEach { child -\u003e val builtChild = (child as ViewConvertable).buildView(rootView) } } } It’s done! Your component now uses other Beagle components!\nIt is mandatory to implement one of the two interfaces for any custom widget that uses Beagle components within the ListView component.  ","excerpt":" To create a custom widget that uses other Beagle components, just …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/custom-widget/serverdrivencomponent-custom-widget/","title":"Serverdrivencomponent Custom Widget"},{"body":" Introdução Você pode registrar a forma como imagens remotas serão baixadas e preenchidas nas ImageView fornecendo uma classe que implementa essa lógica, que foi adicionado ao Beagle 1.3.0\nCom o BeagleImageDownloader sendo criado no frontend sua aplicação Android, o beagle saberá qual lógica usar para baixar e configurar os componentes Image com ImagePath.Remote.\nPasso 1: Adicionar as dependências Localize o arquivo build.gradle(Module:app), abra-o e role a página para baixo até encontrar o bloco de código dependencies { }.\n  Copie e cole a linha abaixo dentro das dependências:\n implementation ‘androidx.core:core-ktx:1.2.0’ implementation ‘org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9’ implementation ‘androidx.lifecycle:lifecycle-runtime-ktx:2.2.0’  __\n  Clique em Sync now para sincronizar o Gradle novamente.\n  Essa dependência é necessária, pois a classe que implementa BeagleImageDownloader vai importar algumas configurações dela.\n  Passo 2: Criar a classe import android.graphics.Bitmap import android.graphics.BitmapFactory import android.graphics.drawable.BitmapDrawable import android.util.Log import android.util.LruCache import android.widget.ImageView import androidx.lifecycle.lifecycleScope import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.imagedownloader.BeagleImageDownloader import br.com.zup.beagle.android.widget.RootView import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.launch import kotlinx.coroutines.withContext import java.io.InputStream import java.net.URL const val BASE_URL = \"http://base.url\" @BeagleComponent class CustomImageDownloader : BeagleImageDownloader { private val imageDownloader: ImageDownloader = ImageDownloader() override fun download(url: String, imageView: ImageView, rootView: RootView) { imageView.post { rootView.getLifecycleOwner().lifecycleScope.launch(Dispatchers.IO) { val bitmap = try { imageDownloader.getRemoteImage(BASE_URL + url, imageView.width, imageView.height) } catch (e: Exception) { Log.e(\"LOG_TAG\", e.message ?: \"Error when try to download Image\") null } bitmap?.let { setImage(imageView, bitmap) } } } } private suspend fun setImage(view: ImageView, bitmap: Bitmap?) { withContext(Dispatchers.Main) { view.context?.let { view.setImageDrawable(BitmapDrawable(it.resources, bitmap)) } } } } internal class ImageDownloader { suspend fun getRemoteImage(url: String, contentWidth: Int, contentHeight: Int) : Bitmap? { val cacheId = LruImageCache.generateBitmapId(url, contentWidth, contentHeight) return withContext(Dispatchers.IO) { val bitmapCached = LruImageCache.get(cacheId) bitmapCached ?: url.let { downloadBitmap(it, contentWidth, contentHeight).apply { LruImageCache.put(cacheId, this) } } } } private fun downloadBitmap(url: String?, contentWidth: Int, contentHeight: Int) : Bitmap { val inputStream: InputStream = URL(url).openStream() return BitmapFactory.decodeStream(inputStream) } } internal object LruImageCache { private val cache: LruCache\u003cString, Bitmap\u003e by lazy { LruCache\u003cString, Bitmap\u003e(anEighthOfMemory()) } fun put(key: String, bitmap: Bitmap?) { if (bitmap != null) { cache.put(key, bitmap) } } fun get(key: String?): Bitmap? = cache.get(key) private fun anEighthOfMemory() = ((Runtime.getRuntime().maxMemory() / 1024).toInt() / 8) fun generateBitmapId( url: String?, contentWidth: Int, contentHeight: Int ) = StringBuilder().append(url).append(contentWidth).append(contentHeight).toString() } ","excerpt":" Introdução Você pode registrar a forma como imagens remotas serão …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/beagleimagedownloader/","title":"BeagleImageDownloader"},{"body":" Introdução Você pode registrar estilos como fontes, cor, tamanho da fonte e componentes customizados com design system, que foi adicionado ao Beagle 1.0.0\nÉ com o design system que se armazena os componentes de estilo registrados, criado no frontend e então a sua aplicação Android saberá qual componente de estilo deverá ser aplicado em cada tela server-drive. É por meio dos elementos de elementos da view são usados para criar sua tela.\nPara definir o design system da sua aplicação, você deve criar a classe que estenda um Open class DesignSystem. Ela irá subscrever as funções que são usadas para aplicar os estilos aos componentes, e dentro de cada função, você pode declarar vários estilos.\nCada estilo mostrado com o Beagle deve ser referenciado de uma forma que, cada um deles tenha um nome a ser identificado.\nExemplo O método da imagem registrada em uma série de imagens que será usada para construir páginas vindas do backend. O operador when é usado para designar os estilos, o primeiro valor listado é uma string que identifica o estilo do componente do Beagle (muito similiar a key/value) e o estilo do componente que foi listado com uma Arrow Function -\u003e.\nO operador desta função else, irá conter o estilo padrão, como no código abaixo:\n// This class is used by the RenderEngine in order to define the styles configured at the application. // It must extend DesignSystem. // These are the styles the AppDesignSystem implements: image, textStyle, inputTextStyle, buttonStyle, toolbarStyle and tabViewStyle  @BeagleComponent class AppDesignSystem : DesignSystem() { override fun image(id: String): Int? { return when (name) { \"delete\" -\u003e android.R.drawable.ic_delete \"logo\" -\u003e android.R.drawable.ic_logo \"banner\" -\u003e android.R.drawable.ic_banner else -\u003e android.R.drawable.ic_menu_help } } override fun textStyle(id: String): Int? { return when (name) { \"TextBlackBold\" -\u003e R.style.TextBlackBold else -\u003e R.style.TextBlackBold } } override fun inputTextStyle(id: String): Int? { return R.style.TextBlack } override fun buttonStyle(id: String): Int? = R.style.ButtonBlack override fun toolbarStyle(id: String): Int? = R.style.Toolbar override fun tabViewStyle(id: String): Int? { return R.style.CustomTab } }  Quando uma classe estende oOpen Class DesignSystem , é possível gerenciar estilos que serão aplicados aos componentes server-driven. É necessário implementar a classe para registrar os estilos no Beagle, porque somente assim você poderá ver os estilos e aplicá-los.  Como um padrão Android, os estilos podem ser definidos no arquivo style e referenciados dentro da classe que entenda o Design System.\n\u003cresources\u003e \u003c!-- Base application theme. --\u003e \u003cstyle name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"\u003e \u003c!-- Customize your theme here. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAccent\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"TextBlackBold\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"TextBlack\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"ButtonBlack\" parent=\"Widget.AppCompat.Button\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e18sp\u003c/item\u003e \u003citem name=\"android:textAllCaps\"\u003efalse\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"Toolbar\" parent=\"Widget.AppCompat.Toolbar\"\u003e \u003citem name=\"android:background\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"navigationIcon\"\u003e?attr/homeAsUpIndicator\u003c/item\u003e \u003c/style\u003e \u003c/resources\u003e ","excerpt":" Introdução Você pode registrar estilos como fontes, cor, tamanho da …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/design-system/","title":"Design System"},{"body":" Introduction The DeepLinkHandler is an interface that sets how to configure the navigation between Server-Driven activities and native activities.\nExample Creating a DeepLinkHandler To make this configuration, you must create a class that implements the DeepLinkHandler interface, and that annotates it with @BeagleComponent, like listed below:\n@BeagleComponent class AppDeepLinkHandler : DeepLinkHandler { override fun getDeepLinkIntent( rootView: RootView, path: String, data: Map\u003cString, String\u003e?, shouldResetApplication: Boolean ) = Intent(\"openThisActivity\") } Once you made it, it’s necessary modify the Android manifest file:\n Step 1: You must add an intent filterat the activity you wish to navigate to. Step 2: You will add an action tag that will identify this activity. The id namewe used here is \"openThisActivity\" Step 3: Add an category tag and name it \"android.intent.category.DEFAULT\" , like the example below  //AndroidManifest \u003cactivity android:name=\".activities.DeepLinkActivity\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"openThisActivity\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e And that’s it. Now you just need to call the Navigate action with the method OpenNativeRoute like the example below:\n//Widget used to navigate to a native activity Button( text = \"Click to navigate!\", onPress = listOf( Navigate.OpenNativeRoute(\"openThisActivity\") ) ) ","excerpt":" Introduction The DeepLinkHandler is an interface that sets how to …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/deep-link-handler/","title":"Deep Link Handler"},{"body":"Serializador/Deserializador customizado Introdução O Beagle oferece um serializador/deserializador customizado por meio da Interface BeagleTypeAdapter. Com esse Adapter é possível mapear uma classe qualquer, inclusive as que representam tipos concretos, como um Integer.\nVeja abaixo o contrato definido da interface:\ninterface BeagleTypeAdapter\u003cT\u003e { fun fromJson(json: String) : T fun toJson(type: T) : String } Exemplo Neste exemplo cum adapter foi criado para a interface Person que é extendida a partir da data class PersonImpl que possui somente um atributo name do tipo String.\nPara criar um adapter você deve:\n Criar uma classe que será seu adapter e anotá-la com @RegisterBeagleAdapter.Neste exemplo o nome dado foi PersonAdapter Declarar qual classe se quer mapear com esse adapter. Aqui mapeamos a interface Person que representa a data class PersomImpl. Estender a classe adapter (PersonAdapter) a partir da Interface BeagleTypeAdapter informando a classe que você quer mapear; Ao estender a interface você deverá implementar os métodos fromJson e toJson, veja o exemplo abaixo:  interface Person data class PersonImpl(val name: String) : Person @RegisterBeagleAdapter class PersonAdapter : BeagleTypeAdapter\u003cPerson\u003e { override fun fromJson(json: String): Person { val rootObject = JSONObject(json) return PersonImpl(rootObject.getString(KEY)) } override fun toJson(type: Person): String { type as PersonImpl val rootObject = JSONObject() rootObject.put(KEY, type.name) return rootObject.toString() } } Método fromJson Esse método recebe um JSONObject como string e retorna uma instância da classe mapeada (Person).\nMétodo toJson Esse método recebe o tipo de dado mapeado (Person) e retorna um JSONObject como uma string.\n","excerpt":"Serializador/Deserializador customizado Introdução O Beagle oferece um …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/serializadordeserializador-customizado/","title":"Serializadordeserializador customizado"},{"body":" Introduction You can register styles as fonts, color, font size and customized components with design system, which was added on Beagle 1.0.0.\nIt is the design system that stores the style components registry created in the frontend and then your Android application will know which style component it must be applied in each server-driven screen. It is through it that views elements are used to create your screen.\nTo define a design system in your application, you have to create a class that extends an Open class DesignSystem. It will overwrite functions that are used to apply sytles to the components, inside each function you can declare several styles.\nEvery style displayed with Beagle must be referenced in a way each one of them has a name to be identified.\nExample The image method is registered in a series of images that will be used in the page construction coming from the backend. The operator when is used to designate the styles, the first listed value is a string that identifies the Beagle’s style component(very similiar to key/value) and the component’s style was listed with theArrow Function -\u003e.\nThis function’s operator else will contain a default style, like the code block below:\n// This class is used by the RenderEngine in order to define the styles configured at the application. // It must extend DesignSystem. // These are the styles the AppDesignSystem implements: image, textStyle, inputTextStyle, buttonStyle, toolbarStyle and tabViewStyle  @BeagleComponent class AppDesignSystem : DesignSystem() { override fun image(id: String): Int? { return when (name) { \"delete\" -\u003e android.R.drawable.ic_delete \"logo\" -\u003e android.R.drawable.ic_logo \"banner\" -\u003e android.R.drawable.ic_banner else -\u003e android.R.drawable.ic_menu_help } } override fun textStyle(id: String): Int? { return when (name) { \"TextBlackBold\" -\u003e R.style.TextBlackBold else -\u003e R.style.TextBlackBold } } override fun inputTextStyle(id: String): Int? { return R.style.TextBlack } override fun buttonStyle(id: String): Int? = R.style.ButtonBlack override fun toolbarStyle(id: String): Int? = R.style.Toolbar override fun tabViewStyle(id: String): Int? { return R.style.CustomTab } }  When a class extends theOpen Class DesignSystem it is able to manage styles that will be applied to the server driven components. It is necessary to implement a class to register the styles on Beagle, only this way it will be able to see the styles and apply them.  As an Android pattern, the styles can be defined in the style file and referenced inside a class that understands Design System.\n\u003cresources\u003e \u003c!-- Base application theme. --\u003e \u003cstyle name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"\u003e \u003c!-- Customize your theme here. --\u003e \u003citem name=\"colorPrimary\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"colorPrimaryDark\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"colorAccent\"\u003e@color/colorAccent\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"TextBlackBold\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"TextBlack\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"ButtonBlack\" parent=\"Widget.AppCompat.Button\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e18sp\u003c/item\u003e \u003citem name=\"android:textAllCaps\"\u003efalse\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"Toolbar\" parent=\"Widget.AppCompat.Toolbar\"\u003e \u003citem name=\"android:background\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"navigationIcon\"\u003e?attr/homeAsUpIndicator\u003c/item\u003e \u003c/style\u003e \u003c/resources\u003e ","excerpt":" Introduction You can register styles as fonts, color, font size and …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/design-system/","title":"Design System"},{"body":" Introdução O sistema de logs do Beagle permite que você investigue erros durante o desenvolvimento e problemas com o aplicativo em produção.\nAs mensagens de log fornecidas pelo Beagle Android podem ser acessadas pelo:\n Console do Android Studio Console da Aplicação  Elas são divididas em 3 categorias:\n Info: relacionada à camada Rede, informações e respostas da comunicação com o servidor. Warning: mensagens informativas de erros relacionados a componentes do Beagle. Error: exibe mensagens de erros relacionadas a parse, http e outras exceções.  É possível desabilitar as mensagens de logs disparadas. Dessa forma, o Beagle não irá mais chamar a API de Log, seja ela a padrão ou customizada. Você precisa passar o atributo isLoggingEnabled do AppBeagleConfig para false:\n@BeagleComponent class AppBeagleConfig : BeagleConfig { override val isLoggingEnabled: Boolean = false } Customização Para deixar o ambiente do Beagle aberto a modificações, a API de Logs padrão pode ser substituída por qualquer outra.\nA configuração dessa customização é feita com a criação de uma classe anotada com @BeagleComponent e que implemente a Interface BeagleLogger. Essa interface precisa da implementação dos métodos de logs, você pode seguir o exemplo abaixo:\n@BeagleComponent class CustomBeagleLog : BeagleLogger { override fun warning(message: String) { TODO(\"Not yet implemented\") } override fun error(message: String) { TODO(\"Not yet implemented\") } override fun error(message: String, throwable: Throwable) { TODO(\"Not yet implemented\") } override fun info(message: String) { TODO(\"Not yet implemented\") } } ","excerpt":" Introdução O sistema de logs do Beagle permite que você investigue …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/sistema-de-log/","title":"Sistema de Log"},{"body":" Introduction This class defines how the services requests are configured, to use it, you need to create a class that implements a HttpClient interface.\nYou can add headers to your requests, define method request, body response, data response, run cryptography, etc.\nCreating a HttpClient class To create this class, follow the next steps:\nStep 1: Add the dependencies Locate the file build.gradle(Module:app) , open it and scroll the page until you find the code block dependencies { }.\n  Copy and paste the line below inside the dependencies:\n implementation ‘com.squareup.okhttp3:okhttp:4.5.0’  __\n  Press Sync now to synchronize the Gradle again.\n  This dependency is necessary, because the class that implements HttpClient will import some of its configuration.\n  If your application uses Retrofit services, it is possible some conflict may occur, because it internally defines a okhttp dependency and then it will conflict with the HttpClient.\n  Replace this line:\nimplementation ‘com.squareup.okhttp3:okhttp:4.5.0’\n  For these two lines:\nimplementation ‘com.squareup.retrofit2:retrofit:2.7.2’\nimplementation ‘com.squareup.retrofit2:converter-gson:2.7.2\n   Step 2: Create a class  Create a class and choose a name for it. For the example,HttpClientDefault was chosen. If Android complain about imports, just check if the dependencies are not conflicting. This configuration is long, so copy and paste the class below. You may modify it later.  import br.com.zup.beagle.android.annotation.BeagleComponent import br.com.zup.beagle.android.exception.BeagleApiException import br.com.zup.beagle.android.networking.HttpClient import br.com.zup.beagle.android.networking.HttpMethod import br.com.zup.beagle.android.networking.RequestCall import br.com.zup.beagle.android.networking.RequestData import br.com.zup.beagle.android.networking.ResponseData import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Job import kotlinx.coroutines.cancel import kotlinx.coroutines.launch import java.io.EOFException import java.net.HttpURLConnection typealias OnSuccess = (responseData: ResponseData) -\u003e Unit typealias OnError = (responseData: ResponseData) -\u003e Unit @BeagleComponent class HttpClientDefault : HttpClient, CoroutineScope { private val job = Job() override val coroutineContext = job + CoroutineDispatchers.IO override fun execute( request: RequestData, onSuccess: OnSuccess, onError: OnError ): RequestCall { if (getOrDeleteOrHeadHasData(request)) { onError(ResponseData(-1, data = byteArrayOf())) return createRequestCall() } launch { try { val responseData = doHttpRequest(request) onSuccess(responseData) } catch (ex: BeagleApiException) { onError(ex.responseData) } } return createRequestCall() } private fun getOrDeleteOrHeadHasData(request: RequestData): Boolean { return (request.method == HttpMethod.GET || request.method == HttpMethod.DELETE || request.method == HttpMethod.HEAD) \u0026\u0026 request.body != null } @Throws(BeagleApiException::class) private fun doHttpRequest( request: RequestData ): ResponseData { val urlConnection: HttpURLConnection try { urlConnection = request.uri.toURL().openConnection() as HttpURLConnection } catch (e: Exception) { throw BeagleApiException(ResponseData(-1, data = byteArrayOf()), request) } request.headers.forEach { urlConnection.setRequestProperty(it.key, it.value) } addRequestMethod(urlConnection, request.method) if (request.body != null) { setRequestBody(urlConnection, request) } try { return createResponseData(urlConnection) } catch (e: Exception) { throw tryFormatException(urlConnection, request) } finally { urlConnection.disconnect() } } private fun tryFormatException(urlConnection: HttpURLConnection, request: RequestData): BeagleApiException { val response = urlConnection.getSafeError() ?: byteArrayOf() val statusCode = urlConnection.getSafeResponseCode() val statusText = urlConnection.getSafeResponseMessage() val responseData = ResponseData(statusCode = statusCode, data = response, statusText = statusText) return BeagleApiException(responseData, request) } private fun addRequestMethod(urlConnection: HttpURLConnection, method: HttpMethod) { val methodValue = method.toString() if (method == HttpMethod.PATCH || method == HttpMethod.HEAD) { urlConnection.setRequestProperty(\"X-HTTP-Method-Override\", methodValue) urlConnection.requestMethod = \"POST\" } else { urlConnection.requestMethod = methodValue } } private fun setRequestBody(urlConnection: HttpURLConnection, request: RequestData) { urlConnection.setRequestProperty(\"Content-Length\", request.body?.length.toString()) try { urlConnection.outputStream.write(request.body?.toByteArray()) } catch (e: Exception) { throw BeagleApiException(ResponseData(-1, data = byteArrayOf()), request) } } private fun createResponseData(urlConnection: HttpURLConnection): ResponseData { return ResponseData( statusCode = urlConnection.responseCode, statusText = urlConnection.responseMessage, headers = urlConnection.headerFields.filter { it.key != null }.map { val headerValue = it.value.toString() .replace(\"[\", \"\") .replace(\"]\", \"\") it.key to headerValue }.toMap(), data = try { urlConnection.inputStream.readBytes() } catch (e: EOFException) { byteArrayOf() } ) } private fun createRequestCall() = object : RequestCall { override fun cancel() { this@HttpClientDefault.cancel() } } } ","excerpt":" Introduction This class defines how the services requests are …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/network-client/","title":"Network Client"},{"body":" Este componente foi descontinuado na versão 1.1.0 e será removido em uma versão futura. Use SimpleForm em seu lugar  Introdução Um componente do tipo Validator é utilizado quando for necessário validar alguma informação em um formulário. Essa validação acontece através do método isValid, que é chamado sempre que são executados umFormSubmit ou um notifyChanges().\nAlém disso, esse Validator é listado no componente que recebe dados em um formulário, ao qual chamamos deFormInput.\nContexto do validador No Beagle, é possível usar o componente Form para capturar dados informados pelo usuário, validá-los e enviá-los ao BFF.\nEssa validação pode tanto ocorrer quando o usuário ativa o FormSubmit e/ou quando o usuário notifica que o estado de seu InputWidget(FormInput) mudou, como por exemplo, quando ditamos um texto ou quando o campo perde o foco.\nO Validator recebe dois parâmetros genéricos e possui um único método isValid que retorna um valor booleano.\ninterface Validator\u003cin I, in W\u003e { fun isValid(input: I, widget: W): Boolean }  input: Representa o valor que o inputWidget envia como informação (data) a ser validada. widget: Widget que referencia o InputWidget que enviou a informação (data).  Implementando um validador É possível implementar um validador quando, por exemplo, você tem um formulário que habilite o FormSubmit apenas nos casos em que o FormInput não estiver vazio. Quando isso acontece, o Form deve receber uma String com a entrada de dados e será validada se está vazia ou não.\n A classe que validará a informação está anotada com um @RegisterValidator Essa anotação registra esse validador no Beagle e o identifica pelo nome listado entre parênteses.  @RegisterValidator(\"text-is-not-blank\") class TextNotBlankValidator : Validator\u003cString, ServerDrivenComponent\u003e { override fun isValid(input: String, widget: ServerDrivenComponent): Boolean { return !input.isBlank() } }  Para enviar ao InputWidget essa validação, é necessário somente referenciar o nome dado na anotação acima \"text-is-not-blank\"no componente.  Siga o exemplo abaixo:\nFormInput( name = \"required-field\", required = true, validator = \"text-is-not-blank\", child = SampleTextField(placeholder = \"placeholder\") ) Já no exemplo a seguir, a implementação de um InputWidget irá executar o Validator chamando o método notifyChanges().\n@RegisterWidget class SampleTextField(private val placeholder: String) : InputWidget() { private lateinit var textFieldView: EditText override fun getValue() = textFieldView.text.toString() override fun onErrorMessage(message: String) { textFieldView.error = message } buildView(rootView: RootView) = EditText(rootView.getContext()).apply { textFieldView = this textFieldView.hint = placeholder textFieldView.isSingleLine = true doOnTextChanged { _, _, _, _ -\u003e notifyChanges() } } }  Se você deseja validar a informação conforme o usuário a digita, a sugestão é que você chame a funçãonotifyChanges() dentro da função doOnTextChange{}.  ","excerpt":" Este componente foi descontinuado na versão 1.1.0 e será removido em …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/validador-customizado/","title":"Validador customizado"},{"body":" Introduction It is possible to watch the screen’s current state during server-driven requests in a BeagleActivity, including error states.\nExample To display a server-driven screen, it is possible to overwrite the onServerDrivenContainerStateChange() method to implement its handles to each screen state.\nSee below a BeagleActivity example with the overwritten onServerDrivenContainerStateChange() method:\n@BeagleComponent class AppBeagleActivity : BeagleActivity() { private val progressBar: ProgressBar by lazy { findViewById\u003cProgressBar\u003e(R.id.progress_bar) } private val mToolbar: Toolbar by lazy { findViewById\u003cToolbar\u003e(R.id.custom_toolbar) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_app_beagle) } override fun getServerDrivenContainerId(): Int = R.id.server_driven_container override fun getToolbar(): Toolbar = mToolbar override fun onServerDrivenContainerStateChanged(state: ServerDrivenState) { when (state) { is ServerDrivenState.Started -\u003e { progressBar.visibility = View.VISIBLE } is ServerDrivenState.Finished -\u003e { progressBar.visibility = View.GONE } is ServerDrivenState.Error -\u003e { Toast.makeText(this, \"Error\", Toast.LENGTH_LONG).show() } } } } On the loadView, you can also see that these states shows the loadView implementation, it is possible to define when to show or to hide Load. And you can also define other action to the states ServerDrivenState, that areStarted, Success , Finished and Error\nsealed class ServerDrivenState { object Started : ServerDrivenState() object Finished : ServerDrivenState() object Success : ServerDrivenState() open class Error( val throwable: Throwable, val retry: BeagleRetry ) : ServerDrivenState() } See more details about each state:\n Started: Indicates that a server-driven component fetch has begun. Finished: Indicates that a server-driven component fetch has finished. Success: Indicates a success state while fetching a server-driven component. Error: Indicates an error state while fetching a server-driven component.  ","excerpt":" Introduction It is possible to watch the screen’s current state …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/loading-and-errors-treatment/","title":"Loading and errors treatment"},{"body":" Introdução O Beagle já fornece alguns widgets básicos prontos que você pode utilizar para criar a interface dos componentes de sua aplicação server-driven.\nNo entanto, a sua aplicação pode precisar de componentes mais especializados (Custom Views) e, para torná-los “visíveis” ao Beagle, você precisa criar um widget específico para ele. Dessa forma, você pode criar quantos novos componentes desejar, desde que sempre torne as Views do seu aplicativo “visíveis” para o Beagle.\nÉ obrigatória a adição da tag @Transient para todos os atributos presentes nas classes que representarão os widgets para que não sejam levados em conta na serialização e desserialização do componente.  ","excerpt":" Introdução O Beagle já fornece alguns widgets básicos prontos que …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/widgets-customizados/","title":"Widgets customizados"},{"body":" Introduction Beagle’s log system allows you to investigate errors during the development and problems that may happen with the application’s production.\nThe log messages given by Android Beagle can be accessed in the:\n Android Studio’s console Application’s console  They are divided in 3 categories:\n Info: related to the Network layer, information and communication’s response with the server. Warning: informational messages of errors related to Beagle’s component. Error: shows error messages related to parse, http and other exceptions.  It is possible to disable triggered log messages. Beagle will not call the Log’s API, even if it is a pattern or customized. You will need to change the attribute isLoggingEnabled ofAppBeagleConfig tofalse:\n@BeagleComponent class AppBeagleConfig : BeagleConfig { override val isLoggingEnabled: Boolean = false } Customization In order to let Beagle’s environment open to modifications, the API logs pattern can be replaced to any other.\nThe configuration of this customization it is done with the creation of an annotation class with @BeagleComponent and that implements the BeagleLogger Interface. This interface needs logs method implementation, you can follow the example below:\n@BeagleComponent class CustomBeagleLog : BeagleLogger { override fun warning(message: String) { TODO(\"Not yet implemented\") } override fun error(message: String) { TODO(\"Not yet implemented\") } override fun error(message: String, throwable: Throwable) { TODO(\"Not yet implemented\") } override fun info(message: String) { TODO(\"Not yet implemented\") } } ","excerpt":" Introduction Beagle’s log system allows you to investigate errors …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/log-system/","title":"Log System"},{"body":" Como criar componentes (custom views) e widgets? No exemplo abaixo, será implementado um custom widget e o componente que ele registrará. Esse componente será composto por um texto e dois botões dentro de um layout linear.\nOs botões neste componente serão responsáveis ​​por aumentar e diminuir o tamanho do texto do título e a tela será como a imagem a seguir:\nVocê pode fazer isso usando a anotação @RegisterWidget e estendendo a classe WidgetView .  Criando um componente e um widget Siga os passos abaixo para criar e customizar um componente e um widget:\nPasso 1: Criar o widget Para criar um widget:\n Crie uma classe e a nomeie\"CustomWidgetTitleIncrease\" Aplique a anotação@RegisterWidget a esta classe; Estenda essa classe utilizando a interface WidgetView A classe agora requisitará que você implemente o método buildView . Nesse momento, deixe a classe como listada abaixo, pois a configuração desse método será finalizada depois.  CustomWidgetTitleIncrease.kt @RegisterWidget class CustomWidgetTitleIncrease: WidgetView() { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 2: Criar e configurar o componente Comece criando um arquivo de configuração.XMLe copie e cole o conteúdo abaixo, pois ela cria o layout que escolhemos para esse exemplo.\ntitle_increase_component_layout.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:orientation=\"vertical\"\u003e \u003cTextView android:id=\"@+id/tv_example_title\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:padding=\"20dp\" android:text=\"Example\" /\u003e \u003cLinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center\"\u003e \u003cButton android:id=\"@+id/bt_increase\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:text=\"B1\" /\u003e \u003cButton android:id=\"@+id/bt_decrease\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"5dp\" android:text=\"B2\" /\u003e \u003c/LinearLayout\u003e \u003c/LinearLayout\u003e Agora, é hora de criar o componente:\n Crie uma classe e a nomeie: TitleIncreaseComponent. É nessa classe que ficará registrado como o componente funciona e a regra de negócio dele. Lembrando que a regra de negocio desse componente é unicamente aumentar e dimunir o tamanho do seu Título. Copie e cole a classe abaixo:  class TitleIncreaseComponent(context: Context) : LinearLayout(context) { init { View.inflate(context, R.layout.title_increase_component_layout, this) changeTitleSize() } fun setTitleText(title: String) { tv_example_title.text = title } fun setTitleButton1(titleButton: String) { bt_increase.text = titleButton } fun setTitleButton2(titleButton: String) { bt_decrease.text = titleButton } private fun changeTitleSize() { var size = tv_example_title.textSize tv_example_title.textSize = size Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() bt_increase.setOnClickListener { if (size \u003c 50) { size += 5f tv_example_title.textSize = size } Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() } bt_decrease.setOnClickListener { if (size \u003e 5) { size -= 5f tv_example_title.textSize = size } Toast.makeText(context, size.toString(), Toast.LENGTH_SHORT).show() } } } Passo 3: Configurar o Widget O layout e o componente estão definidos, é preciso terminar a configuração do Widget customizado:\nAnalise a função abaixo e observe que algumas variáveis de texto foram adicionadas. Essa prática foi escolhida para demonstrar que é possível definir o valor dessas variáveis pelo Widget, colocando o título e o nome dos botões.\nCustomWidgetTitleIncrease.kt @RegisterWidget class CustomWidgetTitleIncrease( private val title: String, private val buttonTitle1: String, private val buttonTitle2: String ) : WidgetView() { override fun buildView(rootView: RootView) = TitleIncreaseComponent(rootView.getContext()).apply { setTitleText(title) setTitleButton1(buttonTitle1) setTitleButton2(buttonTitle2) } } Passo 4: Exibir o componente Agora o Widget customizado está pronto, o componente pode ser exibido.\nPara testar o componente, utilize o método abaixo:\n Perceba que o widget passa alguns parâmetros para o componente, como o “Título” do componente e o título dos botões. O método buildView foi implementado dentro do widget que customizamos  MainActivity.kt import br.com.zup.beagle.android.utils.toView class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val customWidget = CustomWidgetTitleIncrease( \"Example Title\", \"Increase\", \"Decrease\" ) setContentView(customWidget.toView(this)) } }  Execute a aplicação e seu componente customizado (nesse caso uma tela) será exibido:  ","excerpt":" Como criar componentes (custom views) e widgets? No exemplo abaixo, …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/widgets-customizados/widget-customizado-simples/","title":"Widget Customizado Simples"},{"body":" Introduction Beagle has a screen navigation tool that allows you to configure actions like navigate to a new screen or close one.\nBesides these configuration, you can also customize the navigation of your application.\nThere are two customization options:\n According to Android’s animation pattern. Fragments transition provided by Beagle, that it can be customized according to your preference and design system. They are:   PushView PopView PopToView  Protocol and customized Beagle’s pattern protocol for customization is to use a native Android tool, to make fragment transition to customize your animation.\nFor more information on how this process works, check out the Android’s section setCustomAnimations.  The other way to customize an animation it is the transition through the BeagleActivity class implementation, which Beagle uses the getFragmentTransitionAnimation() method.\nIn case this method it isn’t implemented and customized, the transitions will follow the Beagle’s animation pattern. The code below shows the BeagleActivity method, that can be overwritten this way:\nopen fun getFragmentTransitionAnimation() = FragmentTransitionAnimation( enter = R.anim.slide_from_right, exit = R.anim.none_animation, popEnter = R.anim.none_animation, popExit = R.anim.slide_to_right ) \u0000Beagle’s animation pattern are:\n Enter transition (enter) to the new screen that appears on the right side of the application. Stack exit animation (popExit), the screen also go to the right side.  The code above showed that to overwrite the customization method you only need to send a data class instance FragmentTransitionAnimation as a result, like below:\ndata class FragmentTransitionAnimation( @AnimatorRes @AnimRes val enter: Int, @AnimatorRes @AnimRes val exit: Int, @AnimatorRes @AnimRes val popEnter: Int, @AnimatorRes @AnimRes val popExit: Int )  To contextualize this class has four attributes, they are:\n enter exit popEnter popExit  And all of them are described in the setCustomAnimations documentation.\n After you have overwritten the getFragmentTransitionAnimation() method in the BeagleActivity implementation, your screens transitions and Beagle’s fragments will follow its own animation.\nExample The example below is about screens that comes in and out with a vertical animation. To make this configuration, follow the steps:\nStep 1: Create a folder with anim name on the res file of your Android application. This will be the place where the animation will be stored.\n\u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003ctranslate android:duration=\"@android:integer/config_longAnimTime\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:fromYDelta=\"100%\" android:toYDelta=\"0%\"/\u003e \u003c/set\u003e If you follow the code bellow, you will indicate Beagle that the animation must rise from the minimum vertical point to the maximum point, completing the whole application screen. This animation will be used in the enter transitions.\nStep 2: It is time to configure the exit animation. You will make a configuration on it in order that it will behave like the opposite of the input animation, scrolling the whole screen. To make this, just copy this code below:\n\u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003ctranslate android:duration=\"@android:integer/config_longAnimTime\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:fromYDelta=\"0%\" android:toYDelta=\"100%\"/\u003e \u003c/set\u003e Step 3: After creating the animations, you can use the overwritten to thegetFragmentTransition() method on your BeagleActivity implementation, that will be like the example below:\noverride fun getFragmentTransitionAnimation() = FragmentTransitionAnimation( enter = R.anim.slide_from_bottom, exit = R.anim.slide_to_bottom, popEnter = R.anim.slide_from_bottom, popExit = R.anim.slide_to_bottom )  \u0000Done! Beagle now can use the new transition animation!  It is important to mention, only two animation were created, one of them used to animate the enter and popEnter transitions. However, you can create more, one for each or one for all.\n","excerpt":" Introduction Beagle has a screen navigation tool that allows you to …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/navigation-animation/","title":"Navigation Animation"},{"body":" Atualmente no Beagle, os componentes Container e ListView possuem o comportamento de executar uma lista de ações assim que são renderizados. Para isso, eles expõe a propriedade onInit, a qual recebe a lista de ações que serão disparadas.\nPara criar um widget customizado com o comportamento de disparar uma lista de ações assim que for renderizado, o Beagle fornece uma forma fácil de fazer utilizando o pattern delegate através da implementação da interface OnInitiableComponent.\nPara esse passo-a-passo vamos focar na vinculação do OnInitiableComponent ao widget customizável, já que a criação dele em detalhes já foi mostrada no exemplo anterior.  Passo 1: Vincular OnInitiableComponent Com o widget customizável criado, adicione a interface OninitiableComponent.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int ): WidgetView(), OnInitiableComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 2: Implementar propriedade onInit Após adicionar a interface OnInitiableComponent ao widget, sobrescreva a propriedade onInit.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 3: Delegar implementação Além da propriedade onInit, a interface OnInitiableComponent precisa da implementação dos métodos handleOnInit e markToRerunOnInit. Para facilitar e manter o padrão de comportamento do componente, o Beagle já fornece uma implementação pronta e recomendamos o seu uso, bastando somente delegar OnInitiableComponentImpl.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent by OnInitiableComponentImpl(onInit) { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 4: Executar handleOnInit Por fim, com toda a configuração feita no widget, falta somente a execução do método handleOnInit para que a lista de ações onInit sejam executadas assim que a view for renderizada.\n@RegisterWidget class CustomInitiableWidget( val name: String, val phone: String, val age: Int, override val onInit: List\u003cAction\u003e? ): WidgetView(), OnInitiableComponent by OnInitiableComponentImpl(onInit) { override fun buildView(rootView: RootView): View { handleOnInit(rootView, view) } } Pronto! Seu componente agora executa uma lista de ações sempre que for renderizado!\nÉ obrigatório a implementação da interface OnInitiableCompoent para todo widget customizado que for inserido dentro do componente ListView.  ","excerpt":" Atualmente no Beagle, os componentes Container e ListView possuem o …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/widgets-customizados/widget-customizado-com-oninit/","title":"Widget Customizado com Oninit"},{"body":"Serializer / Deserializer Introduction Beagle offers a customized serializer/deserializer set through a BeagleTypeAdapter interface. With this Adapter it is possible to map any class, including classes that represent concrete types, such as an Integer. Below, you can see our interface contract.\nSee below the defined interface contract:\ninterface BeagleTypeAdapter\u003cT\u003e { fun fromJson(json: String) : T fun toJson(type: T) : String } Example This example creates an adapter for the Person interface that is extended from the data class PersonImpl that has only a name attribute as a String type.\nIn order to create an adapter you must:\n Create a class that will be your adapter and annotate it with a@ RegisterBeagleAdapter. In this example we named this class as PersonAdapter ; Declare which class you want to map with this adapter. Here we implemented a PersonImpl data class as an example.; Extend the adapter (PersonAdapter) class from the BeagleTypeAdapter Interface, informing the class to be mapped on; When extending the interface you must implement the fromJson and toJson methods, see the example below:  interface Person data class PersonImpl(val name: String) : Person @RegisterBeagleAdapter class PersonAdapter : BeagleTypeAdapter\u003cPerson\u003e { override fun fromJson(json: String): Person { val rootObject = JSONObject(json) return PersonImpl(rootObject.getString(KEY)) } override fun toJson(type: Person): String { type as PersonImpl val rootObject = JSONObject() rootObject.put(KEY, type.name) return rootObject.toString() } } FromJson method This method takes a JSONObject as a string and returns an instance of the mapped class (Person).\nToJson method This method takes the mapped data type (Person) and returns a JSONObject as a string.\n","excerpt":"Serializer / Deserializer Introduction Beagle offers a customized …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/serializer-deserializer/","title":"Serializer  Deserializer"},{"body":" Para criar um widget customizado que utilize outros componentes do Beagle, basta implementar a interface SingleChildComponent quando houver somente um componente filho, ou MultiChildComponent para o widget que utilizar varios outros componentes.\nUm componente deve implementar somente uma dessas interfaces, ou SingleChildComponent, ou MultiChildComponent, nunca as duas ao mesmo tempo.  SingleChildComponent Widgets customizados que renderizem um unico componente do Beagle devem implementar a interface SingleChildComponent.\nPasso 1: Vincular SingleChildComponent Com o widget customizado criado, adicione a interface SingleChildComponent.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 2: Implementar a propriedade child Após adicionar a interface SingleChildComponent ao widget, sobrescreva a propriedade child.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val child: ServerDrivenComponent ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 3: Utilize o componente Para usar a view gerada a partir do componente child, basta considera-lo como um ViewConvertable e chamar o método buildView.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val child: ServerDrivenComponent ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { val builtChild = (child as ViewConvertable).buildView(rootView) } } MultiChildComponent Widgets customizados que renderizem um ou mais componentes do Beagle devem implementar a interface MultiChildComponent.\nPasso 1: Vincular MultiChildComponent Com o widget customizado criado, adicione a interface MultiChildComponent.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int ): WidgetView(), MultiChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 2: Implementar a propriedade children Após adicionar a interface MultiChildComponent ao widget, sobrescreva a propriedade children.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val children: List\u003cServerDrivenComponent\u003e ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { TODO(\"Not yet implemented\") } } Passo 3: Utilize o componente Para usar a view gerada a partir do componente children, basta considerar cada um como ViewConvertable e chamar o método buildView de cada.\n@RegisterWidget class CustomChildWidget( val name: String, val phone: String, val age: Int, override val children: List\u003cServerDrivenComponent\u003e ): WidgetView(), SingleChildComponent { override fun buildView(rootView: RootView): View { children.forEach { child -\u003e val builtChild = (child as ViewConvertable).buildView(rootView) } } } Pronto! Seu componente agora utiliza outros componentes do Beagle!\nÉ obrigatório a implementação de uma das duas interfaces para todo widget customizado que utilizar componentes do Beagle dentro do componente ListView.  ","excerpt":" Para criar um widget customizado que utilize outros componentes do …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-android/widgets-customizados/widget-customizado-com-serverdrivencomponent/","title":"Widget Customizado com Serverdrivencomponent"},{"body":" Introduction When a obfuscation method is used, it is necessary that some rules are implemented to make sure the IDs internally used in Beagle are not obfuscated or minimized.\nExample To make sure it happes, you have to add the following rules to the Proguard file android-rules.pro.\nproguard-rules.pro # Beagle uses coroutines in network requests -keep class kotlinx.coroutines.experimental.android.AndroidExceptionPreHandler { *; } # Beagle does reflection on generic parameters -keepattributes Signature, InnerClasses, EnclosingMethod # Beagle does reflection on method and parameter annotations -keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations -dontwarn org.jetbrains.annotations.** -keep class kotlin.Metadata { *; } # Yoga is a dependency used on Beagle -keep @com.facebook.proguard.annotations.DoNotStrip class * { *; } # Customized classes for Beagle -keep @br.com.zup.beagle.annotation.** class * { *; } -keep @br.com.zup.beagle.android.annotation.** class * { *; } -keep class * extends br.com.zup.beagle.android.widget.** # Core classes in Beagle -keep class br.com.zup.beagle.android.action.** { *; } -keep class br.com.zup.beagle.android.widget.** { *; } -keep class br.com.zup.beagle.android.components.** { *; } -keep class br.com.zup.beagle.android.context.** { *; } -keep class br.com.zup.beagle.widget.** { *; } -keep class br.com.zup.beagle.core.** { *; } -keep class br.com.zup.beagle.analytics.** { *; }  You also have to enableminifyEnable andshrinkResources onbuildType declaring them as true to test the ProGuard obfuscation.  You must activate ProGuard in your IDE, to test it, you can use Android Studio, just add the listed configuration below:\nbuildTypes { release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile( 'proguard-android-optimize.txt'), 'proguard-rules.pro' } } ","excerpt":" Introduction When a obfuscation method is used, it is necessary that …","ref":"/docs-beagle/docs/resources/customization/beagle-for-android/proguard-configuration/","title":"Proguard configuration"},{"body":" These are Beagle for iOS classes:\n","excerpt":" These are Beagle for iOS classes:\n","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/","title":"Beagle for ios"},{"body":" O Beagle para iOS possui estas principais classes:\n","excerpt":" O Beagle para iOS possui estas principais classes:\n","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/","title":"Beagle para ios"},{"body":" Introdução Uma action é um bloco de código que pode ser executado quando definido em algum evento. O Beagle já possui algumas por padrão, mas é possível criar sua action personalizada.\nExemplo Como criar uma custom action? Para criar uma custom action, siga os seguintes passos:\n Crie uma classe que implemente a interface Action;  struct CustomAction: Action { func execute( controller: BeagleController, origin: UIView) { print(\"Custom action foi chamada!\") } }  Depois disso, a interface solicitará que o método execute seja implementado. É nesse método que deve ser implementado o bloco de código que sua ação irá executar;\n  Agora, é necessário registrar essa nova ação nas dependências do Beagle:\n  let dependencies = BeagleDependencies() dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\" ) Beagle.dependencies = dependencies Como usar? Veja abaixo um exemplo de como usar um botão que executa a ação customizada no evento de clique:\nButton( text: \"do request\", onPress: [ CustomAction() ] ) ","excerpt":" Introdução Uma action é um bloco de código que pode ser executado …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/a%C3%A7%C3%B5es-customizadas/","title":"Ações customizadas"},{"body":" Introduction Your application can change Beagle’s default behaviour with the properties customization of the Beagle.dependencies instantiation.\nThey have a specific role in Beagle’s capacity, this is the reason you have to deal Beagle.dependencies as the main focus on your customization, so that other parts of your application are able to see the changes you made in the dependencies.\nYou must trust in the pattern implementation, like the example below:\nclass BeagleDependencies: BeagleDependenciesProtocol { var urlBuilder: UrlBuilderProtocol var networkClient: NetworkClient var decoder: ComponentDecoding var appBundle: Bundle var theme: Theme var validatorProvider: ValidatorProvider? var deepLinkHandler: DeepLinkScreenManaging? var localFormHandler: LocalFormHandler? var repository: Repository var analytics: Analytics? var navigation: BeagleNavigation var preFetchHelper: BeaglePrefetchHelping var cacheManager: CacheManagerProtocol? var formDataStoreHandler: FormDataStoreHandling var windowManager: WindowManager var opener: URLOpener var globalContext: GlobalContext var isLoggingEnabled: Bool var logger: BeagleLoggerType } The Beagle’s dependencies must be register in the AppDelegate, see the example below:\n@UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool { let dependencies = BeagleDependencies() dependencies.theme = AppTheme.theme dependencies.urlBuilder = UrlBuilder(baseUrl: URL(string: .baseURL)) dependencies.navigation.defaultAnimation = .init( pushTransition: .init( type: .fade, subtype: .fromRight, duration: 0.1 ), modalPresentationStyle: .formSheet ) dependencies.isLoggingEnabled = true dependencies.decoder.register( component: CustomComponent.self, named: \"CustomComponent\" ) dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\") Beagle.dependencies = dependencies let rootViewController = MainScreen().screenController() window?.rootViewController = rootViewController return true } } UrlBuilder It configures the base URL to your application, it’s used when the navigation flow via Beagle are defined, you can use a relative URL.\nSee how to use it below:\ndependencies.urlBuilder = UrlBuilder(baseUrl: URL(string: \"YOUR BASE URL NetworkClient It can run network requests. Your application must be customized here, because every project has a specific network layer. For that, the pattern implementation cannot work on your project.\nDecoder It transforms a JSON into Beagle’s Component (Elements Section). It already has a logic to decode all the default components. If you have to work with customized components, you can register them in this instance.\nSee below how to register a component and a customized action:\nBeagle.dependencies.decoder.register( component: CustomWidget.self, named: \"CustomWidget\" ) Beagle.dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\" ) AppBundle You can provide a package for your application in a way Beagle can access your resources, for example, images, fonts, colors, etc.\nTheme It stores all your styles and it knows how to apply them in your components. Some widgets have a variable that allows you to define the style. Each name must be passed on the dependency of theme, so that style may be used in your component.\nTo configure the customized styles, follow the next steps:\nYou will use text as a widget that has UITextView as your UIKit view. After that, you will apply your style changes to this view which will have font and textColor customization.  Step 1: create a function that it will receive a UIKit widget representation of what you want to apply to the style.\nstatic func blackTextNormalStyle() -\u003e (UITextView?) -\u003e Void { return { $0?.font = .systemFont(ofSize: 16) $0?.textColor = .black } } Passo 2: create a concrete instance of AppTheme with the names of yout style and its functions.\nlet theme = AppTheme(styles: [ \"myStyleName\": blackTextNormalStyle ]) Passo 3: assign your Theme instance to Beagle’s dependencies.\nBeagle.dependencies.theme = theme Passo 4: now, you can use Text with your style properties and then configure the name your defined for your customized style.\nText(\"Some text\", style: \"myStyleName\") ValidatorProvider Validates the customization that it will be made when the Form widget will be used.\nDeepLinkHandler This handler is used for adeep link navigation action. The variable has a default value, you can add new screens or replace for other in the application.\nYou will find how to add a screen with a possible deep linking routing using a default value below:\nlet deepLinkHandler = DeeplinkScreenManager.shared deepLinkHandler[\"MyDeepLinkScreen\"] = MyDeepLinkScreenClass.self Beagle.dependenciesdeepLinkHandler = deepLinkHandler LocalFormHandler Your application can deal with form being send by the user using FormLocalAction.\nLocalFormHandler defined on Beagle’s dependencies will be used to run this.\nRepository It is responsible for three main operations on:\n fetchComponent: orchestrate the request to search widgets on the server. submitForm: submit forms on widget. fetchImage: search images for networkImage.  Analytics It is a protocol that can be implemented to track the appearence of the screen or its closing or a click event.\nSee the example below:\nclass AnalyticsSample: Analytics { func trackEventOnScreenAppeared(_ event: AnalyticsScreen) { print(\"Screen \\(event.screenName)appeared\") } func trackEventOnScreenDisappeared(_ event: AnalyticsScreen) { print(\"Screen \\(event.screenName)disappeared\") } func trackEventOnClick(_ event: AnalyticsClick) { print(\"Button touch with:\\ncategory = \\(event.category)\\nlabel = \\(event.label ?? \"empty\")\\nvalue = \\(event.value ?? \"empty\")\") } } Navigation navigation deals with the navigate types of action in your application. There is one implementation that it is used with default value, but that it can be replaced for a BeagleNavigation class.\nOn this same attribute is also possible to define a navigation animation.\npreFetchHelper This component is used to search BeagleScreenViewControllers and delivers a fluid experience to the user. It already has a value, it can be altered to fit what you need.\nThe pre search is used when there is a navigataion widget in a way you can download all the data possible in the next screen, avoiding navigation delays. This behaviour can be deactivated.\nCacheManager It is responsible to keep and manage the server-driven content cache of your application.\nFormDataStoreHandler It is a way to persist the form data.\nWindowManager It is responsible to manage a window.\nOpener It is a protocol that has a method and opens an URL in case you need to navigate through an external link.\nGlobalContext Variable that defines a global scope context.\nIsLoggingEnabled It is a boolean variable that enables or disable the logs, it comes already enabled by a pattern.\nLogger Logger is a variable type BeagleLoggerType that organizes the application’s logs. These logs follow a LogType protocol, which there are parameters:\n category: log’s matter; message: log’s message; level: ranks the critical level.  It is possible to create a customized logger, which it has the application’s specifics categories.  ","excerpt":" Introduction Your application can change Beagle’s default behaviour …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/beagles-dependencies/","title":"Beagle's dependencies"},{"body":" Introdução No protocolo BeagleNavigation temos uma variável defaultAnimation que permite que você mude as animações de transição da sua aplicação, e também outra função que lida com os tipos de ações navigate e define os seus comportamentos.\nSugerimos que você use a implementação default, mas se necessário, é permitido que essa implementação seja substituída por uma classe que está de acordo com o protocolo acima.\nProtocolo e customização No protocolo da BeagleNavigation temos uma variável defaultAnimation que determina como a animação de uma tela acontece quando ela é apresentada.\nÉ permitido que as transições de Push e Pop de uma View Controller sejam alteradas usando as variáveis pushTransition e popTransition. É possível também mudar o modalPresentationStyle e modalTransitionStyle de uma view usando as variáveis abaixo:\npublic struct BeagleNavigatorAnimation { var pushTransition: Transition? var popTransition: Transition? var modalPresentationStyle: UIModalPresentationStyle? var modalTransitionStyle: UIModalTransitionStyle } Na estrutura abaixo, proporcionamos os tipos de CATransition , onde você pode fazer uma transição de estados de uma layer criando e adicionando um objecto de CATransition.\npublic struct Transition { var type: CATransitionType var subtype: CATransitionSubtype? var duration: Double } Exemplo Veja o exemplo abaixo onde o default das transições de pushTransition e modalPresentationStyle foi modificado:\nlet animation = BeagleNavigatorAnimation( pushTransition: .init( type: .fade, subtype: .fromRight, duration: 1.0), modalPresentationStyle: .formSheet) let dependencies = BeagleDependencies() dependencies.navigation.defaultAnimation = animation  Esta configuração se aplica a todas as navegações da sua aplicação.  ","excerpt":" Introdução No protocolo BeagleNavigation temos uma variável …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/anima%C3%A7%C3%B5es-de-navega%C3%A7%C3%A3o/","title":"Animações de navegação"},{"body":" Introduction Beagle View is an UIView that must be used when it is necessary to add a Beagle’s component in a native screen that has other views and use AutoLayout.\nUsing a Beagle View Creating an AutoLayout Check out below a native layout that can be used as an example of AutoLayout use with Beagle:\nstruct AutoLayoutComponent: ServerDrivenComponent { var widgetProperties: WidgetProperties = WidgetProperties() func toView(renderer: BeagleRenderer) -\u003e UIView { return AutoLayoutWrapper(view: AutoLayoutSample()) } } class AutoLayoutSample: UIView { let constraintView: UIView let heightConstraint: NSLayoutConstraint override init(frame: CGRect) { let view = UIView() self.constraintView = view self.heightConstraint = view.heightAnchor.constraint(equalToConstant: 100) super.init(frame: frame) backgroundColor = .yellow layer.borderWidth = 1 layer.borderColor = UIColor.black.cgColor view.backgroundColor = .cyan addSubview(view) translatesAutoresizingMaskIntoConstraints = false let label = UILabel() label.text = \"AUTO\" addSubview(label) label.translatesAutoresizingMaskIntoConstraints = false label.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 5).isActive = true label.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -5).isActive = true label.topAnchor.constraint(equalTo: topAnchor, constant: 5).isActive = true view.translatesAutoresizingMaskIntoConstraints = false view.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 5).isActive = true view.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -5).isActive = true view.topAnchor.constraint(equalTo: label.bottomAnchor, constant: 5).isActive = true view.widthAnchor.constraint(equalToConstant: 50).isActive = true heightConstraint.isActive = true } required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } Creating a BeagleView A BeagleView can be created with like an UIView. Check out below an example of a ViewController with a container that has a text and a button:\nclass CustomViewController: UIViewController { private lazy var beagleView = BeagleView( Container( widgetProperties: WidgetProperties( id: \"container\", style: Style().backgroundColor(\"#D3D3D3\") .margin(EdgeValue(all: 5)) .padding(EdgeValue(all: 5)) .flex(Flex().flexWrap(.wrap))) ) { Text(\"YOGA\") Button( text: \"ADD\", onPress: [AddChildren(componentId: \"container\", value: [AutoLayoutComponent()])] ) AutoLayoutComponent() } ) override func viewDidLoad() { super.viewDidLoad() navigationItem.title = \"BeagleView\" setupView() } private func setupView() { view.backgroundColor = .white let margin = view.layoutMarginsGuide view.addSubview(beagleView) beagleView.translatesAutoresizingMaskIntoConstraints = false beagleView.topAnchor.constraint(equalTo: margin.topAnchor).isActive = true beagleView.leadingAnchor.constraint(equalTo: margin.leadingAnchor).isActive = true beagleView.trailingAnchor.constraint(lessThanOrEqualTo: margin.trailingAnchor).isActive = true beagleView.bottomAnchor.constraint(lessThanOrEqualTo: margin.bottomAnchor).isActive = true } } Notice that the onPress of the button is calls the AddChildren method that adds the native layout, which means that every time the button is pressed, it adds a view with native layout.\n","excerpt":" Introduction Beagle View is an UIView that must be used when it is …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/beagle-view/","title":"Beagle View"},{"body":" Introdução Beagle View é uma UIView que deve ser usada quando é necessário adicionar um componente do Beagle em uma tela nativa que possui outras views e usam AutoLayout.\nUsando uma Beagle View Criando um AutoLayout Segue abaixo um layout nativo que será usado para exemplificar o uso do AutoLayout junto com o Beagle:\nstruct AutoLayoutComponent: ServerDrivenComponent { var widgetProperties: WidgetProperties = WidgetProperties() func toView(renderer: BeagleRenderer) -\u003e UIView { return AutoLayoutWrapper(view: AutoLayoutSample()) } } class AutoLayoutSample: UIView { let constraintView: UIView let heightConstraint: NSLayoutConstraint override init(frame: CGRect) { let view = UIView() self.constraintView = view self.heightConstraint = view.heightAnchor.constraint(equalToConstant: 100) super.init(frame: frame) backgroundColor = .yellow layer.borderWidth = 1 layer.borderColor = UIColor.black.cgColor view.backgroundColor = .cyan addSubview(view) translatesAutoresizingMaskIntoConstraints = false let label = UILabel() label.text = \"AUTO\" addSubview(label) label.translatesAutoresizingMaskIntoConstraints = false label.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 5).isActive = true label.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -5).isActive = true label.topAnchor.constraint(equalTo: topAnchor, constant: 5).isActive = true view.translatesAutoresizingMaskIntoConstraints = false view.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 5).isActive = true view.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -5).isActive = true view.topAnchor.constraint(equalTo: label.bottomAnchor, constant: 5).isActive = true view.widthAnchor.constraint(equalToConstant: 50).isActive = true heightConstraint.isActive = true } required init?(coder: NSCoder) { fatalError(\"init(coder:) has not been implemented\") } } Criando uma BeagleView Uma BeagleView pode ser criada como uma UIView. Segue um exemplo abaixo de uma ViewController com um container que possui um texto e um botão:\nclass CustomViewController: UIViewController { private lazy var beagleView = BeagleView( Container( widgetProperties: WidgetProperties( id: \"container\", style: Style().backgroundColor(\"#D3D3D3\") .margin(EdgeValue(all: 5)) .padding(EdgeValue(all: 5)) .flex(Flex().flexWrap(.wrap))) ) { Text(\"YOGA\") Button( text: \"ADD\", onPress: [AddChildren(componentId: \"container\", value: [AutoLayoutComponent()])] ) AutoLayoutComponent() } ) override func viewDidLoad() { super.viewDidLoad() navigationItem.title = \"BeagleView\" setupView() } private func setupView() { view.backgroundColor = .white let margin = view.layoutMarginsGuide view.addSubview(beagleView) beagleView.translatesAutoresizingMaskIntoConstraints = false beagleView.topAnchor.constraint(equalTo: margin.topAnchor).isActive = true beagleView.leadingAnchor.constraint(equalTo: margin.leadingAnchor).isActive = true beagleView.trailingAnchor.constraint(lessThanOrEqualTo: margin.trailingAnchor).isActive = true beagleView.bottomAnchor.constraint(lessThanOrEqualTo: margin.bottomAnchor).isActive = true } } Note que no onPress do botão é chamado um método AddChildren que adiciona o layout nativo, ou seja, toda vez que o botão for clicado é adicionado uma view com o layout nativo.\n","excerpt":" Introdução Beagle View é uma UIView que deve ser usada quando é …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/beagle-view/","title":"Beagle View"},{"body":" Introduction Beagle Navigation Controller is a class like the UINavigationController, but more focused on handle the server-driven screen state when it starts or finishes.\nThe method serverDrivenStateDidChange() is the entry point to handle screen state changes.\nThe default implementation shows an “ActivityIndicator” when the screen is loading and does nothing. When an error happens, you can override this method to handle errors properly.\nWhen overriding, if you want to preserve loading behavior, a “super” implementation should be called or you can customize a loading behavior by yourself.\nParameters  State: New state that tells if screen is loading or any error happened ScreenController: Controller that triggered the state change  Check out below the Beagle Navigation Controller class:\nopen class BeagleNavigationController: UINavigationController { open func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { switch state { case .started: view.showLoading(.whiteLarge) case .finished: view.hideLoading() case .success, .error: break } } } The ServerDrivenState is an enum that typifies the screen state. See its structure below:\npublic typealias BeagleRetry = () -\u003e Void public enum ServerDrivenState { case started case finished case success case error(ServerDrivenState.Error, BeagleRetry) } extension ServerDrivenState { public enum Error: Swift.Error { case remoteScreen(Request.Error) case action(Swift.Error) case lazyLoad(Request.Error) case submitForm(Request.Error) case webView(Swift.Error) case declarativeText } } Example class CustomBeagleNavigationController: BeagleNavigationController { private var errorView = ErrorView(message: nil) { } override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) guard case let .error(serverDrivenError, retry) = state else { return } let message: String switch serverDrivenError { case .remoteScreen(let error), .lazyLoad(let error), .submitForm(let error): switch error { case .networkError(let messageError): message = messageError.localizedDescription case .decoding(let messageError): message = messageError.localizedDescription case .loadFromTextError, .urlBuilderError: message = error.localizedDescription } case .action(let error): message = error.localizedDescription default: message = \"Unknow Error.\" } if !view.subviews.contains(errorView) { errorView = ErrorView(message: message, retry: retry) errorView.present(in: view) } else { errorView.addRetry(retry) } } }  You must register this class in Beagle’s dependencies.  let dependencies = BeagleDependencies() dependencies.navigation.registerNavigationController( builder: CustomBeagleNavigationController.init, forId: \"CustomBeagleNavigation\" ) Beagle.dependencies = dependencies  You can register as many BeagleNavigationController as you need.  Now when you instantiating the BeagleScreenViewController, you can pass the controllerId “CustomBeagleNavigation” so that your BeagleScreenViewController use your CustomBeagleNavigationController.\nfunc screenController() -\u003e UIViewController { let screen = Screen( child: Text() ) return BeagleScreenViewController( .declarative(screen), controllerId: \"CustomBeagleNavigation\" ) } ","excerpt":" Introduction Beagle Navigation Controller is a class like the …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/custom-beagle-navigation-controller/","title":"Custom Beagle Navigation Controller"},{"body":" Introduction action is a code block that can run when some event is defined. Beagle already has some by pattern, however it is possible to create your own customized action.\nExample How to create a custom action? To create a custom action, follow the next steps:\n Create a class that implements an action interface:  struct CustomAction: Action { func execute( controller: BeagleController, origin: UIView) { print(\"Custom action foi chamada!\") } }  After that, the interface will request that the method execute is implemented. On this method the code block will be implemented, then your action will run;\n  Now, it is necessary to register this new action on Beagle’s dependencies:\n  let dependencies = BeagleDependencies() dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\" ) Beagle.dependencies = dependencies How to use it? See below an example on how to use the button that runs the customized action on the click event:\nButton( text: \"do request\", onPress: [ CustomCAction() ] ) ","excerpt":" Introduction action is a code block that can run when some event is …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/custom-action/","title":"Custom Action"},{"body":" Introdução BeagleScreenViewController é uma classe que gerencia a hierarquia de exibição na aplicação e possui o mesmo funcionamento de uma UIViewController.\nComo implementar essa classe? Você precisa criar um objeto BeagleScreenViewController com um conjunto de atributos e parâmetros.\nEsse processo pode ser feito com seguintes passos:\n Crie um objeto BeagleScreenViewModel com o screenType remote que deve passar uma URL, um fallback opcional, ou um declarative que passa a tela para o modo declarativo.  Você pode encontrar os comandos a serem executados a seguir:\npublic class BeagleScreenViewModel { public enum ScreenType { case remote(String, fallback: Beagle.Screen?) case declarative(BeagleUI.Screen) } public init(screenType: BeagleUI.BeagleScreenViewModel.ScreenType, delegate: BeagleUI.BeagleScreenDelegate? = nil) } let viewController = BeagleScreenViewController( viewModel: viewModel) Além dos comandos acima, há outros exemplos de inicialização utilizando o declarative e remote:\n//1  let viewModel = BeagleScreenViewModel(screenType: .declarative(content: Home().screen)) //2 let viewModel = BeagleScreenViewModel(screenType: .remote(\"/cash-withdrawal/home\"), fallback: nil)) //3 let viewModel = BeagleScreenViewModel( screenType:.remote( \"http://localhost:8090/cash-withdrawal/home\"), fallback: Home().screen)) Você pode instanciar o BeagleScreenViewModel com um screenType do tipo declarative passando uma tela criada para o seu modo declarativo.\nNesse exemplo, o BeagleScreenViewModel foi instanciado com um screenType do tipo remote onde se passa uma URL relativa e um fallback nulo. Para usar essa URL você deve colocar primeiro uma URL base no BeagleDependencies do seu projeto.\nO segundo BeagleScreenViewModel foi instanciado com um screenType do tipo remote onde passa a URL absoluta e um fallback de uma tela no modo declarativo.\nEstados da tela Para acompanhar o estado da tela temos o enum state:\npublic enum State { //1 case loading //2 case success //3 case failure(Beagle.Request.Error) //4 case rendered }  O estado loading é executado enquanto a requisição não foi recebida ou a tela não foi renderizada e assim que as informações são recebidas e a tela é renderizada, o estado muda para sucesso e se der erro o estado muda para failure. O estado de sucesso é executado logo após que a verificação da requisição for concluída e a tela renderizada. O failure é executado quando há algo errado na requisição ou na renderização da tela, logo BeagleUI.Request.Error informa qual foi o erro. O rendered é utilizado logo após o sucesso, quando a tela é chamada para ser renderizada.  Quando tudo executa o BeagleScreenViewModel com o screenType do tipo declarative, o estado passa direto para sucesso pulando o loading.\nNo BeagleScreenViewModel há uma variável delegate que está relacionada ao BeagleScreenDelegate. Ao estender esse protocolo, caso ocorra algum erro de requisição ao implementar um screenType do tipo remote, ele cairá na função de erro desse protocolo. Onde o usuário pode complementar essa função com o erro.\npublic protocol BeagleScreenDelegate : AnyObject { typealias ViewModel = Beagle.BeagleScreenViewModel func beagleScreen(viewModel: Self.ViewModel, didFailToLoadWithError error: Beagle.Request.Error) } Exemplo para implementar o protocolo BeagleScreenDelegate: //1 let viewModel = BeagleScreenViewModel(screenType: .remote(\"/cash-withdrawal/home\"), fallback: nil)) viewModel.delegate = self //2 extension ViewController: BeagleScreenDelegate { func beagleScreen(viewModel: ViewController.ViewModel, didFailToLoadWithError error: Beagle.Request.Error) { print(\"didFailToLoadWithError: \\(error)\") } }  Reutilizando o exemplo de instanciar o BeagleScreenViewModel você pode adicionar o viewModel.delegate = self, onde se acontecer algum erro de requisição você pode fazer uma tratativa. Ao implementar o protocolo BeagleScreenViewModel você pode complementar essa função, como no exemplo e a função irá mostrar o erro.  A BeagleScreenViewController trabalha com a customização de componentes na view:\nextension BeagleScreenViewController: Beagle.BeagleContext { //1  public func register(action: Beagle.Action, inView view: UIView) //2 public func register(form: BeagleSchema.Form, formView: UIView, submitView: UIView, validatorHandler: Beagle.ValidatorProvider?) //3 public func lazyLoad(url: String, initialState: UIView) //4 public func doAction(_ action: Beagle.Action, sender: Any) } ","excerpt":" Introdução BeagleScreenViewController é uma classe que gerencia a …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/screen-view-controller/","title":"Screen View Controller"},{"body":" Introdução Beagle Navigation Controller é uma classe como uma UINavigationController, porém focada em observar o estado da tela server-driven para, por exemplo, saber quando ela inicia ou finaliza.\nO serverDrivenStateDidChange() é o método que observa as mudanças de estado da tela.\nA implementação padrão mostra um “ActivityIndicator” enquanto o estado da tela é “loading” e nada acontece. Se um erro acontece, você pode sobrescrever esse método para tratar o erro.\nCaso queira preservar o loading depois que ele for sobrescrito, você deve implementar o “super” ou personalizar o próprio loading.\nParâmetros  State: Novo estado que indica se a tela está carregando ou ocorreu algum erro. ScreenController: Controller que indica a mudança de estado.  Confira abaixo a classe BeagleNavigationController:\nopen class BeagleNavigationController: UINavigationController { open func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { switch state { case .started: view.showLoading(.whiteLarge) case .finished: view.hideLoading() case .success, .error: break } } } O ServerDrivenState é um enum que define as possibilidades de estados da tela. Veja essa estrutura abaixo:\npublic typealias BeagleRetry = () -\u003e Void public enum ServerDrivenState { case started case finished case success case error(ServerDrivenState.Error, BeagleRetry) } extension ServerDrivenState { public enum Error: Swift.Error { case remoteScreen(Request.Error) case action(Swift.Error) case lazyLoad(Request.Error) case submitForm(Request.Error) case webView(Swift.Error) case declarativeText } } Exemplo class CustomBeagleNavigationController: BeagleNavigationController { private var errorView = ErrorView(message: nil) { } override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) guard case let .error(serverDrivenError, retry) = state else { return } let message: String switch serverDrivenError { case .remoteScreen(let error), .lazyLoad(let error), .submitForm(let error): switch error { case .networkError(let messageError): message = messageError.localizedDescription case .decoding(let messageError): message = messageError.localizedDescription case .loadFromTextError, .urlBuilderError: message = error.localizedDescription } case .action(let error): message = error.localizedDescription default: message = \"Unknow Error.\" } if !view.subviews.contains(errorView) { errorView = ErrorView(message: message, retry: retry) errorView.present(in: view) } else { errorView.addRetry(retry) } } }  É muito importante que você registre sua CustomBeagleNavigationController nas configurações de dependências do Beagle.  let dependencies = BeagleDependencies() dependencies.navigation.registerNavigationController( builder: CustomBeagleNavigationController.init, forId: \"CustomBeagleNavigation\" ) Beagle.dependencies = dependencies  É possível registrar quantas BeagleNavigationController você quiser.  Quando iniciar uma BeagleScreenViewController, você deve passar o parâmetro controllerId com o id escolhido para sua custom BeagleNavigationController e usar a controller desejada.\nfunc screenController() -\u003e UIViewController { let screen = Screen( child: Text() ) return BeagleScreenViewController( .declarative(screen), controllerId: \"CustomBeagleNavigation\" ) } ","excerpt":" Introdução Beagle Navigation Controller é uma classe como uma …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/beagle-navigation-controller-customizada/","title":"Beagle Navigation Controller customizada"},{"body":" Introduction Beagle already have basic widgets, that can be used to alter your UI application through backend. However you can add new components to make the views of your applications visible to Beagle and also make them be used in the backend.\nHow to create components (custom views) and widgets? Passo 1: Create a Widget See below an example of a customized component that represents UILabel:\nstruct MyCustomComponent: ServerDrivenComponent { let text: String func toView(renderer: BeagleRenderer) -\u003e UIView { let label = UILabel(frame: .zero) label.text = text label.numberOfLines = 0 return label } } You can see in the example MyCustomComponent is a ServerDrivenComponent, it is a protocol that conforms to Decodable which is responsible to decode the properties your widgets exposes to the backend.\nStep 2: Register the Widget It is required you register to Beagle. Inside the configure file use the registerCustomComponent(). method. The first parameter is a string tha refers as your BFF will call it and the second parameter is the component’s class.\nBeagle.registerCustomComponent( \"MyCustomComponent\", componentType: MyCustomComponent.self ) After you register your customized component, you can use via server-driven.\nStep 3: Display the component You can use your component declaratively or put it in an instance until BeagleScreenViewController or call it with the toView() method and present the UIView that appears in your own view controller.\nlet beagleScreenViewController = Beagle.screen( .declarative( .init(child: MyCustomComponent(text: \"Hello Beagle!\") ) ) ) Even if you have a more complex component in your UIViews, the process will be very similar, you just have to provide an ServerDrivenComponent or a Widget type.\n","excerpt":" Introduction Beagle already have basic widgets, that can be used to …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/custom-widgets/","title":"Custom Widgets"},{"body":" Introdução O Beagle realiza todas requisições web a partir da dependência networkClient presente no BeagleDependencies, ela é do tipo NetworkClient, sendo assim é possível substituir a implementação default utilizada no framework por outra.\nVocê precisa fazer a substituição nos casos em que:\n É preciso unificar a camada de networking do sistema em um módulo; Modificar algumas propriedades como, por exemplo, cabeçalhos de requisições, métodos request, body response, data response, executar criptografia, etc.  public protocol NetworkClient { typealias Error = NetworkError typealias NetworkResult = Result\u003cNetworkResponse, NetworkError\u003e typealias RequestCompletion = (NetworkResult) -\u003e Void @discardableResult func executeRequest( _ request: Request, completion: @escaping RequestCompletion ) -\u003e RequestToken? }  A implementação default do protocolo NetworkClient usada pelo Beagle utiliza recursos do Foundation para realizar as requisições como o URLSession.  Customizações Para customizar o seu protocolo NetworkClient, veja as seções abaixo:\nAdicione header fields Para adicionar header fields nas requisições criadas pelo NetworkClient default basta seguir os seguintes passos:\n No AppDelegate ou na classe de configurações do ambiente do beagle instancie o NetworkClientDefault passando as dependências recém criadas no inicializador; Adicione os headers desejados no atributo additionalHeaders presente no objeto HttpRequestBuilder. Ele é uma dependência do NetworkClientDefault responsável por criar as URLRequest que são passadas para a dataTask do URLSession; Atribuia o NetworkClient instanciado e modificado como o networkClient das dependências:  let dependencies = BeagleDependencies() let client = NetworkClientDefault(dependencies: dependencies) client.httpRequestBuilder.additionalHeaders = [ \"X-Frame-Options\": \"deny\", \"client-Identification\":\"123123123\" ] dependencies.networkClient = client Beagle.dependencies = dependencies Modifique URL base Para modificar a URL base utilizada pelo Beagle, siga os passos:\n No AppDelegate ou na classe de configurações do ambiente do Beagle, instancie um objeto do tipo URLBuilder e passe a URL base no inicializador; Atribua o objeto criado ao atributo urlBuilder presente no BeagleDependencies:  let dependencies = BeagleDependencies() let urlBuilder = UrlBuilder(baseUrl: URL(string: Constants.Server.baseURL)) dependencies.urlBuilder = urlBuilder Beagle.dependencies = dependencies Substituindo a camada de Networking Para substituir a classe responsável por realizar as requisições Http para o Beagle, siga os passos a seguir:\nPasso 1: implementar a NetworkClient Implemente o protocolo NetworkClient na classe que deseja utilizar para realizar as requisições, neste caso o CustomNetworkClient será usado como exemplo:\nclass CustomNetworkClient: NetworkClient { func executeRequest( _ request: Request, completion: @escaping RequestCompletion ) -\u003e RequestToken? { let url: URL = request.url let requestType = request.type let headers = request.additionalData //Implementacao de Requisicoes } //Implementacao Network Client... } Esse protocolo tem a responsabilidade de executar as requisições a partir da função executeRequest que recebe 2 parâmetros:\n request: valor do tipo Request que contém os dados necessários para a requisição:  URL Headers RequestType   completion: bloco que deve ser chamado ao final da execução da função passando o resultado da requisição.  Além disso a função pode retornar o RequestToken, para que a requisição possa ser cancelada internamente pelo Beagle.\nPasso 2: atribuir as dependências No AppDelegate ou na classe de configurações do ambiente do Beagle, atribua a instância de CustomNetworkClient ao atributo networkClient presente no Beagle Dependencies:\nlet dependencies = BeagleDependencies() let client = CustomNetworkClient() dependencies.networkClient = client Beagle.dependencies = dependencies Pronto! Agora o Beagle utilizará a sua classe com todas as modificações e definições necessárias para realizar as requisições Http.\n","excerpt":" Introdução O Beagle realiza todas requisições web a partir da …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/camada-de-rede/","title":"Camada de rede"},{"body":" Added in Beagle 1.0.0 Beagle uses the unified log system recommend by Apple, to provide different log messages in critical stages of a server driven flow.\nThe log messages provided for Beagle iOS can be access through:\n Xcode console Application console  They are divided in 4 categories:\n Network: related to the network layer, information and error messages for each request, response and network URL construction. Decoding: displays messages every time a parse error occurs. Navigation: informative messages that describes the navigations inside the server driven flow and possible errors may occur. Form: related to forms.  It is possible to disable triggered log messages. Beagle will not call the Log’s API, even if it is a pattern or customized. You will need to change the attribute isLoggingEnabled ofBeagleDependencies tofalse.\nThe log messages can be filtered using these categories names and the main package identifier of the application as a subsystems.\nInstructions to filter log messages: Follow the steps below to filter the log messages:\nStep 1: open Console App;\nStep 2: select device on the Devices menu;\nStep 3: insert the filters in the search bar, search only for log messages with the Network category in the subsystem br.com.zup.BeagleDemoApp\nStep 4: when you open the BeagleDemo application, you will see two log messages with the network category, one will show that Beagle made a request and the other indicating the response.\nStep 5: error messages will be displayed with a yellow dot in the field Type, as showed below:\nStep 6: to select the second log message received with a Network filter, you will see a verbosa version of this response.\nStep 7: the body of the response contains the server-driven screen and all its attributes and specifications can be accessed.\nInstructions to replace the Logs API In order to let Beagle’s environment open to modifications, the API logs pattern can be replaced to any other. Follow th next steps to make the API’s logs replacement:\nStep 1: implement BeagleLoggerType protocol on the class you want to use as log API, you will see that it is necessary to implement the methods log(_ log: LogType) and logDecodingError(type: String) that are internally called by Beagle when a message needs to be triggered:\nclass CustomLogger: BeagleLoggerType { func log(_ log: LogType) { print(log.message) } func logDecodingError(type: String) { print(type) } } Step 2: on Beagle’s configuration of your project, assign to a class' instance to the logger dependency on BeagleDependencies:\nlet dependencies = BeagleDependencies() dependencies.logger = CustomLogger() Beagle.dependencies = dependencies ","excerpt":" Added in Beagle 1.0.0 Beagle uses the unified log system recommend by …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/log-system/","title":"Log System"},{"body":" Introdução Para customizar os comportamentos de carregamento e erro no Beagle iOS, você precisa criar seu próprio navigation controller.\nAo cria-lo, você precisa seguir os seguintes passos:\n Extender sua controller a partir daBeagleNavigationController Alterar as dependências do Beagle para utilizá-lo.  O método serverDrivenStateDidChange deve ser sobrescrito para fazer a customização.  Exemplo Criando o Beagle navigation controller Passo 1: Criar um Beagle navigation controller: import Beagle class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { // TODO:Exibir carregamento e erros quando necessário. } } Passo 2: Configurar a dependência: let dependencies = BeagleDependencies() dependencies.navigation.registerNavigationController( builder: MyAppNavigationController.init, forId: \"MyAppNavigationController\") Beagle.dependencies = dependencies É possível cadastrar mais de uma customização do BeagleNavigationController. Para escolher qual delas usar, o BFF precisa que você informe o forId.\nFaça a configuração do navigationControllerType com as demais configurações do Beagle para não sobrescrevê-las_._  Configurando o Carregamento Por padrão, a implementação no Beagle sempre retorna uma interface com fundo preto semitransparente. Você pode ver isso por meio do UIActivityIndicatorView.\nSe você quiser apresentar um carregamento específico da sua aplicação, verifique o estado da tela (state) e reaja apropriadamente. Veja no exemplo a seguir:\nextension UIView { func showLoading() { // ... } func hideLoading() { // ... } } class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { switch state { case .loading(let loading): loading ? view.showLoading() : view.hideLoading() case .error: view.hideLoading() } } } Caso queira manter o estilo original de carregamento, basta executar a implementação padrão e seguir para o tratamento de erros.\noverride func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) // TODO:Tratar casos de erro } Tratando os erros Quando ocorre algum erro na aplicação, o Beagle altera o estado da tela (state) para ServerDrivenState.Error. Nesse caso, você deve verificar qual foi tipo do erro e fazer a tratativa quando necessário.\nOs possíveis erros são:\n remoteScreen(Request.Error): A requisição para carregar uma tela remota falhou. Veja abaixo quando isso ocorre. lazyLoad(Request.Error): A requisição para carregar um componente Lazy falhou. Veja abaixo quando isso ocorre. action(Swift.Error): A execução de uma Action falhou.  Erros em uma requisição (Request.Error):\n urlBuilderError: A URL do recurso ou a baseURL é inválida. networkError: Não foi possível estabelecer a conexão ou um erro foi retornado pelo BFF. decoding: A resposta enviado pelo BFF é diferente do objeto esperado.  O erro possui um bloco retry que permite executar novamente a ação que falhou.  Veja o exemplo de como exibir uma tela de erro quando o carregamento de uma tela falha:\nclass ErrorView: UIVIew { var retry: (() -\u003e Void)? func present(in view: UIView) { // ... } } class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) if case let .error(serverDrivenError, retry) = state, case .remoteScreen = serverDrivenError { let errorView = ErrorView() errorView.retry = retry errorView.present(in: view) } } } ","excerpt":" Introdução Para customizar os comportamentos de carregamento e erro …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/carregamento-e-tratamento-de-erros/","title":"Carregamento e tratamento de erros"},{"body":" Added in Beagle 1.0.0 To customize the loading and error treatment behaviors on Beagle iOS, you have to create your own navigation controller.\nIt can be done by:\n Extending BeagleNavigationController Changing the dependencies to use them.  The serverDrivenStateDidChange method must be overwritten to make this customization.  See how to create a navigation controller:\nimport Beagle class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { // TODO:Exibir carregamento e erros quando necessário. } } And, right after, how to configure a dependency:\nlet dependencies = BeagleDependencies() dependencies.navigation.registerNavigationController( builder: MyAppNavigationController.init, forId: \"MyAppNavigationController\") Beagle.dependencies = dependencies It’s possible register more than one custom BeagleNavigationController. To choose which one to use, the BFF needs to inform the forId.\nMake thenavigationControllerType configuration with other Beagle’s settings, so you don’t overwrite them.  Configuring the Loading As standard, Beagle’s implementation always return an interface with partially transparent black background. You can see this through UIActivityIndicatorView.\nIf you want to display a specific loading behavior on your application, check the screen state (state) and react to it properly. See how on the example below:\nextension UIView { func showLoading() { // ... } func hideLoading() { // ... } } class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { switch state { case .loading(let loading): loading ? view.showLoading() : view.hideLoading() case .error: view.hideLoading() } } } If you want to keep the original loading style, just run the standard implementation and move forward toerror treatment\noverride func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) // TODO:Tratar casos de erro } Checking the Error Treatment When occurs an error on the application, Beagle changes the screen state (state) to ServerDrivenState.Error. In this case, you must check out what kind of error and make the necessary treatment.\nThe possibles errors are:\n remoteScreen(Request.Error): When the request to load a remote screen fails. Check out on the example below when it happens. lazyLoad(Request.Error): When the request to load a Lazy component fails. Check out on the example below when it happens. action(Swift.Error): When an Action ’s execution fails.  Errors on a request (Request.Error):\n urlBuilderError: When the resource URL or a baseURL is invalid. networkError: When it’s not possible to establish a connection or an error was returned from the BFF. decoding: When the answer sent from BFF is different than the object expected.  The error has a retry block that allows you to run again the action that has failed.  See the example below how to display an error screen when the screen loading fails:\nclass ErrorView: UIVIew { var retry: (() -\u003e Void)? func present(in view: UIView) { // ... } } class MyAppNavigationController: BeagleNavigationController { override func serverDrivenStateDidChange( to state: ServerDrivenState, at screenController: BeagleController ) { super.serverDrivenStateDidChange(to: state, at: screenController) if case let .error(serverDrivenError, retry) = state, case .remoteScreen = serverDrivenError { let errorView = ErrorView() errorView.retry = retry errorView.present(in: view) } } } ","excerpt":" Added in Beagle 1.0.0 To customize the loading and error treatment …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/loading-and-error-treatment/","title":"Loading and Error Treatment"},{"body":" Introdução A sua aplicação pode mudar o comportamento default do Beagle, a partir da customização de propriedades da instância do Beagle.dependencies.\nElas possuem um papel específico na capacidade do Beagle, esta é a razão pela qual você deve tratar o Beagle.dependenciescomo principal foco de customização para que as outras partes de sua aplicação possa ver as modificações feitas nas dependências.\nVocê deve confiar nas implementações padrão, como nos exemplos abaixo:\nclass BeagleDependencies: BeagleDependenciesProtocol { var urlBuilder: UrlBuilderProtocol var networkClient: NetworkClient var decoder: ComponentDecoding var appBundle: Bundle var theme: Theme var validatorProvider: ValidatorProvider? var deepLinkHandler: DeepLinkScreenManaging? var localFormHandler: LocalFormHandler? var repository: Repository var analytics: Analytics? var navigation: BeagleNavigation var preFetchHelper: BeaglePrefetchHelping var cacheManager: CacheManagerProtocol? var formDataStoreHandler: FormDataStoreHandling var windowManager: WindowManager var opener: URLOpener var globalContext: GlobalContext var isLoggingEnabled: Bool var logger: BeagleLoggerType } As dependências do Beagle deverão ser registradas no AppDelegate, veja o exemplo abaixo:\n@UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool { let dependencies = BeagleDependencies() dependencies.theme = AppTheme.theme dependencies.urlBuilder = UrlBuilder(baseUrl: URL(string: .baseURL)) dependencies.navigation.defaultAnimation = .init( pushTransition: .init( type: .fade, subtype: .fromRight, duration: 0.1 ), modalPresentationStyle: .formSheet ) dependencies.isLoggingEnabled = true dependencies.decoder.register( component: CustomComponent.self, named: \"CustomComponent\" ) dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\") Beagle.dependencies = dependencies let rootViewController = MainScreen().screenController() window?.rootViewController = rootViewController return true } } UrlBuilder Configura uma URL base para sua aplicação, é usada quando os fluxos de navegação via Beagle serão definidos, você pode usar uma URL relativa.\nVeja abaixo um exemplo de como usar:\ndependencies.urlBuilder = UrlBuilder(baseUrl: URL(string: \"SUA URL BASE\")) NetworkClient É responsável por executar network requests. A sua aplicação deverá ser customizada nesta parte porque cada projeto possui uma demanda específica para network layer. Por isso, a implementação padrão pode não servir dependendo das necessidades do seu negócio.\nDecoder Transforma um JSON em Componentes do Beagle (Seção Elementos). Ele já possui uma lógica para decodificar todos os componentes default. Se você precisar trabalhar com componentes customizáveis, você pode registrá-los nesta instância.\nVeja abaixo um exemplo de como registrar um componente e uma action customizada:\nBeagle.dependencies.decoder.register( component: CustomWidget.self, named: \"CustomWidget\" ) Beagle.dependencies.decoder.register( action: CustomAction.self, named: \"CustomAction\" ) AppBundle Você pode fornecer um pacote para sua aplicação de modo que o Beagle possa acessar seus recursos, como por exemplo, imagens, fontes, cores, etc.\nTheme Armazena todos os seus styles e sabe como aplicá-los em seus componentes.\nAlguns widgets possuem uma variável que permite você definir o estilo. O nome de cada uma deverá ser repassada à dependência do Theme, de modo que aquele estilo possa ser usado no seu respectivo componente.\nPara configurar os estilos customizados, siga os seguintes passos:\nVocê irá usar o Text como um widget que possui o UITextView como seu UIKit view. Depois disso, você irá aplicar suas mudanças de estilo para esse view nos quais terão também customizações de font e textColor.  Passo 1: crie uma função que irá receber a representação o UIKit com a representação do widget que você quer aplicar o estilo.\nstatic func blackTextNormalStyle() -\u003e (UITextView?) -\u003e Void { return { $0?.font = .systemFont(ofSize: 16) $0?.textColor = .black } } Passo 2: crie uma instância concreta do AppTheme com os nomes dos seus estilos e as funções correspondentes.\nlet theme = AppTheme(styles: [ \"myStyleName\": blackTextNormalStyle ]) Passo 3: atribua sua instância Theme às dependências do Beagle.\nBeagle.dependencies.theme = theme Passo 4: agora, você pode usar o Text com sua propriedade de style definida e assim configurar o nome que você definiu para o seu style customizado.\nText(\"Some text\", style: \"myStyleName\") ValidatorProvider Valida a customização que será realizada quando o widget Form for utilizado.\nDeepLinkHandler Este handler é usado para uma ação de deep link navigation. A variável possui um valor default, você pode adicionar novas telas ou substituir por outras na aplicação.\nAbaixo, você encontra um comando de como adicionar uma tela com um possível roteamento para deep linking usando um valor default:\nlet deepLinkHandler = DeeplinkScreenManager.shared deepLinkHandler[\"MyDeepLinkScreen\"] = MyDeepLinkScreenClass.self Beagle.dependenciesdeepLinkHandler = deepLinkHandler LocalFormHandler Sua aplicação pode lidar com o envio de formulário por conta própria usando o FormLocalAction.\nO LocalFormHandler definido nas dependências do Beagle será usado para executar isso.\nRepository É responsável pelas três principais operações no:\n fetchComponent: Orquestra a requisição para buscar widgets no servidor. submitForm: Submete forms no widget. fetchImage: Busca imagens para o networkImage;  Analytics É um protocolo que pode ser implementado para rastrear ações de aparecimento da tela ou sua finalização e eventos de clique.\nVeja o exemplo abaixo:\nclass AnalyticsSample: Analytics { func trackEventOnScreenAppeared(_ event: AnalyticsScreen) { print(\"Screen \\(event.screenName)appeared\") } func trackEventOnScreenDisappeared(_ event: AnalyticsScreen) { print(\"Screen \\(event.screenName)disappeared\") } func trackEventOnClick(_ event: AnalyticsClick) { print(\"Button touch with:\\ncategory = \\(event.category)\\nlabel = \\(event.label ?? \"empty\")\\nvalue = \\(event.value ?? \"empty\")\") } } Navigation O navigation lida com tipo de ações de navigate da sua aplicação. Existe uma implementação que é usada como valor default, mas que também pode ser substituída por uma classe que está de acordo com BeagleNavigation\nNesse mesmo atributo também é possível definir uma animação de navegação.\nPreFetchHelper Este componente é usado como pré-busca do BeagleScreenViewControllers e entrega uma experiência para o usuário mais fluida. Ela já possui um valor e pode ser alterado para se adequar em que você precisa.\nA pré-busca é acionada quando há um navigation widget de modo que você possa fazer um pré carregamento dos dados das possíveis próximas telas, evitando delays na navegação. Este comportamento pode ser desativado.\nCacheManager É responsável por manter e gerenciar o cache do conteúdo server-driven da aplicação.\nFormDataStoreHandler É uma forma de persistir os dados de um formulário.\nWindowManager É responsável por gerenciar uma janela.\nOpener É um protocolo que tem um método que abre URL caso necessite navegar para um link externo.\nGlobalContext Variável para definir um contexto de escopo global.\nIsLoggingEnabled É uma variável boolean para habilitar ou desabilitar os logs e já vem habilitada por padrão.\nLogger O logger é uma variável do tipo BeagleLoggerType que organiza os logs da aplicação. Esses logs seguem o protocolo LogType, o qual tem os parâmetros:\n category: assunto do log; message: mensagem do log; level: classifica o nível crítico.  É possível criar um logger customizado, o qual possuí categorias especificas da aplicação.  ","excerpt":" Introdução A sua aplicação pode mudar o comportamento default do …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/depend%C3%AAncias-do-beagle/","title":"Dependências do Beagle"},{"body":" Added in Beagle 1.0.0 Protocol public protocol BeagleNavigation { var defaultAnimation: BeagleNavigatorAnimation? { get set } func navigate(action: Navigate, controller: BeagleController, animated: Bool) } On BeagleNavigation protocol we have a defaultAnimation variable that allows you to change the transition animation of your application, and also another function that deals with the navigate actions types and define their behaviours.\nWe suggest that you use the default implementation, but if it is necessary, it is allowed that this implementation is replaced by a class according to the protocol above.\nDefault implementation There is a implementation for this protocol used as a default value on BeagleDependencies It will treat the action with a more intuitive way.\nOpenExternalURL This action opens an available browser on the device from a informed URL.\nOpenNativeRoute This action opens a locally defined screen. It can be or not defined in the backend. It also allows you to add a ViewController to the stack with a push operation.\nSee the code below:\ncase openNativeRoute(String, data: [String: String]? = nil, shouldResetApplication: Bool = false) The attributes from the example above are:\n Route: represents the registered route for a native screen. ShouldResetAplication: indicates the stack view restart of the application. Data: passes the information between screens.  PushStack It is responsible for preseting a new ViewController with a default animation system, that can change the defaultAnimation variable provided in the BeagleNavigation protocol above.\nOn this case, this action presents aViewController to a stack with a present operation.  PopStack This action dismisses the presented ViewController .\nPushView Opens a new screen in the same stack using a route.\nThis ViewController is added with apushViewController operation.  popView It closes the current screen and remove it from the stack.\nThis ViewController is removed from the stack with a é retirada da stack popViewController operation.  PopToView Returns a specific ViewController stack.\nThis operation returns to a specificViewControllerusing a popToViewController operation.  ResetApplication Opens a informed route of a new flow and erases the views stacks of the whole application.\nResetStack Open a screen with an informed route of a new flow and cleans the loaded screen stacks.\nTransition Animation On BeagleNavigation Protocol we provide a defaultAnimation variable that determines how the view is animated onscreen when it is presented.\nWe allow you to change transitions for pushing and popping view controllers with pushTransition and popTransition variables and you can also change your modalPresentationStyle and modalTransitionStyle.\npublic struct BeagleNavigatorAnimation { var pushTransition: Transition? var popTransition: Transition? var modalPresentationStyle: UIModalPresentationStyle? var modalTransitionStyle: UIModalTransitionStyle } In the structure below, we provide you the types of CATransition , where you can transition between a layer’s states by creating and adding a CATransition object to it.\npublic struct Transition { var type: CATransitionType var subtype: CATransitionSubtype? var duration: Double } In the example below, we changed the apps default push transition and modalPresentationStyle.\nlet animation = BeagleNavigatorAnimation( pushTransition: .init( type: .fade, subtype: .fromRight, duration: 1.0), modalPresentationStyle: .formSheet) let dependencies = BeagleDependencies() dependencies.navigation.defaultAnimation = animation  This configuration is applied to all of the navigations in your application.  ","excerpt":" Added in Beagle 1.0.0 Protocol public protocol BeagleNavigation { var …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/navigation/","title":"Navigation"},{"body":" Added in Beagle 1.0.0 Introduction Beagle makes all the web request from the networkClient dependency that it is in the BeagleDependencies, and its type is NetworkClient, because of that it is possible to replace a default implementation used in the framework to another.\nYou need to make the replacement in the following cases:\n It is necessary to unify the networking layer in the module system; Modify some properties for example, like request headers, request methods, body response, data response, run cryptography, etc.  public protocol NetworkClient { typealias Error = NetworkError typealias NetworkResult = Result\u003cNetworkResponse, NetworkError\u003e typealias RequestCompletion = (NetworkResult) -\u003e Void @discardableResult func executeRequest( _ request: Request, completion: @escaping RequestCompletion ) -\u003e RequestToken? }  The default implementation of the NetworkClient protocol used on Beagle has the Foundation resources to make the URLSession requests  Customization To customize your NetworkClient protocol, see the sections below:\nAdding header fields To add header fields on the requests created by the NetworkClient default, follow the steps:\n No AppDelegate ou na classe de configurações do ambiente do beagle instancie o NetworkClientDefault passando as dependências recém criadas no inicializador; Adicione os headers desejados no atributo additionalHeaders presente no objeto HttpRequestBuilder. Ele é uma dependência do NetworkClientDefault responsável por criar as URLRequest que são passadas para a dataTask do URLSession; Atribuia o NetworkClient instanciado e modificado como o networkClient das dependências:  let dependencies = BeagleDependencies() let client = NetworkClientDefault(dependencies: dependencies) client.httpRequestBuilder.additionalHeaders = [ \"X-Frame-Options\": \"deny\", \"client-Identification\":\"123123123\" ] dependencies.networkClient = client Beagle.dependencies = dependencies Modifying URL base To modify the URL base used on Beagle, follow the steps:\n On AppDelegate or in a Beagle’s environment configuration class, instantiate an object with the URLBuilder type and pass the URL base in the initiator; Assign the created object to the urlBuilder attribute that it is on BeagleDependencies:  let dependencies = BeagleDependencies() let urlBuilder = UrlBuilder(baseUrl: URL(string: Constants.Server.baseURL)) dependencies.urlBuilder = urlBuilder Beagle.dependencies = dependencies Replacing the Networking layer To replace the class responsible for making Http request to Beagle, follow the next steps:\nStep 1: implement NetworkClient Implement the NetworkClient protocol in the class you want to use to make requests, in this case, the CustomNetworkClient will be used, like the example below:\nclass CustomNetworkClient: NetworkClient { func executeRequest( _ request: Request, completion: @escaping RequestCompletion ) -\u003e RequestToken? { let url: URL = request.url let requestType = request.type let headers = request.additionalData //Implementacao de Requisicoes } //Implementacao Network Client... } This protocol run the requests from the executeRequest function, it receives two parameters:\n request: request type value that contains the data necessary to make a request:  URL Headers RequestType   completion: block that must be called in the end of the function execution, passing the request result.  Besides that, the function can return the RequestToken, in order to make the request be able to be canceled internally by Beagle.\nStep 2: assign the dependencies OnAppDelegate or on Beagle’s environment, assing the instance CustomNetworkClient to the networkClient attribute that it is on Beagle Dependencies:\nlet dependencies = BeagleDependencies() let client = CustomNetworkClient() dependencies.networkClient = client Beagle.dependencies = dependencies Done! Now, Beagle will use your class with all the changes and definition needed to make the http requests.\n","excerpt":" Added in Beagle 1.0.0 Introduction Beagle makes all the web request …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/networkclient/","title":"Networkclient"},{"body":" Introdução O Beagle usa o sistema de log unificado recomendado pela Apple para fornecer mensagens de logs diferentes em estágios críticos de um fluxo Server Driven.\nAs mensagens de log fornecidas pelo Beagle iOS podem ser acessadas pelo:\n Console do Xcode Console da Aplicação  Elas são divididas em 4 categorias:\n Network: relacionada à camada Rede, informações e mensagens de erro para cada solicitação, resposta e construção de URL da rede. Decoding: exibe mensagens toda vez que ocorre um erro de parse. Navigation: mensagens informativas que descrevem todas as navegações dentro de um fluxo Server Driven e possíveis erros que podem ocorrer. Form: relacionado a formulários.  É possível desabilitar as mensagens de log disparadas, dessa forma o Beagle não irá mais chamar a API de Log, seja ela a padrão ou customizada. Você precisa passar o atributo isLoggingEnabled do BeagleDependencies para false.\nAs mensagens de log podem ser filtradas usando esses nomes como categorias e o identificador do pacote principal do aplicativo como subsistema.\nFiltrando mensagens de log: Siga os passos abaixo para filtrar mensagens de log:\nPasso 1: abra o Console App;\nPasso 2: selecione o device no menu Devices;\nPasso 3: insira os filtros na barra de busca, procure somente as mensagens de log com a categoria Networkno subsistema br.com.zup.BeagleDemoApp\nPasso 4: ao abrir a aplicação BeagleDemo vemos duas mensagens de log com a categoria network, uma mostrando que o Beagle fez uma requisição e outra indicando a resposta dessa requisição:\nPasso 5: mensagens de erro serão exibidas com um ponto amarelo no campo Type, como mostrado abaixo:\nPasso 6: ao selecionar a segunda mensagem de log recebida com filtro Networkvocê verá a versão verbosa dessa resposta:\nPasso 7: o corpo da resposta contém a tela Server Driven e todos os seus atributos e especificações podem ser acessados.\nCustomização Para deixar o ambiente do Beagle aberto a modificações, a API de Logs padrão pode ser substituída por qualquer outra. Siga os passos abaixo fazer a substituição a API de logs:\nPasso 1: implemente o protocolo BeagleLoggerType na classe que deseja utilizar como API de logs, você irá observar que é preciso implementar os métodos log(_ log: LogType) e logDecodingError(type: String) que são chamados internamente pelo Beagle sempre que uma mensagem precisa ser disparada:\nclass CustomLogger: BeagleLoggerType { func log(_ log: LogType) { print(log.message) } func logDecodingError(type: String) { print(type) } } Passo 2: nas configurações do Beagle de seu projeto atribua uma instância da classe à dependência logger no BeagleDependencies:\nlet dependencies = BeagleDependencies() dependencies.logger = CustomLogger() Beagle.dependencies = dependencies ","excerpt":" Introdução O Beagle usa o sistema de log unificado recomendado pela …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/sistema-de-log/","title":"Sistema de Log"},{"body":" Added in Beagle 1.0.0 What is Screen View Controller? It is a class that manages the display hierarchy in the application and it works like a UIViewController.\nHow to implement this class? You have to create an object BeagleScreenViewController with a set of attributes and parameters.\nThis process can be done following the next steps:\n Create an object BeagleScreenViewModel with screenType remote that have to send a URL, a optional fallback or a declarative that changes the screen to a declarative mode.  You can find the commands below:\npublic class BeagleScreenViewModel { public enum ScreenType { case remote(String, fallback: Beagle.Screen?) case declarative(BeagleUI.Screen) } public init(screenType: BeagleUI.BeagleScreenViewModel.ScreenType, delegate: BeagleUI.BeagleScreenDelegate? = nil) } let viewController = BeagleScreenViewController( viewModel: viewModel) There are other boot examples using declarative and remote:\n//1  let viewModel = BeagleScreenViewModel(screenType: .declarative(content: Home().screen)) //2 let viewModel = BeagleScreenViewModel(screenType: .remote(\"/cash-withdrawal/home\"), fallback: nil)) //3 let viewModel = BeagleScreenViewModel( screenType:.remote( \"http://localhost:8090/cash-withdrawal/home\"), fallback: Home().screen)) You can instantiate BeagleScreenViewModel with a declarative type, screenType changing your created screen to the declarative mode.\nIn this example, BeagleScreenViewModeli was instantiated with a remote type screenType where there’s a relative URL and a null fallback. To use this URL you must put a base URL in the BeagleDependencies of your projects.\nThe second BeagleScreenViewModel was instantiated with a remote type screenType where there’s an absolute URL and a screen with a declarative fallback.\nScreen states To follow the screen states, there is the enum state:\npublic enum State { //1 case loading //2 case success //3 case failure(BeagleUI.Request.Error) //4 case rendered }  Loading state happens when a request was not received or the screen was not rendered, when the information are received the state changes to success, if not it changes to failure. Success state happens right after the request verification is finished and the screen rendered. Failure happens when something is wrong in the request or screen render, BeagleUI.Request.Error informs what was the error. Rendered is used right after the success, when the screen is rendered.  When everything runs BeagleScreenViewModel with declarative screenType, the state goes straight to success, skipping loading.\nBeagleScreenViewModel has a variable delegate, it is related to BeagleScreenDelegate. When this protocol is extended, in case of any request error to implement remote screenType, it will fall into the error function of this protocol, where the user may complement the function with the error.\npublic protocol BeagleScreenDelegate : AnyObject { typealias ViewModel = Beagle.BeagleScreenViewModel func beagleScreen(viewModel: Self.ViewModel, didFailToLoadWithError error: Beagle.Request.Error) } Example to implement the BeagleScreenDelegate protocol: //1 let viewModel = BeagleScreenViewModel(screenType: .remote(\"/cash-withdrawal/home\"), fallback: nil)) viewModel.delegate = self //2 extension ViewController: BeagleScreenDelegate { func beagleScreen(viewModel: ViewController.ViewModel, didFailToLoadWithError error: Beagle.Request.Error) { print(\"didFailToLoadWithError: \\(error)\") } }  Reuse the instantiate BeagleScreenViewModel example, you can add the viewModel.delegate = self. When implementing the BeagleScreenViewModel protocol you may complete this function, it will show the error.  BeagleScreenViewController works with components customization in the view:\nextension BeagleScreenViewController: Beagle.BeagleContext { //1  public func register(action: Beagle.Action, inView view: UIView) //2 public func register(form: BeagleSchema.Form, formView: UIView, submitView: UIView, validatorHandler: Beagle.ValidatorProvider?) //3 public func lazyLoad(url: String, initialState: UIView) //4 public func doAction(_ action: Beagle.Action, sender: Any) } ","excerpt":" Added in Beagle 1.0.0 What is Screen View Controller? It is a class …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/screen-view-controller/","title":"Screen View Controller"},{"body":" Introdução O Beagle já possui alguns widgets básicos que podem ser usados para alterar a sua aplicação UI através do backend. No entanto, você pode adicionar novos componentes para fazer as views da sua aplicação fiquem “visíveis” ao Beagle e que possam também ser usadas no backend.\nComo criar componentes (custom views) e widgets? Passo 1: Criar o Widget Segue abaixo um exemplo de um componente customizado que representa um UILabel:\nstruct MyCustomComponent: ServerDrivenComponent { let text: String func toView(renderer: BeagleRenderer) -\u003e UIView { let label = UILabel(frame: .zero) label.text = text label.numberOfLines = 0 return label } } Podemos ver que o MyCustomComponent é do tipo ServerDrivenComponent, que é um protocolo que conforma com Decodable e é responsável por decodificar as propriedades que seu widget expõem ao backend.\nPasso 2: Registrar o Widget É obrigatório registrá-lo no Beagle. Dentro do arquivo de configuração utilize o método registerCustomComponent(). O primeiro parâmetro é uma string que referencia como o seu BFF irá chama-lo e o segundo parâmetro é a classe criada do componente.\nBeagle.registerCustomComponent( \"MyCustomComponent\", componentType: MyCustomComponent.self ) Após registrar o seu componente de customização, você pode usá-lo via server-driven.\nPasso 3: Exibir o Componente Você pode usar o seu componente declarativamente assim como passá-lo por uma instância até o BeagleScreenViewController ou chamá-lo via método toView() para apresentar oUIView que aparece dentro do seu próprio view controller.\nlet beagleScreenViewController = Beagle.screen( .declarative( .init(child: MyCustomComponent(text: \"Hello Beagle!\") ) ) ) Se você usar componentes mais complexos que estejam no UIViews ou outros componentes não mencionados, o processo seria parecido, você apenas precisa providenciar um tipo de ServerDrivenComponent ou Widget.\n","excerpt":" Introdução O Beagle já possui alguns widgets básicos que podem ser …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/widgets-customizados/","title":"Widgets customizados"},{"body":" What is Sourcery? Sourcery is a code generator that helps boilerplate code creation.\nIt is recommended, however the installation of this library is optional. If you want to install, follow the instructions below.\nInstallation After you have integrated Beagle, now you can intall Sourcery in your computer using Homebrew.\n$ brew install sourcery Configuration It is necessary to configure the path files template, the generated files and the path where Sourcery will scan the font code. Follow the next steps:\nStep 1: in Build Phases, create a new Run Script Phase;\nStep 2: put ABOVE Compile Sources; If you don’t do this, sourcery won’t be able to compile the generated code.\nStep 3: paste the following code:\nif which sourcery \u003e/dev/null; then unset SDKROOT sourcery --config $SRCROOT else echo \"warning: Sourcery not installed, download using brew install sourcery\" fi This script warns Xcode to look for a .sourcery.yml file in your project root. It will have some properties that Sourcery will have to know to generate the code.\nThe list below shows the attributes used in this file:\n sources : path for your swift files. It is the root of the project. templates : path for your template files that Sourcery will use to generate the code. output : o path for generates files.  For more information and details about Sourcery, check their documentation.  .yml file configuration The .yml file configuration are different due to the way Cocoapods and Carthage deals with the Beagle’s files.\nFor the Sourcery to use the Beagle’s templates, you must specify the SourceryProtocols.swif in sources and the template path in templates.\nThe attributes written inside the.yml consider that Cartfile or Podfile file are in the same directory that .xcodeproj or .xcworkspace  Cocoapods Carthage sources:include:- RootOfYourProject- Pods/BeagleUI/iOS/Sources/BeagleUI/CodeGeneration/SourceryProtocols.swifttemplates:- Pods/BeagleUI/iOS/Sources/BeagleUI/CodeGeneration/Templatesoutput:RootOfYourProject/CodeGeneration/Generated sources:include:- RootOfYourProject- Carthage/Checkouts/beagle/iOS/Sources/BeagleUI/CodeGeneration/SourceryProtocols.swifttemplates:- Carthage/Checkouts/beagle/iOS/Sources/BeagleUI/CodeGeneration/Templatesoutput:RootOfYourProject/CodeGeneration/Generated Use By default, custom widgets need to implementinit(from decoder: Decoder) throws. This can be automated with Sourcery, like the example below:\nimport UIKit import BeagleUI enum ComponentColorTypes: String, Decodable { case veryColorful case blackAndWhite } struct SomeComponent: Widget { var widgetProperties: WidgetProperties var property1: String var property2: Double? var colorPallete: ComponentColorTypes = .blackAndWhite func toView(context: BeagleContext, dependencies: RenderableDependencies) -\u003e UIView { return UIView() } } Without the metaprogramming, it is necessary to write the following code:\nextension SomeComponent { enum CodingKeys: String, CodingKey { case property1 case property2 case colorPallete } internal init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) widgetProperties = try WidgetProperties(from: decoder) property1 = try container.decode(String.self, forKey: .property1) property2 = try container.decodeIfPresent(Double.self, forKey: .property2) colorPallete = try container.decode(ComponentColorTypes.self, forKey: .colorPallete) } } It is necessary with Sourcery, to do the structs in accordance with AutoDecodable and the same code will be generated\nThis same process works for all protocols and it is also possible to create templates and customized protocols.\nAfter the file generation AutoDecodable.generated.swift and Equality.generated.swift using Sourcery, it is necessary to insert them in the project.  Available protocols Some protocols are already on Beagle. They are located in SourceryProtocols.swift. See the list below:\n   Protocol Use     AutoEquatable Implements equatable   AutoDecodable Implements customized decodable, according to the Beagle’s pattern. It only works for structs   AutoInitiable Implements customized init, according to the Beagle’s pattern   AutoInitiableAndDecodable Protocols combination AutoInitiable and AutoDecodable    ","excerpt":" What is Sourcery? Sourcery is a code generator that helps boilerplate …","ref":"/docs-beagle/docs/resources/customization/beagle-for-ios/sourcery/","title":"Sourcery"},{"body":" O que é o Sourcery? O Sourcery é uma ferramenta de geração de código que auxilia na criação de código boilerplate, ou seja, aqueles trechos de código incluídos em mais locais com pouca ou sem alteração.\nA instalação dessa biblioteca é opcional, apesar de recomendada. Caso queira instalar, siga as instruções abaixo.\nInstalação Depois de integrar o Beagle ao seu projeto, você pode instalar o Sourcery no seu computador usando o Homebrew.\n$ brew install sourcery Configuração Depois da instalação, é necessário configurar o path dos arquivos de template, dos arquivos gerados e o path onde o Sourcery irá escanear o código fonte. Siga os passos a seguir:\nPasso 1: Em Build Phases, crie um novo Run Script Phase;\nPasso 2: Coloque ACIMA de Compile Sources; Isso é importante pois, caso não seja feito, o sourcery não irá compilar os arquivos que foram gerados.\nPasso 3: Cole o código a seguir:\nif which sourcery \u003e/dev/null; then unset SDKROOT sourcery --config $SRCROOT else echo \"warning: Sourcery not installed, download using brew install sourcery\" fi Esse script avisa o Xcode para procurar por um arquivo .sourcery.yml na raiz do seu projeto. Ele terá algumas propriedades que o Sourcery precisa saber para gerar o código.\nA lista abaixo, mostra os atributos utilizados neste arquivo:\n sources : o path de seus arquivos swift. É a raiz do projeto. templates : o path dos arquivos de template que o Sourcery vai usar para gerar o código. output : o path dos arquivos gerados.  Para mais informações e detalhes sobre o Sourcery, acesse a documentação oficial.  Configuração do arquivo .yml As configurações do arquivo .yml são diferentes devido a forma que Cocoapods e o Carthage lidam com os arquivos do Beagle.\nPara que o Sourcery use os templates do Beagle, você deve especificar o SourceryProtocols.swif em sources e o path de templates em templates.\nOs atributos escritos dentro do.yml consideram que os arquivos Cartfile ou Podfile estão no mesmo diretório que o .xcodeproj ou .xcworkspace  Cocoa Pods Carthage sources:include:- RootOfYourProject- Pods/Beagle/iOS/Sources/Beagle/CodeGeneration/SourceryProtocols.swifttemplates:- Pods/Beagle/iOS/Sources/Beagle/CodeGeneration/Templatesoutput:RootOfYourProject/CodeGeneration/Generated sources:include:- RootOfYourProject- Carthage/Checkouts/beagle/iOS/Sources/Beagle/CodeGeneration/SourceryProtocols.swifttemplates:- Carthage/Checkouts/beagle/iOS/Sources/Beagle/CodeGeneration/Templatesoutput:RootOfYourProject/CodeGeneration/Generated Utilização Por default, os Custom Widgets precisam implementar init(from decoder: Decoder) throws. Isso pode ser automatizado com o Sourcery, como no exemplo abaixo:\nimport UIKit import BeagleUI enum ComponentColorTypes: String, Decodable { case veryColorful case blackAndWhite } struct SomeComponent: Widget { var widgetProperties: WidgetProperties var property1: String var property2: Double? var colorPallete: ComponentColorTypes = .blackAndWhite func toView(context: BeagleContext, dependencies: RenderableDependencies) -\u003e UIView { return UIView() } } Sem o uso de metaprogramação, é necessário escrever o seguinte trecho de código:\nextension SomeComponent { enum CodingKeys: String, CodingKey { case property1 case property2 case colorPallete } internal init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) widgetProperties = try WidgetProperties(from: decoder) property1 = try container.decode(String.self, forKey: .property1) property2 = try container.decodeIfPresent(Double.self, forKey: .property2) colorPallete = try container.decode(ComponentColorTypes.self, forKey: .colorPallete) } } Com o Sourcery é necessário fazer as structs conformarem com AutoDecodable e o mesmo código será gerado.\nEsse mesmo processo funciona para todos os protocolos e também é possível criar templates e protocolos customizados.\nApós a geração dos arquivos AutoDecodable.generated.swift e Equality.generated.swift usando o Sourcery, é necessário inseri-los no projeto.  Protocolos disponíveis Alguns protocolos (protocols) já estão no Beagle. Eles estão localizados em SourceryProtocols.swift. Veja a lista:\n   Protocolo Uso     AutoEquatable Implementa equatable   AutoDecodable Implementa decodable customizável, de acordo com os padrões do Beagle. Funciona apenas para structs   AutoInitiable Implementa init customizável, de acordo com os padrões do Beagle   AutoInitiableAndDecodable Combinação dos protocolos AutoInitiable and AutoDecodable    ","excerpt":" O que é o Sourcery? O Sourcery é uma ferramenta de geração de código …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-ios/sourcery/","title":"Sourcery"},{"body":" You will find here the main class that are part of Beagle’s framework for Web.\n","excerpt":" You will find here the main class that are part of Beagle’s framework …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/","title":"Beagle for Web"},{"body":" O Beagle possui essas principais classes para Web: \n","excerpt":" O Beagle possui essas principais classes para Web: \n","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/","title":"Beagle para Web"},{"body":" ","excerpt":" ","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/","title":"Advanced topics"},{"body":" É possível criar ações customizadas para o seus components com o Beagle.\nCriar um ActionHandler Passo 1: Crie um interface com a propriedade obrigatória _beagleAction_ e outra com os outros valores necessários, como no exemplo abaixo onde dois parâmetros foram criados: A e B.\nO nome da ação customizada _beagleAction_\ninterface CustomAction { _beagleAction_: 'custom:myCustomAction', parameterA: string, parameterB: number } Passo 2: Crie a função ActionHandler com a seguinte interface:\nimport { ActionHandler } from '@zup-it/beagle-web' export const customAction: ActionHandler\u003cCustomAction\u003e = ({ action }) =\u003e { }  Na função ActionHandler, você pode acessar os valores definidos como no exemplo acima:action.parameterA e action.parameterB.  Passo 3: Adicione o nome da ação no arquivo de associação do seu framework.\nAngular React Para Angular: adicione beagle.module.ts\n@BeagleModule({ ... customActions:{ \"custom:myCustomAction\": customAction //nome do action handler  } }) export class Beagle {}  Para React: adicione ao seu arquivo de configuração do Beagle\nexport default createBeagleUIService\u003cany\u003e({ ... customActions:{ \"custom:myCustomAction\": customAction //nome do action handler  } })  Adicione ações ao JSON Adicione a ação customizada ao JSON e adicione os parâmetros definidos na inteface do ActionHandler.\nVeja abaixo um exemplo com button:\n{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"Clique para ação customizada\", \"onPress\": { \"_beagleAction_\": \"custom:myCustomAction\", \"parameterA\": \"Beagle Web\", \"parameterB\": 10 } }  Fique atento aos tipos de classe, quando você adicionar um parâmetro a ação cusomizada, o exemplo acima era uma string enumber.  ","excerpt":" É possível criar ações customizadas para o seus components com o …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/a%C3%A7%C3%B5es-customizadas/","title":"Ações customizadas"},{"body":" Loading Component A biblioteca do Beagle já possui por padrão um componente que é chamado quando ocorre o carregamento de uma tela. Se necessário, é possível trocá-lo por um customizado de acordo com a necessidade da sua aplicação.\nPara criar um componente loading, siga os passos abaixo:\nReact Angular No React:\nPasso 1: Crie um componente que será o substituto.\nVeja o exemplo:\nimport React, { FC } from 'react' const CustomLoadingComponent: FC\u003cany\u003e = () =\u003e { return ( \u003cdiv\u003eCarregando\u003c/div\u003e ) } export default CustomLoadingComponent Passo 2: Adicione-o à lista de componentes do Beagle Service para substituir o componente padrão:\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomLoadingComponent from '../components/CustomLoading' export default createBeagleUIService\u003cany\u003e({ baseUrl: \"localhost:4000\", components: { \"custom:loading\":CustomLoadingComponent } })  No Angular\nPasso 1: Crie um componente que será o substituto.\nVocê pode usar o angular cli se preferir com o comando para gerar automaticamente o componente, veja:\nng generate component components/custom-loading Passo 2: Depois, abra o arquivo beagle-components.module.ts e adicione o componente a lista:\nimport { NgModule } from '@angular/core' import { CustomLoadingComponent } from './components/custom-loading/custom-loading.component'; // import all the components you're going to use with beagle const components = [ CustomLoadingComponent ]; @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} Passo 3: Finalmente você pode substituir o componente padrão no arquivo beagle.module.ts\nimport { BeagleModule } from '@zup-it/beagle-angular'; import { CustomLoadingComponent } from './components/custom-loading/custom-loading.component'; // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://mypath', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { 'custom:loading': CustomLoadingComponent } }) export class Beagle { } Os arquivos beagle.module.ts e beagle-components.module.ts são gerados automaticamente pela biblioteca no angular. Se você não encontrou verifique sua instalação\n  Error Component O componente de erro padrão do Beagle é chamado quando ocorrem erros de conexão como, por exemplo, um caminho para o servidor está inacessível.\nPara este componente a biblioteca expõe uma interface chamada ErrorComponentParams, por meio dela você tem acesso a lista de erros e a um método retry, responsável por refazer a requisição para o servidor.\nErrorComponentParams    Atributo Tipo Definição     retry Método Refaz a requisição para o servidor    Usando essa interface você pode criar o componente, veja o exemplo de acordo com cada framework:\nReact Angular No React, é preciso criar um Functional Component que usa a interface ErrorComponentParams, note que ao usá-la você tem acesso à duas props errors e retry, que são respectivamente a lista de erros e o método retry ambos descritos na interface:\nimport { ErrorComponentParams } from '@zup-it/beagle-react' import React, { FC } from 'react' const CustomErrorComponent: FC\u003cErrorComponentParams\u003e = ({ retry }) =\u003e { return ( \u003c\u003e \u003cp\u003e Unexpected Error! \u003c/p\u003e \u003cbutton onClick={retry}\u003eRetry\u003c/button\u003e \u003c/\u003e ) } export default CustomErrorComponent Depois de criado basta adicioná-lo a lista de componentes do Beagle Service:\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomErrorComponent from '../components/CustomError' export default createBeagleUIService\u003cany\u003e({ baseUrl: \"localhost:4000\", components: { \"custom:error\":CustomErrorComponent } })  No Angular, crie primeiro um componente, se você preferir pode usar o angular cli para gerar automaticamente a estrutura inicial:\nng g component components/custom-error Abra o arquivo controller do componente que acabou de ser criado e adicione a interface ErrorComponentParams. A interface nos da acesso a dois @Inputs errors e retry que são respectivamente a lista de erros e o método para refazer a requisição:\nimport { Component, Input } from '@angular/core'; import { ErrorComponentParams } from '@zup-it/beagle-angular'; @Component({ selector: 'app-custom-error', templateUrl: './custom-error.component.html', styleUrls: ['./custom-error.component.less'] }) export class CustomErrorComponent implements ErrorComponentParams { @Input() retry: () =\u003e void; handleRetry() { this.retry(); } } Agora, adicione o componente criado a lista do arquivo beagle-components.module.ts\nimport { NgModule } from '@angular/core'; import { CustomErrorComponent } from './components/custom-error/custom-error.component'; // import all the components you're going to use with beagle const components = [ CustomErrorComponent ]; @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} Finalmente, substitua o componente padrão no arquivo beagle.module.ts\nimport { CustomErrorComponent } from './components/custom-error/custom-error.component'; // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4202/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { 'custom:error': CustomErrorComponent } }) export class Beagle { } Os arquivos beagle.module.ts e beagle-components.module.ts são gerados automaticamente pela biblioteca no angular. Se você não os encontrou verifique sua instalação\n  ","excerpt":" Loading Component A biblioteca do Beagle já possui por padrão um …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/carregamento-e-tratamento-de-erros/","title":"Carregamento e tratamento de erros"},{"body":" How does Beagle represent a view? The features described here are only available in versions 1.2.0 and above.  Beagle works over a tree of components and in order to work, it must follow some rules. In Typescript terms, Beagle Tree can be defined as follows:\nexport interface BeagleUIElement { _beagleComponent_: string, id: string, context?: DataContext, children?: BeagleUIElement[], style?: Style, [key: string]: any, } See below every tree’s componenent:\n _beagleComponent_ is the name of the UI component to render. id is a unique identifier for the node. Observation: although the id is required by the internal tree structure, before processing the tree, Beagle assigns random unique ids for each node without an id, making it optional in the json provided by the backend. context is a context defined for the component and its children. children is an array of nodes representing the children of the current node. style is the stylization rules for the component. These rules are not CSS, instead it’s a structure defined by Beagle; Additionally, a node has every property expected by the component itself, a text component could have text and justify, while a button could have onPress, text and disabled.  Below, we show an example of a tree of components ready to be processed by Beagle:\n{ \"_beagleComponent_\": \"container\", \"id\": \"container\", \"children\": [ { \"_beagleComponent_\": \"image\", \"id\": \"logo\", \"url\": \"https://i.ibb.co/rvRN9kv/logo.png\" }, { \"_beagleComponent_\": \"text\", \"id\": \"welcome\", \"text\": \"Welcome to the Beagle playground!\" }, { \"_beagleComponent_\": \"text\", \"id\": \"instructions\", \"text\": \"Use the panel on the left to start coding!\" }, { \"_beagleComponent_\": \"button\", \"id\": \"fast-guide\", \"text\": \"Access the fast guide\" } ] } The json above is a simpler version of the welcome page of the Beagle Playground website. It renders a container to hold the rest of the elements: an image, two texts and a button. To see the full example and the UI rendered by it, access the Beagle Playground.\nThe Beagle Payload The type defined in the last section (BeagleUIElement), you can see the id is a required property and that the children of a node must always be named children. The backend, however, may not guarantee any of that. For this reason, Beagle internally generates unique ids for every node without one and translates the children property. A table component, for instance, might have its children in the property rows. Before starting to process, Beagle converts rows to the expected name children (see section The children property).\nIn fact, the payload returned by the backend can be anything, but internally Beagle must work with a tree of components (BeagleUIElement). You must be able to traverse the tree and detect every component and its children. The payload can be anything, because it gives the developer a chance to change it before it gets processed by Beagle.\nWe recommend that the backend always return a JSON representing a tree of components, as it is expected by Beagle, but if, for some reason, it is not possible, Beagle Web makes it possible to pre-process the response and build the tree in the front-end before Beagle actually works upon it, like in lifecycles.\nThe children property You should always use an array named children to specify the child nodes of a component. But, Beagle will work out of the box, if instead of an array of components, a single node is passed, and will also work if the name child is used.\nIf a component that represents a table, the children might be named rows instead of children, in this case, you can inform Beagle that, for this specific component, the name of the property children is different. See the example below:\n@BeagleChildren({ property: 'rows' }) @Component({ // ... }) class Table { // ... } The example above is for Angular, but it would work the same way in other platforms. If your component is functional or if you don’t want to use decorators (annotations), you can use it as a function, see the example below:\nconst Table = (props) =\u003e { // ... } BeagleChildren({ property: 'rows' })(Table) ","excerpt":" How does Beagle represent a view? The features described here are …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/data-structure/","title":"Data structure"},{"body":" Criar um componente customizado O primeiro passo que você deve fazer é criar um componente comum. Para isso, crie um novo componente em seu projeto.\nAngular React Neste exemplo, o componente será criado com o nome customText. Basta utilizar o comando abaixo no seu terminal:\nng generate component components/customText --skip-import  Neste exemplo, será criado um componente chamado CustomTextComponent para renderizar um texto. Basta criar um novo arquivo chamado CustomTextComponent.tsx dentro da pasta components (se esta pasta não existir basta criá-la dentro da pasta src).\nNo arquivo criado coloque o seguinte código:\nimport React from 'react' function CustomTextComponent() { return ( \u003cp\u003eBeagle Web React\u003c/p\u003e ) } export default CustomTextComponent;  Feito isso, adicione no arquivo de associações da biblioteca Beagle do seu projeto como indicado nos exemplos a seguir.\nAngular React Abra o arquivo beagle-components.module.ts e adicione o novo CustomTextComponent gerado na lista, como no exemplo abaixo:\n... import { CustomTextComponent } from './components/custom-text/custom-text.component' // import all the components you're going to use with beagle const components = [ CustomTextComponent ] @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} No arquivo beagle.module.ts adicione seu novo componente na lista de associações\nimport { BeagleModule } from '@zup-it/beagle-angular' import { CustomTextComponent } from './components/custom-text/custom-text.component' // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. \"custom:text\": CustomTextComponent }, }) export class Beagle {} Se você não encontrou os arquivos beagle-components.module.ts ou beagle.module.ts, veja como configurar a biblioteca Beagle Web para o Angular.\n  Abra o arquivo de configuração da biblioteca Beagle em seu projeto (se você seguiu o tutorial é o arquivo beagle-service.ts) e adicione o seu componente a lista de associações.\nCaso você não tenha este arquivo em seu projeto, veja como configurar a biblioteca Beagle Web para o React.\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomTextComponent from '../components/CustomTextComponent' export default createBeagleUIService\u003cany\u003e({ baseUrl: '', components: { 'custom:text': CustomTextComponent } })  Observe que, no passo acima, a palavra custom foi adicionada para identificar os componentes. Isto fará com que a biblioteca Beagle entenda que este componente não faz parte da lista de componentes pré-definidos.\nAdicionando propriedades ao componente Para adicionar propriedades ao componente criado, siga os seguintes passos:\nAngular React Abra o arquivo custom-text.component.ts e adicione um @Input, como no código abaixo:\nimport { Component, OnInit, Input } from '@angular/core'; @Component({ selector: 'app-custom-text', templateUrl: './custom-text.component.html', styleUrls: ['./custom-text.component.less'] }) export class CustomTextComponent implements OnInit { @Input() myCustomText: string constructor() { } ngOnInit(): void { } } Feito isso, adicione a referência ao arquivo custom-text.component.html\n\u003cdiv\u003e \u003ch1\u003e{{myCustomText}}\u003c/h1\u003e \u003c/div\u003e Se você estiver com o projeto rodando, é necessário reiniciá-lo com um dos comandos:yarn serve ou npm run serve\n  No React, todos os atributos definidos no JSON podem ser acessados através de props, veja o exemplo\nimport React from 'react' interface CustomText { myCustomText: string } function CustomTextComponent(props: CustomText) { return ( \u003cp\u003e{props.myCustomText}\u003c/p\u003e ) } export default CustomTextComponent;  Criando o JSON Podemos agora adicionar o nosso componente ao arquivo JSON. Se você seguiu o tutorial, abra o arquivo payload.json e o substitua com o conteúdo abaixo, caso contrário, apenas substitua a fonte de onde o seu JSON foi guardado ou gerado.\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"custom:text\", \"myCustomText\": \"Beagle Web is Awesome\" } ] }  Parabéns, você criou seu primeiro componente customizado no Beagle!\nLembrando que este componente recebe propriedades e é renderizado pela biblioteca Beagle.\n ","excerpt":" Criar um componente customizado O primeiro passo que você deve fazer …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/componentes-customizados/","title":"Componentes customizados"},{"body":" Accessing and controlling the BeagleView The features described here are only available in versions 1.2.0 and above.  The Beagle View is the entity responsible to manage a server-driven view. It can be created through the Beagle Service via the function createBeagleView. The BeagleView can fetch a new view, update its tree, navigate, etc.\nAccessing the Beagle View A Beagle View is created in Angular or React when the component BeagleRemoteView is used. To get access to it, you should use the property onCreateBeagleView, in Angular, or viewRef in React.\nSee the examples below:\nAngular \u003cbeagle-remote-view [loadParams]=\"loadParams\" (onCreateBeagleView)=\"onCreateBeagleView($event)\"\u003e beagle-remote-view\u003e import { Component } from '@angular/core' import { BeagleView } from '@zup-it/beagle-web' @Component({ // ... }) class MyComponent { private beagleView: BeagleView | undefined // ... logBeagleView() { if (!this.beagleView) return console.log(this.beagleView)) } onCreateBeagleView(beagleView) { this.beagleView = beagleView this.logBeagleView() } } React import React, { useRef, MutableRefObject, useEffect } from 'react' import { BeagleRemoteView } from '@zup-it/beagle-react' import { BeagleView } from '@zup-it/beagle-web' const MyComponent: FC = () =\u003e { const beagleView = useRef() as MutableRefObject\u003cBeagleView | undefined\u003e // ... logBeagleView() { if (!beagleView.current) return console.log(beagleView.current) } useEffect(logBeagleView, []) return \u003cBeagleRemoteView path=\"/my-path\" viewRef={beagleView} /\u003e } In the examples above, we accessed the Beagle View and logged it. It is important to notice that you need to check for the Beagle View availability before using it. Since the Beagle View is created by a child component, it won’t be available before the children components are created.\nFetching a view To fetch a view from the backend and update the current view, you need to use the method fetch of the BeagleView.\nA fetch operation can be over the entire tree or just a branch. If it’s the entire tree, it gets replaced by the result of the request. Otherwise, the tree is kept the same, but for the branch you use fetch to update, this specific branch will get replaced by the result of the request. See an example of a call to the function fetch:\n// fetches the remote view at /my-path and uses it to replace the entire current view beagleView.fetch({ path: '/my-path' }) // fetches the remote view at /my-lazy-container and uses it to replace the component with id 'lazy' beagleView.fetch({ path: '/my-lazy-container' }, 'lazy') fetch can accept 3 parameters, they are:\n loadParams: required. object containing the parameters to control the request, the options are the following:    path: required. Path to the view in the backend.\n  fallback: optional. A Beagle Tree to fallback to in case of an error.\n  method: optional. get by default. Use this option if you need another http method.\n  headers: optional. Use this option to pass additional headers to this single request.\n  shouldShowLoading: optional. Tells wether to use or not the loadingComponent while the view loads. Will use the global configuration if not specified.\n  shouldShowError: optional. Tells wether or not to show the error component if the request fails. Will use the global configuration if not specified.\n  strategy: optional. Tells which cache strategy should be used to load this specific view. Will use the global configuration if not specified.\n  loadingComponent: optional. The loading component to use. Will use the global configuration if not specified.\n  errorComponent: optional. The error component to use. Will use the global configuration if not specified.\n anchor: optional. Id of the node to attach the resulting view to. By default, it uses the root node and it uses to update a single branch.\n  mode: optional. How to attach the resulting view to the anchor, there are four modes:\n    replaceComponent: default. Replaces the entire anchor with the result of the request.\n  replace: replaces the children of the anchor with the result of the request.\n  prepend: adds the result of the request at the start of the list of children of the anchor.\n  append: adds the result of the request at the end of the list of children of the anchor.\n  Subscribing to events You can subscribe to events in the Beagle View. There are two types of subscriptions, one that listens to every update to the tree (beagleView.subscribe) and another that listens to every error in the fetch/renderization process (beagleView.addErrorListener).\nWhen calling beagleView.subscribe, you must pass a single parameter, which is a function that receives the current rendered tree. See the example below:\nconst unsubscribeLogger = beagleView.subscribe((newTree) =\u003e { console.log('The tree was updated!') console.log(newTree) }) To remove a listener, just call the function it returned. In the previous example unsubscribeLogger().\nError listeners are registered in a similar way. The only difference is that they receive a list of errors:\nconst removeErrorListener = beagleView.addErrorListener((errors) =\u003e { console.log('Oops! An error just happened!') console.log(errors) }) By default, Beagle logs every error in the fetch/rendering process to the console. Once a custom error listener is added to the Beagle View, Beagle will stop logging errors by itself and use the treatment provided by the developer instead.\nDestroying the Beagle View To avoid memory leaks, the Beagle View must be destroyed if it won’t be used again. If you’re using Angular or React, there’s no need to worry about it, it will get done under the hood. If you’re using Beagle Web directly, you must call beagleView.destroy() when the remote view is removed from the page.\nAPI Below you can find all methods of the Beagle View and their description:\n   Attribute Type Definition     subscribe  function Receives the listener and returns a function to unsubscribe.   \naddErrorListener  function subscribes to errors. Receives the listener and returns a function to remove the listener.   fetch  function fetches a view from the backend and uses it to update the current tree.   getRenderer  function returns the renderer of the view. Can be used to update the tree directly.   getTree  function returns a copy of the currently rendered tree.   getBeagleNavigator  function returns the navigator.   getBeagleService  function returns the BeagleService that created this view.   destroy  function destroys this view.    ","excerpt":" Accessing and controlling the BeagleView The features described here …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/the-beagle-view/","title":"The Beagle View"},{"body":" O Beagle Web oferece algumas estratégias de cache, entre elas o protocolo de cache padrão do Beagle guiado pelo backend.\nOutras estratégias que você pode usar são:\n beagle-with-fallback-to-cache beagle-cache-only network-with-fallback-to-cache cache-with-fallback-to-network network-only cache-first  As duas primeiras implementam o protocolo de cache do Beagle, já as demais são independentes deste protocolo.  Onde o cache é armazenado? No framework para Web, os dados de cache são armazenados no local storage do navegador.\nTipos de estratégias No Beagle, você tem duas possibilidades de estratégia: as que são compatíveis com o protocolo de cache e as que são independentes. A seguir, você verá como funciona cada uma delas:\nEstratégias compatíveis 1. beagle-with-fallback-to-cache Estratégia padrão que implementa:\n Protocolo de cache do Beagle. A adição de um fallback.  Nela, é salvo de forma local no storage tanto a árvore quanto os metadados relacionados ao protocolo de cache (beagle-hash, max-age e um identificador da hora em que a chamada foi enviada).\nEssa estratégia permite que você use o fallback para retornar uma árvore, mesmo em casos de erro. Quando isso acontece, o fallback retorna a árvore que já tenha sido salva localmente antes (se existir), mesmo que ela esteja desatualizada.\nImportante deixar claro que essa configuração só funcionará se o backend estiver com cache habilitado.\nIsso porque o Beagle Web só extrai as informações do header das requisições. Se elas não estiverem disponíveis, as requisições serão sempre enviadas e, mesmo com o cache armazenado, ele não será utilizado, a não ser para o fallback.\nSe o seu backend estiver com cache desabilitado, os payloads da árvore serão salvos no storage e não serão utilizados.\n 2. beagle-cache-only Estratégia que implementa apenas no caso do protocolo de cache do Beagle. Isso significa que ela funciona igual à estratégia padrão, mas sem o fallback.\nQuando você habilita essa estratégia, a árvore que está no cache só é utilizada se tiver um max-age válido ou se receber o status de 304 do backend.\nCaso a requisição falhe, a view não vai ser exibida e pode não exibir o componente de erro, de acordo com a definição da config.\nEstratégias independentes 1. network-with-fallback-to-cache Estratégia que inicia a chamada no backend para trazer como resultado o que estiver salvo no cache. Esse cache só será usado em casos de falha na requisição, funcionando como fallback.\nSe a requisição falhar e o dado estiver no cache, você conseguirá fazer o retorno corretamente. Caso isso não aconteça, o componente de erro é (ou não) exibido de acordo com a definição da config.\n2. cache-with-fallback-to-network: Estratégia que inicia a chamada no cache para retornar a árvore que estiver renderizada nesse cache. Se não for encontrado nada, o fallback é realizar a chamada para buscar a árvore.\nDesta forma, a chamada só é disparada se o dado não for encontrado no cache.\nNo caso desse tipo de estratégia, não há uma estratégia de invalidação ou revalidação do cache. Enquanto o dado estiver no cache, ele é considerado válido.  3. network-only Estratégia que busca fazer chamadas exclusivamente do backend. Nesse caso, você sempre enviará a requisição para buscar as árvores a serem renderizadas.\nSe a requisição falhar, não existe fallback para exibir (ou não) o componente de erro.\nEsta é a única estratégia que não salva dados no local storage. Por isso, ela é recomendada nos casos em que você quer que o Beagle Web não salve nenhuma informação no storage.  4. cache-first: Estratégia que envia a view depois de fazer a busca no cache, mesmo que não encontre a requisição que estiver procurando.\nSe a árvore é encontrada no cache, ela é utilizada para renderizar a view. Quando a requisição retorna, a view é atualizada com o resultado da requisição. No caso de retornar algum erro, é mantida a view exibida com a informação do cache.\nComo alterar a estratégia de cache utilizada? Para mudar a estratégia de cache, você deve utilizar o parâmetro strategy com o nome da estratégia escolhida dentro no config do Beagle.\nNas configs abaixo, você encontra um exemplo de como alterar a estratégia paranetwork-only:\nAngular React @BeagleModule({ baseUrl: 'yourBackendUrlGoesHere', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, strategy: 'network-only' }) export class Beagle { }  export default createBeagleUIService({ baseUrl: \"\", components: {}, strategy: 'network-only' })  ","excerpt":" O Beagle Web oferece algumas estratégias de cache, entre elas o …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/estrat%C3%A9gias-de-cache/","title":"Estratégias de Cache"},{"body":" The features described here are only available in versions 1.2.0 and above.  We recommend you to read about Beagle tree data structure in order to help you understand rendering.\nEvery Beagle Web library has a very well defined process of how it fetches, process and renders a view. There’s an order that must always be respected and hook points where the developer can execute some code of his own (lifecycles).\nSee the full rendering process of Beagle Web:\nThe Beagle lifecycles are:\n BeforeStart BeforeViewSnapshot AfterViewSnapshot BeforeRender  They can be used as global hooks to the lifecycle:\nconst config = { // ... lifecycles: { beforeStart: (payload) =\u003e { // ... }, beforeViewSnapshot: (payload) =\u003e { // ... }, afterViewSnapshot: (payload) =\u003e { // ... }, beforeRender: (payload) =\u003e { // ... }, } } Or local hooks to the lifecycles in a per-component basis (annotations/decorators):\n// Attention: these won't work with production builds in Angular. Keep reading for more details. @BeforeStart((textComponentPayload) =\u003e { // ... }) @BeforeViewSnapshot((textComponentPayload) =\u003e { // ... }) @AfterViewSnapshot((textComponentPayload) =\u003e { // ... }) @BeforeRender((textComponentPayload) =\u003e { // ... }) @Component({ // ... }) class Text { // ... } The example above won’t work with Angular when building for production, because of the Angular compiler. To write a readable code you must choose one of two options:\n Place the comment // @dynamic before calling the decorator:  // @dynamic @BeforeRender((textComponentPayload) =\u003e { // ... }) @Component({ // ... }) class Text { // ... } Replace the arrow function for a common function and export it:  export function beforeRender(textComponentPayload) { // ... } @BeforeRender(beforeRender) @Component({ // ... }) class Text { // ... } Since annotations/decorators cannot be used for functions, if you have a functional component or if you simply don’t want to use decorators, you can use them as normal function calls:\nconst Table = (props) =\u003e { // ... } BeforeStart((textComponentPayload) =\u003e { // ... })(Table) It is important to notice, mainly for React, where Higher Order Components (HOCs) are common, that the component to receive the decorator must be the final component. For instance, if you want to apply a hoc named withTheme to your component:\nconst MyComponent: FC = () =\u003e { // ... } // This is wrong, it has no effect! // BeforeRender(myLifecycleFunction)(MyComponent) // export default withTheme(MyComponent) // You need to apply the decorator to the final component instead: const MyComponentWithTheme = withTheme(MyComponent) BeforeRender(myLifecycleFunction)(MyComponentWithTheme) export default MyComponentWithTheme The return value of a lifecycle hook can be either nothing (undefined) or a tree. If it is a tree, the rendering process will discard the previous tree and start working on the tree returned by the hook.\nTo take control over the rendering process, besides the lifecycles, Beagle also offers the Renderer API, which can be accessed through BeagleView.getRenderer(). The BeagleView can be accessed via the BeagleRemoteView component through the attributes onCreateBeagleView, in Angular and viewRefin React.\nAnother way to get access to the BeagleView is through the ViewContentManager API, which can be found under this.viewContentManager in an Angular component that extends BeagleComponent; or under props.viewContentManager in a React component that implements the BeagleComponent interface.\nProcess and lifecycles Lifecycles deprecates the feature middlewares. Middlewares will still be supported at least until the next major version (2.0.0) and they will be interpreted as they were part of the global lifecycle beforeViewSnapshot.  Beagle Web has a very well defined process from when a new payload is received to the moment it gets rendered in the browser screen. We also have some “breakpoints” in this process where you do your own stuff, this is called breakpoints “lifecycles”.\nProcess to render a view See below the steps to render a view:\n Run the global beforeStart hook; Run the beforeStart hook of each component; Identify the children of each component considering the decorator “BeagleChildren”; Assign an id to every node that doesn’t have one yet; Remove any properties of the object that has a null value (nulls are interpreted as inexistent in Beagle); If needed, pre-fetch views that could be accessed next; Run the global beforeViewSnapshot hook; Run the beforeViewSnapshot hook of each component; Takes a snapshot of the current tree and stores it. From now on, any reference to the current rendered tree will be referencing the copy. Starts processing a copy of the snapshotted view, the next lifecycles will run over this copy. Run the global afterViewSnapshot hook; Run the afterViewSnapshot hook of each component; Deserialize beagle actions into javascript functions; Evaluate contexts and expressions; Interpret styles, converting the Beagle styling syntax to css; Run the global beforeRender hook; Run the beforeRender hook of each component; Hand the component tree to the render function. This function is different in Angular and React.  Lifecycles There are four lifecycle hooks, but you probably want to use just two of them: beforeViewSnapshot and beforeRender. The main difference between them is that the first runs before any expression or action has been evaluated and the second runs after. Also important to notice is that, when using the Renderer API, doFullRender will run both lifecycles, but doPartialRender will run only the beforeRender lifecycle.\nA simple rule to decide if you want to alter the tree via beforeViewSnapshot or beforeRender is: if your modification doesn’t depend on the result of an expression, use beforeViewSnapshot otherwise usebeforeRender.\nA lifecycle hook receives the Beagle Tree and returns either nothing (undefined) or a tree. If it is a tree, the rendering process will discard the previous tree and start working on the tree returned by the hook. If it’s a global lifecycle, by “tree” we mean the entire Beagle Tree, if it’s a component lifecycle, by “tree”, we mean the branch corresponding to the component.\nBelow, see detailed explanations and examples of each lifecycle:\nBeforeStart This lifecycle runs before anything else. Here it should be done modifications that must happen before any id is assigned or any children property is computed. Since it runs so early, if the payload is not at all what Beagle expects, here is the place to completely change it.\nSince the children translation has not run yet, components decorated with @BeforeStart might not run at all, since they might not be considered part of the tree. Take, for instance, a text inside a component table that has its children defined by the property rows. In this lifecycle, Beagle has no idea that rows actually represents the children of table and when traversing the tree, it would ignore everything inside rows, including the text we mentioned.\nThis is the only lifecycle where new nodes can be added to the tree and not have ids. Every lifecycle after this is run after the ids are assigned, i.e. if they add a new node, they must also provide its id.\nExamples of usage Custom ID generator This lifecycle can be used to ignore Beagle’s default id generation and use one of your own. Since Beagle only computes random ids for nodes without id’s, you can use this lifecycle to assign your own unique ids to every node.\nconst config = { // ... lifecycles: { beforeStart: (tree) =\u003e { let next = 1 function assignIds(data: any) { // if it's not a component or not a structure that can have a component inside, return if (!data || typeof data !== 'object') return // if it's an array, assign ids to the components inside if (Array.isArray(data)) return data.forEach(assignIds) // if it is a component node, assign an ID if (data._beagleComponent_) data.id = `myAppID-${next++}` // if it's an object, assign ids to the components inside const keys = Object.keys(data) keys.forEach(key =\u003e assignIds(data[key])) } assignIds(tree) } } } Complex children calculation\nAnother use case would be complex children calculations. Let’s say the children of a table component is actually the union of three properties: header, rows and footer. This cannot be expressed via the decorator @BeagleChildren and is not at all what Beagle expects. This lifecycle could be used to remove these properties from the original JSON and create the property children, which would be the union of the three.\nimport { BeforeStart } from '@zup-it/beagle-web' @BeforeStart((table) =\u003e { table.children = [header, ...rows, footer] delete table.header delete table.rows delete table.footer }) class Table { // ... } The code above works only if every other component has children as the name of the property that represents its children. If this is not the case, a global lifecycle should be used instead.\nThis feature could also be implemented using BeforeViewSnapshot, but, in this case, you’d have to assign id’s to every node inside the new property children, since in BeforeViewSnapshot the ids have already been assigned. See the example here.\nBeforeViewSnapshot Runs just before the view snapshot, useful to alter the payload, but after the ids were already assigned. This is where you should do most of your modifications to the tree, since id’s have already been assigned and the tree structure is ready to be traversed.\nThe only thing we must be aware of is: if we create any new node, we must assign an id to it.\nExample of usage Writing a shortcut to control text-inputs The component beagle:textInput can be controlled through a context. Let’s see an example where the value of the input “email” is controlled by the context property email.address and the input “message” is controlled by the context property email.message.\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"email\", \"value\": { \"address\": \"\", \"message\": \"\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"E-mail\", \"value\": \"@{email.address}\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"email\", \"path\": \"address\", \"value\": \"@{onChange.value}\" } ] }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Message\", \"value\": \"@{email.message}\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"email\", \"path\": \"message\", \"value\": \"@{onChange.value}\" } ] }, ] } It is possible to add a shortcut. Let’s say whenever the json brings the property model we create the entire structure automatically? In model, it must be typed which value in the context will control the input. Let’s see the same example, but now using this new property model that we just came up with.\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"email\", \"value\": { \"address\": \"\", \"message\": \"\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"E-mail\", \"model\": \"email.address\" }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Message\", \"model\": \"email.message\" } ] } Much simpler, right? But for this to work, we still need to write the lifecycle that will transform model to the expected structure.\nimport { BeforeViewSnapshot } from '@zup-it/beagle-web' @BeforeViewSnapshot((component) =\u003e { component.value = `@{${component.model}}` component.onChange = component.onChange || [] const [contextId, ...path] = component.model.split('.') component.onChange.push({ _beagleAction_: 'beagle:setContext', contextId, path: path ? path.join('.') : undefined, value: \"@{onChange.value}\" }) }) @Component({ // ... }) class TextInput { // ... } With this code, despite receiving model from the backend, the payload processed by Beagle will have the expected values.\nThis example might not have worked if it was placed under the lifecycle BeforeStart. This is because, at this time, the children wouldn’t have been interpreted yet. Let’s say we had a component custom:table where the children is placed under the property rows and inside one of the rows there was a beagle:textInput. The property model wouldn’t be transformed for this particular text input, because, by this time (BeforeStart), Beagle still has no idea that rows are the children of a custom:table and the beagle:textInput would’ve been inaccessible.\nComplex children calculation with BeforeViewSnapshot The example from the previous lifecycle (BeforeStart) could also have been done here without the danger of skipping the component’s lifecycle due to a children property named incorrectly. The only difference is that we’d must assign the ids ourselves:\nimport { BeforeViewSnapshot, Tree, Component } from '@zup-it/beagle-web' @BeforeStart((table) =\u003e { table.children = [header, ...rows, footer] delete table.header delete table.rows delete table.footer // assigns a random id for each component in the tree table.children Tree.forEach(table.children, Component.assignId) }) class Table { // ... } AfterViewSnapshot When using the Renderer API we have two different types of render: full renders and partial renders. The two previous lifecycles will run only in full renders, while this lifecycle and the next runs on both full and partial renders.\nDifferently from the two previous lifecycles, the changes done here are valid for the current render only. Since any update to the view is done over a tree based on the snapshotted view, the modifications done in this lifecycle are not permanent and will be executed in every render. For instance, if we have a property counter with the value 0 in the tree and in our lifecycle we increment counter by 1. In the 5th full render these would be the values for counter depending on which lifecycle was used:\n BeforeStart: 5 BeforeViewSnapshot: 5 AfterViewSnapshot: 1 BeforeRender: 1  This lifecycle can be used to run code that needs to run every time the view is rendered but doesn’t require actions, context, expressions and styles to have already been processed.\nExample of usage Contexts are defined, referenced and manipulated in the JSON of the view. But what if we want to access data of the application and not the view itself? Beagle offers a feature called “Global context” that is able to deal with this scenario, but suppose there is no Global context, we can still implement this behavior by using the AfterViewSnapshot lifecycle.\nLet’s say we have a financial application and we want to show the user’s balance. We must guarantee that, in every re-render the most recent value for the balance will be used.\n{ \"_beagleComponent_\": \"container\", \"context\": { \"id\": \"user\", \"value\": { \"name\": \"\", \"balance\": 0 } }, \"children\": [ { \"_beagleComponent_\": \"text\", \"text\": \"@{user.name}, your balance is $@{user.balance}\" } ] } In the JSON above, we use the context user, where it starts with empty values and the view has no way of knowing the correct values. Now, replace the values of the context in the JSON by the values you have in your application. See the example below:\nimport Tree from '@zup-it/beagle-web' function findContextById(tree, id) { const it = Tree.iterator(tree) let next = it.next() while (!next.done) { const component = next.value if (component.context \u0026\u0026 component.context.id === id) return component.context next = it.next() } } const config = { // ... lifecycles: { afterViewSnapshot: (payload) =\u003e { const userContext = findContextById(payload, 'user') const userData = getUserData() // this method gets the user data from the application userContext.name = userData.name userContext.balance = userData.balance } } } The code above tells Beagle to replace the values in the context “user” by the values in the application. This piece of code cannot be placed before the view is snapshotted because we have the requirement to update the balance value in every render. It also can’t be placed in the next lifecycle (BeforeRender), because the context would then be already evaluated and our values wouldn’t be processed.\nIt is important to notice that the action setContext would not work over the context user, since we are always replacing the values for this context before processing any expression. This is just an example to show how this lifecycle could be used. To use application values in your beagle view, it is always preferred to use the global context.\nBeforeRender The changes here are valid for the current render only and is executed in every render. The difference from BeforeRender to AfterViewSnapshot, is that it is guaranteed that all actions, expressions and styles have already been processed.\nExample of usage When the backend decided to express colors in the following format: { red: number, green: number, blue: number }. For example, black would be { red: 0, green: 0, blue: 0 }. This is not a valid color for browsers, so we decide to convert the value of every color property to a valid RGB format. Basically, the function that could do this work is the following:\nconst colorProperties: ['color', 'backgroundColor', 'borderColor'] function fixColorCodes(componentPayload) { const style = componentPayload.style if (!style) return colorProperties.forEach((property) =\u003e { if (!style[property]) return style[property] = `rgb(${style[property].red}, ${style[property].green}, ${style[property].blue})` }) } Now, just need to run the function above for every component in the tree. If you want to have a dynamic behavior for the color by changing it via the context feature, check the JSON below:\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"bgColor\", \"value\": { \"red\": 255, \"green\": 255, \"blue\": 255 }, }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"My dynamically colored text\", \"style\": { \"backgroundColor\": \"@{bgColor}\" } }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"red\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 255, \"green\": 0, \"blue\": 0 } } ], \"_beagleComponent_\": \"beagle:button\", \"text\": \"green\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 0, \"green\": 255, \"blue\": 0 } } ], \"_beagleComponent_\": \"beagle:button\", \"text\": \"blue\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 0, \"green\": 0, \"blue\": 255 } } ] } ] } The text starts with a white background and as soon as the user presses a button, the background color changes.\nIf you call fixColorCodes before the context is evaluated, it will be trying to execute it over the string @{bgColor} instead of the object { red: 255, green: 255, blue: 255 } which will get you a massive runtime error, since red, green or blue are not properties of a string.\nBeforeStart, BeforeViewSnapshot and AfterViewSnapshot are executed before the context gets evaluated, so everything that might be affected by the context, must be executed in the last lifecycle: BeforeRender.\nimport { Tree } from '@zup-it/beagle-web' const config = { // ... lifecycles: { // ... beforeRender: tree =\u003e Tree.forEach(tree, fixColorCodes), } } The Renderer API For fine control of the rendering process, Beagle also let you manage when to render a new tree to your Beagle View. You can have a component, that when clicks changes the current Beagle Tree, so a new component is added or a property is modified.\nA common scenario is when you need to create an action that modifies the current tree. Take for example the action addChildren, when executed, it must get the current tree and add the given children to the component with the given id. To do it, we must have a way to get the current tree, modify it and tell the Beagle View to render it again.\nA renderization can be one of two processes: a full renderization or a partial renderization. The first runs all steps of the renderization (1 to 8 in this list). The second executes only the view snapshot and the steps after it (9 to 18 in this list).\nAccessing the Renderer Each Beagle View has its renderer, to get access to it, you must call beagleView.getRenderer().\nSee examples of how to get the renderer:\n In React: a reference to the BeagleView can be obtained through the property viewRef of the BeagleRemoteView:  import React, { FC, useRef, useEffect, MutableRefObject } from 'react' import { BeagleRemoteView } from '@zup-it/beagle-react' import { BeagleView } from '@zup-it/beagle-web' const Home: FC = () =\u003e { const beagleView = useRef() as MutableRefObject\u003cBeagleView | undefined\u003e useEffect(() =\u003e { if (beagleView.current) { const renderer = beagleView.current.getRenderer() } }, []) return ( \u003cBeagleRemoteView path=\"/home\" viewRef={beagleView} /\u003e ) }  In Angular: you can use the attribute onCreateBeagleView of the beagle-remote-view component:  import { Component } from '@angular/core' import { LoadParams, BeagleView } from '@zup-it/beagle-web' @Component({ selector: 'home', template: '', }) export class Home { loadParams: LoadParams private beagleView: BeagleView constructor() { this.loadParams = { path: '/home' } } onCreateBeagleView(beagleView: BeagleView) { this.beagleView = beagleView } getRenderer() { return this.beagleView \u0026\u0026 this.beagleView.getRenderer() } } When inside a component rendered by Beagle, you can use the ViewContentManager to get the BeagleView and obtain access to the renderer.\nWhen inside an action handler (custom actions), the Beagle View is provided via parameter, which can be used to get the renderer. See the example below:\nconst MyCustomActionHandler: ActionHandler\u003cMyCustomAction\u003e = ({ action, beagleView }) =\u003e { const renderer = beagleView.getRenderer() // ... } Using the Renderer The renderer has only two functions: doFullRender and doPartialRender.\n doFullRender: renders the tree passed as parameter by running all rendering steps over it. Full renders must be done every time new nodes are created doPartialRender: it only runs the view snapshot and the steps after that. Partial renders should be used to modify existent nodes.  The tree received by doFullRender is of type BeagleUIElement, for example, it might or not have ids. The tree received by doPartialRender is of type IdentifiableBeagleUIElement:\nExample: it must have ids for every node. You can never pass a tree to doPartialRender with missing ids.\nBesides the type of the tree, there is no difference to the way we call doFullRender and doPartialRender. They both accept the following parameters:\n The first parameter is the tree. The second parameter is optional and it is the anchor. If the anchor is not specified, the tree passed in the first parameter will replace the entire currently rendered tree. If the anchor is specified, the tree passed as parameter will be attached to the currently rendered tree at the same position as the node with the id referenced by anchor. How the attachment is done is defined by the third parameter. The third parameter is optional and it is the mode. If the mode is not defined, it is treated as replaceComponent. There are four different modes:  replaceComponent: replaces the node with the same id as the parameter anchor (or the root if no anchor is specified) with the tree passed in the first parameter. replace: replaces the children of the node with the same id as the parameter anchor (or the root if no anchor is specified) with the tree passed in the first parameter. prepend: pre-pends the tree passed in the first parameter to the children of the node with the same id as the parameter anchor (or the root if no anchor is specified). append: appends the tree passed in the first parameter to the children of the node with the same id as the parameter anchor (or the root if no anchor is specified).    Examples: /* example 1: renders a container with an empty list */ beagleView.getRenderer().doFullRender({ _beagleComponent_: 'beagle:container', children: [ _beagleComponent_: 'custom:list', id: 'list', ], }) /* example 2: adds a property to the root of the currently rendered tree */ const current = beagleView.getTree() current.newProperty = 'new' beagleView.getRenderer().doPartialRender(current) /* example 3: adds an element to the \"custom:list\" inside the container */ const item = { _beagleComponent_: 'beagle:container', children: [ { _beagleComponent_: 'beagle:text', text: 'Client name: Jasnah Kholin' }, { _beagleComponent_: 'beagle:text', text: 'Client age: 30' } ] } // we should always do full renders when creating new nodes beagleView.getRenderer().doFullRender(item, 'list', { mode: 'append' })  With the renderer API you get to alter the view whenever you want. You can’t, for instance, call renderer.doFullRender(tree, componentId) in the onInit of the Angular component with id componentId. If this is done, Beagle will remove a component of the tree before it even gets the chance to be fully rendered. Cases like this can happen using the Beagle Renderer inside components lifecycles, so be careful!\nA solution to the example given would be to replace the children of the component instead of the component itself (renderer.doFullRender(tree, componentId, 'replace')).\n The ViewContentManager API List view component is a component that needs to use the Renderer API, but how do we access the renderer from the component itself? In both Angular and React this can be done via the ViewContentManager.\nThe ViewContentManager provides a way to access the Beagle View and the node in the current Beagle Tree that gave origin to the component being rendered and with that you can access the renderer and call re-renders for this specific component.\nAccessing the ViewContentManager React The ViewContentManager can be accessed inside a React component if this component implements the BeagleComponent interface.\nSee below an example to re-render the component with a new set of children based on the data source and the template:\nimport React, { FC, useRef, useEffect, MutableRefObject } from 'react' import { BeagleComponent } from '@zup-it/beagle-react' interface ListViewInterface extends BeagleComponent { // ... } const ListView: FC\u003cListViewInterface\u003e = (props) =\u003e { useEffect(() =\u003e { /* Once the component implements the BeagleComponent interface, we have access to the viewContentManager, but if the component was not instantiated by Beagle, the viewContentManager will be undefined. We must verify it before continuing. */ if (!props.viewContentManager) return const children = createChildrenFromTemplate(props.dataSource, props.template) const element = props.viewContentManager.getElement() element.children = children props.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id) }, [props.dataSource, props.template]) return ( // ... ) } The re-render happens every time the data source or the template changes.\nAngular In Angular, if you need access to the ViewContentManager, the component class must extend BeagleComponent, then, you just need to reference this.viewContentManager.\nimport { Component, Input } from '@angular/core' import { BeagleComponent } from '@zup-it/beagle-angular' @Component({ // ... }) export class ListView extends BeagleComponent { // ... renderDataSource() { /* Checks if the viewContentManager is available. If the components has not been created by Beagle, it won't be. */ if (!this.viewContentManager) return const children = this.createChildrenFromTemplate(this.dataSource, this.template) const element = this.viewContentManager.getElement() element.children = children this.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id) } } The method renderDataSource should be called every time the data source or the template changes.\nUsing the ViewContentManager The ViewContentManager have the following properties/functions\n   Property Type Definition     \u003cb\u003e\u003c/b\u003e\ngetElement()  function returns the node in the Beagle Tree responsible for the renderization of the component.   \ngetElementId()  function shortcut to getElement().id    getBeagleView()  function returns the BeagleView responsible for the view containing the component.    Updating the view with the result of a request In case you need to update the current view with a tree that comes from the backend, you should use the method fetch of the BeagleView. It will internally use all the cache mechanisms of Beagle and also do the rendering part.\n","excerpt":" The features described here are only available in versions 1.2.0 and …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/rendering/","title":"Rendering"},{"body":" O Beagle Web envia dois tipos de headers que são padrões para o Beagle:\n beagle-platform: header utilizado que indica para o backend que a requisição partiu da Web. Desta forma, o valor enviado é sempre WEB. beagle-hash: header utilizado para o correto funcionamento do protocolo de cache de Beagle.  Por padrão, esses headers são sempre enviados, porém podem ser desabilitados pelo parâmetro useBeagleHeaders na config.\nAbaixo, você confere exemplos de como desabilitar o envio desses headers nas configs do Angular e React:\nAngular React @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: {}, useBeagleHeaders: false }) export class Beagle { }  export default createBeagleUIService({ baseUrl: \"\", components: {}, useBeagleHeaders: false })  Você deve manter os headers habilitados para o correto funcionamento do protocolo de cache do Beagle.  ","excerpt":" O Beagle Web envia dois tipos de headers que são padrões para o …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/headers-padr%C3%B5es/","title":"Headers Padrões"},{"body":" Introduction It is possible to create customized actions with Beagle for your components.\nCreate an ActionHandler Step 1: Create an interface with the required property _beagleAction_ and with other necessary values, like the example below, where two parameters were created: A and B.\n__The customized action name is _beagleAction_\ninterface CustomAction { _beagleAction_: 'custom:myCustomAction', parameterA: string, parameterB: number } Step 2: Create the function ActionHandler with the interface:\nimport { ActionHandler } from '@zup-it/beagle-web' export const customAction: ActionHandler\u003cCustomAction\u003e = ({ action }) =\u003e { }  In the ActionHandler function, you can access the defined values like the example above: action.parameterA or action.parameterB.  Step 3: Add the action name in the association file according to your framework:\nAngular React For Angular: Add beagle.module.ts\n@BeagleModule({ ... customActions:{ \"custom:myCustomAction\": customAction //nome do action handler  } }) export class Beagle {}  For React: add to your Beagle configuration file\nexport default createBeagleUIService\u003cany\u003e({ ... customActions:{ \"custom:myCustomAction\": customAction //nome do action handler  } })  Adding actions to JSON Add the customized action to the JSON and add the defined parameters in the ActionHandler interface\nSee below an example with a button:\n{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"Clique para ação customizada\", \"onPress\": { \"_beagleAction_\": \"custom:myCustomAction\", \"parameterA\": \"Beagle Web\", \"parameterB\": 10 } }  Pay attention to the class types when you add a customized action parameter, the example above was string and number.  ","excerpt":" Introduction It is possible to create customized actions with Beagle …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/customized-actions/","title":"Customized Actions"},{"body":" Beagle Remote View A biblioteca do Beagle fornece um componente auxiliar para renderizar as telas server-driven, o remote view:\nAngular React \u003cbeagle-remote-view [loadParams]=\"loadParams\"\u003e\u003c/beagle-remote-view\u003e  \u003cBeagleRemoteView {...loadParams} /\u003e  Tanto no Angular como no React, o remote view aceita propriedades que são chamadas de Load Params. É por meio dela que algumas opções são configuradas para influenciar a maneira como as telas são renderizadas.\nVeja abaixo as propriedades aceitas, apenas path é obrigatória:\nimport { LoadParams } from '@zup-it/beagle-web'; const params: LoadParams = { path: '/payload.json', fallback: {_beagleComponent_: 'beagle:text', text:'Fallback Error'}, method: 'get', headers: {'header': 'value'}, shouldShowLoading: true, shouldShowError: true, strategy: \"network-only\", loadingComponent: 'myComponentLoading', errorComponent: 'myComponentError' }    Propriedade Tipo Descrição     path string Obrigatória. Caminho do servidor para carregar o JSON com a tela server-driven.   fallback BeagleComponent Componente para ser renderizado caso a requisição falhe.   method método Http Método Http para fazer a requisição.   headers Mapa\u003cchave, valor\u003e Lista de header para anexar ao fazer a requisição.   shouldShowLoading booleano Mostra ou não o componente de loading.   shouldShowError booleano Mostra ou não o componente de erro.   strategy string\u003cEstratégia de cache\u003e Estratégia de cache adotada na requisição.   loadingComponent string Componente customizado para loading.   errorComponent string Componente customizado para error.    ","excerpt":" Beagle Remote View A biblioteca do Beagle fornece um componente …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/par%C3%A2metros-remote-view/","title":"Parâmetros Remote View"},{"body":" Creating a customized component To create a customized component, follow the next steps:\n You need an ordinary component, after that you have to create a new one in your project:  Angular React The component will be created with customText name, in this example. In your terminal, use the following command:\nng generate component components/customText --skip-import  Here, a component will be created to render a CustomTextComponent text.\nimport React from 'react' function CustomTextComponent(){ return ( \u003cp\u003eBeagle Web React\u003c/p\u003e ) } export default CustomTextComponent;  Now, add Beagle’s library association in your project  Angular React Open beagle-components.module.ts file and add the new CustomTextComponent generated in the list, see the example below:\n... import { CustomTextComponent } from './components/custom-text/custom-text.component' // import all the components you're going to use with beagle  const components = [ CustomTextComponent ] @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on  ], }) export class BeagleComponentsModule {} On beagle.module.ts file, add your new component in the association’s list:\nimport { BeagleModule } from '@zup-it/beagle-angular' import { CustomTextComponent } from './components/custom-text/custom-text.component' // import all the components you wish to use with Beagle.  @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component.  \"custom:text\": CustomTextComponent }, }) export class Beagle {} If you didn’t find the beagle-components.module.ts files or beagle.module.ts, see how to configure Beagle’s library in your project. \n  Now, access Beagle’s library configuration file in your project and add your component to the association list. If you don’t have this file in your project,learn here how to configure Beagle Web React library. \nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomTextComponent from '../components/CustomTextComponent' export default createBeagleUIService\u003cany\u003e({ baseUrl: '', components: { 'custom:text': CustomTextComponent } })  On the step below, the word custom was added to identify the components, this will make Beagle’s library understand that this component does not belong to the predefined component’s list.\nAdding properties to the component To add properties to the created component, follow the next steps:\nAngular React  Open the custom-text.component.ts file and add an @Input like the code below:  import { Component, OnInit, Input } from '@angular/core'; @Component({ selector: 'app-custom-text', templateUrl: './custom-text.component.html', styleUrls: ['./custom-text.component.less'] }) export class CustomTextComponent implements OnInit { @Input() myCustomText: string constructor() { } ngOnInit(): void { } } Add the reference to the file custom-text.component.html  \u003cdiv\u003e \u003ch1\u003e{{myCustomText}}\u003c/h1\u003e \u003c/div\u003e If you have a project that is currently running, it is necessary to restart with the commands: yarn serve or npm run serve\n  On React, all the attributes defined in the JSON can be accessed through props, see the example:\nimport React from 'react' function CustomTextComponent(props){ return ( \u003cp\u003e{props.myCustomText}\u003c/p\u003e ) } export default CustomTextComponent;  Creating a JSON Now you can add your component to a JSON file:\n{ \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"custom:text\", \"myCustomText\":\"Beagle Web is Awesome\" } ] }  Done! You have created a customized component that receives properties and it is rendered by Beagle’s library.  ","excerpt":" Creating a customized component To create a customized component, …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/custom-component/","title":"Custom Component"},{"body":" Beagle Service Para usar a biblioteca Beagle se faz necessária a criação de um Beagle Service com as configurações de onde e como buscar as telas server-driven.\n No React você pode facilmente criar um Beagle Service por meio da função createBeagleService(beagleServiceOptions)\n  No Angular o código base é gerado automaticamente e as propriedades podem ser modificadas e adicionadas em beagle.module.ts\n O objeto de configuração possui as propriedades a seguir:\n   Atributo Tipo Default Obrigatório Descrição     baseUrl string  ✓ URL para o servidor com as telas (JSON) no formato Beagle   components Map\u003cstring,Component\u003e  ✓ Um mapa de componentes que serão renderizados através da biblioteca Beagle. Os valores são pares chave e valor onde a chave é o identificador Beagle e sempre começará por beagle: ou custom:. Já o valor será o componente ligado ao identificador   strategy Strategy beagle-with-fallback-to-cache  Estratégia de cache aplicada nas requisições de telas ao servidor   fetchData fetch   Permite adicionar uma função customizada para fazer requisições HTTP.   analytics Analytics   Permite o uso de handlers para a captura e tagueamento de alguns eventos.   customActions Map\u003cstring,ActionHandler\u003e   Um mapa de ações customizadas que podem ser interpretadas pela biblioteca Beagle. É um mapa chave e valor onde a chave será sempre um identificador começado por beagle: ou custom: e o valor será o ActionHandler ligado aquela ação.   lifecycles LifeCycleHook   Um mapa global para adicionar comportamentos aos ciclos de vida dos componentes. Cada ciclo ocorre no processo de renderização das telas, antes dos componentes se tornarem HTML   customStorage Storage localStorage  Substitui o localStorage padrão dos browsers   useBeagleHeaders boolean true  Usar ou não headers específicos do Beagle ao fazer as requisições de telas para o servidor   navigationControllers Map\u003cstring, NavigationController\u003e   Permite adicionar opções de controle de reposta visual, como mostrar ou não itens de carregamento e componentes de erro    ","excerpt":" Beagle Service Para usar a biblioteca Beagle se faz necessária a …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/par%C3%A2metros-beagle-service/","title":"Parâmetros Beagle Service"},{"body":" Beagle Web offers some cache strategies, one of them is the Beagle’s pattern cache protocol guided by the backed.\nOther strategies you are able to use:\n beagle-with-fallback-to-cache beagle-cache-only network-with-fallback-to-cache cache-with-fallback-to-network network-only cache-first  The two first implements Beagle’s cache protocol, the others are independent from it.  Where is the cache stored? On the web, the cache data are stored in the browser.\nTypes of strategies You have two strategy possibilities on Beagle: the ones that are compatible with the cache protocol and the others that are independent. You will see next how each works:\nCompatible strategies 1. beagle-with-fallback-to-cache Standard strategy that implements:\n Beagle’s cache protocol. Adding to a fallback.  Here, it is locally saved on the storage the tree and the related cache protocol metadata (beagle-hash, max-age and a time identifier that shows the time the request has been sent).\nThis strategy allows you to use a fallback to return a tree, even in some error cases. When this happens, the fallback returns a tree that has already been locally saved before (if it exists), even if it is not updated.\nIt is important to make it clear, this configuration will only work if the backend has the cache enabled.\nBeagle Web only extracts the header information from the requests. If they are not available, the request will always be sent and even with the stored cache, it won’t be used, the exception is the for a fallback.\nIf you backend is with disabled cache, the payload from the tree will be saved on the storage and it will not be used.\n 2. beagle-cache-only This strategy only implements Beagle’s cache protocol. This means that, it works the same way the standard one, but without the fallback.\nWhen you enable this strategy, the tree that is on cache it is only used if there is a valid max-age or if it receives a 304 status from the backend.\nIn case the request fails, the view will not be displayed and it can not exhibit the error component, according to the config definition.\nIndependents strategies 1. network-with-fallback-to-cache This strategy starts the request on backend to bring as a result what it is saved on cache. This cache will only be used in case the request fails, working as fallback.\nIf the request fails and the data is on cache, you will be able to make the return correctly. In case this does not happens, the error component is (or not) displayed according the to the config definition.\n2. cache-with-fallback-to-network: This one starts the request on cache to return the tree that it is rendered in this cache. If nothing is found, the fallback will make a request to search the tree.\nThis way, the request is only triggered if the data is not found on cache.\nOn this kind of strategy, there isn’t an invalid one or a cache revalidation. While the data is on cache, it is considered valid.  3. network-only This strategy makes exclusive backend requests. On this case, you will always send a request to search the trees to be rendered.\nIf the request fails, there isn’t a fallback to display (or not) the error component.\nThis is the only strategy that does not save data on local storage. For that, this one is recommended for cases you want Beagle Web to not save any information on the storage.  4. cache-first: This one sends the view after searching on cache, even if it doesn’t find the request that it is looking for.\nIf the tree is found on cache, it is used to render the view. When the request returns, the view is updated with the request result. In case it returns an error, the displayed view is kept with the cache information.\nHow do I alter the cache strategy used? To change the cache strategy, you have to use the strategy parameter with the strategy name chosen inside Beagle’s config.\nOn the configs below, you will find an example on how to alter the strategy to network-only:\nAngular  @BeagleModule({ baseUrl: 'yourBackendUrlGoesHere', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { // Associate every beagle component to your angular component. }, strategy: 'network-only' }) export class Beagle { }  ","excerpt":" Beagle Web offers some cache strategies, one of them is the Beagle’s …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/cache-strategy/","title":"Cache strategy"},{"body":" ","excerpt":" ","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/t%C3%B3picos-avan%C3%A7ados/","title":"Tópicos avançados"},{"body":" Beagle Web sends two types of headers that are a standart for Beagle:\n beagle-platform: header used to indicate to the backend that this request came from the Web. This way, the value is sent is always WEB. beagle-hash: header used to make Beagle’s cache protocol work properly.  By pattern, these headers are always sent, however it can be disabled by the useBeagleHeaders parameter on the config.\nSee below the examples on how to disable the headers request on the Angular and React’s configs.\nAngular React @BeagleModule({ baseUrl: 'http://localhost:4200/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: {}, useBeagleHeaders: false }) export class Beagle { }  export default createBeagleUIService({ baseUrl: \"\", components: {}, useBeagleHeaders: false })  You must keep the headers enabled to make Beagle’s cache protocol working properly.  ","excerpt":" Beagle Web sends two types of headers that are a standart for Beagle: …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/standard-headers/","title":"Standard headers"},{"body":" Como o Beagle representa a view? As features descritas aqui estão disponíveis apenas nas versões acima de 1.2.0.  Beagle trabalha em uma árvore de componenentes e para fazer funcionar, é preciso seguir algumas regras. Nos termos do Typescript, a árvore do Beagle pode ser definida como:\nexport interface BeagleUIElement { _beagleComponent_: string, id: string, context?: DataContext, children?: BeagleUIElement[], style?: Style, [key: string]: any, } Veja abaixo cada componente da árvore:\n _beagleComponent_ é o nome do componenete UI a ser renderizado; id é o identificador único para o node. Observação: mesmo que o id é obrigatório pela estrutura interna da árvore, antes de processá-la, o Beagle atribui um id único qualquer para cada node sem um id, tornando-o opcional no json fornecido pelo backend. context é um contexto definido para um componente e seus filhos. children é uma array de nodes representando os filhos que estão no node atual. style é a regra de estilização dos componentes. Essas regras não são CSS, mas estruturas definidas pelo Beagle. O node possui propriedades esperadas pelo próprio componente, como text, que poderia ter text e justify, enquanto o botão poderia ter onPress, text e disabled.  Veja abaixo um exemplo da árvore de componentes, pronta para ser processada pelo Beagle:\n{ \"_beagleComponent_\": \"container\", \"id\": \"container\", \"children\": [ { \"_beagleComponent_\": \"image\", \"id\": \"logo\", \"url\": \"https://i.ibb.co/rvRN9kv/logo.png\" }, { \"_beagleComponent_\": \"text\", \"id\": \"welcome\", \"text\": \"Welcome to the Beagle playground!\" }, { \"_beagleComponent_\": \"text\", \"id\": \"instructions\", \"text\": \"Use the panel on the left to start coding!\" }, { \"_beagleComponent_\": \"button\", \"id\": \"fast-guide\", \"text\": \"Access the fast guide\" } ] } O json acima é uma versão simplificada da página inicial do Beagle Playground. Ele renderiza o container para guardar o resto dos elementos: uma imagem, dois textos e um botão. Para ver o exemplo completo e o UI renderizado, veja o Beagle Playground.\nO payload do Beagle No tipo definido anteriormente (BeagleUIElement), você pode ver que o id é uma propriedade obrigatória e que os filhos de um node devem sempre ser nomeados children. No backend isso não é uma garantia, por essa razão, o Beagle gera internamente ids únicos para cada node sem um e traduz a propriedade children. Uma mesa de componente, por exemplo, pode ter seus filhos em uma propriedade rows. Antes de começar o processo da árvore, o Beagle converte o rows para o nome esperado children, veja a seção abaixo sobre the children property.\nO payload pode retornar para o backend qualquer coisa, mas internamente o Beagle deve trabalhar com a árvore de componentes BeagleUIElement. Você deve atravessar a árvore e detectar cada componente e seus filhos.\nÉ recomendado que o backend retorne o JSON representando a árvore de componentes, como é esperado pelo Beagle, mas se por alguma razão isso não seja possível, o Beagle Web torna possível o pré processamento da resposta e constrói a árvore no front-end antes que o Beagle começe a trabalhar com ela, como em lifecycles.\nA propriedade children É recomendado sempre usar a array com o nome children para especificar os filhos nodes de um componente. Mas, o Beagle irá trabalhar fora da caixa, se ao invés de um array de componentes, o único node é passado e o nome child também pode ser usado. Em alguns casos, quando o componente representa uma tabela, os filhos podem ser nomeados rows ao invés de children, nesse caso você pode informar ao Beagle que é um componente específico e que o nome da propriedade children é diferente. Veja o exemplo abaixo:\n@BeagleChildren({ property: 'rows' }) @Component({ // ... }) class Table { // ... } O exemplo acima é para Angular, mas funciona da mesma forma em outras plataformas. Se o componente é funcional ou se você não quiser usar anotações, você pode usá-lo como uma função, veja o exemplo abaixo:\nconst Table = (props) =\u003e { // ... } BeagleChildren({ property: 'rows' })(Table) ","excerpt":" Como o Beagle representa a view? As features descritas aqui estão …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/t%C3%B3picos-avan%C3%A7ados/estrutura-de-dados/","title":"Estrutura de dados"},{"body":" Loading Component Beagle’s library already has by pattern a component that it is called when a screen loads. If necessary, you are able to change it to a customized one, according your application’s needs.\nTo create a loading component, follow the steps below:\nReact Angular On React:\nStep 1: Create a substitute component;\nSee an example:\nimport React, { FC } from 'react' const CustomLoadingComponent: FC\u003cany\u003e = () =\u003e { return ( \u003cdiv\u003eCarregando\u003c/div\u003e ) } export default CustomLoadingComponent Step 2: Add it to Beagle’s Service components list to substitute the pattern component:\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomLoadingComponent from '../components/CustomLoading' export default createBeagleUIService\u003cany\u003e({ baseUrl: \"localhost:4000\", components: { \"custom:loading\":CustomLoadingComponent } })  On Angular\nStep 1: Create a substitute component.\nYou can use angular CLI, if you want, to generate the component automatically, see:\nng generate component components/custom-loading Step 2: After that, open the file beagle-components.module.ts and add the component to the list:\nimport { NgModule } from '@angular/core' import { CustomLoadingComponent } from './components/custom-loading/custom-loading.component'; // import all the components you're going to use with beagle const components = [ CustomLoadingComponent ]; @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} Step 3: Now, you can substitute the pattern component in the beagle.module.ts file:\nimport { BeagleModule } from '@zup-it/beagle-angular'; import { CustomLoadingComponent } from './components/custom-loading/custom-loading.component'; // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://mypath', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { 'custom:loading': CustomLoadingComponent } }) export class Beagle { } The files beagle.module.ts and beagle-components.module.ts are automatically generated by Angular’s library. If you haven’t found it, check you installation.\n  Error Component The pattern error component on Beagle it is called when connection error happens, for example, when a server path cannot be reached.\nTo this component, the library shows an interface called ErrorComponentParams, throught it you have access to the error list and a retry method, responsible to retry the server request.\nErrorComponentParams    Attribute Type Definition     retry Method Retry the request to the server.    When using this interface, you can create a component, see the example below with each framework:\nReact Angular On React, you have to create a Functional Component that uses the ErrorComponentParams interface. When using it, you have access to two props errors and retry, which are the errors list and the retry method, both described on the interface:\nNo React, é preciso criar um Functional Component que usa a interface ErrorComponentParams, note que ao usá-la você tem acesso à duas props errors e retry, que são respectivamente a lista de erros e o método retry ambos descritos na interface:\nimport { ErrorComponentParams } from '@zup-it/beagle-react' import React, { FC } from 'react' const CustomErrorComponent: FC\u003cErrorComponentParams\u003e = ({ retry }) =\u003e { return ( \u003c\u003e \u003cp\u003e Unexpected Error! \u003c/p\u003e \u003cbutton onClick={retry}\u003eRetry\u003c/button\u003e \u003c/\u003e ) } export default CustomErrorComponent After that, add it to the Beagle Service components list:\nimport { createBeagleUIService } from '@zup-it/beagle-react' import CustomErrorComponent from '../components/CustomError' export default createBeagleUIService\u003cany\u003e({ baseUrl: \"localhost:4000\", components: { \"custom:error\":CustomErrorComponent } })  On Angular, create a component, if you prefer use angula cli to automatically generate the inicial structure:\nng g component components/custom-error Open the controller file of the created component and add the ErrorComponentParams interface. The interface gives access to two @Inputs errors and retry, which are the errors list and the request method:\nimport { Component, Input } from '@angular/core'; import { ErrorComponentParams } from '@zup-it/beagle-angular'; @Component({ selector: 'app-custom-error', templateUrl: './custom-error.component.html', styleUrls: ['./custom-error.component.less'] }) export class CustomErrorComponent implements ErrorComponentParams { @Input() retry: () =\u003e void; handleRetry() { this.retry(); } } Now, add the created component to the file list beagle-components.module.ts\nimport { NgModule } from '@angular/core'; import { CustomErrorComponent } from './components/custom-error/custom-error.component'; // import all the components you're going to use with beagle const components = [ CustomErrorComponent ]; @NgModule({ declarations: components, entryComponents: components, exports: components, imports: [ // everything your components depend on ], }) export class BeagleComponentsModule {} Finally, replace the pattern component to the beagle.module.ts file:\nimport { CustomErrorComponent } from './components/custom-error/custom-error.component'; // import all the components you wish to use with Beagle. @BeagleModule({ baseUrl: 'http://localhost:4202/assets', module: { path: './beagle-components.module', name: 'BeagleComponentsModule', }, components: { 'custom:error': CustomErrorComponent } }) export class Beagle { } The files beagle.module.ts and beagle-components.module.ts are automatically generated by Angular’s library. If you haven’t found them, check your installation.\n  ","excerpt":" Loading Component Beagle’s library already has by pattern a component …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/loading-components-and-error-treatment/","title":"Loading components and error treatment"},{"body":" Acessar e controlar o BeagleView As features descritas aqui estão disponíveis apenas em versões acima de 1.2.0.  Beagle View é uma entidade responsável por gerenciar a view do server-driven. Pode ser criada por meio do Beagle Service, pela função createBeagleView. O BeagleView pode buscar uma nova view, atualizar a sua árvore, navegar, etc.\nAcessando o Beagle View O Beagle View é criado no Angular ou React quando o componenenteBeagleRemoteView é usado. Para acessá-lo, você deve usar a propriedade onCreateBeagleView no Angular ou a viewRef no React. Veja os exemplos abaixo:\nAngular \u003cbeagle-remote-view [loadParams]=\"loadParams\" (onCreateBeagleView)=\"onCreateBeagleView($event)\"\u003e beagle-remote-view\u003e import { Component } from '@angular/core' import { BeagleView } from '@zup-it/beagle-web' @Component({ // ... }) class MyComponent { private beagleView: BeagleView | undefined // ... logBeagleView() { if (!this.beagleView) return console.log(this.beagleView)) } onCreateBeagleView(beagleView) { this.beagleView = beagleView this.logBeagleView() } } React import React, { useRef, MutableRefObject, useEffect } from 'react' import { BeagleRemoteView } from '@zup-it/beagle-react' import { BeagleView } from '@zup-it/beagle-web' const MyComponent: FC = () =\u003e { const beagleView = useRef() as MutableRefObject\u003cBeagleView | undefined\u003e // ... logBeagleView() { if (!beagleView.current) return console.log(beagleView.current) } useEffect(logBeagleView, []) return \u003cBeagleRemoteView path=\"/my-path\" viewRef={beagleView} /\u003e } Nos exemplos acima, o Beagle View foi acessado e logado. É importante lembrar que é preciso checar a disponibilidade do Beagle View antes de usá-lo, uma vez que ele é criado por um componente child, ele não estará disponível antes da criação dos componentes children.\nBuscando a view Para buscar uma view do backend e atualizar a view atual, você precisa usar o método fetch do BeagleView.\nA operação de busca por ser em toda a árvore ou apenas nas branch. Se for a primeira, a árvore é toda substituída pelo resultado da requisição. Caso contrário, a árvore é mantida, mas a branch é atualizada pelo fetch, é ela que será substituída pelo resultado da requisição.\nAbaixo veja o exemplo da chamada da função fetch:\n// fetches the remote view at /my-path and uses it to replace the entire current view beagleView.fetch({ path: '/my-path' }) // fetches the remote view at /my-lazy-container and uses it to replace the component with id 'lazy' beagleView.fetch({ path: '/my-lazy-container' }, 'lazy') fetch aceita 3 parâmetros, e eles são:\n loadParams: obrigatório. Objeto contendo os parâmetros para controlar a requisição, veja as opções a seguir:    path: obrigatório. Caminho para a view no backend.\n  fallback: opcional. A árvore do Beagle é retornada em caso de erro.\n  method: opcional. get por padrão. Use essa opção se você precisar de um método http.\n  headers: opcional. Use essa opção para passar headers adicionais para uma única requisição.\n  shouldShowLoading: opcional. Mostra se você deve usar ou não o loadingComponent. E usará a configuração global caso não for especificado.\n  shouldShowError?: opcional. Mostra se o componente da requisição falhou. E usará a configuração global caso não for especificado.\n  strategy: opcional. Mostra qual estratégia de cache deve ser usada para carregar uma view específica. E usará a configuração global caso não for especificado.\n  loadingComponent: opcional. O componente de carregamento a ser usado. E usará a configuração global caso não for especificado.\n  errorComponent: optional. O componente de erro a ser usado.\n anchor: opcional. Id do node a ser anexado no resultado da view, por padrão use o node raiz. É usado para atualizar apenas uma branch.\n  mode: opcional. Como anexar o resultado da view direto do anchor, veja os quatro modos possíveis:\n    replaceComponent: default. Substitui a âncora com o resultado da requisição.\n  replace: substitui os filhos (children) da âncora com o resultado da requisição.\n  prepend: adiciona o resultado da requisição no começo da lista dos filhos da âncora.\n  append: adiciona o resultado da requisição no final da lista dos filhos.\n  Inscrevendo os eventos Você pode se inscrever a eventos no Beagle View. Há dois tipos de assinatura, a primeira escuta cada atualização da árvore (beagleView.subscribe) e a outra observa cada erro do processo de busca/renderização (beagleView.addErrorListener).\nQuando o beagleView.subscribe é chamado, você deve passar o único parâmetro, onde a função recebe a árvore renderizada atual. Veja o exemplo abaixo:\nconst unsubscribeLogger = beagleView.subscribe((newTree) =\u003e { console.log('The tree was updated!') console.log(newTree) }) Para remover o ouvinte, apenas chame a função retornada. No exemplo anterior unsubscribeLogger().\nOuvintes de erros são registrados de forma similar, a única diferença é que eles recebem uma lista de erros:\nconst removeErrorListener = beagleView.addErrorListener((errors) =\u003e { console.log('Oops! An error just happened!') console.log(errors) }) Por padrão, o Beagle loga cada erro que foi renderizado/buscado no processo até o console. Uma vez que o erro do ouvinte é adicionado no Beagle View, o Beagle irá parar de de logar os erros por ele mesmo e usar o tratamento que você adicionou.\nDestruindo o Beagle View Para evitar vazamento de memória, o Beagle View precisa ser destruído, se não for usado novamente. Se você estiver usando Angular ou React, não há necessidade de se preocupar com isso, porque será feito pelo framework. Se você estiver usando o Beagle Web, você deve chamar o beagleView.destroy() quando a remote view é removida da página.\nAPI Você encontra abaixo todos os métodos do Beagle View e sua descrição:\n   Atributo Tipo Definição     subscribe  função Recebe o ouvinte e retorna a função para cancelar a inscrição.   \naddErrorListener  função Subscreve aos erros. Recebe o ouvinte e retorna a função para removê-lo.   fetch  função Busca a view do backend e a usa para a atualizar a árvore.   getRenderer  função retorna o redenrizador da view. Pode ser usado para atualizar a árvore diretamente.   getTree  função retorna a cópia da árvore renderizada.   getBeagleNavigator  função retorna o navegador.   getBeagleService  função retorna o BeagleService para criar a view.   destroy  função destrói a view.    ","excerpt":" Acessar e controlar o BeagleView As features descritas aqui estão …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/t%C3%B3picos-avan%C3%A7ados/beagle-view/","title":"Beagle view"},{"body":" Beagle Remote View Beagle’s library offers a component to help render the server-driven screens, remote view:\nAngular React \u003cbeagle-remote-view [loadParams]=\"loadParams\"\u003e\u003c/beagle-remote-view\u003e  \u003cBeagleRemoteView {...loadParams} /\u003e  Angular and React accept remote view’s properties that are called Load Params. It is through it, that some options are configured to influence the way the screens are rendered.\nSee below that properties accepted by it:\nimport { LoadParams } from '@zup-it/beagle-web'; const params: LoadParams = { path: '/payload.json', fallback: {_beagleComponent_: 'beagle:text', text:'Fallback Error'}, method: 'get', headers: {'header': 'value'}, shouldShowLoading: true, shouldShowError: true, strategy: \"network-only\", loadingComponent: 'myComponentLoading', errorComponent: 'myComponentError' }    Property Type Description     path string Required. Server path to load the JSON with the server-drive screen.   fallback BeagleComponent Component to be rendered in case the request fails.   method Http method Http method to make a request.   headers Map\u003ckey, value\u003e Header list to attach when you make a request.   shouldShowLoading boolean Show or not the loading component.   shouldShowError boolean Show or not the error component.   strategy string\u003cCache strategy\u003e Cache strategy used in the request.   loadingComponent string Customized component for loading.   errorComponent string Customized component for error.    ","excerpt":" Beagle Remote View Beagle’s library offers a component to help render …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/remote-view-parameters/","title":"Remote view parameters"},{"body":" As features descritas aqui, estão disponíveis nas versões a partir de 1.2.0.  Para entender melhor sobre renderização, recomendamos a leitura da seção estrutura de dados.\nCada biblioteca do Beagle Web possui um processo definido de como busca, processa e renderiza a view. Há uma ordem que deve ser sempre respeitada e pontos de extensão (hooks), onde você pode executar seus códigos (lifecycles).\nVeja o processo de renderização do Beagle Web:\nOs lifecycles (ciclos de vida) do Beagle, são:\n BeforeStart BeforeViewSnapshot AfterViewSnapshot BeforeRender  Eles podem ser usados como ganchos globais para o lifecycle:\nconst config = { // ... lifecycles: { beforeStart: (payload) =\u003e { // ... }, beforeViewSnapshot: (payload) =\u003e { // ... }, afterViewSnapshot: (payload) =\u003e { // ... }, beforeRender: (payload) =\u003e { // ... }, } } Ou os hooks locais para os lifecycles na base do componente (anotações):\n// Attention: these won't work with production builds in Angular. Keep reading for more details. @BeforeStart((textComponentPayload) =\u003e { // ... }) @BeforeViewSnapshot((textComponentPayload) =\u003e { // ... }) @AfterViewSnapshot((textComponentPayload) =\u003e { // ... }) @BeforeRender((textComponentPayload) =\u003e { // ... }) @Component({ // ... }) class Text { // ... } O exemplo acima não funciona com Angular quando for construído para produção, por causa do compilador. Para escrever um código para a leitura do compilador dele, você deve escolher duas opções:\n Adicione o comentário// @dynamic antes de chamar a anotação:  // @dynamic @BeforeRender((textComponentPayload) =\u003e { // ... }) @Component({ // ... }) class Text { // ... } Substitua a função da flecha para uma função comum e a exporte:  export function beforeRender(textComponentPayload) { // ... } @BeforeRender(beforeRender) @Component({ // ... }) class Text { // ... } Desde que as anotações não podem ser usadas por funções, se você tem algum componente funcional ou não quer usar as anotações, use normalmente as chamadas de funções:\nconst Table = (props) =\u003e { // ... } BeforeStart((textComponentPayload) =\u003e { // ... })(Table) É importante notar que para o React, onde Higher Order Components (HOC) são comuns, o componente que recebe a anotação deve ser o final. Por isso, você deve aplicar ao nome do hoc withTheme ao seu componente:\nconst MyComponent: FC = () =\u003e { // ... } // This is wrong, it has no effect! // BeforeRender(myLifecycleFunction)(MyComponent) // export default withTheme(MyComponent) // You need to apply the decorator to the final component instead: const MyComponentWithTheme = withTheme(MyComponent) BeforeRender(myLifecycleFunction)(MyComponentWithTheme) export default MyComponentWithTheme O valor retornado do hook do lifecycle pode ser indefinido ou uma árvore. Se for uma árvore, o processo de renderização será descartar a árvore anterior e começar a trabalhar na árvore retornada pelo hook.\nPara controlar o processo de renderização, além do lifecycles, o Beagle também oferece a Renderer API, que pode ser acessada por meio do BeagleView.getRenderer(). O BeagleView pode ser acessado via o componente BeagleRemoteView, por meio de atributos como onCreateBeagleView no Angular e o viewRef no React.\nOutra forma de acessar o BeagleView é por meio do ViewContentManager API, que pode ser encontrado no this.viewContentManager no componente do Angular que extende o BeagleComponent ou no props.viewContentManager no React, um componente que implementa a interface do BeagleComponent.\nProcesso e lifecycles Lifecycles deprecates the feature middlewares. Middlewares will still be supported at least until the next major version (2.0.0) and they will be interpreted as they were part of the global lifecycle beforeViewSnapshot.  Beagle possui um processo definido desde quando o payload é recebido até quando é renderizado na tela do browser. Há também os ‘breakpoints’ que é quando você faz seu processo, e isso é chamado de lifecycle.\nProcesso para renderizar uma view Veja os passos abaixo para renderizar a view:\n Rode o hook global beforeStart; Rode o hook beforeStart para cada componente; Identifique os filhos de cada componente considerando a anotação “BeagleChildren”; Atribua um id para cada node que não tenha; Remova qualquer propriedade do objeto que possua o valor null; Se necessário, faça uma pré busca das views que serão acessadas em seguida; Rode o hook global beforeViewSnapshot; Rode o hook beforeViewSnapshot de cada componente; Tire um captura de tela da árvore e reserve. A partir de agora, qualquer referência a a árvore renderizada, será da cópia dessa árvore. Começe processando a cópia da captura de tela da view, o próximo lifecycle rodará em cima dessa cópia; Rode o hook global afterViewSnapshot; Rode o hook afterViewSnapshot para cada componente; Deserialize as ações do Beagle em funções javascript;Deserialize beagle actions into javascript functions; Avalie os contextos e expressões; Interprete os estilos, convertendo o estilo do Beagle a sintaxe de estilo do css; Rode o hook global beforeRender; Rode o hook beforeRender para cada componente; Passe a árvore do componente para a função de renderização. Essa função é diferente em Angular e React.  Lifecycles Existem quatro hooks de lifecycles, mas voê usará apenas dois: beforeViewSnapshot e beforeRender. A diferença entre eles é que o primeiro roda antes de qualquer expressão ou ação tenha sido avaliada e o segundo roda depois. É importante mencionar, quando você usar a API Renderer, doFullRender rodará ambos lifecycles, mas o doPartialRender rodará apenas o lifecycle beforeRender.\nA regra simples para decidir se você uqer alterar a árvore via beforeViewSnapshot oubeforeRender é: se sua modificação não depende do resultado da expressão, use o beforeViewSnapshot, caso contrário, use o beforeRender.\nO lifecycle hook recebe da árvore do Beagle e retorna nada ou uma árvore. Se for uma árvore, o processo de renderização discarta a árvore anterior e trabalha na retornada pelo hook.\n Lifecycle global: a árvore toda no Beagle. Componente lifecycle: a árvore significa uma branch correspondente ao componente.  Veja abaixo os detalhes de cada lifecycle:\nBeforeStart Este lifecycle roda antes de tudo, aqui algumas modificações devem ser feitas antes que id seja atribuido ou qualquer propriedade filho seja computada. Se o seu payload não é tudo que o Beagle espera, aqui é onde você pode mudá-lo.\nDesde que a tradução dos filhos ainda tenha sido rodada, os componentes decorados com @BeforeStart podem não rodar. Por exemplo, um texto dentro do componente table que tem seus filhos definidos pela propriedade rows. Nesse cenário o Beagle não sabe que rows representa os filhos de table, então ele ignoraria tudo dentro desse componente.\nEsse é o único lifecycle onde novas nodes podem ser adicionadas a árvores que não tenha ids. Cada um deles, roda depois que os ids são atribuídos.\nExemplos de uso Custom ID generator Esse lifecycle pode ser usado para ignorar a geração de id padrão do Beagle e usar a sua própria. O Beagle apenas aceita ids aleatórios de nodes sem ids, você pode usar esse lifecycle para atribuir seu único ids para cada node:\nconst config = { // ... lifecycles: { beforeStart: (tree) =\u003e { let next = 1 function assignIds(data: any) { // if it's not a component or not a structure that can have a component inside, return if (!data || typeof data !== 'object') return // if it's an array, assign ids to the components inside if (Array.isArray(data)) return data.forEach(assignIds) // if it is a component node, assign an ID if (data._beagleComponent_) data.id = `myAppID-${next++}` // if it's an object, assign ids to the components inside const keys = Object.keys(data) keys.forEach(key =\u003e assignIds(data[key])) } assignIds(tree) } } } Complex children calculation\nUm caso complexo seria a cálculo de children. Os children de uma tabela de componentes é a união de três propriedades header, rows e footer, mas isso não pode ser expressado via anotação @BeagleChildren, por isso esse lifecylce remove as propriedades do JSON original e cria a propriedade dos seus filhos, que seria a união das três propriedades.\nimport { BeforeStart } from '@zup-it/beagle-web' @BeforeStart((table) =\u003e { table.children = [header, ...rows, footer] delete table.header delete table.rows delete table.footer }) class Table { // ... } O exemplo acima funciona apenas com componentes que possuem children como nome da propriedade que representa seus filhos. E se esse não for o caso, o lifecycle global pode ser usado.\nBeforeViewSnapshot Esse roda logo antes do snapshot da view, é útil para alterar o payload, mas depois que os ids já fora atribuídos. Aqui é onde você deve modificar a árvore, já que os ids já estão atribuídos e a estrutura da árvore está pronta para ser atravessada.\nTenha cuidado quando criar qualquer node nova, é preciso atribuir os ids a ela.  Exemplos de uso Escrevendo um atalho para controlar os text-inputs O componente beagle:textInput pode ser controlado pelo contexto. Veja um exemplo, onde o valor de entrada do ‘email’ é controlado pela propriedade de contexto email.adress e a entrada de ‘message’ é controlado por email.message:\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"email\", \"value\": { \"address\": \"\", \"message\": \"\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"E-mail\", \"value\": \"@{email.address}\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"email\", \"path\": \"address\", \"value\": \"@{onChange.value}\" } ] }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Message\", \"value\": \"@{email.message}\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"email\", \"path\": \"message\", \"value\": \"@{onChange.value}\" } ] }, ] } O ideal é criar um atalho para evitar repetições, por exemplo, quando um json traz a propriedade model, é criado uma estrutura automaticamente. No model, é preciso ser digitado qual valor de contexto irá controlar essa entrada, veja abaixo:\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"email\", \"value\": { \"address\": \"\", \"message\": \"\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"E-mail\", \"model\": \"email.address\" }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Message\", \"model\": \"email.message\" } ] } Para isso funcionar, é preciso escrever o lifecycle que irá transformar o model na estrutrua esperada:\nimport { BeforeViewSnapshot } from '@zup-it/beagle-web' @BeforeViewSnapshot((component) =\u003e { component.value = `@{${component.model}}` component.onChange = component.onChange || [] const [contextId, ...path] = component.model.split('.') component.onChange.push({ _beagleAction_: 'beagle:setContext', contextId, path: path ? path.join('.') : undefined, value: \"@{onChange.value}\" }) }) @Component({ // ... }) class TextInput { // ... } Com esse código, apesar de estar recebendo o model do backend, o payload processado pelo Beagle terá os valores esperados.\nCálculo complexo da children com o BeforeViewSnapshot O exemplo anterior poderia ter sido feito sem o risco de pular algum lifecycle do componente devido a propriedade children estar nomeada incorretamente. A única diferença é que você deve atribuir os ids:\nimport { BeforeViewSnapshot, Tree, Component } from '@zup-it/beagle-web' @BeforeStart((table) =\u003e { table.children = [header, ...rows, footer] delete table.header delete table.rows delete table.footer // assigns a random id for each component in the tree table.children Tree.forEach(table.children, Component.assignId) }) class Table { // ... } AfterViewSnapshot Quando usar a API Renderer, há dois tipos de renderizar: renderização completa e renderização parcial. Os dois lifecycles anteriores funcionam na completa, enquanto esse e os próximos lifecycles funcionam nos dois.\nAs mudanças feitas aqui são válidas para a renderização atual. Qualquer atualização da view é feita por meio da árvore baseada na no snapshot da view, as modificações feitas nesse lifecycle não são permanentes e serão executadas a cada renderização. Se você tem uma propriedade counter com o valor 0 na árvore e no seu lifecycle é com o valor 1. Na quinta renderização completa, os valores de counter serão:\n BeforeStart: 5 BeforeViewSnapshot: 5 AfterViewSnapshot: 1 BeforeRender: 1  Esse lifecycle pode ser usado para rodar o código necessário para que a view seja renderizada e não requer ações, contexto, expressões e estilos, pois já foram processados.\nExemplos de uso Contextos são definidos, referenciados e manipulados no JSON da view. Mas, se você quiser acessar os dados da aplicação o Beagle oferece uma funcionalidade chamada Contexto Global, que é possivel lidar com esse cenário. Se não tivesse essa função, o lifecycle AfterViewSnapshot também consegue lidar com isso.\nUm exemplo, se você tem uma aplicação financeira e quer saber o balanço do usuário. Você deve garantir que cada haja a renderização de cada valor recente.\n{ \"_beagleComponent_\": \"container\", \"context\": { \"id\": \"user\", \"value\": { \"name\": \"\", \"balance\": 0 } }, \"children\": [ { \"_beagleComponent_\": \"text\", \"text\": \"@{user.name}, your balance is $@{user.balance}\" } ] } No JSON acima, o contexto user foi usado, onde começa com valores vazios e não há possibilidade de saber os valores corretos. Agora, substitua o valores do contexto por valores da sua aplicação, como abaixo:\nimport Tree from '@zup-it/beagle-web' function findContextById(tree, id) { const it = Tree.iterator(tree) let next = it.next() while (!next.done) { const component = next.value if (component.context \u0026\u0026 component.context.id === id) return component.context next = it.next() } } const config = { // ... lifecycles: { afterViewSnapshot: (payload) =\u003e { const userContext = findContextById(payload, 'user') const userData = getUserData() // this method gets the user data from the application userContext.name = userData.name userContext.balance = userData.balance } } } O código não pode ser feito antes do view ser snapshotted, porque o requisito é atualizar o valor em cada renderização. É importante mencionar que a ação setContext não funciona sob o contexto de user. Lifecycles podem ser usados, mas é recomendado usar o contexto global em casos de valores no Beagle view.\nBeforeRender As alterações aqui são válidas apenas para a renderização atual e são executadas em todas as renderizações. A diferença entre BeforeRender e AfterViewSnapshot é a garantia de que todas as ações, expressões e estilos já foram processadas.\nExemplos de uso Quando o backend decide expressar cores no seguintes formatos:{ red: number, green: number, blue: number }. Por exemplo, preto seria { red: 0, green: 0, blue: 0 }. Isso não é válido para cores nos browsers, então é preciso converter o valor de cada propriedade de cor para validar o formato RGB. Veja abaixo a função:\nconst colorProperties: ['color', 'backgroundColor', 'borderColor'] function fixColorCodes(componentPayload) { const style = componentPayload.style if (!style) return colorProperties.forEach((property) =\u003e { if (!style[property]) return style[property] = `rgb(${style[property].red}, ${style[property].green}, ${style[property].blue})` }) } Agora, execute a função acima para cada componente na árvore. Se você quiser ter um comportamento dinâmico para a mudança de cor via contexto, veja o JSON abaixo:\n{ \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"bgColor\", \"value\": { \"red\": 255, \"green\": 255, \"blue\": 255 }, }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"My dynamically colored text\", \"style\": { \"backgroundColor\": \"@{bgColor}\" } }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"red\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 255, \"green\": 0, \"blue\": 0 } } ], \"_beagleComponent_\": \"beagle:button\", \"text\": \"green\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 0, \"green\": 255, \"blue\": 0 } } ], \"_beagleComponent_\": \"beagle:button\", \"text\": \"blue\", \"onPress\": [ { \"_beagleAction_\": \"setContext\", \"contextId\": \"bgColor\", \"value\": { \"red\": 0, \"green\": 0, \"blue\": 255 } } ] } ] } O texto começa com o fundo branco e quando o usuário apertar o botão, o fundo muda de cor. Se você chamar fixColorCodes antes do contexto ser validado, ele estará tentando executar sobre a string @{bgColor} ao invés do objeto { red: 255, green: 255, blue: 255 } o que pode ocorrer um erro no tempo, já que eles não são propriedades da string.\nBeforeStart, BeforeViewSnapshot and AfterViewSnapshot são executados antes de cada contexto ser avaliado, então tudo que pode ser afetado por ele deve ser executado no último lifecycle: BeforeRender:\nimport { Tree } from '@zup-it/beagle-web' const config = { // ... lifecycles: { // ... beforeRender: tree =\u003e Tree.forEach(tree, fixColorCodes), } } The Renderer API Para controlar o processo de renderização, o Beagle permite você gerenciar quando uma nova renderização é feita na árvore do Beagle View. Você pode ter um componente que quando é clicado muda a árvore atual, para que um novo componente seja adicionado ou uma propriedade seja modificada.\nUm cenário comum é quando você cria uma ação que muda a árvore atual, por exemplo, uma ação addChildren, quando executada deve ir a árvore atual e adicionar o filho ao componente com o id dado. Para fazer isso, é preciso ter uma forma de obter a árvore atual, modificá-la e avisar ao Beagle View para renderizar de novo.\nA renderização pode ser feita em dois processos: a completa e a parcial. A primeira executa todos os passos da lista no início dessa página e a segunda executa apenas o view snapshot e os passos 9 ao 18 da mesma lista.\nAcessando o Renderer Cada Beagle View possui seu renderizador, para acessá-lo, você deve chamar o beagleView.getRenderer().\nVeja os exemplos de como chegar ao renderizador:\n React: a referência ao BeagleView pode ser obtida por meio da propriedade do viewRef do BeagleRemoteView:  import React, { FC, useRef, useEffect, MutableRefObject } from 'react' import { BeagleRemoteView } from '@zup-it/beagle-react' import { BeagleView } from '@zup-it/beagle-web' const Home: FC = () =\u003e { const beagleView = useRef() as MutableRefObject\u003cBeagleView | undefined\u003e useEffect(() =\u003e { if (beagleView.current) { const renderer = beagleView.current.getRenderer() } }, []) return ( \u003cBeagleRemoteView path=\"/home\" viewRef={beagleView} /\u003e ) }  Angular: você pode usar o atributo onCreateBeagleView do componente beagle-remote-view :  import { Component } from '@angular/core' import { LoadParams, BeagleView } from '@zup-it/beagle-web' @Component({ selector: 'home', template: '', }) export class Home { loadParams: LoadParams private beagleView: BeagleView constructor() { this.loadParams = { path: '/home' } } onCreateBeagleView(beagleView: BeagleView) { this.beagleView = beagleView } getRenderer() { return this.beagleView \u0026\u0026 this.beagleView.getRenderer() } } Quando dentro do componente renderizado pelo Beagle, você pode usar o ViewContentManager para acessar o BeagleView e obter o renderizador.\nQuando dentro do action handler (ações customizadas), o Beagle View é provido via parametro que pode ser usado para obter o renderizador, veja o exemplo abaixo:\nconst MyCustomActionHandler: ActionHandler\u003cMyCustomAction\u003e = ({ action, beagleView }) =\u003e { const renderer = beagleView.getRenderer() // ... } Usando o Renderer O renderizador possui duas funções: doFullRender edoPartialRender.\n doFullRender: renderiza a árvore passada como parâmetro rodando todo os passos para renderização. Renderização completa deve ser feita toda vez que novas nodes são criadas. doPartialRender: apenas roda a view snapshot e os passos depois disso. Renderização parcial deve ser usada para modificar nodes existentes.  A árvore recebida pelo doFullRender é o tipo de BeagleUIElement, por exemplo, e pode ou não ter ids. A árvore recebida do doPartialRender é o tipo de IdentifiableBeagleUIElement:\nExemplo: deve ter ids para cada node. Você nunca pode passar a árvore para odoPartialRender sem ids.\nAlém do tipo de árvore, não há diferença na forma que o doFullRender e o doPartialRendersão chamados. Eles aceitam os seguintes parâmetros:\n  O primeiro é a árvore;\n  O segundo é opcional e a âncora. Se a âncora não for especificada, a árvore passada no primeiro parâmetro será substituída pela árvore renderizada. Se a âncora é especificada, a árvore passada como parametro será anexada a árvore renderizada atual, na mesma posiçao que a node com id referenciado por anchor. Como o anexo é feito é definido pelo terceiro parâmetro.\n  Opcional. É o mode, se o modo não é definido, ele é tratado como replaceComponent. Há 4 modos diferentes:\n  replaceComponent: substitui a node com mesmo id que o parâmetro\nanchor com a árvore passada no primeiro parâmetro\n  replace: substitui a árvore passada no primeiro parâmetro para a children do node com o mesmo id que o parâmetro anchor (ou a raíz, se o anchor não for especificado).\n  prepend: precede a árvore passada no primeiro parâmetro para a children do node com o mesmo id que o parâmetro anchor (ou a raíz, se o anchor não for especificado).\n  append: acrescenta a árvore passada no primeiro parâmetro para a children do node com o mesmo id que o parâmetro anchor (ou a raíz, se o anchor não for especificado).\n    Exemplos: /* example 1: renders a container with an empty list */ beagleView.getRenderer().doFullRender({ _beagleComponent_: 'beagle:container', children: [ _beagleComponent_: 'custom:list', id: 'list', ], }) /* example 2: adds a property to the root of the currently rendered tree */ const current = beagleView.getTree() current.newProperty = 'new' beagleView.getRenderer().doPartialRender(current) /* example 3: adds an element to the \"custom:list\" inside the container */ const item = { _beagleComponent_: 'beagle:container', children: [ { _beagleComponent_: 'beagle:text', text: 'Client name: Jasnah Kholin' }, { _beagleComponent_: 'beagle:text', text: 'Client age: 30' } ] } // we should always do full renders when creating new nodes beagleView.getRenderer().doFullRender(item, 'list', { mode: 'append' })  Com a API do rendered, você pode alterar uma view quando quiser. Você não pode chamar renderer.doFullRender(tree, componentId) no onInit do componente do Angular com o id componentId. Se isso for feito, o Beagle irá remover o componente da árvore antes de ser renderizado. Casos como esse podem acontecer usando o Beagle renderer dentro dos componentes de lifecycle.\nA solução do exemplo dado seria substituir a children do componente (renderer.doFullRender(tree, componentId, 'replace')).\n API ViewContentManager A list view é um componente que precisa usar a Rendered API, mas como acessar o renderizador do componente? Em ambos Angular e React, isso pode ser feito via ViewContentManager.\nO ViewContentManager provê um caminho para acessar o BeagleView e o node que a árvore atual do Beagle que deu origem ao componente sendo renderizado e com isso você pode acessar e chamar a renderização desse componente específico.\nAcessando o ViewContentManager React O ViewContentManager pode ser acessado dentro to componente do React, se ele implementar a interface do BeagleComponente.\nVeja abaixo o exemplo de re-renderizar o componente com um novo grupo de children baseado nos dados e no template:\nimport React, { FC, useRef, useEffect, MutableRefObject } from 'react' import { BeagleComponent } from '@zup-it/beagle-react' interface ListViewInterface extends BeagleComponent { // ... } const ListView: FC\u003cListViewInterface\u003e = (props) =\u003e { useEffect(() =\u003e { /* Once the component implements the BeagleComponent interface, we have access to the viewContentManager, but if the component was not instantiated by Beagle, the viewContentManager will be undefined. We must verify it before continuing. */ if (!props.viewContentManager) return const children = createChildrenFromTemplate(props.dataSource, props.template) const element = props.viewContentManager.getElement() element.children = children props.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id) }, [props.dataSource, props.template]) return ( // ... ) } Isso acontece quando a fonte de dados ou template mudam.\nAngular No Angular, se você precisar acessar o ViewContentManager, a classe do componente deve extender o BeagleComponent, então você pode referenciar a this.viewContentManager.\nimport { Component, Input } from '@angular/core' import { BeagleComponent } from '@zup-it/beagle-angular' @Component({ // ... }) export class ListView extends BeagleComponent { // ... renderDataSource() { /* Checks if the viewContentManager is available. If the components has not been created by Beagle, it won't be. */ if (!this.viewContentManager) return const children = this.createChildrenFromTemplate(this.dataSource, this.template) const element = this.viewContentManager.getElement() element.children = children this.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id) } } O método renderDataSource deve ser chamado toda vez que a fonte de dados ou o template mudarem.\nUsando o ViewContentManager O ViewContentManager possui as seguintes propriedades e funções: have the following properties/functions\n   Propriedade Tipo Definição     \u003cb\u003e\u003c/b\u003e\ngetElement()  função retorna a node na árvore do Beagle responsável pela renderização do componente.   \ngetElementId()  função atalho para o getElement().id    getBeagleView()  função retorna o BeagleView responsável pela view contendo o componente.    Atualizando a view com o resultado da requisição Caso você precisa atualizar a view atual com a árvore que vem do backend, você deve usar o método fetch do BeagleView. Isso irá internamente usar todo o mecanismo de cache do Beagle e também a parte de renderização.\n","excerpt":" As features descritas aqui, estão disponíveis nas versões a partir de …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-web/t%C3%B3picos-avan%C3%A7ados/renderiza%C3%A7%C3%A3o/","title":"Renderização"},{"body":" Beagle Service To use the Beagle library, it is necessary to create a Beagle Service with the configurarion where and how to search server-driven screens.\n On React you can easily create a Beagle Service through the function**createBeagleService(beagleServiceOptions)**\n  On Angular the base code is automatically generated and the properties can be modify and added on beagle.module.ts.\n The configuration object has the following properties:\n   Attribute Type Default Required Description     baseUrl string  ✓ URL to the server with screens (JSON) on Beagle format.   components Map\u003cstring,Component\u003e  ✓ A components map that will be rendered through Beagle’s library. The values are key pairs and value where the key is identifier Beagle will always start by beagle: or custom:. The value will always be the component connected to identifier.   strategy Strategy beagle-with-fallback-to-cache  Cache strategy applied on requests of the server screen.   fetchData fetch   It allows to add a customized function t to make HTTP requests.   analytics Analytics   It allows the use of handlers to the tag capture of some events.   customActions Map\u003cstring,ActionHandler\u003e   A customized action map that can be interpreted by Beagle’s library. It is a key and value map where the key will always be an identifier starting by beagle: or custom: and the value will be the ActionHandler connected to that action.   lifecycles LifeCycleHook   A global map to add lifecycles behaviors of the components. Each cycle happens on the screen renderization process, before the components become HTML.   customStorage Storage localStorage  It replaces the localStorage default of the browsers.   useBeagleHeaders boolean true  It uses or not Beagle’s specific headers when it requests to the server screens.   navigationControllers Map\u003cstring, NavigationController\u003e   It allows you to add control options of the visual response, like show the no items of loading and errors components.    ","excerpt":" Beagle Service To use the Beagle library, it is necessary to create a …","ref":"/docs-beagle/docs/resources/customization/beagle-for-web/beagle-service-parameter/","title":"Beagle Service Parameter"},{"body":" Beagle for backend has the following customizations:\n","excerpt":" Beagle for backend has the following customizations:\n","ref":"/docs-beagle/docs/resources/customization/beagle-for-backend/","title":"Beagle for Backend"},{"body":" O Beagle para backend possui as seguintes customizações:\n","excerpt":" O Beagle para backend possui as seguintes customizações:\n","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-backend/","title":"Beagle para Backend"},{"body":" This section explains how to create a backend without using frameworks such as Spring or Micronaut. You will find the tools to create a BFF to your project.\nIt’s important to say that:\n Beagle was created to be independent, you dont need a specific backend structure. starters of the initial configuration already does all the process described in this page and automatically add the configuration below:  It’s worth to reinforce that the initial configuration customization does not apply to this module.  Follow the next steps to configure your BFF manually:\nStep 1: Add dependencies \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003eframework\u003c/artifactId\u003e \u003cversion\u003e${beagle_version}\u003c/version\u003e \u003c/dependency\u003e Step 2: Configure the Jackson’s ObjectMapper It is necessary to setup Jackson’s ObjectMapper for Beagle. There are two ways to do this:\nFirst, you can register BeagleModule in yourObjectMapper.\nval mapper = // however your ObjectMapper is initialized mapper.registerModule(BeagleModule) Or you can use the function beagleObjectMapper. This function returns a ObjectMapper using jacksonObjectMapper()https://github.com/ZupIT/beagle/pull/229/files with a BeagleModule registered.\nval mapper = BeagleSerializationUtil.beagleObjectMapper() Step 3: Configure the BeagleCacheHandler In order to use the cache mechanism, Beagle offers a class called BeagleCacheHandler and an interface RestCacheHandler. It is recommended to use them as a response filter in your project.\nBeagleCacheHandler class contains a implementation template of the protocol. This template doesn’t depend of the HTTP and REST structure and uses a handleCache method. However, it needs to interact with the HTTP response details, then RestCacheHandler is used.\nUsing the javax.servlet See below a demostration of this class, it was implemented using a javax.servlet class.\n A javax.servlet.Filter filter was created. It applies to the cache protocol for every response given by the backend. To focus on the cache managers, the javax.servlet.HttpServletResponse was left out, this omission is addressed in the codes with comments.  Step 4: Implement the RestCacheHandler You have to implement a RestCacheHandler interface, with four transformation that a manipulator needs to run in your response object. It is generic and it must be specified for the kind of response used in your HTTP structure. Your methods must behave like described below:\n   Method Behaviour     addHashHeader(response, header) Returns a response with aheader adding their headers to the BeagleCacheHandler.CACHE_HEADER key   addStatus(response, status) Returns a response with a status   callController(response) Returns a response resulting from the calling of the controller (generally following the filter chain).   getBody(response) Returns a body of the response with a String    class MyCacheHandler( private val request: HttpServletRequest, private val chain: FilterChain ) : RestCacheHandler\u003cHttpServletResponse\u003e { override fun addHashHeader( response: HttpServletResponse, header: String ): HttpServletResponse { response.setHeader(BeagleCacheHandler.CACHE_HEADER, header) return response } override fun addStatus( response: HttpServletResponse, status: Int ): HttpServletResponse { response.status = status return response } override fun callController(response: HttpServletResponse): HttpServletResponse { this.chain.doFilter(this.request, response) return response } // There is no direct way to access an HttpServletResponse's content,  // this is only to demonstrate the idea  override fun getBody(response: HttpServletResponse) = response.content } Step 5: Create a Filter that uses theBeagleCacheHandler Now, you need to create an BeagleCacheHandler instance and call the handleCache method for it. This instance can accept a string list that represents a regex’s endpoint to not be stored in cache.\nThey must be a valid java.util.regex.Pattern. The handleCache parameters are described below. This filter returns a transformed response:\n   Parameter Description     endpoint endpoint requested.   receivedHash BeagleCacheHandler.CACHE_HEADER value that came with the request.   initialResponse A type of response to be transformed.   restCacheHandler your implementation instance of the RestCacheHandler.    class MyFilter : Filter { private val beagleCacheHandler = BeagleCacheHandler() override fun doFilter( request: ServletRequest?, response: ServletResponse?, chain: FilterChain? ) { if (request is HttpServletRequest \u0026\u0026 response is HttpServletResponse \u0026\u0026 chain != null) { this.beagleCacheHandler.handleCache( request.requestURI, request.getHeader(BeagleCacheHandler.CACHE_HEADER), response, MyCacheHandler(request, chain) ) } } } Step 6: Configure the platform’s specification mechanism In order to have the element’s filtration by platform working, it is necessary to configurate. It is recommended to register a filter that verifies your BFF’s response and filters the sent elements according to the specified platform on your customized beagle-platform header.\nThe BeaglePlatformUtil class was created to provide some tools to make the configuration easier to be used in your filter. See below:\n   Constant Description     BEAGLE_PLATFORM_HEADER Name of the header field used by Beagle to verify which platform BFF is interacting with.       Method Description     treatBeaglePlatform(currentPlatform, jsonNode) Returns a JsonNode as a parameter jsonNode with elements that the platform does not correspond to the parameter currentPlatform removed    An example of a Spring interceptor:\nclass BeaglePlatformInterceptor(private val objectMapper: ObjectMapper) : HandlerInterceptor { override fun preHandle(request: HttpServletRequest, response: HttpServletResponse, handler: Any): Boolean { request.setAttribute( BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER, request.getHeader(BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER) ) return true } override fun postHandle( request: HttpServletRequest, response: HttpServletResponse, handler: Any, modelAndView: ModelAndView? ) { val responseWrapper = (response as ContentCachingResponseWrapper) val jsonTree = this.objectMapper.readTree(responseWrapper.contentAsByteArray) BeaglePlatformUtil.treatBeaglePlatform( request.getHeader(BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER), jsonTree ) val jsonData = jsonTree.toPrettyString() responseWrapper.resetBuffer() responseWrapper.outputStream.write(jsonData.toByteArray()) responseWrapper.setContentLength(jsonData.length) } } The example above, preHandle passed the information from the platform the request was made as an attribute, so that it can be accessed after by BFF and then it will make the platform’s identification easier. We also have postHandle that filters the elements according to the targeted platform in your BFF’s response.\n","excerpt":" This section explains how to create a backend without using …","ref":"/docs-beagle/docs/resources/customization/beagle-for-backend/beagle-framework/","title":"Beagle Framework"},{"body":" Esta seção explica como criar um backend sem fazer uso das configurações prontas para os frameworks Spring ou Micronaut. Você encontrará as ferramentas necessárias para criar um Backend(BFF) para o seu projeto.\nÉ importante reforçar que:\n Beagle foi projetado para ser independente de qualquer estrutura de backend específica, como Micronaut ou Spring. Os Starters da configuração inicial já fazem todo o processo descrito nesta página e adicionam automaticamente as configurações abaixo.  Vale reforçar que as customizações da configuração inicial não se aplicam a esse módulo.  Para configurar seu BFF manualmente, siga os seguintes passos:\nPasso 1: Adicionar as dependências \u003cdependency\u003e \u003cgroupId\u003ebr.com.zup.beagle\u003c/groupId\u003e \u003cartifactId\u003eframework\u003c/artifactId\u003e \u003cversion\u003e${beagle_version}\u003c/version\u003e \u003c/dependency\u003e Passo 2: Configurar o ObjectMapper do Jackson Na configuração do projeto no backend é necessário realizar o setup doObjectMapper do Jackson para o Beagle. Existem duas maneiras de fazer isso:\nPrimeiro, você pode registrar o BeagleModule no seuObjectMapper.\nval mapper = // however your ObjectMapper is initialized mapper.registerModule(BeagleModule) Ou você pode utilizar a função utilitáriabeagleObjectMapper. Essa função retorna um ObjectMapper usando o jacksonObjectMapper() com um BeagleModule registrado.\nval mapper = BeagleSerializationUtil.beagleObjectMapper() Passo 3: Configurar o BeagleCacheHandler Para fazer uso do mecanismo de cache, o Beagle oferece uma classe chamada BeagleCacheHandler e uma interface chamada RestCacheHandler. É recomendado usá-las como um filtro de resposta em seu projeto.\nA classe BeagleCacheHandler contém um template de implementação do protocolo. Este template é independente da estrutura HTTP e REST e utiliza o método de instância handleCache.\nNo entanto, ele precisa interagir com os detalhes da resposta HTTP, e é aqui que o RestCacheHandler é acionado.\nUsando o javax.servlet Para demonstrar o funcionamento dessas classes, o exemplo abaixo foi implementado utilizando uma classe do javax.servlet.\n Como recomendado, foi criado um filtro javax.servlet.Filter que aplica o protocolo de cache para toda resposta dada pelo backend do qual ele faz parte. Com o objetivo de focar no uso dos gerenciadores de cache, a parte do código que ojavax.servlet.HttpServletResponserequer, foi omitida. Essa omissão é apontada nos códigos com comentários.  Passo 4: Implementar o RestCacheHandler Você precisa implementar a interface RestCacheHandler, composta por quatro transformações que o manipulador precisa executar no seu objeto de resposta. É genérico e deve ser especializado para o tipo de resposta disponibilizada em sua estrutura HTTP. Seus métodos devem se comportar conforme descrito abaixo:\n   Método Comportamento     addHashHeader(response, header) Retorna a resposta com header adicionado aos headers dela na chave BeagleCacheHandler.CACHE_HEADER   addStatus(response, status) Retorna uma resposta com status ao invés de uma resposta com o status do HTTP atual   callController(response) Retorna a resposta resultante da chamada do controlador atual (geralmente prosseguindo na cadeia de filtros).   getBody(response) Retorna o corpo da resposta como uma String    class MyCacheHandler( private val request: HttpServletRequest, private val chain: FilterChain ) : RestCacheHandler\u003cHttpServletResponse\u003e { override fun addHashHeader( response: HttpServletResponse, header: String ): HttpServletResponse { response.setHeader(BeagleCacheHandler.CACHE_HEADER, header) return response } override fun addStatus( response: HttpServletResponse, status: Int ): HttpServletResponse { response.status = status return response } override fun callController(response: HttpServletResponse): HttpServletResponse { this.chain.doFilter(this.request, response) return response } // There is no direct way to access an HttpServletResponse's content,  // this is only to demonstrate the idea  override fun getBody(response: HttpServletResponse) = response.content } Passo 5: Criar um Filter que utilize oBeagleCacheHandler Logo depois, você precisa criar uma instância do BeagleCacheHandler e chamar o método handleCache nele. O construtor do BeagleCacheHandler pode aceitar uma lista de strings que representam a regex do endpoint para não ser armazenada em cache.\nEles devem ser um java.util.regex.Pattern válido. Os parâmetros para o método handleCacheestão descritos abaixo.\nEsse filtro retorna uma resposta totalmente transformada:\n   Parâmetro Descrição     endpoint O endpoint requisitado.   receivedHash O valor doBeagleCacheHandler.CACHE_HEADER que veio com a requisição.   initialResponse Uma instância do tipo de resposta a ser transformada.   restCacheHandler Instância da sua implementação do RestCacheHandler.    class MyFilter : Filter { private val beagleCacheHandler = BeagleCacheHandler() override fun doFilter( request: ServletRequest?, response: ServletResponse?, chain: FilterChain? ) { if (request is HttpServletRequest \u0026\u0026 response is HttpServletResponse \u0026\u0026 chain != null) { this.beagleCacheHandler.handleCache( request.requestURI, request.getHeader(BeagleCacheHandler.CACHE_HEADER), response, MyCacheHandler(request, chain) ) } } } Passo 6: Configurar o mecanismo de especificação de plataforma Para que o Beagle tenha o funcionamento esperado na filtragem de elementos por plataforma, é necessário realizar algumas configurações.\nÉ recomendado registrar um filtro ou um interceptor que verifique a resposta de seu BFF e filtre os elementos enviados de acordo com a plataforma especificada no header customizado beagle-platform.\nA classe BeaglePlatformUtil foi criada disponibilizando algumas ferramentas para facilitar essa configuração e ser usada em seu filtro/interceptor. Elas são especificadas abaixo:\n   Constante Descrição     BEAGLE_PLATFORM_HEADER Nome do campo header utilizado pelo Beagle para verificar com qual plataforma o BFF está interagindo       Método Descrição     treatBeaglePlatform(currentPlatform, jsonNode) Retorna o JsonNode passado como parâmetro jsonNode com os elementos cuja plataforma não correspondem ao parâmetro currentPlatform removidos    Um exemplo de interceptor para Spring:\nclass BeaglePlatformInterceptor(private val objectMapper: ObjectMapper) : HandlerInterceptor { override fun preHandle(request: HttpServletRequest, response: HttpServletResponse, handler: Any): Boolean { request.setAttribute( BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER, request.getHeader(BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER) ) return true } override fun postHandle( request: HttpServletRequest, response: HttpServletResponse, handler: Any, modelAndView: ModelAndView? ) { val responseWrapper = (response as ContentCachingResponseWrapper) val jsonTree = this.objectMapper.readTree(responseWrapper.contentAsByteArray) BeaglePlatformUtil.treatBeaglePlatform( request.getHeader(BeaglePlatformUtil.BEAGLE_PLATFORM_HEADER), jsonTree ) val jsonData = jsonTree.toPrettyString() responseWrapper.resetBuffer() responseWrapper.outputStream.write(jsonData.toByteArray()) responseWrapper.setContentLength(jsonData.length) } } No exemplo acima, preHandle passa a informação da plataforma pela qual a requisição foi feita como um atributo da request, para que ele possa ser acessado posteriormente pelo BFF e facilite a identificação da plataforma. Já o postHandle realiza o trabalho de filtrar os elementos devidos de acordo com a plataforma alvo na resposta de seu BFF.\n","excerpt":" Esta seção explica como criar um backend sem fazer uso das …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-backend/beagle-framework/","title":"Beagle Framework"},{"body":" Definition  Since mostly of the frameworks integrate to Jackson and offer proprieties to customize serialization, we decided to not add our proprieties. Instead of that, we kept the compatibility with your chosen framework.\nCustomization  Inside the folder src/main/resources, look for a file called application.properties. If you don’t have it, you can easily create. In case the key isn’t listed on this file, it means that the standard configuration will be automatically applied.\nOn the links below you can see the available configurations to make the serialization according to the framework:\n ​Micronaut​ ​Spring​  In the case of Spring, you must use only keys spring.jackson  ","excerpt":" Definition  Since mostly of the frameworks integrate to Jackson and …","ref":"/docs-beagle/docs/resources/customization/beagle-for-backend/serialization/","title":"Serialization"},{"body":" Como a maioria dos frameworks integram com Jackson e oferecem propriedades para customizar serialização, optamos por não adicionar propriedades nossas. Em vez disso, mantivemos a compatibilidade com seu framework escolhido.\nCustomização Dentro da pasta src/main/resources procure por um arquivo chamado(se não existir pode criar) application.properties. Caso a chave não esteja listada no seu arquivo, significa que a configuração padrão será automaticamente aplicada.\nNos links abaixo você confere as propriedades disponíveis para serialização de acordo com framework:\n Micronaut Spring​  No caso do Spring, deve-se utilizar apenas as chaves spring.jackson  ","excerpt":" Como a maioria dos frameworks integram com Jackson e oferecem …","ref":"/docs-beagle/pt/docs/recursos/customiza%C3%A7%C3%A3o/beagle-para-backend/serializa%C3%A7%C3%A3o/","title":"Serialização"},{"body":" Beagle offers two ways to define your components using builders:\n Pattern builder DSL builder  With them, you are able to use the platform’s components in a declarative way with Kotling or more practical way to assemble the components with your pattern values, in case if you are using Java instead of Kotlin.\nYou can mix two available ways to define a component.  Pattern builder The way to use the patterns builder on Beagle is similiar to any other builder you have used before. The builder’s name is generally the component’s name with the suffix Builder attached.\nThe exceptions are the components with the type:\n sealed classes, builders that has its father class as an attached prefix. Screen, builder that is a ScreenComponentBuilder.  Java Kotlin //Navigate is a sealed class with //OpenNativeRoute as a child class new NavigateOpenNativeRouteBuilder() .route(\"/route\") .shouldResetApplication(false) .data(new HashMap\u003cString, String\u003e()) .build();  //Navigate is a sealed class with //OpenNativeRoute as a child class NavigateOpenNativeRouteBuilder() .route(\"/route\") .shouldResetApplication(false) .data(mutableMapOf\u003cString, String\u003e()) .build()  DSL builder To define a Beagle component using this method, you have to declare the component and its properties using keys and methods with the same field name to be declared or directly by the attribution operator (=). See the example below:\nalert{ title{ valueOf(\"Titulo\") }//using the keys  message( valueOf(\"Message\") )//using the methods  labelOk = \"OK\"//attributing the value directly } //equivalent Alert( title = valueOf(\"Titulo\"), message = valueOf(\"Message\"), labelOk = \"OK\" ) In cases where the field waits a list or a map, you have to put before the elemement to be added in the collection with the operator ‘+’. This operator also accepts a unique element. See the examples:\nLists Maps container{ children{ +Text(\"Hello\") +Text(\"There\") +listOf(Text(\"General\"), Text(\"Kenobi\")) } } //equivalent Container(children = listOf( Text(\"Hello\"), Text(\"There\"), Text(\"General\"), Text(\"Kenobi\") ))  navigateOpenNativeRoute { route = \"/route\" shouldResetApplication = false data{ +(\"Content-Type\" to \"application/json\") +mapOf( \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\" ) } } //equivalent Navigate.OpenNativeRoute( route = \"/route\", shouldResetApplication = false, data = mapOf( \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\" ) )  Example The example below defines a simple declared screen in the three available options on Beagle:\nPattern Builder DSL Pattern builder Screen( navigationBar = NavigationBar( title = \"Navigation Bar Title\", showBackButton = false ), child = Text( text = valueOf(\"Hello There\") ).applyStyle(Style( margin = EdgeValue(bottom = 10.unitReal()) )) )  screen{ navigationBar{ title = \"Navigation Bar Title\" showBackButton = true } child{ text{ text = valueOf(\"Hello There\") }.style { margin{ bottom = 10.unitReal() } } } }  ScreenComponentBuilder() .navigationBar( NavigationBarBuilder() .title(\"Navigation Bar Title\") .showBackButton(true) .build() ).child( TextBuilder() .text(valueOf(\"Hello There\")) .build().applyStyle( StyleBuilder() .margin( EdgeValueBuilder() .bottom(10.unitReal()) .build() ) .build() ) ).build()  ","excerpt":" Beagle offers two ways to define your components using builders: …","ref":"/docs-beagle/docs/resources/builders-for-kotlin-dsl/","title":"Builders for Kotlin Dsl"},{"body":" Criando a ação no frontend No Beagle, é possível criar uma ação customizada a partir de uma CustomAction .\nCada plataforma tem sua forma própria para fazer esta implementação no frontend. Abaixo, listamos exemplos para cada uma.\nAndroid iOS Web Primeiro, você deve criar uma classe anotada com @RegisterAction que implemente a interface Action. Esta mesma interface solicitará que o método execute seja implementado e, aqui, você irá declarar o resultado da action.\nO atributo msg listado é apenas um exemplo de parâmetro que pode ser declarado no construtor desta classe. O exemplo a seguir mostra uma ação com Toast:\n@RegisterAction data class CustomAction( val msg: String? = null ) : Action { override fun execute(rootView: RootView) { Toast.makeText( rootView.getContext(), msg, Toast.LENGTH_LONG).show() } }  Primeiro, você deve criar uma classe que implemente o tipo Action. Esta mesma classe solicitará que o método execute seja implementado e irá ditar as ações da action .\nO atributo msg listado é apenas um exemplo de parâmetro que pode ser declarado no construtor desta classe. O exemplo a seguir mostra uma ação com Alert:\nclass CustomAction: Action { let msg: String? init(msg: String? = nil) { self.msg = msg } func execute(controller: BeagleController, sender: Any) { let alert = UIAlertController( title: nil, message: msg, preferredStyle: .alert ) controller.present(alert, animated: true) } } Para registrar a ação, basta criar um método onde terá todas suas custom action e chamar o método do Beagle registerCustomAction que fará o registro.\nChame o método criado no BeagleConfig, tal como no tutorial da seção “Criando um projeto do zero”. \nprivate func registerCustomAction() { Beagle.registerCustomAction(\"CustomAction\", actionType: CustomAction.self) }  Primeiro, você deve criar uma interface com a propriedade obrigatória _beagleAction_ __e os parâmetros necessários para sua ação. Para este exemplo, criaremos o atributo msg do tipo string.\nEm ___beagleAction_ , coloque o nome da ação customizada seguindo o padrão ‘custom:nomeDaAção’\ninterface CustomAction { _beagleAction_: 'custom:CustomAction', msg: string } Feito isso, declare uma função do tipo ActionHandler com a interface que você acabou de criar.\nimport { ActionHandler } from '@zup-it/beagle-web' export const customHandler: ActionHandler\u003cCustomAction\u003e = ({ action }) =\u003e { /* Podemos acessar nosso parâmetro definido na interface, por exemplo action.msg nos traz o valor de msg. */ alert(action.msg) } Por fim, adicione o nome da ação no arquivo de associações de acordo com cada framework:\nPara o Angular, adicione em beagle.module.ts\n@BeagleModule({ ... customActions:{ \"custom:CustomAction\": customHandler //nome do action handler  } }) export class Beagle {} Para o React, adicione ao seu arquivo de configurações do Beagle\nexport default createBeagleUIService\u003cany\u003e({ ... customActions:{ \"custom:CustomAction\": customHandler //nome do action handler  } })  Criando a referência da ação no backend Para criar a referência, o seu código deve ficar assim:\n@RegisterAction data class CustomAction( val msg: String? = null ) : Action Abaixo, temos um exemplo de Action em um componente do tipo Botão.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Beagle Button\", \"onPress\": [ { \"_beagleAction_\": \"custom:customAction\", \"msg\": \"Eu sou um Toast.\" } ] }  Button( text = \"Beagle Button\", onPress = listOf(CustomAction(\"Eu sou um Toast\")) )  ","excerpt":" Criando a ação no frontend No Beagle, é possível criar uma ação …","ref":"/docs-beagle/pt/docs/recursos/cria%C3%A7%C3%A3o-de-novas-a%C3%A7%C3%B5es/","title":"Criação de novas ações"},{"body":" O Beagle fornece duas maneiras para definir seus componentes utilizando builders.\n Builder padrão Builder DSL  Com eles, você consegue usar os componentes da plataforma de forma declarativa com Kotlin ou de uma maneira mais prática para montar os componentes com seus valores padrões, caso esteja utilizando Java ao invés de Kotlin.\nVocê pode misturar as 3 maneiras disponíveis para definir um componente.  Builder padrão A maneira de usar os builders padrões do Beagle é semelhante a qualquer outro builder que você já tenha utilizado. O nome de cada builder de forma geral é o nome do componente com o sufixo Builder anexado.\nAs exceções são componentes do tipo:\n sealed classes, cujo builders possuem o nome de sua classe pai como prefixo anexado. Screen, cujo builder é ScreenComponentBuilder.  Java Kotlin DSL //Navigate é uma sealed class com //OpenNativeRoute como uma classe filha new NavigateOpenNativeRouteBuilder() .route(\"/route\") .shouldResetApplication(false) .data(new HashMap\u003cString, String\u003e()) .build();  //Navigate é uma sealed class com //OpenNativeRoute como uma classe filha NavigateOpenNativeRouteBuilder() .route(\"/route\") .shouldResetApplication(false) .data(mutableMapOf\u003cString, String\u003e()) .build()  Builder DSL Para definir um componente do Beagle utilizando esse método, você deve declarar o componente e suas propriedades utilizando chaves e métodos com o mesmo nome do campo a ser declarado ou diretamente pelo operador de atribuição (=). Veja o exemplo:\nalert{ title{ valueOf(\"Titulo\") }//utilizando as chaves  message( valueOf(\"Message\") )//utilizando os métodos  labelOk = \"OK\"//atribuindo o valor diretamente } //equivalente Alert( title = valueOf(\"Titulo\"), message = valueOf(\"Message\"), labelOk = \"OK\" ) Nos casos em que o campo espera uma lista ou um mapa, você deve colocar antes do elemento a ser adicionado na coleção com o operador ‘+’. Esse operador também aceita elemento único. Veja os exemplos:\nListas Mapas container{ children{ +Text(\"Hello\") +Text(\"There\") +listOf(Text(\"General\"), Text(\"Kenobi\")) } } //equivalente Container(children = listOf( Text(\"Hello\"), Text(\"There\"), Text(\"General\"), Text(\"Kenobi\") ))  navigateOpenNativeRoute { route = \"/route\" shouldResetApplication = false data{ +(\"Content-Type\" to \"application/json\") +mapOf( \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\" ) } } //equivalente Navigate.OpenNativeRoute( route = \"/route\", shouldResetApplication = false, data = mapOf( \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\", \"Content-Type\" to \"application/json\" ) )  Exemplo O exemplo abaixo define uma tela simples declarada nas três maneiras disponíveis pelo Beagle:\nPadrão Builder DSL Builder Padrão Screen( navigationBar = NavigationBar( title = \"Navigation Bar Title\", showBackButton = false ), child = Text( text = valueOf(\"Hello There\") ).applyStyle(Style( margin = EdgeValue(bottom = 10.unitReal()) )) )  screen{ navigationBar{ title = \"Navigation Bar Title\" showBackButton = true } child{ text{ text = valueOf(\"Hello There\") }.style { margin{ bottom = 10.unitReal() } } } }  ScreenComponentBuilder() .navigationBar( NavigationBarBuilder() .title(\"Navigation Bar Title\") .showBackButton(true) .build() ).child( TextBuilder() .text(valueOf(\"Hello There\")) .build().applyStyle( StyleBuilder() .margin( EdgeValueBuilder() .bottom(10.unitReal()) .build() ) .build() ) ).build()  ","excerpt":" O Beagle fornece duas maneiras para definir seus componentes …","ref":"/docs-beagle/pt/docs/recursos/builders-para-kotlin-dsl/","title":"Builders para Kotlin Dsl"},{"body":" Beagle offers a style resources for your components. You can know more about this process checking out the styles for each operational system in the next pages:\n","excerpt":" Beagle offers a style resources for your components. You can know …","ref":"/docs-beagle/docs/resources/style/","title":"Style"},{"body":" Introduction Inside Beagle’s library, there is a DesignSystem class that can be used to personalize the components used on your application.\nThis class also can map application’s local resources so we can refer to BFF when you build a Server-Driven screen.\nBeside the images, Beagle’s Design System can customize:\n the appearance of the texts; the style of the input components; the style of the buttons; the style of the toolbars and tabViews.  Customized attributes For Beagle to be able to apply customized styles to components, when they are declared in the application, their parents must refer to each corresponding family. That is, to customize the components:\n Text, your style should extend from Widget.AppCompat.TextView TextInput, your style should extend from Widget.AppCompat.EditText Button, your style should extend from Widget.AppCompat.Button Toolbar, your style should extend from Widget.AppCompat.Toolbar TabView, your style should extend from Widget.Design.TabLayout   Text The text’s components for Beagle Android are totally customized. To make this change, you just have to follow the pattern below:\n\u003c!-- Custom style for textual components. --\u003e \u003cstyle name=\"CustomText\" parent=\"Widget.AppCompat.TextView\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e TextInput The input components in Beagle Android are also fully customizable. To make any changes, just follow the pattern below:\n\u003c!-- Custom style for textual components. --\u003e \u003cstyle name=\"CustomInput\" parent=\"Widget.AppCompat.EditText\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"android:background\"\u003e@drawable/text_input_background\u003c/item\u003e \u003c/style\u003e Button Like the texts and inputs, the buttons on the Beagle Android are fully customizable. To make any changes, just follow the pattern below:\n\u003c!-- Custom style for Button components. --\u003e \u003cstyle name=\"CustomButton\" parent=\"Widget.AppCompat.Button\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e18sp\u003c/item\u003e \u003citem name=\"android:textAllCaps\"\u003efalse\u003c/item\u003e \u003citem name=\"android:background\"\u003e?attr/selectableItemBackground\u003c/item\u003e \u003c/style\u003e Toolbar Inside Beagle’s library for Android, the tool bar is part ofNavigationBar’s class. To make it properly work on BeagleActivity, you need to inform Beagle which bar will be used on your application.\nThe bar customization can be done in the moment that she passes through Beagle. Besides these attributes, Toolbar has other four that are exclusive:\n backgroundColor: defines the Tool Bar’s background color. navigationIcon: receives a drawable and attributes it to a navigation bar icon on tool bar. titleTextAppearance: receives a text style to personalize a tool bar’s title. centerTitle: when activated, centralize the tool bar’s title.  \u003c!-- Custom style for Toolbar components. --\u003e \u003cstyle name=\"CustomToolbar\" parent=\"Widget.AppCompat.Toolbar\"\u003e \u003citem name=\"backgroundColor\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"navigationIcon\"\u003e?attr/homeAsUpIndicator\u003c/item\u003e \u003citem name=\"titleTextAppearance\"\u003e@style/CustomTitleToolbar\u003c/item\u003e \u003citem name=\"centerTitle\"\u003etrue\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"CustomTitleToolbar\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e TabView The Beagle’s TabView component represents the Android’s TabLayout and all its visual structure tha can be stylized with the following attributes:\n tabSelectedTextColor: attributes a different color to a selected tab’s text. tabTextColor: attributes a text color to all tabs, which means not selected tabs. tabBackground: receives a drawable and attributes it to TabView’s background. tabIndicatorColor: attributes a color to a selection’s indicator of one tab. tabIconTint: receives a drawable to define icons' colors, being selected or not.  \u003c!-- Custom style for TabLayout components. --\u003e \u003cstyle name=\"CustomTab\" parent=\"Widget.Design.TabLayout\"\u003e \u003citem name=\"tabSelectedTextColor\"\u003e@color/colorWhite\u003c/item\u003e \u003citem name=\"tabTextColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"tabBackground\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"tabIndicatorColor\"\u003e@color/colorWhite\u003c/item\u003e \u003citem name=\"tabIconTint\"\u003e@color/selector_icon_color\u003c/item\u003e \u003c/style\u003e To manage all the selected tabs, we recommend you the use of a selector for the tabIconTint attribute, as in the example below:\n\u003cselector xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:color=\"@android:color/white\" android:state_selected=\"true\" /\u003e \u003citem android:color=\"@android:color/black\" /\u003e \u003c/selector\u003e ","excerpt":" Introduction Inside Beagle’s library, there is a DesignSystem class …","ref":"/docs-beagle/docs/resources/style/android/","title":"Android"},{"body":" O Beagle disponibiliza na sua biblioteca o recurso de estilização de componentes. Você pode conhecer melhor o processo para cada sistema operacional nas próximas páginas:\n","excerpt":" O Beagle disponibiliza na sua biblioteca o recurso de estilização de …","ref":"/docs-beagle/pt/docs/recursos/estiliza%C3%A7%C3%A3o/","title":"Estilização"},{"body":" Introdução Dentro da biblioteca do Beagle, existe a classe DesignSystem que pode ser usada para personalizar os componentes utilizados na sua aplicação.\nEsta classe serve para mapear os recursos locais de um aplicativo para podermos referenciá-los no BFF ao construir uma tela Server-Driven.\nAlém de imagens, o Design System do Beagle pode personalizar:\n A aparência dos textos; O estilo dos componentes de input; O estilo dos botões; O estilo das toolbars e Das tabViews.  Atributos customizáveis Para o Beagle ser capaz de aplicar os estilos customizados aos componentes, quando forem declarados na aplicação seus pais devem se referir a cada familia correspondente. Ou seja, para customizar os componentes:\n Text, seu estilo deve estender de Widget.AppCompat.TextView TextInput, seu estilo deve estender de Widget.AppCompat.EditText Button, seu estilo deve estender de Widget.AppCompat.Button Toolbar, seu estilo deve estender de Widget.AppCompat.Toolbar TabView, seu estilo deve estender de Widget.Design.TabLayout   Text Os textos no Beagle Android são totalmente customizáveis. Para realizar qualquer mudança, basta seguir o padrão abaixo:\n\u003c!-- Custom style for textual components. --\u003e \u003cstyle name=\"CustomText\" parent=\"Widget.AppCompat.TextView\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e TextInput Os componentes de input no Beagle Android também são totalmente customizáveis. Para realizar qualquer mudança, basta seguir o padrão abaixo:\n\u003c!-- Custom style for textual components. --\u003e \u003cstyle name=\"CustomInput\" parent=\"Widget.AppCompat.EditText\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"android:background\"\u003e@drawable/text_input_background\u003c/item\u003e \u003c/style\u003e Button Assim como os textos e inputs, os botões no Beagle Android são totalmente customizáveis. Para realizar qualquer mudança, basta seguir o padrão abaixo:\n\u003c!-- Custom style for Button components. --\u003e \u003cstyle name=\"CustomButton\" parent=\"Widget.AppCompat.Button\"\u003e \u003citem name=\"android:textColor\"\u003e#000000\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e18sp\u003c/item\u003e \u003citem name=\"android:textAllCaps\"\u003efalse\u003c/item\u003e \u003citem name=\"android:background\"\u003e?attr/selectableItemBackground\u003c/item\u003e \u003c/style\u003e Toolbar Dentro da biblioteca Beagle no Android, a barra de ferramentas faz parte da classe NavigationBar. Para que ela funcione corretamente no BeagleActivity, você precisar informar ao Beagle qual barra irá utilizar na sua aplicação.\nA customização da barra pode ser feita no momento em que ela é passada para o Beagle. A Toolbar, além dos atributos já mencionados, possui outros quatro que são exclusivos:\n backgroundColor: define a cor de fundo da Barra de Ferramentas. navigationIcon: recebe um drawable e o atribui ao ícone de navegação da barra de ferramentas. titleTextAppearance: recebe um estilo de texto para personalizar o título da barra de ferramentas. centerTitle: quando ativado, centraliza o título na barra de ferramentas.  \u003c!-- Custom style for Toolbar components. --\u003e \u003cstyle name=\"CustomToolbar\" parent=\"Widget.AppCompat.Toolbar\"\u003e \u003citem name=\"backgroundColor\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"navigationIcon\"\u003e?attr/homeAsUpIndicator\u003c/item\u003e \u003citem name=\"titleTextAppearance\"\u003e@style/CustomTitleToolbar\u003c/item\u003e \u003citem name=\"centerTitle\"\u003etrue\u003c/item\u003e \u003c/style\u003e \u003cstyle name=\"CustomTitleToolbar\" parent=\"TextAppearance.AppCompat\"\u003e \u003citem name=\"android:textColor\"\u003e@color/colorPrimary\u003c/item\u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:textStyle\"\u003ebold\u003c/item\u003e \u003c/style\u003e TabView O componente TabView no Beagle representa o TabLayout do Android e toda a sua estrutura visual pode ser estilizada com os seguintes atributos:\n tabSelectedTextColor: atribui uma cor diferente ao texto da aba selecionada. tabTextColor: atribui uma cor ao texto a todas as guias, ou seja, as abas não selecionadas. tabBackground: recebe um drawable e atribuí-lo ao plano de fundo do TabView. tabIndicatorColor: atribui uma cor ao indicador de seleção de uma aba. tabIconTint: recebe um drawable para definir as cores dos ícones, sendo selecionados ou não.  \u003c!-- Custom style for TabLayout components. --\u003e \u003cstyle name=\"CustomTab\" parent=\"Widget.Design.TabLayout\"\u003e \u003citem name=\"tabSelectedTextColor\"\u003e@color/colorWhite\u003c/item\u003e \u003citem name=\"tabTextColor\"\u003e@color/colorBlack\u003c/item\u003e \u003citem name=\"tabBackground\"\u003e@color/colorPrimaryDark\u003c/item\u003e \u003citem name=\"tabIndicatorColor\"\u003e@color/colorWhite\u003c/item\u003e \u003citem name=\"tabIconTint\"\u003e@color/selector_icon_color\u003c/item\u003e \u003c/style\u003e Para gerenciar as abas selecionadas, é recomendado o uso de um seletor para o atributotabIconTint. Como no exemplo abaixo:\n\u003cselector xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:color=\"@android:color/white\" android:state_selected=\"true\" /\u003e \u003citem android:color=\"@android:color/black\" /\u003e \u003c/selector\u003e ","excerpt":" Introdução Dentro da biblioteca do Beagle, existe a classe …","ref":"/docs-beagle/pt/docs/recursos/estiliza%C3%A7%C3%A3o/android/","title":"Android"},{"body":" Introdução Inside Beagle’s library for iOS, there’s an AppTheme class that allows you to personalize components used on your application.\nThis class also can map application’s styles so it can be referenced on BFF to build a Server-Driven screen.\nIt makes possible to personalize, for example:\n Texts' styles; Button’s styles; TabView.  It’s importante to make clear that iOS doesn’t map all the components' attributes. However, the more important are already mapped, so they can be modified if necessary.\nCustomized attributes As not all customization’s attributes can be stylized, on the list below we’ll see which elements can be personalized through Beagle.\nAnother important point is that styles created on iOS and related to componentes that came from backend. On these cases, you can configure the styles so each of them can be referenced, just like the example below:\nlet theme = AppTheme(styles: [ Styles.customButton.key : Styles.customButton.style, Styles.customText.key : Styles.customText.style, Styles.customTab.key : Styles.customTab.style ]) dependencies.theme = theme Besides reference styles, you have to create a key value pair defining a name to each style created:\nstruct StylePair { var key: String var style: Any } class Styles { static let customText = StylePair(key: \"CustomText\", style: customText) static let customButton = StylePair(key: \"CustomButton\", style: customButton) static let customTab = StylePair(key: \"CustomTab\", style: customTab) } Text The text’s components for Beagle iOS are totally personalized. To make any attribute change, you just have to follow the pattern below:\nprivate static func textH1() -\u003e (UITextView?) -\u003e Void { BeagleStyle.text(font: .boldSystemFont(ofSize: 32), color: UIColor(named: \"ColorText\")!) } Button Besides the complete text personalization, the Button component can be customized with another attribute: the withTitleColor, which is responsible to personalize button’s color.\nOn Swift, you can also add extra styles to a component by using the \u003c\u003e note , according to the example below:\nstatic func defaultStylishButton() -\u003e (UIButton?) -\u003e Void { return BeagleStyle.button(withTitleColor: .white) \u003c\u003e { $0?.titleLabel |\u003e BeagleStyle.label(withFont: .systemFont(ofSize: 16, weight: .regular)) $0?.layer.cornerRadius = 6 $0?.clipsToBounds = true $0?.backgroundColor = UIColor(hex: \"#3C3737\") } } TabView The Beagle’s TabView component for iOS can be stylized with these attributes:\n backGroundColor: attributes a different color to a selected tab background. indicatorColor: attributes a color to a selected background.  static func customTab() -\u003e (UITabBar) -\u003e Void { return BeagleStyle .tabView(backgroundColor: .blue, indicatorColor: .white) } ","excerpt":" Introdução Inside Beagle’s library for iOS, there’s an AppTheme class …","ref":"/docs-beagle/docs/resources/style/ios/","title":"IOS"},{"body":" Introdução Na biblioteca do Beagle para iOS, existe a classe AppTheme que permite personalizar os componentes utilizados na sua aplicação.\nEsta classe mapeia os estilos de um aplicativo para que seja possível referenciá-los no BFF ao construir uma tela Server-Driven.\nIsso possibilita personalizar, por exemplo:\n Aparência dos textos Estilo dos botões TabView  É importante deixar claro que o Beagle para iOS não mapeia todos os atributos destes componentes, porém os mais já estão mapeados e, portanto, podem ser modificados se necessário.\nAtributos customizáveis Como nem todos os atributos de customização podem ser estilizados, abaixo você encontra a lista com quais elementos podem ser personalizados pelo Beagle.\nOutro ponto importante é o dos estilos criados no iOS e vinculados a componentes vindos do Backend. Nestes casos, você precisa configurar os estilos para que cada um deles esteja referenciado, como no exemplo abaixo:\nlet theme = AppTheme(styles: [ Styles.customButton.key : Styles.customButton.style, Styles.customText.key : Styles.customText.style, Styles.customTab.key : Styles.customTab.style ]) dependencies.theme = theme Além de referenciar os estilos, é preciso criar um par chave valor definindo um nome para cada style criado:\nstruct StylePair { var key: String var style: Any } class Styles { static let customText = StylePair(key: \"CustomText\", style: customText) static let customButton = StylePair(key: \"CustomButton\", style: customButton) static let customTab = StylePair(key: \"CustomTab\", style: customTab) } Text Os componentes de texto no Beagle iOS são totalmente personalizáveis. Quando for realizar qualquer alteração nos atributos, é só seguir o padrão abaixo:\nprivate static func textH1() -\u003e (UITextView?) -\u003e Void { BeagleStyle.text(font: .boldSystemFont(ofSize: 32), color: UIColor(named: \"ColorText\")!) } Button Além da personalização completa para textos, o componente Button possibilita customizar outro atributo: withTitleColor, que é responsável por personalizar a cor do botão.\nNo Swift, você pode ainda adicionar estilos extras ao componente utilizando a anotação \u003c\u003e , de acordo com o exemplo abaixo:\nstatic func defaultStylishButton() -\u003e (UIButton?) -\u003e Void { return BeagleStyle.button(withTitleColor: .white) \u003c\u003e { $0?.titleLabel |\u003e BeagleStyle.label(withFont: .systemFont(ofSize: 16, weight: .regular)) $0?.layer.cornerRadius = 6 $0?.clipsToBounds = true $0?.backgroundColor = UIColor(hex: \"#3C3737\") } } TabView O componente TabView no Beagle iOS pode ser estilizado com os seguintes atributos:\n backGroundColor: atribui uma cor diferente ao background da aba selecionada. indicatorColor: atribui uma cor ao background selecionado.  static func customTab() -\u003e (UIView?) -\u003e Void { return BeagleStyle .tabView(backgroundColor: .blue, indicatorColor: .white) } ","excerpt":" Introdução Na biblioteca do Beagle para iOS, existe a classe AppTheme …","ref":"/docs-beagle/pt/docs/recursos/estiliza%C3%A7%C3%A3o/ios/","title":"IOS"},{"body":" Introduction It’s possible to make two main kinds of stylization with Beagle for Web:\n Adding style classes JSON components style  Here, you will see a detailed explanation for each of these stylizations.\nAdding style classes Adding style’s propriety on JSON To make this change, you must add on your JSON file a styleId propriety with the name of the style’s class that you created on your angular component.\nOn the example below, you see how this addition was done to a “card” hypothetical class.\n{ \"_beagleComponent_\": \"custom:card\", \"myCustomTitle\": \"Beagle Web\", \"myCustomDescription\": \"Lorem ipsum dolor ...\" \"styleId\": \"card\" } Inserting a class on components The process to insert a class to a component varies according to the framework you’re using. Check out the step by step of each case in the following tabs:\nAngular React On Angular, there are two ways to add a class we receive through styleId propriety:\n1. Through ViewEncapsulation Open the file on your angular component and right down the styleUrls propriety on @Component decorator, add the ViewEncapsulation.none. enum.\nSee how it works on the example below:\n@Component({ selector: 'app-card', templateUrl: './card.component.html', styleUrls: ['./card.component.less'], encapsulation: ViewEncapsulation.None, }) Once you made it, you just have to run the project with one of these commands:\nnpm run serve yarn serve After you add the None enum to a @Component() encapsulation propriety, it’s necessary to make it useful. See how to make it on the image below:\nIf you want to see more about ViewEncapsulation, check out Angular’s documentation.\n 2. Through StyleId propriety Another way to add a class is by maintaining a native encapsulation propriety. To do so, you have to open your Angular’s component file and add a new @Input, that in this case is StyleId.\nSee how it works on the example below:\nexport class CardComponent implements OnInit { @Input() myCustomTitle: string @Input() myCustomDescription: string @Input() styleId: string constructor() { } ... } Once you made it, this Input has the reference of the class' name you added on JSON in the previous step. In the sequence, you need to change the HTML as in the model below:\n\u003cdiv class=\"{{styleId}}\"\u003e \u003cdiv\u003e \u003ch1\u003e{{myCustomTitle}}\u003c/h1\u003e \u003ch3\u003e{{myCustomDescription}}\u003c/h3\u003e \u003c/div\u003e \u003c/div\u003e Finally, you just have to run the project with one of the these commands:\nnpm run serve yarn serve Anyway you used to connect your style class to a component may brings the same result and your component can be changed according to the defined style in your class.\n On React’s projects, you have to access your class through styleId propriety.\nImport your style’s file on the component and then you need to attribute a value to styleId on className through the props.\nimport React from 'react' import './custom-text.style.css' function CustomTextComponent(props){ return ( \u003cp className={props.styleId}\u003e{props.customText}\u003c/p\u003e ) } export default CustomTextComponent; The elements' components can now receive the class defined on JSON.\n It’s worth reinforcing that to define a class withstyleId class added, it’s fundamental that you have a style file inside your project (Ex: CSS, SASS, LESS).  Stylizing components through JSON Another Beagle Web’s possibility is to stylize its components. You see on the following topics what can be done directly through JSON:\nPosition You can change the element’s position on the screen by using the position propriety, like in the example:\n{ ... { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Welcome to the Beagle playground!\", \"style\": { \"positionType\":\"relative\", \"position\": { \"top\": { \"value\": 10, \"type\": \"REAL\" }, \"left\": { \"value\": 10, \"type\": \"REAL\" } } } } ] } Margin e Padding You can change the element’s margin or spacing on the screen by using margin e padding proprieties, like in the example below:\n{ ... { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Welcome to the Beagle playground!\", \"style\": { \"margin\": { \"top\": { \"value\": 10, \"type\": \"REAL\" }, \"left\": { \"value\": 10, \"type\": \"REAL\" } } } } ] } Size It’s also possible to change elements' dimension by using Size propriety, which receives the values on Height or Width. See on the example below:\n{ \"_beagleComponent_\": \"beagle:container\", \"size\": { \"height\": { \"value\": 100, \"type\": \"REAL\" }, \"width\": { \"value\": 100, \"type\": \"REAL\" } } } ... }  Notice that, in all the examples above, the proprieties receive the values' maps in a \u003cvalue, type\u003e format.\nIn Beagle’s case, the available values are:\n REAL - Value on pixel (‘px’) PERCENT - Value on percentage (%)   Flex Finally, you have the possibility to add proprieties in a flexbox layout model with Beagle’s library.\n{ \"_beagleComponent_\": \"beagle:container\", \"style\": { \"backgroundColor\":\"red\", \"flex\": { \"flexDirection\": \"COLUMN\", \"alignItems\": \"CENTER\", \"justifyContent\": \"CENTER\" } } } ...  Besides these functionalities, there are some components that have specific proprieties like text change color or alignement. Check out more about Beagle’s components.  ","excerpt":" Introduction It’s possible to make two main kinds of stylization with …","ref":"/docs-beagle/docs/resources/style/web/","title":"WEB"},{"body":" Introdução É possível realizar duas principais maneiras de estilização com Beagle para Web. São elas:\n Adição de classes de estilo  Estilização de componentes via JSON  Abaixo, você encontra a explicação detalhada para cada uma delas.\nAdicionando classes de estilo Adicionar propriedade de estilo ao JSON Para fazer essa mudança, você deve adicionar, em seu arquivo JSON, a propriedade styleId com o nome da classe de estilo que você criou em seu componente angular.\nNo exemplo abaixo, você vê como foi feita a adição para uma classe hipotética com nome ‘card’.\n{ \"_beagleComponent_\": \"custom:card\", \"myCustomTitle\": \"Beagle Web\", \"myCustomDescription\": \"Lorem ipsum dolor ...\" \"styleId\": \"card\" } Inserir a classe ao componente O processo de inserir uma classe ao componente varia de acordo com o framework que estiver utilizando. Confira o processo para cada um deles nas abas a seguir:\nAngular React No Angular, há duas formas de adicionar a classe que recebemos da propriedade styleId:\n1. Pelo ViewEncapsulation Abra o arquivo do seu componente angular e, logo abaixo da propriedade styleUrls do decorator @Component, adicione o enum ViewEncapsulation.none.\nVeja como funciona no exemplo abaixo:\n@Component({ selector: 'app-card', templateUrl: './card.component.html', styleUrls: ['./card.component.less'], encapsulation: ViewEncapsulation.None, }) Feito isso, basta rodar o projeto com um dos comandos:\nnpm run serve yarn serve Depois que você adicionar o enum None à propriedade encapsulation do @Component(), é necessário fazer com que ela seja utilizada. Veja como na imagem abaixo:\nPara entender mais sobre o ViewEncapsulation, acesse a documentação do Angular.\n 2. Pela propriedade StyleId Outra maneira de você adicionar a classe é mantendo a propriedade encapsulation como nativo. Para isso, é só abrir o arquivo do seu componente Angular e adicionar um novo @Input, no caso, o styleId.\nVeja no exemplo a seguir:\nexport class CardComponent implements OnInit { @Input() myCustomTitle: string @Input() myCustomDescription: string @Input() styleId: string constructor() { } ... } Uma vez feito isso, este Input está com a referência do nome da classe que você adicionou ao JSON no passo anterior. Na sequência, você precisa mudar o HTML como no modelo abaixo:\n\u003cdiv class=\"{{styleId}}\"\u003e \u003cdiv\u003e \u003ch1\u003e{{myCustomTitle}}\u003c/h1\u003e \u003ch3\u003e{{myCustomDescription}}\u003c/h3\u003e \u003c/div\u003e \u003c/div\u003e Por fim, basta rodar o projeto com um dos comandos:\nnpm run serve yarn serve Qualquer uma das formas que você usou para conectar sua classe de estilo ao componente deve gerar o mesmo resultado e seu componente deve ser alterado de acordo com o estilo definido em sua classe.\n Para projetos React, você acessa a sua classe por meio da propriedade styleId.\nImporte seu arquivo de estilos no componente e você precisa atribuir o valor de styleId ao className por meio das props.\nimport React from 'react' import './custom-text.style.css' function CustomTextComponent(props){ return ( \u003cp className={props.styleId}\u003e{props.customText}\u003c/p\u003e ) } export default CustomTextComponent; Pronto, os elementos do seu componente já devem receber a classe definida no JSON\n Vale reforçar que para definir a classe adicionada com valor de styleId, é fundamental que você tenha um arquivo de estilo dentro do seu projeto (Ex: CSS, SASS, LESS).  Estilizando componentes via JSON Mais uma possibilidade do Beagle Web é o de estilizar os seus componentes. Abaixo, você confere o que pode ser feito diretamente pelo JSON:\nPosition Você pode modificar a posição de elementos na tela usando a propriedade position, como no exemplo:\n{ ... { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Welcome to the Beagle playground!\", \"style\": { \"positionType\":\"relative\", \"position\": { \"top\": { \"value\": 10, \"type\": \"REAL\" }, \"left\": { \"value\": 10, \"type\": \"REAL\" } } } } ] } Margin e Padding Você pode também mudar a margem e o espaçamento dos elementos na tela usando as propriedades margin e padding, como no modelo abaixo:\n{ ... { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Welcome to the Beagle playground!\", \"style\": { \"margin\": { \"top\": { \"value\": 10, \"type\": \"REAL\" }, \"left\": { \"value\": 10, \"type\": \"REAL\" } } } } ] } Size É possível ainda alterar as dimensões dos elementos na tela usando a propriedade Size, que recebe os valores de Height ou Width. Veja como no exemplo:\n{ \"_beagleComponent_\": \"beagle:container\", \"size\": { \"height\": { \"value\": 100, \"type\": \"REAL\" }, \"width\": { \"value\": 100, \"type\": \"REAL\" } } } ... }  Repare que, em todos os exemplos acima, as propriedades recebem os mapas de valores no formato \u003cvalue, type\u003e.\nNo caso do Beagle, os valores disponíveis para type são:\n REAL - Valor em pixel (‘px’) PERCENT - Valor em porcentagem (%)   Flex Por fim, você tem a possibilidade de adicionar propriedades no modelo de layout flexbox com a biblioteca do Beagle.\n{ \"_beagleComponent_\": \"beagle:container\", \"style\": { \"backgroundColor\":\"red\", \"flex\": { \"flexDirection\": \"COLUMN\", \"alignItems\": \"CENTER\", \"justifyContent\": \"CENTER\" } } } ...  Além dessas funcionalidades, alguns componentes possuem propriedades específicas como mudança na cor do texto ou alinhamento. Conheça mais sobre os componentes do Beagle  ","excerpt":" Introdução É possível realizar duas principais maneiras de …","ref":"/docs-beagle/pt/docs/recursos/estiliza%C3%A7%C3%A3o/web/","title":"WEB"},{"body":" Introduction Live Preview is a visualization resource that helps with layout development. It allows that screens in development be rendered without need to run your backend server for the layout changes done, thus reducing a screen’s development time.\nIn other words, when a developer edits code defining a screen, they can use the plugin so that updates are communicated to the client and it renders them. This way, it’s possible to view change without running a backend server.\nThis frontend and backend connection is done through a WebSocketon port: 9721.  Requirements To use Live Preview, you must:\n Use Beagle SDK in your BFF**;** Install BeaglePreview plugin;  BFF Configuration You must have a configured BFF with Beagle to use Live Preview. In case you haven’t done it, click here to download an initial project. As an alternative, follow our tutorial on how to implement a Beagle configured backend.\nIntelliJ plugin installation To install BeaglePreview, click on the link below to install:\n{% embed url=“https://plugins.jetbrains.com/plugin/14575-beagle-sdk-live-preview\" caption=“Live Preview plugin for IntelliJ” %}}\nLive Preview Use You must configure both backend and frontend for the Live Preview The frontend can be Android or iOS client.  Step 1: Backend’s Configuration The following steps allow you to view a screen defined in the backend using Live Preview:\n You will create a declarative screen to test. The code ahead will return a simple screen as an example. You will create a function that returns the screen to be viewed through the plugin. Finally, you must annotate this function with@BeaglePreview.  After this, Live Preview will be capable of receiving the developed screen to be rendered. Some interesting points on the example below:\n Notice the screen itself is defined in the ScreenBeagleBuilder class. The buildPreview function is annotated with @BeaglePreview and, therefore, the sender of our screen to be rendered by the plugin.  @BeaglePreview fun buildPreview() = ScreenBeagleBuilder() class ScreenBeagleBuilder: ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text(\"Live Preview!!!\") ) ) ) } If your function is recognized by the plugin, the Beagle logo will appear as a button to the left of the function. When clicking this button, BeaglePreview will push the layout to the client (frontend application), allowing it to update on your layout instantly!\nAfter running the plugin on some function, you only need to save the changes done in your layout so that the Live Preview updates the screen being rendered by the frontend. It does this by compiling your modified code and verifying if there is some change and, if there is, push your new layout to the client.\nStep 2: Frontend’s configuration Once you have configured your backend, the next step is to configure the frontend’s application emulator for a Beagle Android or iOS project.\nAndroid client iOS client Step 1: Installing the submodule To make this installation, your gradle file must contain the following fragment:\nThe latest Beagle’s version:![https://img.shields.io/bintray/v/zupit/repo/beagle](https://img.shields.io/bintray/v/zupit/repo/beagle]()\n// Add in your plugins apply plugin: 'kotlin-kapt' // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" debugImplementation \"br.com.zup.beagle:android-preview:$beagle_version\" } On ext.beagle_version = \"${beagle_version}\", insert the Beagle’s release version on the place of ${beagle.version}. That means that you put the Beagle’s version indicated on the blue badge, but without the v character.\nFor example: undefined-ext.beagle.version = \"0.2.8\"\nOnce you made it, you can update your dependencies.\nStep 2: Creating a Preview Activity First of all, it’s necessary to state a PreviewActivity on your application’s manifest to show a preview:\nIt’s not necessary to create, in fact, an Activity because it’s already internally created on Beagle. You should only refer it on your manifest indicating that it’s part of Activities' hall accessible on this application.\n Copy and paste the Activity below on your AndroidManifest:\n... \u003capplication\u003e ... \u003cactivity android:exported=\"true\" android:name=\"br.com.zup.beagle.android.preview.PreviewActivity\" android:theme=\"@style/AppTheme.NoToolbar\"/\u003e \u003c/application\u003e \u003c/manifest\u003e As well as in BeagleActivity, you must inform onPreviewActivity state that the theme has not the ActionBar, because Beagle already coordinates this component.\nAnother important point is that you have to enable the exported flag so it can start through ADB\n Visualizing screens through Android Studio’s Emulator After you finished the previous configurations, you must start the IntelliJ plugin by clicking on Beagle’s symbol next to the function that notes @BeaglePreview and opensPreviewActivity to receive the updates sent from BFF to be automatically rendered.\n To start the PreviewActivity through intent, you just have to call the intent below to see the emulator’s screen:  startActivity(PreviewActivity.newIntent(this)) However, if you prefer to start through ADB, just call the method:\nadb shell am start -n applicationpackagename/br.com.zup.beagle.android.preview.PreviewActivity For more information about your package, access the attribute’s package on yourAndroidManifest’s file\n Visualizing screens through Android Device You can also view the screen you’re creating by an Android device. To do so, it’s necessary to inform your network’s IP on the intent that calls the Live Preview screen.\nThe Live Preview’s Activity connects to the Backend ’s screen through the client’s\nwebsocket connection. In this way, this client needs to know whichIP must be used to establish the connection.\n  To start a PreviewActivity through device, you just have to call the intent below so you can see the screen on your device:  startActivity( PreviewActivity .newIntent( this, endpoint = \"http://myIP:9721\" ) )  Step 1: Installing the submodule To make the installation, your pod file must contain the following fragments:\n... pod 'BeagleUI', :git =\u003e 'https://github.com/ZupIT/beagle.git' pod 'BeagleUI/Preview', :git =\u003e 'https://github.com/ZupIT/beagle.git' ... After that, you can update your dependencies:\n$ pod install Step 2: Use The user must present the preview’s controller of any visible UIViewController with BeaglePreview.present(in:self) code.\nOnce you made it, the preview controller will connect to a plugin and start to listen the received messages about layout change.\nOn the hypothetical example below, you can see how the UIViewController must be shown:\nimport BeagleUI class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) BeaglePreview.present(in: self) } }  Limitations When using Live Preview, there are two important points to keep in mind:\n The Live Preview client can render any change using the elements available to it when it was started. Custom elements added afterward require a client to rebuild and restart. The @BeaglePreview annotation works with public methods with no parameters outside any class or in a public class that has a constructor with no parameters. See the snippets below.  class UnsupportedConstructor(thing: Any) { @BeaglePreview fun preview() = Text(\":(\") } class SupportedPrimaryConstructor { @BeaglePreview fun preview() = Text(\":)\") } class SupportedBySecondaryConstructor(thing: Any) { constructor() : this(\"solved\") @BeaglePreview fun preview() = Text(\":)\") } class MethodSupport { @BeaglePreview fun supportedMethod() = Text(\":)\") @BeaglePreview fun unsupportedMethod(thing: Any) = Text(\":(\") } @BeaglePreview fun unsupportedFunction(thing: Any) = Text(\":(\") @BeaglePreview fun supportedFunction() = Text(\":)\") ","excerpt":" Introduction Live Preview is a visualization resource that helps with …","ref":"/docs-beagle/docs/resources/live-preview/","title":"Live Preview"},{"body":" Introdução O Live Preview é um recurso de visualização que auxilia no desenvolvimento de layouts. Ele permite que as telas em desenvolvimento sejam renderizadas sem a necessidade de subir seu servidor backend para as alterações de layout feitas, reduzindo, assim, o tempo de desenvolvimento de uma tela.\nEm outras palavras, o Live Preview dá a opção de editar um código que define a tela e, assim, o desenvolvedor pode utilizar o plugin para que as atualizações sejam comunicadas ao cliente e ele as renderize.\nDesta forma, é possível visualizar as mudanças sem precisar subir um servidor backend.\nEsta conexão entre frontend e backend é feita via WebSocket utilizando a porta :9721  Requisitos Para usar o Live Preview você deve:\n Usar o Beagle SDK em seu BFF**;** Instalar o BeaglePreview plugin;  Configuração do BFF Você precisa que seu BFF esteja configurado com o Beagle para utilizar o Live Preview. Caso ainda não o tenha, faça o download de um projeto inicial pronto. Outra possibilidade que você pode fazer, é o nosso tutorial de como implementar um backend com o Beagle configurado.\nInstalação do plugin IntelliJ Para instalar o BeaglePreview entre no link abaixo e clique na opção instalar na IDE:\n{% embed url=“https://plugins.jetbrains.com/plugin/14575-beagle-sdk-live-preview\" caption=“Plugin do Live Preview para IntelliJ” %}}\nUso do Live Preview Você deve configurar tanto o backend quanto o frontend para esse Live Preview. O frontend pode ser cliente Android ou iOS.  Passo 1: Configurar o Backend Os passos a seguir nos permitirão visualizar uma tela definida no backend usando o Live Preview:\n Vamos criar uma tela declarativa para teste. O código mais adiante trará uma tela bem simples como exemplo. Iremos criar uma função que retorna a tela a ser visualizada pelo plugin. Por fim, vamos anotar essa função com @BeaglePreview.  Feito isso, o Live Preview já será capaz de receber a tela em desenvolvimento a ser renderizada.\nAlguns pontos interessantes de se notar do exemplo abaixo:\n Perceba que a tela em si está definida na classe ScreenBeagleBuilder. A função buildPreview está anotada com @BeaglePreview, com isso o plugin consegue utilizar ela para renderizar a tela.  @BeaglePreview fun buildPreview() = ScreenBeagleBuilder() class ScreenBeagleBuilder: ScreenBuilder { override fun build() = Screen( child = Container( children = listOf( Text(\"Live Preview!!!\") ) ) ) } Se sua função for reconhecida pelo plugin, o símbolo do Beagle aparecerá como um botão à esquerda da função. Clicando neste botão, o BeaglePreview faz um push do layout para o cliente (aplicação frontend), permitindo que ele atualize seu layout instantaneamente.\nVeja como no exemplo abaixo:\nDepois de acionar o plugin para alguma função, basta você salvar as modificações realizadas no seu layout para que o Live Preview atualize a tela sendo renderizada pelo frontend.\nO Live Preview faz isso ao compilar seu código modificado e verificar se existe alguma alteração a ser feita. Se for o caso, ele faz o push de seu novo layout para o cliente.\nPasso 2: Configurar o frontend iOS e Android Uma vez configurado o seu backend, o próximo passo é configurar o emulador no frontend da sua aplicação com um projeto Beagle Android ou Beagle iOS.\nCliente Android Cliente iOS Passo 1: Instalar o submódulo Para realizar a instalação, seu arquivo de gradle deve conter o fragmento abaixo:\nA versão atual do Beagle :![https://img.shields.io/bintray/v/zupit/repo/beagle](https://img.shields.io/bintray/v/zupit/repo/beagle]()\n// Add in your plugins apply plugin: 'kotlin-kapt' // Add in your app level dependency ext.beagle_version = \"${beagle_version}\" dependencies { implementation \"br.com.zup.beagle:android:$beagle_version\" kapt \"br.com.zup.beagle:android-processor:$beagle_version\" debugImplementation \"br.com.zup.beagle:android-preview:$beagle_version\" } Em ext.beagle_version = \"${beagle_version}\", insira a versão de release do Beagle no lugar de ${beagle.version}. Ou seja, coloque a versão do Beagle destacada em azul da badge acima, mas sem o caracter v que antecede os números de versão.\nPor exemplo:undefined-ext.beagle.version = \"0.2.8\"\nFeito isso, você pode atualizar suas dependências.\nPasso 2: Criar uma Preview Activity Antes de tudo, é necessário declarar uma PreviewActivity no manifesto da aplicação para mostrar a pré-visualização:\nAqui não é necessário criar uma Activity de fato, pois ela já está criada internamente no Beagle. Você deve somente referência-la no manifesto indicando que ela faz parte do hall de Activities acessíveis nessa aplicação\n Copie e cole a Activity abaixo em seu AndroidManifest:\n... \u003capplication\u003e ... \u003cactivity android:exported=\"true\" android:name=\"br.com.zup.beagle.android.preview.PreviewActivity\" android:theme=\"@style/AppTheme.NoToolbar\"/\u003e \u003c/application\u003e \u003c/manifest\u003e Assim como oBeagleActivity, você deve informar na declaração do PreviewActivity que o tema que não tem ActionBar, pois o Beagle já coordena esse componente.\nOutro ponto importante é que você precisa habilitar a flag exportada que poderá começar via ADB\n Visualizando telas no Emulador do Android Studio Após realizar estas configurações, é só começar o plugin no IntelliJ clicando no simbolo do Beagle ao lado da função que anota @BeaglePreview e abrir o PreviewActivity para receber as atualizações do enviadas pelo BFF para renderizá-los automaticamente.\n Para começar uma PreviewActivity via intent, basta fazer a chamada com intent abaixo para visualizar a tela no emulador:  startActivity(PreviewActivity.newIntent(this)) No entanto, se você preferir começá-la por meio por meio da ADB, é só chamar o método:\nadb shell am start -n applicationpackagename/br.com.zup.beagle.android.preview.PreviewActivity Para mais informações sobre o seu pacote, acesse seu pacote de atributo no seu arquivo AndroidManifest\n Visualizando telas no Device Android Você também pode visualizar a tela que esta criando utilizando um device Android. Para isso é necessário informar o IP da sua rede no intent que chama tela de Live Preview.\nA Activity de Live Preview se conecta a tela no Backend via uma conexão websocket do client (emulador ou dispositivo físico) utilizando o BFF através do plugin BeaglePreview. Dessa forma, o client precisa saber qual IP deve utilizar para estabelecer a conexão.\n  Para começar uma PreviewActivity via device, basta fazer a chamada com o intent abaixo para visualizar a tela no dispositivo:  startActivity( PreviewActivity .newIntent( this, endpoint = \"http://seuIP:9721\" ) )  Passo 1: Instalar o submódulo Para realizar a instalação, é necessário primeiro já ter seguido os passos de instalação do Beagle para iOS. Assim os passos seguintes variam de acordo com o método utilizado.\nUtilizando via CocoaPods Adicione a dependência do LivePreview no seu arquivo Podfile:\n... pod 'Beagle/Preview' ... Depois disso, você pode instalar essa nova dependência:\n$ pod install Utilizando via Carthage Junto com o Beagle.framework gerado, haverá também o BeaglePreview.framework. Basta então adicioná-lo como mais uma dependência no seu projeto.\nPasso 2: Usar Depois de instalado, é necessário agora apresentar o UIViewController do BeaglePreview utilizando o seguinte código BeaglePreview.present(in:self).\nUma vez que você fizer isso, ele irá se conectar ao plugin e começar a escutar as mensagens recebidas de mudança de layout.\nAbaixo, você encontra um exemplo hipotético de como fazer essa inicialização:\nimport Beagle class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) BeaglePreview.present(in: self) } }  Limitações Durante o uso do Live Preview, existem dois pontos importantes de ter em mente:\n O cliente do Live Preview pode renderizar qualquer alteração usando os elementos disponíveis quando o recurso foi iniciado. Os elementos personalizados que forem adicionados posteriormente requerem uma reconstrução e reinicialização do cliente. A anotação @BeaglePreview funciona com métodos públicos sem parâmetros, fora de qualquer classe ou em uma classe pública e que possui um construtor sem parâmetros, permitindo que ele retorne um widget. Veja como nos trechos abaixo:  class UnsupportedConstructor(thing: Any) { @BeaglePreview fun preview() = Text(\":(\") } class SupportedPrimaryConstructor { @BeaglePreview fun preview() = Text(\":)\") } class SupportedBySecondaryConstructor(thing: Any) { constructor() : this(\"solved\") @BeaglePreview fun preview() = Text(\":)\") } class MethodSupport { @BeaglePreview fun supportedMethod() = Text(\":)\") @BeaglePreview fun unsupportedMethod(thing: Any) = Text(\":(\") } @BeaglePreview fun unsupportedFunction(thing: Any) = Text(\":(\") @BeaglePreview fun supportedFunction() = Text(\":)\") ","excerpt":" Introdução O Live Preview é um recurso de visualização que auxilia no …","ref":"/docs-beagle/pt/docs/recursos/live-preview/","title":"Live Preview"},{"body":" On Beagle, navigation works as a type of Action, which can be used by all components that receives an action.\nBefore configuring the navigation between screens of your application, it is required you have installed Beagle, checked the use configuration and tested Beagle’s framework on the displaying a server-driven screen tutorial  After these configuration, just add the example code as a return of you service and call the endpoint, defining in your controller, in your frontend.\nNavigation’s routes Some navigation actions needs a parameter. It is possible to receive two route type:\n Local: intern navigation that expects a new screen. Remote: expects that the url points into an API that will return one of more Beagle’s components.  On the example below, we case a case where the route is remote:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushStack\", \"route\": { \"url\": \"/my-next-screen\", \"shouldPrefetch\": false } } ] }  Button( text = \"Click me!\", onPress = listOf( Navigate.PushStack( route = Route.Remote(\"/my-next-screen\") ) ) )  Types of navigation The following pages, you will see more details about Beagle’s navigation types:\n","excerpt":" On Beagle, navigation works as a type of Action, which can be used by …","ref":"/docs-beagle/docs/resources/screen-navigation/","title":"Screen navigation"},{"body":" No Beagle, a navegação (ou Navigate) é um tipo de Ação e que, por isso, pode ser usada por todos componentes que recebem uma ação.\nVale lembrar que, antes de configurar a navegação entre telas da sua aplicação, é preciso que você já tenha feito a instalação do Beagle, as configurações de uso e testado o framework do Beagle no tutorial para exibir uma tela server-driven.  Depois de fazer todas as configurações, basta colocar o código dos exemplos como retorno do seu serviço e chamar o endpoint, definido na sua controller, no frontend de sua preferência.\nRotas de Navegação Algumas ações de navegação precisam de um parâmetro. É possível receber dois tipos de rota, que são:\n Local: navegação interna que já espera pela nova tela. Remote: navegação que, a partir de uma URL, aponta para uma API que irá retornar um ou mais componentes do Beagle.  No exemplo abaixo, você vê um caso onde o route é remote:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushStack\", \"route\": { \"url\": \"/my-next-screen\", \"shouldPrefetch\": false } } ] }  Button( text = \"Click me!\", onPress = listOf( Navigate.PushStack( route = Route.Remote(\"/my-next-screen\") ) ) )  Tipos de navegação Nas páginas a seguir, você confere mais detalhes de cada tipo de navegação do Beagle:\n","excerpt":" No Beagle, a navegação (ou Navigate) é um tipo de Ação e que, por …","ref":"/docs-beagle/pt/docs/recursos/navega%C3%A7%C3%A3o-de-telas/","title":"Navegação de telas"},{"body":" Introduction Most elements from Beagle use a field to points out a path to define the URLs. This field, in special, it is sent to backend to indicate HTTP requests that an application needs to do and that are managed by Beagle’s client.\nTypes of paths You have two ways to use these paths on Beagle:\n Absolute Relative  Absolute path A type of path used when you want to ignore the base URL already configured in your frontend application. If you make this indication, Beagle will understand that the URL is already complete and it will use it like this:\nExample of absolute path:https://api.zup.com.br/my-bff/home\nRelative path A type of path used when you decide to keep the base URL configured in your frontend application.\nFor example, if you define a base URL like https://api.zup.com.br/my-bff and receive a relative path somewhere like / home, Beagle will create the complete URL like https://api.zup.com. br /my-bff/home.\nIt is recommended that you start with the relative path with an inverted bar (/), because this is how Beagle’s indicates a relative URL.  Encode type Beagle uses the Encoding type RFC 3986 standard when handling URLs.\n","excerpt":" Introduction Most elements from Beagle use a field to points out a …","ref":"/docs-beagle/docs/resources/urls/","title":"Urls"},{"body":" Introdução A maior parte dos elementos disponibilizados pelo Beagle usa um campo para indicar o caminho para definir as URLs.\nEste campo, em específico, é enviado pelo backend para indicar as chamadas HTTP que o aplicativo precisa fazer e que são gerenciadas pelo cliente do Beagle.\nTipos de caminhos Você tem duas maneiras de utilizar estes caminhos no Beagle:\n Forma Absoluta Forma Relativa  Caminho Absoluto É o tipo de caminho usado quando você deseja ignorar a URL base configurada no aplicativo frontend. Se você faz esta indicação, o Beagle entenderá que essa URL já está completa e irá usá-la dessa forma.\nUm exemplo de caminho absoluto:https://api.zup.com.br/my-bff/home\nCaminho Relativo É o tipo de caminho usado quando você decide respeitar a URL base configurada no seu aplicativo frontend.\nPor exemplo, se você definir uma URL base como https://api.zup.com.br/my-bff e receber um caminho relativo em algum lugar como / home, o Beagle irá criar a URL completa como https://api.zup.com. br /my-bff/home.\nSugerimos que você sempre comece um caminho relativo com uma barra invertida (/), pois esta é a marca usada no Beagle para indicar que é uma a URL relativa.  Encode type O Beagle utiliza o padrão Encoding type RFC 3986 ao tratar URLs.\n","excerpt":" Introdução A maior parte dos elementos disponibilizados pelo Beagle …","ref":"/docs-beagle/pt/docs/recursos/urls/","title":"Urls"},{"body":" What is Beagle? Beagle is an open source framework of cross-platform development, it is based on the native Server-Driven UI implementation in iOS and Android. You can easily change your application’s layout and DATA changing only the screen code in backend.\nHow does Beagle work? The developer declares the backend screens and the expose the endpoints that represent them. These endpoints are called using Beagle to render the screen components on the web or mobile.\nBeagle works as a ‘bridge’ between front and backend, it is possible that the design components of your application have a parameter in backend which makes a native application possible.\nMy application’s architecture will change if I use? No, Beagle does not interfere with your project’s architecture.\nWhy should I use Beagle and not React Native or Flutter? Beagle’s solution is different from other tecnologies. It is a tool to make the development easier, it has UI oriented concept of continuous delivery. Beagle allows you to handle through backend, native components of your application, change layouts and the display of these components.\nIs it possible to make tests in server driven screens? Yes! Unit tests like instrumented test work the same way on Beagle.\nCan I use Beagle in an application that already has developed resources? Yes! If your application already have the developed components in a design system, you are able to use them on Beagle. You only have to see if these components are defined and then it will be easy to register them on Beagle.\nDoes a Beagle application need to be 100% Server Driven? No, the application can use only one Server Driven screen in some app’s flows. You can continue in one server driven flow or return to the native screen normally.\nDo I have to use Beagle in the whole application? No, your application will continue the same and it can be native even with Beagle on it. You may use Beagle whenever you want.\nWill my application work offline? Depends. All server driven application when requests the server a flow, it needs to be connected in order to receive a response from backend. The server driven flows cannot be solved without a connection. But, your if your application is not 100% server driven, there is a part of it that doesn’t need to get online information, then it will work. The application also can be configured to call other screens in case they are offline.\nIf my my internet connection is interrupted in the middle of the application flow? The way to deal with disconnection cases it is to create local declaratives screens to fallback.\nWill I have problems to upload an application with Beagle on App Store or Play Store? No! All the components used will be defined in your application when the store’s upload happens. Beagle is dynamic when dealing with updates, this happens because the work is in the backend and there isn’t any frontend configuration that is big enough to cause a block on Apple or Google. Beagles wants to minimize the deploys on the stores.\nWill I have performance problems with Beagle? Not, it’s the quite opposite. We made a renderization benchmark and Beagle - using Yoga’s Layout mechanism - had a better answer than other native renderization strategies, like Auto Layout (IOS) and Constraint Layout (Android).\nHow about backend’s answer time? Will my application be slower? No, because Beagle uses a cache mechanism to store adjacent screens and, then, optimize backend’s calls. This means that you don’t need to request again to backend in the user’s click moment.\nWhat is the latest Beagle’s version? Beagle’s latest version is:undefined\nIs Beagle a free tool? Yeas! Beagle is an open source development framework, which means that its totally free.\nCan I create a BFF with a different language than JVM? It’s possible to create a BFF in a different language. However, we don’t have ready libs to help you on this process, so it would be necessary that the developer create a mechanism to respect Beagle’s contracts.\nWhat are the advantages of using Beagle? One of the main advantages is that Beagles facilitates the development because of backend’s configuration based on BFF paradigm.\nThis means that Beagle helps you on changing screen’s layouts, screen’s flows and app’s navigation. All of this is made from pages declaratively created in your BFF with a components' library defined on your application’s frontend, which helps on interface’s change.\nIt allows you to:\n Decide which visual component must be presented: which texts, subtitles and any other visual information that must be shown, centralized and abstracted on the server.  This avoids a replication on each frontend’s platform that consumes this API. The server applies this business logic and use its results to assemble the API response representing it.\n Make A/B tests to change the order how components are presented.  Can I use Beagle for Android, iOs or Web development? Yes! As a cross-platform framework, Beagle helps you on developing application on these three platforms by using the Server-Driven UI concept, which enables that even a BFF may be used on all of these applications.\nYou can see more how to create Beagle’s projects with each of these platforms on:\n Beagle for Android  Beagle for iOS Beagle for Web  How to make unitary and instrumented tests on Server-Driven screens? Yes! Unitary and instrumented tests can be normally done when using Beagle because its structure doesn’t interfere in these tests.\nHow to make unitary tests using Beagle? Unitary tests has the goal to gauge the code’s functionality in a minor fraction. The applications' tests that use Beagle are done in the same way as in applications that don’t use our tool. That means Beagle doesn’t interfere in these tests.\nHow to make instrumented tests using Beagle? Instrumented tests are done in applications using Beagle in the same way as in applications that don’t use our tool.\nHowever, it’s important to reinforce that, usually, a server-driven component may not contain an ID that mostly identifies an instrumented test. Thinking of it, we add a WIDGET element (that refers a component) and a ID attribute so it can be possible to programatically identify it.\n","excerpt":" What is Beagle? Beagle is an open source framework of cross-platform …","ref":"/docs-beagle/docs/faq/","title":"FAQ"},{"body":" A comunicação entre componentes é uma forma de compartilhar informações com o uso de Observables que, de modo geral, emitem notificações sempre que uma mudança acontece com eles.\nAbaixo, você verá como fazer a configuração dessa comunicação usando o Contexto, um componente do Beagle. \nConfigurando a comunicação entre componentes. O que vou comunicar? Nesse exemplo, consumiremos o resultado de uma API pública que retorna valores de cotação das moedas no mercado ou Currency Rates .\nO endpoint abaixo retorna um JSON semelhante. Listamos somente os dados que vamos utilizar, mas vale dizer que a resposta desse JSON é bem maior.\n Endpoint: https://api.exchangeratesapi.io/latest?base=USD  { \"rates\": { \"CAD\": 1.3563421308, \"BRL\": 5.3397475505, \"EUR\": 0.8826904405, \"USD\": 1.0, }, \"base\": \"USD\", \"date\": \"2020-07-13\" } Como vou comunicar? Uma função chamada SetContext é a responsável por atualizar os valores do componente contexto. Ela poderá ser chamada na tela se você quiser usar as informações que estiverem nesse contexto.\nPara fazer a comunicação, basta seguir os próximos passos:\n Ao definir o contexto na estrutura Kotlin DSL no backend é necessário implementar uma classe que estruture as informações que serão recebidas no contexto. Utilizar duas estruturas para configurar e utilizar o contexto, sendo elas, uma classe para representar a informação da resposta da API e um Container para exibir essa informação em uma tela.  Passo 1: Criar a classe Currency De acordo com a resposta da API de exemplo, escrevemos a classe abaixo para estruturar os dados. Essa é a primeira estrutura:\ndata class Currency( val eur: String, val brl: String, val cad: String, val usd: String ) Passo 2: Criar o Container Criada a primeiro estrutura, é o momento de estruturar o Container que conterá os componentes que desejamos exibir. É nele que listaremos os componentes e também o *Contexto para esse grupo de componentes.\nÉ importante lembrar que o *Contexto , nesse caso, é a funcionalidade do Beagle que registra informações de um componente e que podem ser recuperadas em outro componente. Ele não é o contexto(Context) das views no Android.  O Container está dividido em 2 partes principais:\n O context : É um objeto do tipo ContextData que será a variável responsável por conter as informações que você deseja transferir. O children: É uma lista dos componentes que fazem parte desse container e que terão acesso ao contexto definido nele.  JSON Kotlin { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Currency Table in USD\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click to get the currency Table\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:sendRequest\", \"url\" : \"https://api.exchangeratesapi.io/latest?base=USD\", \"method\" : \"GET\", \"onSuccess\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"myContext\", \"value\" : { \"eur\" : \"@{onSuccess.data.rates.EUR}\", \"usd\" : \"@{onSuccess.data.rates.USD}\", \"brl\" : \"@{onSuccess.data.rates.BRL}\", \"cad\" : \"@{onSuccess.data.rates.CAD}\" }, \"path\" : \"currency\" } ] } ] }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"EUR: @{myContext.currency.eur}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"BRL: @{myContext.currency.brl}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"CAD: @{myContext.currency.cad}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"USD: @{myContext.currency.usd}\" } ], \"context\" : { \"id\" : \"myContext\", \"value\" : { \"eur\" : \"\", \"usd\" : \"\", \"brl\" : \"\", \"cad\" : \"\" } } }  Container( context = ContextData( id = \"myContext\", value = Currency( eur = \"\", brl = \"\", cad = \"\", usd = \"\" ) ), children = listOf( Text(\"Currency Table in USD\"), Button( text = \"Click to get the currency Table\", onPress = listOf( SendRequest( url = \"https://api.exchangeratesapi.io/latest?base=USD\", method = RequestActionMethod.GET, onSuccess = listOf( SetContext( contextId = \"myContext\", path = \"currency\", value = Currency( eur = \"@{onSuccess.data.rates.EUR}\", brl = \"@{onSuccess.data.rates.BRL}\", cad = \"@{onSuccess.data.rates.CAD}\", usd = \"@{onSuccess.data.rates.USD}\" ) ) ) ) ) ), Text( text = \"EUR: \" + \"@{myContext.currency.eur}\" ), Text( text = \"BRL: \" + \"@{myContext.currency.brl}\" ), Text( text = \"CAD: \" + \"@{myContext.currency.cad}\" ), Text( text = \"USD: \" + \"@{myContext.currency.usd}\" ) ) )  O Container A estrutura dessa página tem 1 título, 1 botão e 4 text views que receberão as informações do contexto.\n O título é meramente ilustrativo para exemplificar a estrutura e hierarquia da página. O botão é utilizado para disparar a resposta da API e chamar a função SetContext para atribuir o resultado da resposta ao contexto. Os 4 text views receberão as informações vindas do contexto.  O Botão e as funções SendRequest e SetContext Para configurar o botão é preciso definir primeiro, a função que será acionada quando o botão for clicado, ou seja, você deve configurar o atributo onPress do botão. A função que deve ser chamada no clique é a SendRequest e ela será responsável por requisitar a resposta da API configurada nela.\nVeja abaixo os parâmetros dessa função cujo exemplo está no código do container acima.\nSendRequest    Atributo Descrição     url Endpoint que responderá com as informações que desejamos definir no contexto.   method Define o method do request. Nesse exemplo será o GET.   onSuccess Define uma ação a ser realizada quando a requisição da API é bem sucedida. É aqui no onSuccess que será chamada de função SetContext.    Quando a requisição da API recebe uma resposta, o método SetContext é chamado e é nele que atribuiremos o resultado da chamada da API ao contexto.\nVeja abaixo os atributos do SetContext:\nSetContext    Atributo Descrição     contextId Obrigatório. O ID que foi definido no ContextData, que referencia esse contexto. No exemplo o id é \"MyContext\"   path Este atributo pode ser implementando para definir uma path especializado. Neste exemplo o definimos como “currency” , que é como os valores serão requisitados do contexto.   value Obrigatório. Ele atribui valor aos atributos declarados no contexto de acordo com a resposta da API. Neste exemplo para recuperar o valor da API devemos construir esse valor da seguinte forma: \"@{onSuccess.data.rates.EUR}\", ou seja, a parte onSuccess.data representa a informação recebida na resposta da API, e de acordo com o JSON que representa essa estrura o resultado pode ser acessado usando .rates.EUR por exemplo, que é a chave do valor que queremos acessar.    O texto Temos 4 componentes visuais nesse exemplo, eles que exibirão as informações atribuídas ao contexto. E aqui você percebe como ocorre a comunicação entre componentes, no passo anterior enviamos uma informação para o contexto, que agora irá ser recuperada.\nAqui temos somente o atributo text desse componente textual, porque é ele que definirá a informação a ser exibida.\n   Atributo Descrição     text Valor no formato String que será exibido na tela. Para recuperar o valor do contexto use a notação \"@{myContext.currency.eur}\", ou seja, você deve definir o caminho para acessar as informações salvas no contexto utilizando o \"@{ID_DO_CONTEXTO+PATH+NOME_DO_ATRIBUTO}\"    A tela E agora a tela está pronta! Foi configurado um exemplo de contexto e demonstrado como acontece a comunicação entre os componentes.\nNo final deste exemplo a sua tela deve estar assim:\n","excerpt":" A comunicação entre componentes é uma forma de compartilhar …","ref":"/docs-beagle/pt/docs/tutoriais/como-fazer-comunica%C3%A7%C3%A3o-entre-componentes/","title":"Como fazer comunicação entre componentes"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/release-notes/","title":"Release Notes"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/tutoriais/","title":"Tutoriais"},{"body":" Siga as orientações de acordo com o sistema operacional que estiver usando:\nAndroid e Backend iOS Configurando o Gradle Se você trabalha com aplicações Android ou via Backend, deve começar configurando o arquivo**gradle.properties**, que se encontra na **pasta root**. Essa configuração vale tanto para versões remotas como locais.\nAssim que abrir o arquivo, o primeiro passo é mudar o nome da versão que será gerada. Para isso, você pode alterar o valor da variável **VERSION_NAME**para o valor desejado.\nEssa variável serve para referenciar o nome da versão quando você for importar o Beagle.\n Além disso, é preciso acrescentar uma variável chamada RELEASE_SIGNING_ENABLED e atribui-lá ao valor false. Isso significa que você não precisa assinar a versão, já que essa configuração permite gerar uma versão do Beagle de forma local ou para um repositório próprio.\nDepois que terminar essas configurações, você terá de ter no seu gradel as seguintes variáveis de acordo com o nome que escolher para sua versão (neste exemplo, usamos**beagle-test**):\nVERSION_NAME=beagle-test RELEASE_SIGNING_ENABLED=false Publicando em um repositório remoto Ao final da configuração do gradle.properties, você precisa configurar um arquivo que está na pasta root do Beagle, no caso, o maven-publish.gradle. Nesse arquivo, adicione um target, que definirá:\n Em qual repositório será gerado a versão As credenciais necessárias para acessar esse repositório.     Chaves Definição     releaseRepositoryUrl URL do repositório onde a versão será gerada.   repositoryUsername Nome de usuário.   repositoryPassword Senha do nome de usuário declarado.    Segue abaixo um exemplo de publicação:\napply plugin: \"com.vanniktech.maven.publish\" def versionName = System.env.VERSION_DEPLOY != null ? System.env.VERSION_DEPLOY : VERSION_NAME ?: \"\" version = versionName mavenPublish { nexus { stagingProfile = \"br.com.zup\" } targets { uploadArchives { releaseRepositoryUrl = \"https://meu-repo.com.br\" repositoryUsername = \"username\" repositoryPassword = \"password\" } } } Publicando em um repositório local Ao final da configuração do gradle.properties , você deve rodar alguns comandos do gradle.\nPara isso, vá até a pasta root da plataforma em que você deseja gerar versão (Android ou Backend) e no terminal de sua preferência execute o seguinte comando:\nSe estiver em um terminal do Windows:\ngradlew clean build publishToMavenLocal Caso esteja nos demais terminais:\n./gradlew clean build publishToMavenLocal Depois de rodar o comando, a versão será gerada automaticamente.\n Diferente da configuração para Android e Backend, em aplicações iOS você não precisa configurar o arquivo gradle.properties. Nesse caso, basta seguir direto para as configurações de acordo com a versão que deseja gerar.\nPublicando em um repositório remoto Usando o CocoaPods No arquivo podfile , assim como qualquer outra dependência, coloque o Beagle e aponte o endereço do seu repositório , como no exemplo a baixo:\npod 'Beagle', :git =\u003e 'https://github.com/profile/myrepo' Depois de configurado o podfile execute o seguinte comando para baixar do seu repositório:\npod install Usando o Carthage No arquivo Cartfile, adicione o repositório da sua versão do Beagle:\ngithub “YourUser/YourRepository” Publicando em um repositório local Usando o CocoaPods Abra o terminal e vá para a pasta raiz do Beagle e digite o seguinte comando:\npod spec create MyBeagle E MyBeagle.podspec será criado. Agora abra esse arquivo com um editor de texto e siga como o exemplo abaixo:\nPod::Spec.new do |spec| spec.name = \"MyBeagle\" spec.version = \"1.0.0\" spec.summary = \"A short description\" spec.description = \"Complete description\" spec.platform = :ios, \"12.2\" spec.source = { :path =\u003e '.' } Em seguida execute o seguinte comando no terminal com a pasta raiz do projeto:\npod install Usando o Carthage No arquivo Cartfile, adicione o diretório da sua versão do Beagle da seguinte forma:\ngit \"file:////Users/beagle\" \"master\" Importante que você adicione o caminho completo do diretório com a sua versão do Beagle para que essa chamada funcione corretamente.\n  ","excerpt":" Siga as orientações de acordo com o sistema operacional que estiver …","ref":"/docs-beagle/pt/docs/tutoriais/como-gerar-uma-vers%C3%A3o-do-beagle-local-ou-remota/","title":"Como gerar uma versão do Beagle local ou remota"},{"body":" What is Playground? Playground is a development tool where you can create components and pages using Beagle. It is very fast and simple, without any installation process. It has a interface that allows you to write a JSON and see the result instantly.\nAccessing Playground You can access the playground through the following link:\n{% embed url=“https://beagle-playground.netlify.app” %}}\nYou will have access to the following demo project:\nThe files menus are on the left, JSON files are centered and on the right you will see the JSON preview.\n","excerpt":" What is Playground? Playground is a development tool where you can …","ref":"/docs-beagle/docs/playground/playground-web/","title":"Playground Web"},{"body":" Criando uma ação do frontend No Beagle, é possível criar uma ação customizada a partir de uma CustomAction.\nCada plataforma possui sua forma especificia de fazer essa implementação no frontend. Você pode ver exemplos abaixo de como fazer em cada uma delas:\nAndroid iOS Web  Crie uma classe anotada com @RegisterAction que implementa uma interface Action. Essa interface irá requistar a implementação do método execute e você irá declarar o resultudo da action. O atributo msg listado, é o único exemplo de parâmetro que deve ser declarado na classe construtora.  O exemplo abaixo mostra um ação com Toast:\n@RegisterAction data class CustomAction( val msg: String? = null ) : Action { override fun execute(rootView: RootView) { Toast.makeText( rootView.getContext(), msg, Toast.LENGTH_LONG).show() } }   Você deve criar a classe que implementa uma Action. Essa mesma classe irá fazer a requisição da implementação do método execute e irá ditar as ações na action. O atributo listado msg é o único parâmetro que deve ser declarado na classe construtora.  O exemplo abaixo mostra um ação com Alert:\nclass CustomAction: Action { let msg: String? init(msg: String? = nil) { self.msg = msg } func execute(controller: BeagleController, sender: Any) { let alert = UIAlertController( title: nil, message: msg, preferredStyle: .alert ) controller.present(alert, animated: true) } }  Para registrar a ação, apenas crie o método com todo seu custom action e chame o método do Beagle registerCustomAction para fazer o registro;\n  Chame o método criado no BeagleConfig, ele pode ser visto nesse exemplo:\n  private func registerCustomAction() { Beagle.registerCustomAction(\"CustomAction\", actionType: CustomAction.self) }   Você deve criar a interface com o _beagleAction_ como uma propriedade obrigatória e com os parâmetros necessários para a sua ação. Para esse exemplo, será criado o atributo msg do tipo string. No ___beagleAction_, coloque o nome da ação customizada no padrão: ‘custom:nomeDaAção’:  interface CustomAction { _beagleAction_: 'custom:CustomAction', msg: string } Depois de ter feito isso, declare a função do tipo ActionHandler com a interface que você criou:  import { ActionHandler } from '@zup-it/beagle-web' export const customHandler: ActionHandler\u003cCustomAction\u003e = ({ action }) =\u003e { /* Podemos acessar nosso parâmetro definido na interface, por exemplo action.msg nos traz o valor de msg. */ alert(action.msg) } Adicione o nome da ação nos arquivos de associação, de acordo com cada framework:  Angular: adicione no beagle.module.ts\n@BeagleModule({ ... customActions:{ \"custom:CustomAction\": customHandler //nome do action handler  } }) export class Beagle {} React: adicione nos arquivos de configuração do Beagle:\nexport default createBeagleUIService\u003cany\u003e({ ... customActions:{ \"custom:CustomAction\": customHandler //nome do action handler  } })  Criando uma ação no backend Para criar essa ação, o seu código deve estar assim:\n@RegisterAction data class CustomAction( val msg: String? = null ) : Action Veja abaixo um exemplo de uma Ação em um componente do tipo Button:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Beagle Button\", \"onPress\": [ { \"_beagleAction_\": \"custom:customAction\", \"msg\": \"Eu sou um Toast.\" } ] }  Button( text = \"Beagle Button\", onPress = listOf(CustomAction(\"Eu sou um Toast\")) )  ","excerpt":" Criando uma ação do frontend No Beagle, é possível criar uma ação …","ref":"/docs-beagle/pt/docs/tutoriais/como-criar-novas-actions/","title":"Como criar novas actions"},{"body":" Using the playground Files menu On the files menu, the left of the screen, you are able to create, delete or select a file and then click on the first top icon or press CRTL+B you can minimize or expand the menu.\nJSON The JSON’s changes can be saved clicking on the second top icon or pressing CRTL+S. You can update the screen preview with a new JSON, click on the fourth icon on the top corner or press F9.\nWhen the changes are saved, a link will be available for your project, it is on the cloud and then you are able to access anywhere you want.\nPlatform On the right top menu, it is possible to select which platform you want to use, React Web or Angular are available.\n","excerpt":" Using the playground Files menu On the files menu, the left of the …","ref":"/docs-beagle/docs/playground/playground-web/using-the-playground/","title":"Using the Playground"},{"body":" Examples of demo components You will see below a list with the demo components implemented in the Playground:\nButton Try it on the Playground\nComponent’s documentation\nContainer Try it on the Playground\nComponent’s Documentation\nLazy Component Try it on the Playground\nComponent’s Documentation\nList View Experimente no Playground\nComponent’s Documentation\nModal Try it on the Playground\nPage View Try it on the Playground\nComponent’s Documentation\nSimple Form Try it on the Playground\nComponent’s Documentation\nTab View Try it on the Playground\nComponent’s Documentation\nText Try it on the Playground\nComponent’s Documentation\nTouchable Try it on the Playground\nComponent’s Documentation\n","excerpt":" Examples of demo components You will see below a list with the demo …","ref":"/docs-beagle/docs/playground/playground-web/demo-components/","title":"Demo components"},{"body":" Exibindo uma tela a partir de uma URL Cada plataforma tem sua forma própria para exibir uma tela server-driven no frontend usando o Beagle. Abaixo, listamos exemplos para cada uma delas.\nAndroid iOS Web Para exibir uma tela full server-driven, você deve usar o método this.newServerDrivenIntent\u003cBeagleActivity\u003e() onde o this é a o contexto da sua tela atual.\nEste método requer apenas o parâmetro ScreenRequest\nVocê deve seguir tal como o comando abaixo:\nCertifique-se de listar a sua Beagle Activity assim como nomeada em seu AndroidManifest.\nNo exemplo abaixo a chamamos somente de \u003cBeagleActivity\u003e. Esse nome é você quem define ao criar sua BeagleActivity. Em nosso tutorial Criando um projeto do zero , chamamos ela de AppBeagleActivity\n val intent = this.newServerDrivenIntent\u003cBeagleActivity\u003e(ScreenRequest(\"/screen\")) startActivity(intent) Para testar o comando acima, o componente ScreenRequest requer somente uma URL que traga o JSON com as informações da tela server-driven que você quer exibir.\nNeste caso, siga estes passos:\n Use o exemplo de tela no link abaixo. Ele traz um JSON de uma tela simples para teste. Basta copiar e colar no lugar da URL \"/screen\" . https://run.mocky.io/v3/73322be2-96bf-467b-b6dc-e3fff179852c Veja como fica o código abaixo.  val intent = this.newServerDrivenIntent\u003cBeagleActivity\u003e(ScreenRequest(\"https://run.mocky.io/v3/73322be2-96bf-467b-b6dc-e3fff179852c\")) startActivity(intent)   A classe Screen Request. AScreenRequest é uma classe interna do Beagle utilizada para solicitar qual tela você deseja exibir. Você listará apenas o atributo URL referente a página que deseja carregar vinda do BFF.\nNo entanto, esse elemento possui outros atributos, que podem ser utilizados na transição e entre telas. Para saber mais sobre essa classe, veja em Screen Request\n Para renderizar uma tela server-driven, basta criar uma instância BeagleScreenViewController do tipo remote e fazer a inicialização com a URL do seu BFF, como no exemplo abaixo:\nlet beagleViewController = Beagle.screen( .remote( .init(url: \"// URL AQUI\") ) ) Feito isso, basta apresentá-la onde preferir. Neste caso, você deve seguir como no comando de exemplo.\npresent(beagleViewController, animated: true, completion: nil) A resposta do seu BFF deve ser um JSON que representa um componente visual definido localmente na aplicação.\nVocê também pode renderizar uma tela de exemplo. Para isso, basta passar esta mesma URL na inicialização da**BeagleScreenViewController**.\n Por fim, execute a aplicação e veja uma tela definida em uma URL remota renderizada na sua aplicação local.\nParabéns, você conseguiu exibir uma tela full server-driven 🎉\nDesta forma, será possível criar telas com conteúdo dinâmico, e controle no seu backend.\n  Para projetos no Angular Para definir onde você quer mostrar uma tela server-driven no Angular, você deve usar o componente fornecido pela biblioteca \u003cbeagle-remote-view\u003e\nEste componente tem outros atributos que podem ser configurados. No entanto nessa implementação você utilizará somente o atributo path, descrito no exemplo abaixo.\nPara mais detalhes sobre esse componente clique no link a seguir e verifique os detalhes do Remote View\n No arquivo html do seu componente, adicione o remote view.\n\u003cbeagle-remote-view [loadParams]=\"loadParams\"\u003e\u003c/beagle-remote-view\u003e Feito isso, acesse o controller do componente e crie o loadParams que é esperado pelo remote view.\nloadParams: LoadParams; constructor() { this.loadParams = { path: '/pathToScreen' }; } No campo path, deve ficar o caminho para seu JSON que será associado com o baseUrl definido em beagle.module.ts.\n Para projetos no React Para definir uma tela server-driven no React, você precisa criar um serviço com uma configuração mínima, como no exemplo:\nimport { createBeagleUIService } from '@zup-it/beagle-react' export default createBeagleUIService({ baseUrl: \"\", components: {} }) Feito isso, usamos dois componentes fornecidos pela biblioteca Beagle para definir onde a tela server-driven será renderizada:\n O BeagleProvider O BeagleRemoteView  ... import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from './beagle/beagle-service'; function App() { return ( \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView path={'/pathToScreen'} /\u003e \u003c/BeagleProvider\u003e ); } export default App; No campopath, deve ficar o caminho para seu JSON que será associado com o baseUrl definido em seu serviço.\n  Exibindo uma tela a partir de um JSON Android iOS Para renderizar uma tela a partir de um JSON, é necessário ter uma Activity ou Fragment com um FrameLayout como no exemplo a baixo:\n\u003cFrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/frame_layout_android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"/\u003e Agora basta chamar o método renderScreen() a partir do frame layout criado no xml passando como parâmetro a sua activity e o JSON.\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) frame_layout_android.renderScreen( activity = this, screenJson = \"// JSON here\" ) } } O método renderScreen() também pode receber um fragment como parâmetro seguindo o exemplo abaixo:\nrenderScreen(fragment = yourFragment, screenJson = \"// JSON here\")\n  Para renderizar uma tela de um JSON, basta criar uma instância BeagleScreenViewController do tipo declarativeText e fazer a inicialização com o JSON, como no exemplo abaixo:\nlet beagleViewController = Beagle.screen( .declarativeText( .init(text: \"// JSON HERE\") ) ) Feito isso, basta apresentá-la onde preferir. Neste caso, você deve seguir como no comando de exemplo.\npresent(beagleViewController, animated: true, completion: nil)  ","excerpt":" Exibindo uma tela a partir de uma URL Cada plataforma tem sua forma …","ref":"/docs-beagle/pt/docs/tutoriais/exibindo-uma-tela/","title":"Exibindo uma tela"},{"body":" Existem duas formas que os componentes do Beagle podem ser adicionados a sua aplicação:\n Via BFF (como um server driven componente); Como um componente declarativo no front end.  Veja abaixo mais detalhes de como adicionar um componente Beagle a sua tela nativa:\n","excerpt":" Existem duas formas que os componentes do Beagle podem ser …","ref":"/docs-beagle/pt/docs/tutoriais/adicionando-o-beagle-a-uma-parte-da-tela-nativa/","title":"Adicionando o Beagle a uma parte da tela nativa"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/playground/","title":"Playground"},{"body":" What is it? For now, there are two common accessibility attribute types in all platforms Beagle supports.\n   Attributes Type Required Definition     accessible Boolean ✓ Indicates whether the component will be interpreted as accessible. Default is true.   accessibilityLabel String  string containing a message that will be spoken by programs, like VoiceOver.    If backend does not specify accessibility, the default values ​​for each platform will be used.  How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/rvRN9kv/logo.png\" }, \"accessibility\": { \"accessibilityLabel\": \"Image Label\", \"accessible\": true } } ] }  iner( children = listOf( Image( path = ImagePath.Remote(\"https://i.ibb.co/rvRN9kv/logo.png\") ).applyAccessibility( accessibility = Accessibility(true, \"Image Label\") ) ) )  👉 Test this example on Web Playground ","excerpt":" What is it? For now, there are two common accessibility attribute …","ref":"/docs-beagle/docs/api/accessibility/","title":"Accessibility"},{"body":" É possível que alguns componentes de uma tela que sejam exibidos via server-driven (tela nativa) recebam somente uma seção da página , ou mesmo um único componente do servidor BFF.\nNo exemplo abaixo, vamos exibir um botão server-driven em uma tela nativa. O resultado que deve aparecer na sua aplicação é esse:\nPré-requisitos Para que essa configuração funcione corretamente, você precisa de:\n Um BFF configurado com o Beagle. Caso não o tenha, veja como configurar nesse tutorial. Um frontend configurado com o Beagle para Android ou iOS. Caso não o tenha, siga um dos tutoriais de acordo com sistema operacional:  Android iOS    Passo 1: Criar o componente no backend Neste exemplo, criaremos um botão como componente server-driven para que possamos exibí-lo em uma tela nativa.\nPara isso, siga os passos a seguir:\n Crie uma classe Kotlin em seu backend. Nomeie-o SingleComponentBuilder. Essa será a classe que vai construir o seu componente (objeto) server-driven. Feito isso, copie e cole o código abaixo.  import br.com.zup.beagle.widget.action.Alert import br.com.zup.beagle.widget.ui.Button class SingleComponentBuilder() { fun createButton(): Button { return Button( \"Sou um botão server-driven\", onPress = listOf( Alert( \"Botão server-driven\", \"Sou um botão server-driven\", labelOk = \"OoooK\" ) ) ) } }  Este botão terá uma ação do tipo \"Alert\", que já está configurada no código acima.  Passo 2: Atualizar a classe Service e Controller no backend Depois que você criou o componente, será preciso atualizar algumas classes. Veja como fazer essa configuração de acordo com cada uma delas.\nAtualizando o Service O Service é a classe responsável por configurar o serviço que usaremos, que pode ser de vários tipos. No caso desse exemplo, só será listado o que está sendo configurando.\nComece abrindo a classe ScreenBeagleService.kt (nome escolhido para o tutorial de configuração do BFF, mas você pode renomeá-la se quiser).\nFeito isso, copie a linha abaixo e cole dentro da classe ScreenBeagleService:\n fun createServerDrivenComponent() = SingleComponentBuilder().createButton()  import com.example.bff.builder.SingleComponentBuilder import org.springframework.stereotype.Service @Service class ScreenBeagleService { fun createServerDrivenComponent() = SingleComponentBuilder().createButton() } Atualizando Controller Se a configuração acima funcionar, você atualizará o controller e o componente e eles estarão prontos para serem enviados ao frontend, caso haja uma requisição.\nAgora, na classe controller, você deve chamar o serviço que acabamos de configurar e definir a URL que será o endpoint do componente criado.\nPara isso, siga os passos:\n Abra a classeScreenController. Esse nome foi dado a essa classe no tutorial, ela que é responsável por expor os componentes via API REST. Adicione outra função à essa classe (Lembrando que a classe já tem algumas funções implementadas). Anote a função com o @GetMapping()e listar o endpoint (Path relativo da URL) que identifica esse componente.  Veja como deve ficar a configuração:\n@RestController class ScreenController( private val screenBeagleService: BeagleService ) { @GetMapping(\"/serverDrivenComponent\") fun getServerDrivenComponent() = screenBeagleService.createServerDrivenComponent() } Teste o endpoint Agora que o componente esta criado e configurado, você deve testar o endpoint e verificar a resposta JSON. Para isso, realize essas ações:\n Inicie a sua aplicação no backend (Lembre-se que sua aplicação Backend está configurada para apresentar as resposta no localhost). Abra o um browser e acesse o endpoint: http://localhost:8080/serverDrivenComponent  Você deve receber o JSON abaixo:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Sou um botão server-driven\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Botão server-driven\", \"message\" : \"Sou um botão server-driven\", \"labelOk\" : \"OoooK\" } ] }  Button( \"Sou um botão server-driven\", onPress = listOf( Alert( \"Botão server-driven\", \"Sou um botão server-driven\", labelOk = \"OoooK\" ) ) )  Passo 3: Exibir o componente server-driven Depois dos dois passos anteriores, o seu componente está pronto. Agora, você só precisa exibi-lo em uma tela nativa.\nPara essa configuração, siga as orientações específicas para cada plataforma:\nAndroid iOS WEB Você deve utilizar o frame layout para “receber” o componente do BFF e, assim, exibi-lo em uma tela Android nativa.\nPara isso, basta seguir esses passos:\n Crie o arquivo .XML abaixo que representa uma tela nativa com um título e um frame layout. Nesse exemplo definimos essa pagina como nossa MainActivity Depois, copie e cole a configuração abaixo:  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003cTextView android:id=\"@+id/tv_title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"100dp\" android:text=\"Sou componente Nativo!\" android:textSize=\"30sp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /\u003e \u003cFrameLayout android:id=\"@+id/fr_server_driven\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" app:layout_constraintTop_toBottomOf=\"@id/tv_title\" android:layout_marginTop=\"40dp\" /\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e Após configurar o frame layout, é preciso informar ao Beagle qual componente será exibido. Para isso, utilize a função loadView como listado no exemplo a seguir.\n Veja como fazer isso:\n Abra a activity onde você deseja exibir a sua tela nativa. Crie uma variável do tipo FrameLayout que deve receber a FrameLayout View que configuramos. Agora basta chamar a função .loadView a partir da variável frameLayout  val frameLayout = findViewById\u003cFrameLayout\u003e(R.id.fr_server_driven) frameLayout.loadView(this, ScreenRequest(\"/serverDrivenComponent\")) E pronto: basta iniciar sua aplicação e você verá a tela a seguir!\n .![](/docs-beagle/assets%2F-M-Qy7jZbUpzGRP5GbCZ%2F-MC8IwWJstYtvxLbosfv%2F-MC8QfhsPkq60mGJKtfy%2Fserver-driven-comp-ios.gif?alt=media\u0026token=b5500211-e2bc-477d-aea4-835245be1531).  Clique no botão e perceba que a função nesse componente está implementada e funcional, ou seja, o Beagle exibe todos os componentes como se fossem nativos.\n Você deve utilizar um view controller para “colocar” esse componente do BFF e, assim, exibí-lo em tela iOS nativa.\nMas antes, é preciso criar esse view controller para a tela nativa. Para isso, basta seguir os passos:\n Instancie o componente server-driven a partir da classe BeagleScreenViewController. Utilize o addChild para adicionar o view controller. Também adicione o view do beagleScreenViewController comosubview do nosso view controller nativo. Por último, é necessário adicionar algumas constraints para a UILabel e para a view do beagleScreenViewController como no código abaixo:  class NativeViewController: UIViewController { private let beagleScreenViewController = BeagleScreenViewController(.remote(.init(url: \"http://localhost:8080/serverDrivenComponent\"))) private lazy var descriptionText: UILabel = { let label = UILabel() label.text = \"Sou um componente nativo\" label.font = .systemFont(ofSize: 25, weight: .semibold) return label }() override func viewDidLoad() { super.viewDidLoad() setupView() } func setupView() { view.backgroundColor = .white addChild(beagleScreenViewController) view.addSubview(descriptionText) descriptionText.anchorCenterXToSuperview() descriptionText.anchor(top: view.topAnchor, topConstant: 150) guard let beagleView = beagleScreenViewController.view else { return } view.addSubview(beagleView) beagleView.anchorCenterXToSuperview() beagleView.anchor(top: descriptionText.bottomAnchor, topConstant: 50, widthConstant: 300, heightConstant: 50) beagleScreenViewController.didMove(toParent: self) } Ao final do processo, você poderá “chamar” pela nossa tela nativa que irá aparecer a imagem abaixo. Lembrando que, para esse exemplo, foi criada uma tela composta de uma UILabel e de uma variável do tipo BeagleScreenViewController , onde fica o componente server-driven.\n Se você ainda não configurou a biblioteca em seu projeto, veja aqui como fazer isso.\nVocê deve utilizar o Remote View, fornecido pela biblioteca do Beagle, para criar telas híbridas com alguns componentes server driven na web.\nVeja a seguir como funciona para cada framework:\nReact\nNo React, você só precisa criar uma função que retorna dois componentes. Um deles é o BeagleRemoteView com o caminho para carregar o componente server-driven.\nimport React, { FC } from 'react' import { LoadParams } from '@zup-it/beagle-web'; import { BeagleProvider, BeagleRemoteView } from '@zup-it/beagle-react'; import BeagleService from '../../beagle/beagle.service'; import NativeComponent from '../NativeComponent'; const params: LoadParams = { path: '/mypath', } const Main = () =\u003e { return ( \u003c\u003e \u003cNativeComponent text=\"Sou um componente nativo!\"\u003e\u003c/NativeComponent\u003e \u003cBeagleProvider value={BeagleService}\u003e \u003cBeagleRemoteView {...params} /\u003e \u003c/BeagleProvider\u003e \u003c/\u003e ) } export default Main Angular\nNo Angular, basta criar um componente nativo normalmente e adicionar o beagle-remote-view junto ao template no local que você quer que os itens server-driven sejam renderizados.\n\u003capp-native-component text=\"Sou um componente nativo\"\u003e\u003c/app-native-component\u003e \u003cbeagle-remote-view [loadParams]=\"loadParams\"\u003e\u003c/beagle-remote-view\u003e No caso do Angular, não é possível usar o componente BeagleRemoteView caso ele seja carregado pela biblioteca de outra forma server-driven porque isso causa uma dependência circular e quebra a aplicação.\n Lembre-se de rodar seu projeto Angular usando um dos comandos:\nyarn run serve ou npx run serve\n A sua tela híbrida com elementos nativos e server driven está pronta\n ","excerpt":" É possível que alguns componentes de uma tela que sejam exibidos via …","ref":"/docs-beagle/pt/docs/tutoriais/adicionando-o-beagle-a-uma-parte-da-tela-nativa/adicionando-um-componente-beagle-server-driven/","title":"Adicionando um componente Beagle Server-driven"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/api/","title":"API"},{"body":" What is it? On Beagle, an action deals with behaviours (functions), that are performed in your application when an event is triggred. These actions can be a Beagle’s pattern or customized by you.\nAny Beagle’s event must be associated with an action list. See below a button’s component example, that associates with a pattern action alert to its onPress event:\n{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"click to show alert\", \"onPress\": [{ \"_beagleAction_\": \"beagle:alert\", \"title\": \"Hello\", \"message\": \"World\" }] } An action is map key/value with at least a _beagleAction_ property. Its value indicates which action must be performed when the event it is triggered. The other properties specify the parameters expected by the indicated action.\nThere are several implemented actions on Beagle by pattern and all of them start with prefix “beagle:” and the customized actions start with “custom:”.\nTo learn how to create custom actions, check out Beagle’s customization section.\nAction types Below, you will find a complete description of the attributes that are part of the Standard Actions on Beagle.\n","excerpt":" What is it? On Beagle, an action deals with behaviours (functions), …","ref":"/docs-beagle/docs/api/actions/","title":"Actions"},{"body":" Passo 1: Criar a tela nativa Android iOS Para criar a tela nativa no Android, crie uma nova Activity. Aqui será usado a MainActivity como modelo:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) declarative_content.addView(declarativeComponente().toView(this)) } } Nesse momento, a MainActivity.kt não terá modificações. É necessário que o seu arquivo activity_main.xml seja modificado primeiro.\n  Abra o activity_main.xml Por padrão, este arquivo vem configurado com o Contraint Layout e ele pode ser mantido dessa forma. Para que ele possa ser utilizado pelo Beagle é necessário que se declare um Fragment Layout nesse arquivo xml. É nesse fragment que será carregado o componente declarativo.  Veja o exemplo de xml utlizado nesse tutorial, o que finaliza a criação da tela Nativa.\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003candroidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"\u003e \u003cFrameLayout android:id=\"@+id/declarative_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c/FrameLayout\u003e \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e  Nesse exemplo criamos a seguinte UIViewController:\nclass NativeViewController: UIViewController { private lazy var firstLabel = makeLabel(text: \"I'm a native UILabel\") private lazy var secondLabel = makeLabel(text: \"Another native UILabel\") private func makeLabel(text: String) -\u003e UILabel { let label = UILabel() label.text = text label.textAlignment = .center label.font = .systemFont(ofSize: 25, weight: .semibold) label.backgroundColor = UIColor(hex: grayColor) return label } override func viewDidLoad() { super.viewDidLoad() navigationItem.title = \"Beagle Native\" navigationItem.backBarButtonItem = UIBarButtonItem( title: nil, style: .plain, target: nil, action: nil ) setupView() } private func setupView() { view.backgroundColor = .white view.addSubview(firstLabel) firstLabel.anchorCenterXToSuperview() firstLabel.anchor( top: topLayoutGuide.bottomAnchor, topConstant: 50 ) let layoutMargins = view.layoutMarginsGuide view.addSubview(secondLabel) secondLabel.anchorCenterXToSuperview() secondLabel.anchor(top: beagleView.bottomAnchor, topConstant: 30) secondLabel.bottomAnchor.constraint(lessThanOrEqualTo: layoutMargins.bottomAnchor).isActive = true } private let grayColor = \"#EEEEEE\" }  Passo 2: Criar o componente declarativo Android iOS Para criar um componente declarativo do Beagle, será usado um Container (um componente do Beagle que agrupa outros componentes). Ele pode ser declarado como uma variável ou como uma função que retorna um container. Nesse exemplo, foi configurado como retorno de uma função:\nfun declarativeComponente() = Container( children = listOf( Text( text = \"These buttons are rendered by Beagle\" ).applyFlex( Flex( alignSelf = AlignSelf.CENTER ) ), Button( \"I'm a server-driven button 1\", onPress = listOf( Alert(message = \"I'm a working button\")) ) ), Button( \"I'm a server-driven button too\", onPress = listOf( Alert(message = \"I'm a working as well\")) ) ) ) )  Para criar um componente declarativo do Beagle em forma de UIView utilizamos o componente BeagleView, ele pode ser declarado como os componentes nativos criados no passo anterior. Segue um exemplo abaixo com um Container que possui um texto e dois botões:\nprivate lazy var beagleView = BeagleView(Container( widgetProperties: .init(style: Style() .backgroundColor(grayColor) .margin(.init(all: 20)) .padding(.init(all: 10)) ) ) { Text( \"These buttons are rendered by Beagle\", widgetProperties: .init(style: .init( margin: .init(bottom: 10), flex: Flex().alignSelf(.center) )) ) Button( text: \"I'm a server-driven button\", onPress: [ Alert( title: \"Server-driven button\", message: \"I'm a server-driven button\" ) ] ) Button( text: \"Navigate to Navigator\", onPress: [Navigate.openNativeRoute(.init(route: .navigateStep1Endpoint))] ) })  Passo 3: Adicionar o componente na tela Android iOS Para adicionar esse componente a tela, será necessário chamar a função **addView**do Android a partir do Fragment Layout view que foi declarado no activity_main.xml como listado no exemplo abaixo:\nclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) declarative_content.addView(declarativeComponente().toView(this)) } } Como parâmetro do addView foi listado a função que retorna o componente criado aplicando o método do Beagle .toView(this)v\n O BeagleView pode ser adicionado como a UIView , nesse exemplo foi usado o método addSubview() para adicionar este componente na tela.\nSegue abaixo o método setupView() que é responsável por adicionar e ancorar os componentes da tela:\nprivate func setupView() { view.backgroundColor = .white view.addSubview(firstLabel) firstLabel.anchorCenterXToSuperview() firstLabel.anchor( top: topLayoutGuide.bottomAnchor, topConstant: 50 ) let layoutMargins = view.layoutMarginsGuide view.addSubview(beagleView) beagleView.translatesAutoresizingMaskIntoConstraints = false beagleView.topAnchor.constraint(equalTo: firstLabel.bottomAnchor, constant: 50).isActive = true beagleView.leadingAnchor.constraint(greaterThanOrEqualTo: layoutMargins.leadingAnchor).isActive = true beagleView.trailingAnchor.constraint(lessThanOrEqualTo: layoutMargins.trailingAnchor).isActive = true beagleView.centerXAnchor.constraint(equalTo: firstLabel.centerXAnchor).isActive = true view.addSubview(secondLabel) secondLabel.anchorCenterXToSuperview() secondLabel.anchor(top: beagleView.bottomAnchor, topConstant: 30) secondLabel.bottomAnchor.constraint(lessThanOrEqualTo: layoutMargins.bottomAnchor).isActive = true }  E pronto. Basta inicializar a sua aplicação e a tela declarativa será renderizada nativamente.\n","excerpt":" Passo 1: Criar a tela nativa Android iOS Para criar a tela nativa no …","ref":"/docs-beagle/pt/docs/tutoriais/adicionando-o-beagle-a-uma-parte-da-tela-nativa/adicionando-um-componente-beagle-declarativo/","title":"Adicionando um componente Beagle Declarativo"},{"body":" What is it? The AddChildrenAction class is responsible for adding - at the beginning or in the end - or changing all views that inherit from Widget and who accept children.\nThe AddChildrenAction structure is:\n   Attribute Type Required Definition     componentId String ✓ Defines the widget’s id, in which you want to add the views.   value List\u003cServerDrivenComponent\u003e ✓ Defines the list of children you want to add.   mode Mode  Defines the placement of where the children will be inserted in the list or if the contents of the list will be replaced. By default the set mode is APPEND.    Mode It is an ENUM, which values are:\n   Values Definition     APPEND Adds the view in the end of the children’s list.   PREPEND Adds the view on the beginning of the children’s list.   REPLACE Replaces all children of the widget.    How to use it? JSON Kotlin DSL \"_beagleAction_\": \"beagle:addChildrenAction\", \"componentId\": \"MyContainerID\", \"value\": [{ \"_beagleComponent_\": \"beagle:text\", \"text\": \"This is the new view added\" } ], \"mode\": \"APPEND\" } ] } ], \"id\": \"MyContainerID\"  Container( children = listOf( Button(\"AddChildren\", onPress = listOf( AddChildrenAction( componentId = \"MyContainerID\", value = listOf( Text(\"This is the new view added\") ), mode = Mode.APPEND ) )) ) ).apply { id = \"MyContainerID\" }   ","excerpt":" What is it? The AddChildrenAction class is responsible for adding - …","ref":"/docs-beagle/docs/api/actions/addchildren/","title":"Addchildren"},{"body":" Introdução Para este tutorial, iremos usar algumas ações e também APIs:\nActions\n SetContext SendRequest  APIs\n Context Binding Expressões  Apesar do conceito Server-Driven trabalhar componentes separadamente, é possível realizar a transmissão das informações para uma API e é o que vamos demonstrar abaixo.\nExemplo de Uso Neste exemplo, iremos utilizar os componentes TextInput e Button para simularmos uma tela de Login.\nPasso 1: Criar uma tela de Login Até este momento, vamos apenas sinalizar ao Beagle de que ele deve renderizar na tela dois componentes TextInputs e um componente Button para representarmos a tela de Login.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Username\" }, { \"_beagleComponent_\": \"beagle:textInput\", \"placeholder\": \"Password\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Login\" } ] }  Container( children = listOf( TextInput(placeholder = \"Username\"), TextInput(placeholder = \"Password\"), Button(text = \"Login\") ) )  Passo 2: Configurar o SetContext Agora utilize uma ação chamada SetContext, que altera um contexto específico em uma tela. Isto é necessário para dar vida à tela e fazer com que os dados que forem digitados nela sejam enviados para uma API.\nNeste cenário, o contexto é que irá guardar os dados digitados de nome do usuário e da senha para que, posteriormente, encaminhar estes dados para a API.\nAltere o código para adicionar essa lógica do SetContext:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"@{credentials.username}\", \"placeholder\": \"Username\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"credentials\", \"value\": \"@{onChange.value}\", \"path\": \"username\" } ] }, { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"@{credentials.password}\", \"placeholder\": \"Password\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"credentials\", \"value\": \"@{onChange.value}\", \"path\": \"password\" } ] }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Login\" } ], \"context\": { \"id\": \"credentials\", \"value\": { \"username\": \"\", \"password\": \"\" } } }  data class Credentials( val username: String, val password: String ) Container( context = ContextData( id = \"credentials\", value = Credentials(username = \"\",password = \"\") ), children = listOf( TextInput( placeholder = \"Username\", value = \"@{credentials.username}\", onChange = listOf( SetContext( contextId = \"credentials\", path = \"username\", value = \"@{onChange.value}\" ) ) ), TextInput( placeholder = \"Password\", value = \"@{credentials.password}\", onChange = listOf( SetContext( contextId = \"credentials\", path = \"password\", value = \"@{onChange.value}\" ) ) ), Button(text = \"Login\") ) )  Neste exemplo, utilizamos o evento onChange do próprio TextInput que é chamado sempre que o usuário digita um texto novo no input. Dentro do onChange, existe um contexto implícito chamado onChange no qual o value é o último valor digitado pelo usuário.\nOnChange Ainda dentro deste contexto, a ação de SetContext será executada a cada caractere digitado pelo usuário. Por isso que neste SetContext é obrigatório o contextId, que fará referência ao contexto que será alterado, além do value que representa o novo valor e do path que é o caminho dentro do contexto que iremos alterar.\nPath É o único parâmetro opcional. Isto significa que, caso ele não passe, o SetContext irá alterar a raiz do contexto para que o value seja o novo valor. No exemplo acima, estamos deixando claro que queremos alterar somente a chave username e password nos seus respectivos SetContexts.\nO poder do contexto + expressões é bem grande, pois é possível que, dentro de uma Action, você referencie o contexto implícito de quem a executou. No exemplo que vimos, é o caso do onChange, mas é possível fazer referência a outros contextos dentro de um contexto implícito, assim como usar múltiplas expressões.\nVocê pode inicializar uma tela com valores pré-definidos no contexto. Com isso, é possível que a tela renderize esses valores utilizando expressões.\nNo exemplo visto acima, inicializamos os campos username e password com valores vazios vindo do contexto.\n Passo 3: Enviar dados para uma API Até o momento, o que fizemos foi “salvar” estes valores no contexto para que, a partir desta etapa, possamos enviá-los para uma API por meio de uma requisição.\nEsta etapa não tem nenhuma diferença visual do passo anterior.  Para finalizar o fluxo de Login, vamos agora adicionar uma Action chamada SendRequest que, basicamente, permite fazer uma requisição HTTP e, no caso do onSuccess, mostrar um Alert dando boas-vindas ao usuário.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"@{credentials.username}\", \"placeholder\": \"Username\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"credentials\", \"value\": \"@{onChange.value}\", \"path\": \"username\" } ] }, { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"@{credentials.password}\", \"placeholder\": \"Password\", \"onChange\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"credentials\", \"value\": \"@{onChange.value}\", \"path\": \"password\" } ] }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Login\", \"onPress\": [ { \"_beagleAction_\": \"beagle:sendRequest\", \"url\": \"http://beagle.free.beeceptor.com/login\", \"method\": \"POST\", \"headers\":{ \"Content-Type\":\"application/json\" }, \"data\": { \"username\": \"@{credentials.username}\", \"password\": \"@{credentials.password}\", \"authType\": \"login\" }, \"onSuccess\": [ { \"_beagleAction_\": \"beagle:alert\", \"title\": \"You are logged-in\", \"message\": \"@{onSuccess.data.message}\" } ] } ] } ], \"context\": { \"id\": \"credentials\", \"value\": { \"username\": \"\", \"password\": \"\" } } }  data class Credentials( val username: String, val password: String ) data class RequestCredentials( val username: String, val password: String, val authType: String ) Container( context = ContextData( id = \"credentials\", value = Credentials(username = \"\", password = \"\") ), children = listOf( TextInput( placeholder = \"Username\", value = \"@{credentials.username}\", onChange = listOf( SetContext( contextId = \"credentials\", path = \"username\", value = \"@{onChange.value}\" ) ) ), TextInput( placeholder = \"Password\", value = \"@{credentials.password}\", onChange = listOf( SetContext( contextId = \"credentials\", path = \"password\", value = \"@{onChange.value}\" ) ) ), Button( text = \"Login\", onPress = listOf( SendRequest( url = \"http://beagle.free.beeceptor.com/login\", method = RequestActionMethod.POST, headers = mapOf( \"Content-Type\" to \"application/json\" ), data = RequestCredentials( username = \"@{credentials.username}\", password = \"@{credentials.password}\", authType = \"login\" ), onSuccess = listOf( Alert( title = \"You are logged-in\", message = \"@{onSuccess.data.message}\" ) ) ) ) ) ) )  Ao executar este código, você deve preencher os campos e pressionar o botão “Login”.\nFeito isso, o evento onPress irá executar o SendRequest enviando os dados que estão dentro do Context com o ID credentials.\nAssim que o SendRequest for feito e a requisição for concluída, o evento onSuccess irá executar a Action Alert que irá mostrar um alerta contendo os dados retornados da API.\n","excerpt":" Introdução Para este tutorial, iremos usar algumas ações e também …","ref":"/docs-beagle/pt/docs/tutoriais/criando-um-formul%C3%A1rio-e-submetendo-para-uma-api/","title":"Criando um formulário e submetendo para uma Api"},{"body":" What is it? Alert class creates a confirmation element.\nAlert structure is:\n   Attribute Type Required Definition     title String or Binding  Box alert title.   message String or Binding ✓ Box alert message.   onPressOk Action  Confirmation button action.   labelOk String  Confirmation button label.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Alert Example\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"title\": \"My Title\", \"message\": \"Alert message\", \"labelOk\": \"Close\" } ] } ] }  Container( children = listOf( Button( text = \"Alert Example\", onPress = listOf( Alert( title = \"My Title\", message = \"Alert message\", labelOk = \"Close\" ) ) ) ) )  👉 Test this example in the Web Playground​ ","excerpt":" What is it? Alert class creates a confirmation element.\nAlert …","ref":"/docs-beagle/docs/api/actions/alert/","title":"Alert"},{"body":" Testes Unitários Testes que têm por objetivo medir a funcionalidade do código em sua menor fração. É possível realizar testes unitários no Beagle seguindo o mesmo processo utilizado para caso de aplicações que não utilizem nossa ferramenta, já que o Beagle não interfere na realização dos testes.\nTestes Instrumentados Testes que são feitos como os testes unitários, com a diferença de que, em alguns casos, um um componente server driven pode não conter um ID, o que que geralmente o identifica como teste instrumentado.\nVale reforçar que estes tipos de testes feitos em aplicações que usam Beagle da mesma maneira que em aplicações que não usam nossa ferramenta.\nPara sanar problemas nos testes instrumentados, adicionamos ao elemento WIDGET (que referencia um componente) um atributo ID para que seja possível identificá-lo programaticamente.\nListamos um exemplo de um caso abaixo em que fizemos testes usando um elemento server driven.\nComo testamos? Neste exemplo, fizemos um teste instrumentado na plataforma Android utilizando o Espresso (Framework de automação), em que verificamos a funcionalidade de seleção e inserção de valores em um componente text field, que é server-driven.\n@Test public void TestSelectTextField() { new BeagleRobot() .checkViewContainsText(\"Beagle Sample\") .selectMenuOption() .clickOnText(\"TextField\") .typeIntoTextField(0,0,\"beagle\") ; } Passo 1: Iniciar o teste Você deve começar o teste validando se a aplicação foi devidamente aberta na página principal. Isso é feito para confirmar na função abaixo se o Header foi apresentado na tela.\nComo este componente não possui uma ID propriamente dita, utilizamos o texto contido no Header para localizar essa view na página principal. Veja o exemplo a seguir:\npublic BeagleTest checkViewContainsText(String text) { onView(allOf(withText(text))).check(matches(isDisplayed())); return this; } Passo 2: Apresentar o menu Após localizar o Header, o próximo passo é utilizarmos a função abaixo para selecionar o hamburguer icon e apresentar as opções deste menu.\nPor ser um componente server driven e não possuir um ID nesta implementação, utilizamos o posicionamento do componente para realizar a seleção.\nDesta forma, buscamos pelo texto presente no ContentDescription (\"More options\") e, em seguida, o seu posicionamento na hierarquia do componente. Confira no exemplo:\npublic BeagleTest selectMenuOption() { onView(allOf(withContentDescription(\"More options\"), childAtPosition(childAtPosition(withId(R.id.action_bar), 1), 0))).perform(click()); return this; } Passo 3: Selecionar componente Neste passo, o teste irá clicar em um componente (novamente localizado a partir do texto que contém) chamado text field, que é um item do menu aberto no passo anterior.\npublic BeagleTest clickOnText(final String text) { onView(allOf(withText(text), isDisplayed())).perform(click()); return this; } Passo 4: Inserir o componente Neste último passo, vamos inserir um texto ao componente text field. Uma vez que este componente não possui ID e nem um texto, ele será localizado pelo seu posicionamento na hierarquia do componente. Veja no exemplo a seguir:\npublic BeagleTest typeIntoTextField(int position1, int position2, String text) { onView(allOf(childAtPosition( childAtPosition( withId(R.id.fragment_content), position1), position2) ) ).perform(typeText(text)); Espresso.closeSoftKeyboard(); return this; }  Pronto, o seu teste instrumento foi realizado!  ","excerpt":" Testes Unitários Testes que têm por objetivo medir a funcionalidade …","ref":"/docs-beagle/pt/docs/tutoriais/testes/","title":"Testes"},{"body":" What is it? It is an action that has a boolean parameter and according to the value the action runs onTrue or onFalse.\n   Attribute Type Required Definition     condition Boolean or Binding ✓ Condition to define which action will run.   onTrue List\u003cAction\u003e  List of actions that it will be run when the condition is true.   onFalse List\u003cAction\u003e  List of actions that it will be run when the condition is false.    How to use it? The example below is a Container with a context that has a 18 value and the event onPress of the button is defined as an action with the Condition type, that verifies if the values is the same as 21 and shows an Alert depending on the context value.\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:button\", \"text\":\"Is equal to 21?\", \"onPress\":[ { \"_beagleAction_\":\"beagle:condition\", \"condition\":\"@{eq(age, 21)}\", \"onTrue\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"onTrue\", \"message\":\"Condition is true\" } ], \"onFalse\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"onFalse\", \"message\":\"Condition is false\" } ] } ] } ], \"context\":{ \"id\":\"age\", \"value\":18 } }  Container( context = ContextData( id = \"age\", value = 18 ), children = listOf( Button( text = \"Is equal to 21?\", onPress = listOf( Condition( condition = \"@{eq(age, 21)}\", onTrue = listOf( Alert(message = \"The condition is true\") ), onFalse = listOf( Alert(message = \"The condition is false\") ) ) ) ) ) )  ","excerpt":" What is it? It is an action that has a boolean parameter and …","ref":"/docs-beagle/docs/api/actions/condition/","title":"Condition"},{"body":"Benchmark: Beagle Movies Contexto O Beagle Movies é um aplicativo de filmes que foi desenvolvido usando o framework do Beagle. Com ele, é possível conferir resenhas de filmes e séries, além de criar listas personalizadas com o que você quer ou já assistiu.\nQuais foram os testes? Tamanho do Payload De modo geral, é esperado que o payload do Server-Driven UI seja maior que o nativo, pois toda estrutura de layout vem no payload, enquanto o nativo somente as informações a serem mostradas.\nApesar disso, em algumas telas o tamanho do payload é inferior ao server driven. Isso acontece porque BFF (Backend For Frontend) filtra os dados que não são usados no aplicativo e não envia no payload.\n   Telas Resposta em telas Server-Driven (em KB) Resposta em telas nativas (em KB)     Home 423,89 KB 300,73 KB   Detalhes 2,15 KB 3,37 KB   Search 12,8 KB 14,45 KB   Resultado do teste 438,84 KB 318,55 KB    Para telas mais complexas, o payload do server-driven ficará maior. É importante ressaltar que o Beagle utiliza um mecanismo de cache e que esse teste é considerado apenas a primeira requisição.\nA vantagem em usar o Beagle é porque você só desenvolve a tela apenas uma vez, enquant em telas nativas você terá de desenvolver para cada plataforma.  Tempo de Resposta  Telas Nativas: É necessário fazer várias requisições para montar a tela Telas Server-Driven: É necessário apenas uma requisição do BFF     Telas Tempo de resposta em telas Server-Driven (em ms) Tempo de resposta em telas nativas (em ms)     Home 312 ms 448 ms   Detalhes 179 ms 346 ms   Search 176 ms 271 ms   Resultado do teste 668 ms 1065 ms    Teste de performance iOS Veja a diferença de performance em telas nativas e server-driven considerando o processo de inicialização, chamada e resposta dos serviços de renderização da tela.\n   Etapas Tempo decorrido em telas Server-Driven (em segundos) Tempo decorrido em telas nativas (em segundos)     Start test 0,00 s 0,00 s   Set up 0,10 s 0,06 s   Open project 0,13 s 0,08 s   Launch app 0,15 s 0,12 s   Setting up automation session 3,95 s 2,17 s   Resultado do teste 8,21 segundos 6,39 segundos    ","excerpt":"Benchmark: Beagle Movies Contexto O Beagle Movies é um aplicativo de …","ref":"/docs-beagle/pt/docs/tutoriais/testes/benchmark-beagle-movies/","title":"Benchmark Beagle Movies"},{"body":" What is it? confirm class is responsible for creating a confirmation modal element.\nConfirm structure is:\n   Attribute  Type  Required Definition      title String or\nBinding\u003cb\u003e\u003c/b\u003e\n  Title of the confirmation box.   message String or\n\u003cb\u003e\u003c/b\u003eBinding\u003cb\u003e\u003c/b\u003e\n ✓ Confirmation box message.   onPressOk \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  Confirm button action.   onPressCancel \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  Cancel button action.   labelOk String  Confirmation button message.   labelCancel String  Cancel button message.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Confirm Example\", \"onPress\": [ { \"_beagleAction_\": \"beagle:confirm\", \"title\": \"Confirm Title\", \"message\": \"Confirm Message\", \"onPressOk\": { \"_beagleAction_\":\"beagle:alert\", \"message\": \"Confirmed\" } } ] } ] }  Button(text = \"Confirm Example\", onPress = listOf( Confirm(title = \"Confirm Title\", message = \"Confirm Message\", onPressOk = Alert( title = \"Ok\", message = \"Confirmed\"), onPressCancel = Alert( title = \"Cancel\", message = \"Cancelled\"), labelOk = \"Accept\", labelCancel = \"Deny\" ) ) )  👉 Test this action in the Web Playground ","excerpt":" What is it? confirm class is responsible for creating a confirmation …","ref":"/docs-beagle/docs/api/actions/confirm/","title":"Confirm"},{"body":" O que é? O Roboletric é um framework para testes unitários no Android. Uma de suas funções é simular informações sobre o contexto do Android durante a realização desses testes.\nAntes de utilizá-lo, é preciso configurar uma dependência do Yoga Layout chamada de SoLoader que, se não estiver habilitado para modo TESTE, vai ocorrer um erro de nullPointerException, uma vez que a view não existirá naquele contexto.\nVale lembrar que o Beagle utiliza Yoga Layout para posicionar os componentes na tela  Sendo assim, você precisa configurar o nosso SDK para ativar o “TesteMode” no SoLoader quando iniciar um teste e desativá-lo assim que terminar. Para tal, basta utilizar as funções conforme indicado a seguir.\nComo configurar? Para configurar o Beagle para os testes do Roboeletric, adicione o código abaixo no seu caso de teste:\n@BeforeClass fun setup() { BeagleSdk.setInTestMode() } @AfterClass fun teardown() { BeagleSdk.deinitForTest() } ","excerpt":" O que é? O Roboletric é um framework para testes unitários no …","ref":"/docs-beagle/pt/docs/tutoriais/testes/configura%C3%A7%C3%A3o-do-robolectric/","title":"Configuração do Robolectric"},{"body":" This action has been deprecated alongside Form  What is it? It defines the local action of a form, it doesn’t make HTTP requests, like for example, an action that creates a customized dialogue box.\nFormLocalAction structure is:\n   Attribute Type Required Definition     \nname\n String ✓ Defines the action name.   data Map\u003cString, String\u003e  Data that can be sent as an action parameter.    ","excerpt":" This action has been deprecated alongside Form  What is it? It …","ref":"/docs-beagle/docs/api/actions/formlocalaction/","title":"Formlocalaction"},{"body":" Para testar sua aplicação, você precisa de um Widget ID. Para fazer isso, Beagle oferece alguns métodos set e get.\nNessa seção, você verá dois específicos:\n Set Id Get Id  Set Id O método Set Id é usado quando você precisa setar um Id no widget fornecido para o BFF. Para fazer isso, você precisa chamar esse método no widget que você quer o Id setado durante o momento que você está criando o seu widget.\nVeja como funciona abaixo:\nText(text = \"Text with id\").setId(\"myTextId\") Get Id No Get Id, você tem diferentes maneiras de setar de acordo com a sua plataforma frontend.\nVeja abaixo:\nAndroid iOS Web No Android para obter um Widget Id você precisa chamar a String.toAndroidId() e esse método retornará um Id para você usar onde precisar.\nVeja como funciona, abaixo:\n\"myTextId\".toAndroidId()  No iOS, o Id é registrado no accessibilityIdentifier. Com isso, para usá-lo, você precisa usar o mesmo valor que está no setId().\nVeja como funciona, abaixo:\n\"myTextId\"  Na Web, existe uma configuração default que cada componente renderizado pelo Beagle recebe o ‘data-beagle-id’ que está em html, se o backend não setar o Id.\nSe você quiser recuperar, use o javascript e html rodando o comando abaixo:\nelement.getAttribute(widgetId) O valor do Widget Id será personalizado, se o backend setar o Id (como no exemplo, “myTextId”) ou ele será um valor default (‘data-beagle-id’).\n ","excerpt":" Para testar sua aplicação, você precisa de um Widget ID. Para fazer …","ref":"/docs-beagle/pt/docs/tutoriais/testes/usando-widget-id/","title":"Usando widget Id"},{"body":" This action has been deprecated alongside Form  What is it? It is an action to make the request to submit a form.\nFormRemoteAction structure is:\n   Attribute Type Required Definition     \npath\n String ✓ Defines the URL service path that it will receive the form's data.   method FormMethodType ✓ Defines the type of operation to submit a form.    FormMethodType ENUM to define the HTTP method that it will use to submit a form.\nSee the values below:\n   Type Definition     GET It is used for methods that only receive data.   POST It is used for methods that submit data.   PUT It is used for methods that replace the data.   DELETE It is used for method that remove data.    \u0000\n","excerpt":" This action has been deprecated alongside Form  What is it? It is an …","ref":"/docs-beagle/docs/api/actions/formremoteaction/","title":"Formremoteaction"},{"body":" This action has been deprecated alongside Form.  What is it?  ‌This action is used to configure the error messages returned toby the external service to submit the form, for example, verify the CPF register status when it is submitted.\nFormValidation structure is:\n   Attribute Type Required Definition     errors List\u003cFieldError\u003e ✓ Errors list.    ‌\nFieldError  FieldError is class that defines error.\nThe FieldError structure is:\n   Attribute Type Required Definition     inputName String ✓ Name of the component which the error refers to.   message String ✓ Error message to be displayed.    ","excerpt":" This action has been deprecated alongside Form.  What is it?  ‌This …","ref":"/docs-beagle/docs/api/actions/formvalidation/","title":"Formvalidation"},{"body":" O que é o Playground? O Playground é uma ferramenta de desenvolvimento onde se pode criar componentes e páginas utilizando o Beagle de forma simples e rápida, sem a necessidade de fazer qualquer instalação. Ele possui uma interface que permite você escrever um JSON e ver o resultado de forma instantânea.\nAcessando o Playground O playground pode ser acessado pelo seguinte link:\n{% embed url=“https://beagle-playground.netlify.app” %}}\nVocê terá acesso ao seguinte projeto demo:\nO menu de arquivos fica à esquerda, no centro fica o JSON do arquivo selecionado, e a direita é onde você pode ver o preview do JSON selecionado.\n","excerpt":" O que é o Playground? O Playground é uma ferramenta de …","ref":"/docs-beagle/pt/docs/playground/playground-web/","title":"Playground Web"},{"body":" Navigate is responsible to all screen’s navigation on Beagle. You can configure some navigation action types, which it can be seen on the following pages.\nNavigate Actions ","excerpt":" Navigate is responsible to all screen’s navigation on Beagle. You can …","ref":"/docs-beagle/docs/api/actions/navigate/","title":"Navigate"},{"body":" Utilizando o Playground Menu de arquivos No menu de arquivos, a esquerda da tela, você pode criar, excluir ou selecionar um arquivo e ao clicar no primeiro ícone superior ou pressionando CTRL+B você pode minimizar ou expandir esse menu.\nJSON As alterações do JSON podem ser salvas clicando no 2° ícone superior ou pressionando CTRL+S. Para você atualizar a visualização da tela com o novo JSON, clique no 4° ícone no canto superior ou pressione F9.\nAssim que as alterações são salvas, é disponibilizado um link do seu projeto que está alocado na nuvem, a partir dele, seu projeto pode ser acessado em qualquer local.\nPlataforma No menu superior direito é possível selecionar a plataforma que você deseja, atualmente estão disponíveis as opções React Webe Angular.\n","excerpt":" Utilizando o Playground Menu de arquivos No menu de arquivos, a …","ref":"/docs-beagle/pt/docs/playground/playground-web/usando-o-playground/","title":"Usando o Playground"},{"body":" What is it? It opens a new screen through a deep link.​\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     route String ✓ Identifier to open a new screen.   shouldResetApplication Boolean  Restart an applications preview stack.   Data Map \u003cString, String\u003e  Send data to a new screen.    You must configure a DeepLinkHandler in order to use this component.  How to use it? The example below, we have a screen coming from BFF with a button when you click, opens a native screen.\nTo test is, just configure Deep Link Handler for Android or openNativeRoute for iOS. Besides, your BFF’s endpoint must return the code screen below and call it in the frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:openNativeRoute\", \"route\" : \"my-native\", \"shouldResetApplication\" : false } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.OpenNativeRoute( route = \"my-native\" ) ) ) )  👉 Test this example on Web Playground ","excerpt":" What is it? It opens a new screen through a deep link.​\nThe structure …","ref":"/docs-beagle/docs/api/actions/navigate/opennativeroute/","title":"Opennativeroute"},{"body":" Exemplos de componentes demo Segue a lista com os exemplos de componentes implementados no Playground:\nButton Experimente no Playground\nDocumentação do componente\nContainer Experimente no Playground\nDocumentação do componente\nLazy Component Experimente no Playground\nDocumentação do componente\nList View Experimente no Playground\nDocumentação do componente\nModal Experimente no Playground\nPage View Experimente no Playground\nDocumentação do componente\nSimple Form Experimente no Playground\nTab View Experimente no Playground\nDocumentação do componente\nText Experimente no Playground\nDocumentação do componente\nTouchable Experimente no Playground\nDocumentação do componente\n","excerpt":" Exemplos de componentes demo Segue a lista com os exemplos de …","ref":"/docs-beagle/pt/docs/playground/playground-web/componentes-demo/","title":"Componentes demo"},{"body":" What is it? Open the navigator by selecting the user with the informed URL.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     url String ✓ URL sent to navigator.    How to use it? On the example below, you can see a screen that comes from BFF with a button when is clicked, open the browser with the specific URL. To test, it is necessary an endpoint of your BFF return the code below and call it in the frontend: d.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:openExternalURL\", \"url\" : \"https://docs.usebeagle.io/api/api-acoes/navigate/openexternalurl\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.OpenExternalURL( url = \"https://docs.usebeagle.io/api/api-acoes/navigate/openexternalurl\" ) ) ) )  👉 Test this example on Web Playground ","excerpt":" What is it? Open the navigator by selecting the user with the …","ref":"/docs-beagle/docs/api/actions/navigate/openexternalurl/","title":"Openexternalurl"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/playground/","title":"Playground"},{"body":" What is it? Presents a new screen and puts it on the pile.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route Route ✓ Navigation route.    How to use it? On the example below there’s a screen coming from BFF with a button that when clicked, open a new server-driven activity with a screen specified by BFF.\nTo test, your BFF’s endpoint should return a the screen with the code below and call it in the frontend. You can pass a local route or a remote one that will pass the screen endpoint to the one it will navigate.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushStack\", \"route\" : { \"screen\" : { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello second Screen\" } } } } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PushStack( Route.Local( Screen( child = Text(\"Hello second Screen\") ) ) ) ) ) )  👉 Test this example on Web Playground  ","excerpt":" What is it? Presents a new screen and puts it on the pile.\nYour …","ref":"/docs-beagle/docs/api/actions/navigate/pushstack/","title":"Pushstack"},{"body":" O que é? Por enquanto, existem dois atributos comuns de acessibilidade entre todas as plataformas que o Beagle suporta.\n   Atributo Tipo Obrigatório Definição     accessible Boolean ✓ Indica se o componente será interpretado como acessível. Default é true.   accessibilityLabel String  Uma mensagem que será dita por programas como o VoiceOver.    Caso o backend não especifique acessibilidade, os valores padrões de cada plataforma serão utilizados.  Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/rvRN9kv/logo.png\" }, \"accessibility\": { \"accessibilityLabel\": \"Image Label\", \"accessible\": true } } ] }  Container( children = listOf( Image( path = ImagePath.Remote(\"https://i.ibb.co/rvRN9kv/logo.png\") ).applyAccessibility( accessibility = Accessibility(true, \"Image Label\") ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é? Por enquanto, existem dois atributos comuns de …","ref":"/docs-beagle/pt/docs/api/acessibilidade/","title":"Acessibilidade"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/api/","title":"API"},{"body":" What it is? Presents a new screen and puts it on the pile.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route Route ✓ Navigation route.    How to use it? On the example below, there is a screen coming from BFF with a button when clicked, open a new server-drive fragment with a specific BFF screen.\nTo test is, you need a endpoint to return with the code below from your BFF and call it in the frontend. You can pass a local route (that it will pass a screen in the route) or remote route that will pass the endpoint of the screen which it will navigate.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"screen\" : { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello second Screen\" } } } } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Local( Screen( child = Text(\"Hello second Screen\") ) ) ) ) ) )  👉 Test this example on Web Playground ","excerpt":" What it is? Presents a new screen and puts it on the pile.\nYour …","ref":"/docs-beagle/docs/api/actions/navigate/pushview/","title":"Pushview"},{"body":" O que é? No Beagle, uma ação lida com os comportamentos (funções), que serão executadas em sua aplicação assim que um determinado evento for disparado. Essas ações podem ser padrão do próprio Beagle ou customizadas.\nQualquer evento no Beagle, deve ser associado a uma lista de ações. Veja abaixo um exemplo de componente de botão, que associa uma ação de alerta padrão ao seu evento de onPress:\n{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"click to show alert\", \"onPress\": [{ \"_beagleAction_\": \"beagle:alert\", \"title\": \"Hello\", \"message\": \"World\" }] } Uma ação é um mapa chave/valor com pelo menos uma propriedade:_beagleAction_. O valor dela indica qual ação deve ser executada quando o evento for disparado. As demais propriedades especificam os parâmetros esperados pela ação indicada.\nExistem diversas ações implementadas no Beagle por padrão e todas elas começam com prefixo “beagle:” e as ações customizadas possuem o prefixo “custom:”.\nPara saber como criar ações customizadas, dê uma olhada na seção de customização do Beagle\nTipos de ações Abaixo, você encontra a descrição completa de cada ação disponível por padrão no Beagle:\n","excerpt":" O que é? No Beagle, uma ação lida com os comportamentos (funções), …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/","title":"Ações"},{"body":" What is it? Removes the current exhibition pile.\nHow to use it? On the example below there’s a screen coming from BFF with a button that when clicked, closes the current activity.\nTo test, your BFF’s endpoint should return the screen with the code below and call it in the frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popStack\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PopStack() ) ) )  👉 Test this example on Web Playground ","excerpt":" What is it? Removes the current exhibition pile.\nHow to use it? On …","ref":"/docs-beagle/docs/api/actions/navigate/popstack/","title":"Popstack"},{"body":" O que é? A ação AddChildrenAction é responsável por adicionar - no início ou no final - ou trocar todas as views que foram herdadas de Widget e que aceitam filhos.\nA estrutura do AddChildrenAction é:\n   Atributo Tipo Obrigatório Definição     componentId String ✓ Define o id do Widget, no qual deseja adicionar as views.   value List\u003cServerDrivenComponent\u003e ✓ Define a lista de filhos que deseja adicionar.   mode Mode  Define o posicionamento de onde os filhos serão inseridos na lista ou se o conteúdo da lista será substituído. Por padrão o modo definido é APPEND.    Mode É um ENUM, cujos valores são:\n   Valor Definição     APPEND Adiciona a view no final da lista de filhos.   PREPEND Adiciona a view no começo da lista de filhos.   REPLACE Substitui todos os filhos do widget.    Como usar? Veja abaixo um exemplo de um botão que ao clicado adiciona uma view de texto:\nJSON Kotlin DSL \"_beagleComponent_\": \"beagle:container\", \"children\": [{ \"_beagleComponent_\": \"beagle:button\", \"text\": \"AddChildren\", \"onPress\": [{ \"_beagleAction_\": \"beagle:addChildrenAction\", \"componentId\": \"MyContainerID\", \"value\": [{ \"_beagleComponent_\": \"beagle:text\", \"text\": \"This is the new view added\" } ], \"mode\": \"APPEND\" } ] } ], \"id\": \"MyContainerID\"  Container( children = listOf( Button(\"AddChildren\", onPress = listOf( AddChildrenAction( componentId = \"MyContainerID\", value = listOf( Text(\"This is the new view added\") ), mode = Mode.APPEND ) )) ) ).apply { id = \"MyContainerID\" }  ","excerpt":" O que é? A ação AddChildrenAction é responsável por adicionar - no …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/addchildren/","title":"Addchildren"},{"body":" What is it? Closes the current exhibition screen.\nHow to use it? On the example below there’s a screen coming from BFF with a button that when clicked, removes the current fragment.\nTo test, your BFF’s endpoint should return the screen with the code below and call it in the frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popView\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PopView() ) ) )  👉 Test this example on Web Playground ","excerpt":" What is it? Closes the current exhibition screen.\nHow to use it? On …","ref":"/docs-beagle/docs/api/actions/navigate/popview/","title":"Popview"},{"body":" O que é? A ação Alert é responsável por criar um elemento de confirmação\nA estrutura do Alert é:\n   Atributo  Tipo  Obrigatório Definição      title String ou\nBinding\u003cb\u003e\u003c/b\u003e\n  Título da caixa de alerta.   message String ou\n\u003cb\u003e\u003c/b\u003eBinding\u003cb\u003e\u003c/b\u003e\n ✓ Mensagem da caixa de alerta.   onPressOk \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  Ação do botão de confirmação.   labelOk String  Label do botão de confirmação.    Como usar? Abaixo segue um exemplo de um botão que ao clicado mostra um Alert:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Alert Example\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"title\": \"My Title\", \"message\": \"Alert message\", \"labelOk\": \"Close\" } ] } ] }  Container( children = listOf( Button( text = \"Alert Example\", onPress = listOf( Alert( title = \"My Title\", message = \"Alert message\", labelOk = \"Close\" ) ) ) ) )  👉 Teste essa ação no Web Playground​ ","excerpt":" O que é? A ação Alert é responsável por criar um elemento de …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/alert/","title":"Alert"},{"body":" What is it? Returns to a specific screen and cleans the navigation that was generated from that screen.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route ​String ✓ Route of a screen that it’s on the pile.    How to use it? On the example below, three screens were used: two first used PushView to add the screens to the piles, the last one use PopToView to return to the first.\nTo test, you will need three endpoints:\n The first endpoint will be what your frontend will call to render the screen zero. The second endpoint should be mapped as \"/firstScreen\", because this will be the chosen URL to the navigation of the button on the screen 0 and for that, this endpoint must return the screen 1. The third endpoint must be mapped \"/secondScreen\", because this will be the chose URL to the navigation of the button on the screen 1, for that, this endpoint must return the screen 2. It is through the screen 2 that it pass a route where the endpoint of the screen must return. in this case, it is “/home” that it is the endpoint of the zero screen.  How to call the screen 0  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  How to call the screen 1  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  How to call the screen 2  JSON Kotlin DSL Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to go to first screen\", onPress = listOf( Navigate.PopToView( route = \"/home\" ) ) ) ) ) )  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to go to first screen\", onPress = listOf( Navigate.PopToView( route = \"/home\" ) ) ) ) ) )  👉 Test this example on Web Playground ","excerpt":" What is it? Returns to a specific screen and cleans the navigation …","ref":"/docs-beagle/docs/api/actions/navigate/poptoview/","title":"Poptoview"},{"body":" O que é? É uma ação que tem um parâmetro do tipo Boolean e de acordo com esse valor é executado a ação onTrue ou onFalse.\n   Atributo Tipo Obrigatório Definição     condition Boolean ou Binding ✓ condição para definir qual ação será executada.   onTrue List\u003cAction\u003e  lista de ações que será executada quando a condição for verdadeira.   onFalse List\u003cAction\u003e  lista de ações que será executada quando a condição for falsa.    Como usar? O exemplo abaixo é um Container com um contexto que possui o valor 18 e no evento onPress do botão foi definido uma ação do tipo Condition que verifica se o valor é igual a 21 e mostra um Alert dependendo do valor do contexto.\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:button\", \"text\":\"Is equal to 21?\", \"onPress\":[ { \"_beagleAction_\":\"beagle:condition\", \"condition\":\"@{eq(age, 21)}\", \"onTrue\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"onTrue\", \"message\":\"Condition is true\" } ], \"onFalse\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"onFalse\", \"message\":\"Condition is false\" } ] } ] } ], \"context\":{ \"id\":\"age\", \"value\":18 } }  Container( context = ContextData( id = \"age\", value = 18 ), children = listOf( Button( text = \"Is equal to 21?\", onPress = listOf( Condition( condition = \"@{eq(age, 21)}\", onTrue = listOf( Alert(message = \"The condition is true\") ), onFalse = listOf( Alert(message = \"The condition is false\") ) ) ) ) ) )  ","excerpt":" O que é? É uma ação que tem um parâmetro do tipo Boolean e de acordo …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/condition/","title":"Condition"},{"body":" What is it? Opens a screen with an informed route of a new flow and cleans the pile of previous loaded screens.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route Route ✓ Navigation route.    How to use it? On the example below, three screens were used: two firs used PushView to add the screens to the piles, the last one use ResetStack and reopens the first screen.\nTo test, you will need three endpoints:\n The first endpoint will be what your frontend will call to render the screen zero. The second endpoint must be mapped \"/firstScreen\", because this will be the chosen URL of the screen 0 button’s navigation and for that the endpoint must return the screen 1. The third point must be mapped**\"/secondScreen\",** because this will be the chosen URL of the screen 1 button’s navigation and for that this endpoint must return the screen 2. On the screen 2, the passed route must be the screen endpoint that you want to return when the application restarts. In this case, it is **\"/home\"** that it is screen’s 0 endpoint.  How to call the screen zero  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  How to call the screen 1  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  How to call the screen 2  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to reset stack\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:resetStack\", \"route\" : { \"url\" : \"/home\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to reset stack\", onPress = listOf( Navigate.ResetStack( route = Route.Remote(\"/home\") ) ) ) ) ) )  👉 Test this example on Web Playground ","excerpt":" What is it? Opens a screen with an informed route of a new flow and …","ref":"/docs-beagle/docs/api/actions/navigate/resetstack/","title":"Resetstack"},{"body":" O que é? A ação confirm é responsável por criar um elemento modal de confirmação.\nA estrutura do Confirm é:\n   Atributo  Tipo  Obrigatório Definição      title String ou\nBinding\u003cb\u003e\u003c/b\u003e\n  Título da caixa de confirmação   message String ou\nBinding\u003cb\u003e\u003c/b\u003e\n ✓ Mensagem da caixa de confirmação   onPressOk \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  Ação do botão de confirmação   onPressCancel \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e  Ação do botão de cancelamento   labelOk String  Mensagem do botão de confirmação   labelCancel String  Mensagem do botão de cancelamento    Como usar? Segue abaixo um exemplo com um botão que ao clicado exibe um modal de confirmação:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Confirm Example\", \"onPress\": [ { \"_beagleAction_\": \"beagle:confirm\", \"title\": \"Confirm Title\", \"message\": \"Confirm Message\", \"onPressOk\": { \"_beagleAction_\":\"beagle:alert\", \"message\": \"Confirmed\" } } ] } ] }  Button(text = \"Confirm Example\", onPress = listOf( Confirm(title = \"Confirm Title\", message = \"Confirm Message\", onPressOk = Alert( title = \"Ok\", message = \"Confirmed\"), onPressCancel = Alert( title = \"Cancel\", message = \"Cancelled\"), labelOk = \"Accept\", labelCancel = \"Deny\" ) ) )  👉 Teste essa ação no Web Playground ","excerpt":" O que é? A ação confirm é responsável por criar um elemento modal de …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/confirm/","title":"Confirm"},{"body":" What is it? Opens a screen with an informed route and deletes all the navigation piles.\nYour structure is represented by the attribute below:\n   Attribute Type Required Definition     route ​Route​ ✓ Navigation route.    How to use it? On the example below, three screens were used: two first used PushView to add the screens to the piles, the last one use ResetApplication and reopens the first screen.\nTo test, you will need three endpoints:\n The first endpoint will be what your frontend will call to render the screen zero. The second endpoint must be mapped as \"/firstScreen\", because this will be the chose URL to the screen 0 button’s navigation, and it must return to the screen 1. The third endpoint must be mapped as \"/secondScreen\", because this will be the chosen URL to the screen 1 button’s navigation, and it must return to the screen 2. On the screen 2 the passed route must be the screen’s endpoint that you want to return when the application starts. In this case, \"/home\" is the screen’s 0 endpoint.  How to call the screen zero  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  How to call the screen 1  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  How to call the screen 2  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to reset application\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:resetApplication\", \"route\" : { \"url\" : \"/home\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to reset application\", onPress = listOf( Navigate.ResetApplication( route = Route.Remote(\"/home\") ) ) ) ) ) )  👉 Test this example on Web Playground ","excerpt":" What is it? Opens a screen with an informed route and deletes all the …","ref":"/docs-beagle/docs/api/actions/navigate/resetapplication/","title":"Resetapplication"},{"body":" Essa ação foi depreciada junto com o Form!  O que é? Define as ações locais do formulário, ou seja, não fazem solicitações de HTTP, como por exemplo, uma ação que cria uma caixa de diálogo personalizada.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     \nname\n String ✓ Define o nome da ação.   data Map\u003cString, String\u003e  Dado que pode ser enviado como parâmetro da ação.    ","excerpt":" Essa ação foi depreciada junto com o Form!  O que é? Define as ações …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/formlocalaction/","title":"Formlocalaction"},{"body":" Route defines how the navigation must be loaded.\nYou will find below, the description of the Route’s types available on Beagle:\n","excerpt":" Route defines how the navigation must be loaded.\nYou will find below, …","ref":"/docs-beagle/docs/api/actions/navigate/route/","title":"Route"},{"body":" Essa ação foi depreciada junto com o Form!  O que é? É a ação para fazer uma requisição para submeter o formulário.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     \npath\n String ✓ Define o caminho URL do serviço que irá receber os dados do formulário.   method FormMethodType ✓ Define o tipo de operação para submeter o formulário.    FormMethodType É um ENUM para definir o método HTTP que usará para submeter o formulário.\nSegue abaixo os valores:\n   Tipo Definição     GET É usado para métodos que só recebem dados.   POST É usado para métodos que submetem dados.   PUT É usado para métodos que substituem os dados .   DELETE É usado para métodos de remoção de dados.    \u0000\n","excerpt":" Essa ação foi depreciada junto com o Form!  O que é? É a ação para …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/formremoteaction/","title":"Formremoteaction"},{"body":" What is it? Navigation for remote content.\nThe structure is represented by the attributes below:\n   Attribute  Type  Required Definition      url String or\nBinding\u003cb\u003e\u003c/b\u003e\n ✓ Navigation address.   shouldPrefetch Boolean  Load the address previously.   fallback Screen\u003cb\u003e\u003c/b\u003e  Screen to be returned in case the loading fails.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushView\", \"route\": { \"url\": \"/present/view\", \"shouldPrefetch\": false } } ] }  Button( onPress = listOf( Navigate.PushView( Route.Remote(\"/present/view\") ) ), text = \"Click me!\" )  👉 Teste this action in the Web Playground ","excerpt":" What is it? Navigation for remote content.\nThe structure is …","ref":"/docs-beagle/docs/api/actions/navigate/route/remote/","title":"Remote"},{"body":" Essa ação foi depreciada junto com o Form!  O que é? Essa ação é usada para configurar as mensagens de erro retornadas pelo serviço externo ao submeter um formulário, por exemplo, verificar o status do registro de um CPF ao submetê-lo.\nA estrutura do FormValidation é:\n   Atributo Tipo Obrigatório Definição     errors List\u003cFieldError\u003e ✓ Lista de erros.    FieldError O FieldError é uma classe para definir o erro.\nA estrutura do FieldError é:\n   Atributo Tipo Obrigatório Definição     inputName String ✓ Nome do componente o qual o erro se refere.   message String ✓ Mensagem do erro a ser exibido.    ","excerpt":" Essa ação foi depreciada junto com o Form!  O que é? Essa ação é …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/formvalidation/","title":"Formvalidation"},{"body":" What is it?  Navigation for a local content.\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     screen Screen  Screen to be loaded    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushView\", \"route\": { \"screen\": { \"_beagleComponent_\": \"beagle:screenComponent\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Hello Screen from Navigate\" } } } } ] }  Button( onPress = listOf( Navigate.PushView( Route.Local( Screen( child = Text(\"Hello Screen from Navigate\") ) ) )), text = \"Click me!\" )  👉 Test this action in the Web Playground ","excerpt":" What is it?  Navigation for a local content.\nThe structure is …","ref":"/docs-beagle/docs/api/actions/navigate/route/local/","title":"Local"},{"body":" O Navigate é responsável por toda navegação de telas com Beagle. Nele, é possível configurar alguns tipos de ações de navegação, que você pode conferir nas próximas páginas.\nAções de navegação ","excerpt":" O Navigate é responsável por toda navegação de telas com Beagle. …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/","title":"Navigate"},{"body":" O que é? O OpenNativeRoute é uma ação que realiza a navegação para uma tela nativa.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     route String ✓ Identificador para abrir uma tela nova.   shouldResetApplication Boolean  Reinicia a pilha de visualização do aplicativo.   Data Map \u003cString, String\u003e  Envia informações para a nova tela.    Como usar? No exemplo abaixo, temos uma tela vinda do BFF com um botão que ao clicar nele, abre uma tela nativa.\nPara testar, é preciso configurar o Deep Link Handler para Android ou o openNativeRoute, no caso de aplicação iOS. Além disso, seu endpoint do BFF precisa retornar a tela do código abaixo e chamar esse endpoint no Frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:openNativeRoute\", \"route\" : \"my-native\", \"shouldResetApplication\" : false } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.OpenNativeRoute( route = \"my-native\" ) ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é? O OpenNativeRoute é uma ação que realiza a navegação para …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/opennativeroute/","title":"Opennativeroute"},{"body":" What is it? SendRequest is used to make HTTP requests.\nThe Send Request structure is:\n   Attribute Type Required Definition     url String or Binding ✓ Server URL.   method RequestActionMethod or Binding ✓ HTTP method.   headers Map \u003cString, String\u003e or Binding  Header items for the request.   data Any  Content that will be deliver with the request.   onSuccess List\u003cAction\u003e  Success action.   onError List\u003cAction\u003e  Error action.   onFinish List\u003cAction\u003e  Finish action.    How to use it? See below an example of a button that send a POST request with data user:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Send Request Example\", \"onPress\": [ { \"beagleAction\":\"beagle:sendRequest\", \"url\":\"https://myUrl.com/endpoint\"\", \"method\":\"POST\", \"headers\":{ \"Content-Type\":\"application/json\" }, \"data\":{ \"email\":\"john@email.com\", \"password\":\"password\", \"confirmPassword\":\"password\", \"name\":\"John\" }, \"onSuccess\":[ { \"beagleAction\":\"beagle:alert\", \"title\":\"SUCCESS\", \"message\":\"Success\" } ], \"onError\":[ { \"beagleAction\":\"beagle:alert\", \"title\":\"ERROR\", \"message\":\"Error\" } ], \"onFinish\":[ { \"beagleAction\":\"beagle:alert\", \"title\": \"FINISH\", \"message\":\"Finish\" } ] } ] } ] }  Button( text = \"Send a request\", styleId = \"DesignSystem.MyNativeButtonStyle\", onPress = listOf( SendRequest( url = https://myUrl.com/endpoint\", method = RequestActionMethod.POST, data = User( name = \"John\", email = \"jonh@email.com\", password = \"password\", confirmPassword = \"password\" ), headers = mapOf( \"Content-Type\" to \"application/json\" ), onSuccess = listOf( Alert( title = \"SUCCESS\", message = \"Success\" ) ), onError = listOf( Alert( title = \"ERROR\", message = \"Error\" ) ), onFinish = listOf( Alert( title = \"FINISH\", message = \"Finish\" ) ) ) ) )  👉 Test this action in the Web Playground ","excerpt":" What is it? SendRequest is used to make HTTP requests.\nThe Send …","ref":"/docs-beagle/docs/api/actions/sendrequest/","title":"Sendrequest"},{"body":" O que é? Abre o navegador selecionado pelo usuário com a url informada.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     url String ✓ URL enviada para o navegador.    Como usar? No exemplo abaixo, você pode ver um botão que, ao ser clicado, abre o navegador com a URL especificada. Para testar, basta que um endpoint do seu BFF retorne a tela do código abaixo e chame esse endpoint no frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:openExternalURL\", \"url\" : \"https://docs.usebeagle.io/api/api-acoes/navigate/openexternalurl\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.OpenExternalURL( url = \"https://docs.usebeagle.io/api/api-acoes/navigate/openexternalurl\" ) ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é? Abre o navegador selecionado pelo usuário com a url …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/openexternalurl/","title":"Openexternalurl"},{"body":" What is it? The SetContext action is responsible for changing the value of a context.\nThe setContext structure is:\n   Attribute Type Required Definition     contextId String ✓ Context identifier   value Any ✓ New value to apply in the context   path String  Specific context point for changing value in case of arrays and maps \u003ckey, value\u003e.    Get to know more about Beagle context.  How to use it? See below an example of a text that is set by context and have an initial value “Set Context Example”. The click event have a SetContext action that change the context value to “Context has changed”.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"context\":{ \"id\": \"myContext\", \"value\":\"Set Context Example\" }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\":\"@{myContext}\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Open Modal\", \"onPress\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"myContext\", \"value\": \"Context has changed\" } ] } ] }  Container( children = listOf( Text(text = \"@{myContext}\"), Button( text = \"Open Modal\", onPress = listOf( SetContext( contextId = \"myContext\", value = \"Context has changed\" ) ) ) ), context = ContextData( id = \"myContext\", value = \"Set Context Example\" ) )  👉 Test this action in the Web Playground ","excerpt":" What is it? The SetContext action is responsible for changing the …","ref":"/docs-beagle/docs/api/actions/setcontext/","title":"Setcontext"},{"body":" O que é? Apresenta uma nova tela e a coloca na pilha.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     route Route ✓ Rota de navegação.    Como usar? No exemplo abaixo, temos uma tela vinda do BFF com um botão, que ao ser clicado, abre uma nova activity server-driven com a tela especificada pelo BFF.\nPara testar, basta que um endpoint do seu BFF retorne a tela do código abaixo e chame esse endpoint no frontend. Você poderá passar tanto uma rota local (que passará uma screen na rota), quanto remota (que passará o endpoint da tela para a qual irá navegar).\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushStack\", \"route\" : { \"screen\" : { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello second Screen\" } } } } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PushStack( Route.Local( Screen( child = Text(\"Hello second Screen\") ) ) ) ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é? Apresenta uma nova tela e a coloca na pilha.\nA sua estrutura …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/pushstack/","title":"Pushstack"},{"body":" What is it? SubmitForm is an exclusive action ofSimpleForm, it must be used in some event inside the form, so it will be sent.\nHow to use? For a complete example together with SimpleForm, click here.\n","excerpt":" What is it? SubmitForm is an exclusive action ofSimpleForm, it must …","ref":"/docs-beagle/docs/api/actions/submitform/","title":"Submitform"},{"body":" O que é?  Abre uma nova tela na mesma pilha usando uma rota.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     route ​Route​ ✓ Rota de navegação.    Como usar? No exemplo abaixo, temos uma tela vinda do BFF com um botão, que ao ser clicado, abre um novo fragment server-driven com a tela especificada pelo BFF.\nPara testar, basta que um endpoint do seu BFF retorne a tela do código abaixo e chame esse endpoint no frontend. Você poderá passar tanto uma rota local (que passará uma screen na rota), quanto remota (que passará o endpoint da tela para a qual irá navegar).\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"screen\" : { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Hello second Screen\" } } } } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Local( Screen( child = Text(\"Hello second Screen\") ) ) ) ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é?  Abre uma nova tela na mesma pilha usando uma rota.\nA sua …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/pushview/","title":"Pushview"},{"body":" Analytics As most projects use some sort of tagging to gather data about users behaviors and Beagle offers a way to get those informations.\nIt is necessary to configure all platforms that will be used. You can check the configuration for each one of them bellow:\nConfiguration  Select an option  ANDROID CONFIGURATION IOS CONFIGURATION WEB CONFIGURATION To make the Analytics feature work on your Android project you just need to add a Class that implements the Analytics interface and annotate this Class with the @BeagleComponent annotation:\n@BeagleComponent class SampleAnalytics: Analytics { override fun trackEventOnClick(event: ClickEvent) { //TODO: send click event to your tagging library  } override fun trackEventOnScreenAppeared(event: ScreenEvent) { //TODO: send screen appeared event to your tagging library  } override fun trackEventOnScreenDisappeared(event: ScreenEvent) { //TODO: send screen disappeared event to your tagging library  } }  To make the Analytics feature work on your iOS project you just need to add a class that implements the Analytics protocol and pass an instance of this class to the Beagle Dependencies:\nimport BeagleUI class SampleAnalytics: Analytics { func trackEventOnScreenAppeared(_ event: AnalyticsScreen) { //TODO: send screen appeared event to your tagging library  } func trackEventOnScreenDisappeared(_ event: AnalyticsScreen) { //TODO: send screen disappeared event to your tagging library  } func trackEventOnClick(_ event: AnalyticsClick) { //TODO: send click event to your tagging library  } } Transfer the Analytics implementation to the Beagle Dependencies:\nlet dependencies = BeagleDependencies() dependencies.analytics = SampleAnalytics() Beagle.dependencies = dependencies  To make the Analytics feature work on your Web project, you must create a handler to the click and screen event, see the example below:\nimport { ClickEvent, ScreenEvent } from '@zup-it/beagle-web/types' const analyticsHandler = { trackEventOnClick: (event: ClickEvent) =\u003e { //handle click event }, trackEventOnScreenAppeared: (event: ScreenEvent) =\u003e { //handle screen appeared event }, trackEventOnScreenDisappeared: (event: ScreenEvent) =\u003e { //handle screen disappeared event } } Now, add the analytics property on the configuration files of the framework’s library you are using:\nAngular: open the beagle.module.ts file and alter just like the example below:\n@BeagleModule({ ... analytics: analyticsHandler }) React: open the library configuration file and follow the example:\nexport default createBeagleUIService\u003cany\u003e({ ... analytics: analyticsHandler })  The tagging feature was at first added to only some components and mostly used behaviors. Below we listed and described those behaviors and provided some samples:‌\nClick option For tagging the click event of an Widget, it was added to the Button and Touchable Widgets the property clickAnalyticsEvent with the following attributes:\n Category: This variable specifies the type of object that had some interaction with. It is a required attribute. Label: allows you to provide more context about the interaction. It is an optional attribute. Value: the value of an event. It is an optional attribute.  See below a click event of a tagged Button example:\nBACKEND - BFF ANDROID IOS { \"_beagleType_\": \"beagle:component:button\", \"text\": \"Test\", \"clickAnalyticsEvent\": { \"category\": \"Category\", \"label\": \"Label\", \"value\": \"Value\" } }  Button( text = \"Test\", clickAnalyticsEvent = ClickEvent( category = \"Category\", label = \"Label\", value = \"value\" ) )  Button( text: \"Test\", clickAnalyticsEvent: .init( category: \"Category\", label: \"Label\", value: \"Value\" ) )  ‌ScreenView option if you want to tag a screen appearing and disappearing, it is necessary to add a component with the property screenAnalyticsEvent with the following attributes:\n ScreenName: the name of the screen that will appear.  See below the ScreenView event example, with the tagged screen:\nBACKEND - BFF ANDROID IOS { \"_beagleType_\": \"beagle:component:screencomponent\", \"child\": { \"_beagleType_\": \"beagle:component:button\", \"text\": \"Test\" }, \"screenAnalyticsEvent\": { \"screenName\": \"ScreenName\" } }  Screen( child = Button(\"test\"), screenAnalyticsEvent = ScreenEvent( screenName = \"ScreenName\" ) )  Screen( child: Button(text: \"Test\"), screenAnalyticsEvent: : .init( screenName: \"ScreenName\" ) )  ","excerpt":" Analytics As most projects use some sort of tagging to gather data …","ref":"/docs-beagle/docs/api/analytics/","title":"Analytics"},{"body":" O que é? Remove a pilha de exibição atual.\nComo usar? Para usá-lo basta chamar o PopStack() sem necessidade de nenhum parâmetro.\nNo exemplo abaixo, temos uma tela vinda do BFF com um botão que ao clicar nele, fecha a activity atual.\nPara testar, basta que um endpoint do seu BFF retorne a tela do código abaixo, e chamar esse endpoint no Frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popStack\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PopStack() ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é? Remove a pilha de exibição atual.\nComo usar? Para usá-lo …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/popstack/","title":"Popstack"},{"body":" ServenDrivenComponent is the father of all Beagle’s components, such as widgets, forms e navigation, they will be implemented throughServerDrivenComponent.\nAny visual component is required to extend a specific class to work on Beagle. Some of these components are already implemented like Button, Text and Image.\nYou can have other visual component as well, and you are able to create customized components that will have to extend the widget class, according to your platform (Android or iOS).\nBeagle has 21 components, they are currently divided into 5 categories:\nLayout Navigation Forms Lazy UI  Container List View PageView ScrollView    Touchable    Validator Simple Form Input    LazyComponent    Button Image Tab View Text Web View   ","excerpt":" ServenDrivenComponent is the father of all Beagle’s components, such …","ref":"/docs-beagle/docs/api/components/","title":"Components"},{"body":" O que é? Remove a tela de exibição atual.\nComo usar? Para remover a tela atual basta chamar o método PopView() sem a necessidade de passar nenhum parâmetro. No exemplo abaixo, temos uma tela vinda do BFF com um botão, que ao clicar nele, remove a view atual.\nPara testar, basta que um endpoint do seu BFF retorne a tela do código abaixo e chame esse endpoint no frontend.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popView\" } ] } }  Screen( child = Button( text = \"Click me!\", onPress = listOf( Navigate.PopView() ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é? Remove a tela de exibição atual.\nComo usar? Para remover a …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/popview/","title":"Popview"},{"body":" O que é?  Retorna para uma tela específica e limpa a navegação que foi gerada a partir dessa tela.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     route ​String ✓ Rota de alguma tela que está na pilha.    Como usar? No exemplo abaixo, foram utilizadas três tela: as duas primeiras utilizam o PushView para adicionar as telas na pilha, já a última faz uso do PopToView para retornar para a primeira.\nPara testar, iremos precisar de três endpoints:\n O primeiro endpoint será o que seu frontend irá chamar para renderizar a tela zero. O segundo endpoint deverá ser mapeado como \"/firstScreen\", pois essa será URL escolhida para a navegação do botão da tela 0 e, por isso, esse endpoint deverá retornar a tela 1. O terceiro endpoint deverá ser mapeado como \"/secondScreen\", pois essa será a URL escolhida para a navegação do botão da tela 1 e, por isso, esse endpoint deverá retornar a tela 2. É pela tela 2 que passa a rota na qual deve ser o endpoint da tela que você deseja retornar. No caso desse exemplo, é a \"/home\" que é o endpoint da tela zero.  Como chamar pela tela zero JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  Como chamar a Tela 1 JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  Como chamar a Tela 2 JSON  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to first screen\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:popToView\", \"route\" : \"/home\" } ] } ] } }  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é?  Retorna para uma tela específica e limpa a navegação que …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/poptoview/","title":"Poptoview"},{"body":" Beagle has some components (UI) already ready to facilitate the process of developing an application, it is not necessary to create a customized component whenever using a component. UI Components are a group of building blocks used to build user interfaces or mobile user-focused interfaces.\nWe can also call them Widgets\nThis category has 6 widgets:\n","excerpt":" Beagle has some components (UI) already ready to facilitate the …","ref":"/docs-beagle/docs/api/components/ui/","title":"UI"},{"body":" What is it? The button widget is responsible for defining a native button using a server-driven button through Beagle.\nCheck the example below to see how the structure works:\n   Attribute  Type  Required Definition      text String or\nBinding\u003cb\u003e\u003c/b\u003e\n ✓ \nDefines the button text and what it must be declared and it cannot be null.\n   styleId String or\n\u003cb\u003e\u003c/b\u003eBinding\u003cb\u003e\u003c/b\u003e\n  It refers to a native style to be applied in the button. This attribute is optional, meaning if it is not informed it will be used the style pattern of your application.   onPress List \u003cAction\u003e  Possible array actions that this button will go off when clicked. It is possible to adapt this action to be customized or an extension of any action already available in your interface. This attribute is optional, but if an action it is defined here, it must be configured in the frontend. To create an action in the frontend, see the example here.   clickAnalyticsEvent \u003cb\u003e\u003c/b\u003eClickEvent\u003cb\u003e\u003c/b\u003e  Click event that will go off in case an analytics service has been implemented. Check here fore more information about analytics.\u003cb\u003e\u003c/b\u003e    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Beagle Button\", \"styleId\" : \"DesignSystem.MyNativeStyle\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"Example button.\" } ] }  Button( text = \"Click me!\" styleId = \"DesignSystem.MyNativeStyle\", onPress = listOf(Alert(message=\"Example button.\")) )  👉 Try it in the Web Playground ","excerpt":" What is it? The button widget is responsible for defining a native …","ref":"/docs-beagle/docs/api/components/ui/button/","title":"Button"},{"body":" O que é?  Abre uma tela com a rota informada e apaga todas as pilhas de navegação.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     route ​Route​ ✓ Rota de navegação.    Como usar? No exemplo abaixo, foram utilizadas três telas: as duas primeiras utilizam o PushView para adicionar as telas na pilha, já a última faz uso do ResetApplication e reabre na primeira tela.\nPara testar, iremos precisar de três endpoints:\n  O primeiro endpoint será o que seu frontend irá chamar para renderizar a tela zero.\n  O segundo endpoint deverá ser mapeado como \"/firstScreen\", pois será essa a URL escolhida para a navegação do botão da tela zero e, por isso, esse endpoint deverá retornar a tela 1.\n  O terceiro endpoint deverá ser mapeado como \"/secondScreen\", pois será essa a URL escolhida\npara a navegação do botão da tela 1 e, por isso, esse endpoint deverá retornar a tela 2. Na tela 2, a rota passada deve ser o endpoint da tela que você deseja retornar quando a aplicação for reiniciada. No caso desse exemplo, é a \"/home\" que é o endpoint da tela zero.\n  Como chamar a tela zero JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  Como chamar a Tela 1 JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  Como chamar a Tela 2 JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to reset application\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:resetApplication\", \"route\" : { \"url\" : \"/home\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to reset application\", onPress = listOf( Navigate.ResetApplication( route = Route.Remote(\"/home\") ) ) ) ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é?  Abre uma tela com a rota informada e apaga todas as pilhas …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/resetapplication/","title":"Resetapplication"},{"body":" What is it? The Image widget defines a native image using server-driven data received through Beagle.\nYour structure is represented by the attributes below:\n   Attribute Type Required Definition     path ImagePath or Binding ✓ Refers to a local image or URL of a remote image to be exhibited.   mode ImageContentMode  Responsible to control how the image will be internally controlled.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", { \"_beagleImagePath_\": \"remote\", \"url\": \"/imagePath.png\", \"placeholder\": \"imagePath\" } }, \"mode\": \"CENTER\" }  Image( path = ImagePath.Remote( url = \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", placeholder = ImagePath.Local(mobileId = \"imagePath\", webUrl = \"/imagePath.png\") ), mode = ImageContentMode.CENTER )  👉 Test this example in the Web Playground ","excerpt":" What is it? The Image widget defines a native image using …","ref":"/docs-beagle/docs/api/components/ui/image/","title":"Image"},{"body":" O que é?  Abre uma tela com a rota informada de um novo fluxo e limpa a pilha de telas carregadas anteriormente.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     route ​Route​ ✓ Rota de navegação.    Como usar? No exemplo abaixo, foram utilizadas três telas: as duas primeiras utilizam o PushView para adicionar as telas na pilha, já a última faz uso do ResetStack e reabre na primeira tela.\nPara testar, iremos precisar de três endpoints:\n  O primeiro endpoint será o que seu frontend irá chamar para renderizar a tela zero.\n  O segundo endpoint deverá ser mapeado como \"/firstScreen\", pois será essa a URL escolhida para a navegação do botão da tela zero e, por isso, esse endpoint deverá retornar a tela 1.\n  O terceiro endpoint deverá ser mapeado como \"/secondScreen\", pois será essa a URL escolhida\npara a navegação do botão da tela 1 e, por isso, esse endpoint deverá retornar a tela 2. Na tela 2, a rota passada deve ser o endpoint da tela que você deseja retornar quando a aplicação for reiniciada. No caso desse exemplo, é a \"/home\" que é o endpoint da tela zero.\n  Como chamar a tela zero JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"First Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/firstScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"First Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/firstScreen\" ) ) ) ) ) ) )  Como chamar a Tela 1 JSON KotlinDSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Second Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me!\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:pushView\", \"route\" : { \"url\" : \"/secondScreen\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Second Screen on Stack\" ), Button( text = \"Click me!\", onPress = listOf( Navigate.PushView( Route.Remote( url = \"/secondScreen\" ) ) ) ) ) ) )  Como chamar a Tela 2 JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Third Screen on Stack\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click me to go to reset stack\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:resetStack\", \"route\" : { \"url\" : \"/home\", \"shouldPrefetch\" : false } } ] } ] } }  Screen( child = Container( children = listOf( Text( \"Third Screen on Stack\" ), Button( text = \"Click me to reset stack\", onPress = listOf( Navigate.ResetStack( route = Route.Remote(\"/home\") ) ) ) ) ) )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é?  Abre uma tela com a rota informada de um novo fluxo e limpa …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/resetstack/","title":"Resetstack"},{"body":" It’s an ENUM class responsible to define how the stated image will be visualized on UI.\nKotlin DSL  enum class ImageContentMode { FIT_XY, FIT_CENTER, CENTER_CROP, CENTER }  It can be configured as FIT_XY, FIT_CENTER, CENTER_CROP and CENTER:\n FIT_XY: Considers the X and Y scale so the original image matches to the predicted dimensions for the UI visualization. It can change the image proportion. FIT_CENTER: Considers a computed scale that will keep the image’s original proportion and also guarantees that it entirely fits on the UI’s space. At least two axes (X or Y) will serve. The result is centralized on the image’s local. CENTER_CROP: Considers an uniform scale (keeping the image’s proportion) so both image’s dimensions (width and height) will be equal or bigger than the dimension correspondent to UI’s view. CENTER: center image that will be visualized, but not redimensioned.  ","excerpt":" It’s an ENUM class responsible to define how the stated image will be …","ref":"/docs-beagle/docs/api/components/ui/image/imagecontentmode/","title":"Imagecontentmode"},{"body":" Route define como a navegação deve ser carregada.\nAbaixo, você encontra a descrição completa dos tipos de Rota disponível por padrão no Beagle:\n","excerpt":" Route define como a navegação deve ser carregada.\nAbaixo, você …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/route/","title":"Route"},{"body":" What is it? The ImagePath allows you to define how the image will be loaded, which can be locally or remotely.\nHow to use it? ImagePath.Local It will reference a image that is on locais.JSONKotlin DSL assets. Your structure is represented by the attributes below:\n   Attribute Type Definition     webUrl String Absolute or relative image path to be downloaded.   mobileId String Image’s identifier that was previously registered on mobile platforms.    It will refer an image that it is already in the local assets.\nJSON Kotlin DSL \"_beagleImagePath_\": \"local\", \"url\": \"/imagemlocal.png\", \"mobileId\": \"imagemlocal\" }  ImagePath.Local( webUrl = \"/imagePath.png\", mobileId = \"imagePath\" )  ImagePath.Remote It will reference an image that its hosted on another host or it’s related to its own server.JSONKotlin DSL. Your structure is represented by the attributes below:\n   Attribute Type Required Definition     remoteUrl String ✓ Absolute or relative image path to be downloaded.   placeholder ​ImagePath.Local​  It’s possible to pass a local asset on the app that will be shown meanwhile the remote URL is loaded.    It will refer to an image that is hosted in another host or a relative one in the own server.\nJSON Kotlin DSL \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", \"placeholder\": { \"_beagleImagePath_\": \"local\", \"url\": \"/imagemlocal.png\", \"mobileId\": \"imagemlocal\" } }  ImagePath.Remote( remoteUrl = \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", placeHolder = ImagePath.Local( webUrl = \"/imagePath.png\", mobileId = \"imagePath\" ) )  ","excerpt":" What is it? The ImagePath allows you to define how the image will be …","ref":"/docs-beagle/docs/api/components/ui/image/imagepath/","title":"Imagepath"},{"body":" O que é?  Uma rota de navegação para um conteúdo remoto.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo  Tipo  Obrigatório Definição      url String ou\nBinding\u003cb\u003e\u003c/b\u003e\n ✓ Endereço para navegação.   shouldPrefetch Boolean  Carregar o endereço previamente.   fallback Screen   Tela a ser retornada caso o carregamento falhe.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushView\", \"route\": { \"url\": \"/present/view\", \"shouldPrefetch\": false } } ] }  Button( onPress = listOf( Navigate.PushView( Route.Remote(\"/present/view\") ) ), text = \"Click me!\" )  👉 Teste essa ação no Web Playground ","excerpt":" O que é?  Uma rota de navegação para um conteúdo remoto.\nA sua …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/route/remote/","title":"Remote"},{"body":" O que é?  Rota de navegação para conteúdo local.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     screen Screen ✓ Tela a ser carregada    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Click me!\", \"onPress\": [ { \"_beagleAction_\": \"beagle:pushView\", \"route\": { \"screen\": { \"_beagleComponent_\": \"beagle:screenComponent\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Hello Screen from Navigate\" } } } } ] }  Button( onPress = listOf( Navigate.PushView( Route.Local( Screen( child = Text(\"Hello Screen from Navigate\") ) ) )), text = \"Click me!\" )  👉 Teste essa ação no Web Playground ","excerpt":" O que é?  Rota de navegação para conteúdo local.\nA sua estrutura é …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/navigate/route/local/","title":"Local"},{"body":" What is it? The Tab Bar component is responsible for defining a table that allows navigation between views. It displays tabs corresponding to different views that can be accessed through it.\nThe structure is represented as shown below:\n   Attribute Type Required Definition     items TabBarItem ✓ Receive a list of TabBarItems that will define the Tabs in the TabBar   styleId String  Style ID that identifies an style to be applied on the TabBar   currentTab Bind\u003cInt\u003e  Integer number that identifies that selected TabBarItem``   onTabSelection List\u003cAction\u003e  List of Actions that are performed when a TabBarItem is selected. It can be used to load views according to the selected TabBarItem.    What is Tab Bar Item? This component represents the TabBarItem presented on a Tab Bar.\n   Attributes Type Required Definition     title String  Displays the text in the Tab Bar item Title. If it is not declared or if it is set to null, it will not appear on the screen. The tab wont be displayed.   icon Path  Displays a local image as an icon in the Tab Bar Item. If it is not declared or is set to null, it will not appear on the screen.    If a title or icon is not declared in the TabBarItem, the empty space will remain. If you need navigation between viewers without the Tab interface, it is recommended that you use the navigation components  How to use it? On the following example, it will be used two componentes to explain TabBar: PageView and Context.\nPage View is used to render the pages you want to display, that is, it will create the view on each selected tab. This is where you will define the components you want to display by clicking on each tab.\nThe components will be rendered according to their position in the list of componentes defined at the Page View Component.It means that, if we have 2 text components in our list, TAB 1 and TAB 2. The first has a position of ZERO = 0, and the second has ONE = 1. The currentTab attribute is the one that defines which component is displayed according to the value defined in it.\nThe Context is used to save the indicator (position) of the selected tab, and inform it to PageView, which coordinates which element will be displayed.\nExample JSON kotlin DSL { \"_beagleComponent_\": \"beagle:screenComponent\", \"child\": { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:tabBar\", \"items\": [ {\"title\": \"Tab 1\"}, {\"title\": \"Tab 2\"} ], \"styleId\": \"TabBarStyle\", \"onTabSelection\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"contestTabId\", \"value\": \"@{onTabSelection}\" } ] }, { \"_beagleComponent_\": \"beagle:pageView\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Tab 1\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Tab 2\" } ], \"currentPage\": \"@{contestTabid}\" } ], \"context\": { \"id\": \"contestTabid\", \"value\": 0 } } }  Screen( child = Container( context = ContextData(\"contestTabid\", 0), children = listOf( TabBar( onTabSelection = listOf( SetContext( \"contestTabId\", \"@{onTabSelection}\" ) ), items = listOf( TabBarItem(\"Tab 1\"), TabBarItem(\"Tab 2\") ), styleId = \"TabBarStyle\" ), PageView( currentPage = expressionOf(\"@{contestTabid}\"), children = listOf( Text( \"Tab 1\" ), Text( \"Tab 2\" ) ) ) ) ) )     Tab Bar         👉 Test this component on the Web Playground This example does not exist on the playground, but you can copy and paste the JSON code above and test it on the playground. The section bellow contains more information about this example  ","excerpt":" What is it? The Tab Bar component is responsible for defining a table …","ref":"/docs-beagle/docs/api/components/ui/tabbar/","title":"Tabbar"},{"body":" This component was deprecated in Beagle version 1.1.0 and will be removed in a future version. Use TabBar instead.  What is TabView? A TabView is a component used to navigate between views that are listed in a tab. It displays all tabs that correspond to different previews that can be accessed through it.\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     children List\u003cTabItem\u003e ✓ List of tab items available in the TabView component. The TabItem itself is not a widget, but its content is a server driven component received through Beagle.   styleId String  It uses a key that it is registered in the Design System of evert platform to customize your component.   context ContextData  Add a context to your TabView component.    What is TabItem? TabView components items that have this structure:\n   Attribute Type Required Definition     title String  Displays the text in a TabView item. If it is not declared or if it is configured with the null value, it will not be shown on the screen.   icon Path  Displays a local image as an icon in the TabView item. If it is not declared or if it is configured with the null value, it will not be shown on the screen.   child Component ✓ Defines which view will be inflated in the TabItem, according to the tab clicked. Any server-driven component can be a Tab View item.    If you don’t declare the title and the icon on the TabItem, the empty space will remain. If you need a navigation between viewers without Tab interface, it is recommended that you use the navigation component.  How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:tabview\", \"children\": [ { \"title\": \"Tab 1\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\":\"First Tab Content\" } }, { \"title\": \"Tab 2\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\":\"Second Tab Content\" } } ] } ] }  Screen( child = Container( children = listOf( TabView(children = listOf( TabItem(\"Tab 1\", Image(ImagePath.Remote(\"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\") ) ), TabItem(\"Tab 2\", Image(ImagePath.Remote(\"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\") ) ) ) ) ) ) )     TabView full screen TabView with dividing screen          👉 Test this component in the Web Playground ","excerpt":" This component was deprecated in Beagle version 1.1.0 and will be …","ref":"/docs-beagle/docs/api/components/ui/tabview/","title":"Tabview"},{"body":" O que é? A classe sendRequest é responsável por tratar requisições HTTP\nA estrutura do Send Request é:\n   Atributo Tipo Obrigatório Definição     url String ou Binding ✓ URL do servidor.   method RequestActionMethod ou Binding ✓ Método HTTP.   headers Map \u003cString, String\u003e ou Binding  Itens do header para a requisição.   data Any  Conteúdo a ser enviado junto a requisição.   onSuccess List\u003cAction\u003e  Ação tratativa de sucesso.   onError List\u003cAction\u003e  Ação tratativa de erro.   onFinish List\u003cAction\u003e  Ação tratativa de finalização.    Como usar? Segue abaixo um exemplo de botão que faz uma requisição do tipo POST enviando dados de um usuário:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Send Request Example\", \"onPress\": [ { \"beagleAction\":\"beagle:sendRequest\", \"url\":\"https://myUrl.com/endpoint\"\", \"method\":\"POST\", \"headers\":{ \"Content-Type\":\"application/json\" }, \"data\":{ \"email\":\"john@email.com\", \"password\":\"password\", \"confirmPassword\":\"password\", \"name\":\"John\" }, \"onSuccess\":[ { \"beagleAction\":\"beagle:alert\", \"title\":\"SUCCESS\", \"message\":\"Success\" } ], \"onError\":[ { \"beagleAction\":\"beagle:alert\", \"title\":\"ERROR\", \"message\":\"Error\" } ], \"onFinish\":[ { \"beagleAction\":\"beagle:alert\", \"title\": \"FINISH\", \"message\":\"Finish\" } ] } ] } ] }  Button( text = \"Send a request\", styleId = \"DesignSystem.MyNativeButtonStyle\", onPress = listOf( SendRequest( url = https://myUrl.com/endpoint\", method = RequestActionMethod.POST, data = User( name = \"John\", email = \"jonh@email.com\", password = \"password\", confirmPassword = \"password\" ), headers = mapOf( \"Content-Type\" to \"application/json\" ), onSuccess = listOf( Alert( title = \"SUCCESS\", message = \"Success\" ) ), onError = listOf( Alert( title = \"ERROR\", message = \"Error\" ) ), onFinish = listOf( Alert( title = \"FINISH\", message = \"Finish\" ) ) ) ) )  👉 Teste essa ação no Web Playground ","excerpt":" O que é? A classe sendRequest é responsável por tratar requisições …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/sendrequest/","title":"Sendrequest"},{"body":" What is it? Text component defines the native text using the server driven information.\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     text String or Binding ✓ Defines the content in text to be rendered.   styleId String  Refers to a locally configured style that it will be applied on the text.   textColor String  Defines the text color.   alignment TextAlignment  Define the alignment of the text.    TextAlignment    Attributes Definition     LEFT Content align to the left in the text viewer.   CENTER Content align in the center in the text viewer.   RIGHT Content align to the right in the text viewer.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Hello World!\" }  Text(text = \"Hello World!\")  👉 Test this component in the Web Playground ","excerpt":" What is it? Text component defines the native text using the server …","ref":"/docs-beagle/docs/api/components/ui/text/","title":"Text"},{"body":" O que é? A ação SetContext é responsável por alterar o valor de um contexto.\nA estrutura do SetContext é:\n   Atributo Tipo Obrigatório Definição     contextId String ✓ Id do contexto   value Any ✓ Novo valor a ser aplicado no contexto   path String  Ponto específico do contexto para ser alterado no caso de arrays e mapas \u003cchave, valor\u003e.    Conheça mais sobre o contexto no Beagle.  Como usar? Abaixo temos um exemplo de um texto que é preenchido por contexto e possui um valor inicial “Set Context Example” e no evento de clique do botão o valor do contexto é alterado para “Context has changed”.\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"context\":{ \"id\": \"myContext\", \"value\":\"Set Context Example\" }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\":\"@{myContext}\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Open Modal\", \"onPress\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"myContext\", \"value\": \"Context has changed\" } ] } ] }  Container( children = listOf( Text(text = \"@{myContext}\"), Button( text = \"Open Modal\", onPress = listOf( SetContext( contextId = \"myContext\", value = \"Context has changed\" ) ) ) ), context = ContextData( id = \"myContext\", value = \"Set Context Example\" ) )  👉 Teste essa ação no Web Playground ","excerpt":" O que é? A ação SetContext é responsável por alterar o valor de um …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/setcontext/","title":"Setcontext"},{"body":" What is it? Input is a component that displays an editable text area for the user. These text fields are used to collect inputs that the user insert using the keyboard.\nSee how the structure is represented by the attributes below:\n   Attribute  Type  Required Definition      value String or\nBinding\u003cb\u003e\u003c/b\u003e\n ✓ Item referring to the input value that will be entered in the editable text area of the Text Input component.   placeholder String or\nBinding\u003cb\u003e\u003c/b\u003e\n  The Placeholder is a text that is displayed when nothing has been entered in the editable text field.   disabled Boolean  Enables or disables the field.   readOnly Boolean  Check if the Input will be editable or read only.   hidden Boolean  Enables the component to be visible or not.   type TextInputType or Binding\u003cb\u003e\u003c/b\u003e  This attribute identifies the text type that it will receive in the editable field area. On Android and iOS, this field also attributes the type of keyboard that will be shown to the user.   styleId String  This attribute receives a key that is registered in the Design System of each platform that customizes the component.   onChange List \u003cAction\u003e  Actions array that this field can trigger when its value is altered. It is possible to define a customized action or any available action in the interface, for example, an action that shows an Alert message. \nThis attribute is optional, but if an action is defined here it needs to be configured in the fronted.\n\n   onBlur List \u003cAction\u003e  Action array that this field can trigger when its focus is removed. It is possible to defined a customized action or any available action in the interface, for example, an action that shows an alert message (Alert).\n\nThis attribute is optional, but if an action is defined here it needs to be configured in the fronted.\n   onFocus List \u003cAction\u003e  Actions array that this field can trigger when this field is on focus. It is possible to defined a customized action or any available action in the interface, for example, an action that shows an alert message (Alert).  \u003cb\u003e\u003c/b\u003e\nThis attribute is optional, but if an action is defined here it needs to be configured in the fronted.\n    TextInputType It is an ENUM responsible to define which type of text input.\n   Type Definition     DATE Data input is a date.   EMAIL Data input is an email.   PASSWORD Data input is a password.   NUMBER Data input only with numbers.   TEXT Data input is a text.    How to use it? See below an example of text input with the password type:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"my value\", \"placeholder\": \"user@test.com.br\", \"type\": \"email\", \"onChange\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"Changing input\" } ] }  TextInput( value = \"my value\", placeholder = \"password\", type = TextInputType.PASSWORD, styleId = \"test.input.style\", onChange = listOf( Alert( message = \"Text value changed.\" ) ) )  👉 Teste this component on Web Playground The example on the link above is from a Form, that contains a text input. But you can select the example code above and copy and past it on the playground to see how it works.  ","excerpt":" What is it? Input is a component that displays an editable text area …","ref":"/docs-beagle/docs/api/components/ui/textinput/","title":"Textinput"},{"body":" O que é? O SubmitForm é uma ação exclusiva do SimpleForm, pois deve ser usada em algum evento dentro do formulário, para que o mesmo seja enviado.\nComo usar? Para um exemplo completo junto ao SimpleForm clique aqui\n","excerpt":" O que é? O SubmitForm é uma ação exclusiva do SimpleForm, pois deve …","ref":"/docs-beagle/pt/docs/api/a%C3%A7%C3%B5es/submitform/","title":"Submitform"},{"body":" What is it? This component defines a native web view and uses a server-driven information.\nThe structure is represented by the attributes below:\n   Attribute Type Required Definition     url String or Binding ✓ Defines the Web View home page that will load. It must be declared and it cannot have a null value.    When opening an insecure link (http): It is important to notice that this component will open ONLY secure links like https and it WON’T display any not-safe links like http.  How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:webView\", \"url\": \"https://maps.google.com/\" }  WebView(url: \"https://docs.usebeagle.io/\")  👉 Test this component in the Web Playground​ ","excerpt":" What is it? This component defines a native web view and uses a …","ref":"/docs-beagle/docs/api/components/ui/webview/","title":"Webview"},{"body":" Analytics Como a maioria dos projetos usam alguma forma de marcação/tags para agrupar dados sobre o comportamento do usuário, o Beagle oferece uma ajuda para você conseguir essas informações.\nÉ necessário configurar a sua plataforma para que o analytics funcione, segue abaixo os passos para a configuração:\nConfiguração  Selecione uma opção de cofiguração:  ANDROID IOS WEB Para que o Analytics funcione no seu projeto Android, você precisa adicionar uma classe que implemente a interface do Analytics. Anote essa classe com o @BeagleComponent.\n@BeagleComponent class SampleAnalytics: Analytics { override fun trackEventOnClick(event: ClickEvent) { //TODO: send click event to your tagging library  } override fun trackEventOnScreenAppeared(event: ScreenEvent) { //TODO: send screen appeared event to your tagging library  } override fun trackEventOnScreenDisappeared(event: ScreenEvent) { //TODO: send screen disappeared event to your tagging library  } }  Para que o Analytics funcione no seu projeto iOS, você precisa adicionar a classe que implemente o protocolo Analytics e passar a instanciá-la nas dependências do Beagle:\nimport BeagleUI class SampleAnalytics: Analytics { func trackEventOnScreenAppeared(_ event: AnalyticsScreen) { //TODO: send screen appeared event to your tagging library  } func trackEventOnScreenDisappeared(_ event: AnalyticsScreen) { //TODO: send screen disappeared event to your tagging library  } func trackEventOnClick(_ event: AnalyticsClick) { //TODO: send click event to your tagging library  } } passando a implementação de Analytics para o Beagle Dependencies:\nlet dependencies = BeagleDependencies() dependencies.analytics = SampleAnalytics() Beagle.dependencies = dependencies  Para que o Analytics funcione no seu projeto Web, você precisa criar um handler para os eventos de clique e screen:\nimport { ClickEvent, ScreenEvent } from '@zup-it/beagle-web/types' const analyticsHandler = { trackEventOnClick: (event: ClickEvent) =\u003e { //handle click event }, trackEventOnScreenAppeared: (event: ScreenEvent) =\u003e { //handle screen appeared event }, trackEventOnScreenDisappeared: (event: ScreenEvent) =\u003e { //handle screen disappeared event } } Agora basta adicionar a propriedade analytics nos arquivos de configuração da biblioteca dependendo do framework utilizado:\nPara Angular, abra o arquivo beagle.module.ts e altere como no exemplo:\n@BeagleModule({ ... analytics: analyticsHandler }) Para React, abra o arquivo de configuração da biblioteca e siga o exemplo:\nexport default createBeagleUIService\u003cany\u003e({ ... analytics: analyticsHandler })  A feature de marcação foi adicionada em apenas alguns componentes dos comportamentos mais usados. Segue abaixo a descrição e os exemplos:\nOpção Click Para marcação do click event de um widget, foi adicionado o botão e o Touchable Widgets da propriedade clickAnalyticsEvent com os seguintes atributos:\n Category: essa variável especifica o tipo de objeto com qual teve alguma interação. É um atributo obrigatório. Label: permite que você forneça mais contexto sobre a interação. É um atributo opcional. Value: o valor de um evento. É um atributo opcional.  Segue abaixo um exemplo de click event da marcação de um botão:\nBACKEND - BFF ANDROID IOS { \"_beagleType_\": \"beagle:component:button\", \"text\": \"Test\", \"clickAnalyticsEvent\": { \"category\": \"Category\", \"label\": \"Label\", \"value\": \"Value\" } }  Button( text = \"Test\", clickAnalyticsEvent = ClickEvent( category = \"Category\", label = \"Label\", value = \"value\" ) )  Button( text: \"Test\", clickAnalyticsEvent: .init( category: \"Category\", label: \"Label\", value: \"Value\" ) )  ‌Opção ScreenView Quando for marcar uma tela que aparece e desaparece, é preciso adicionar um componente com a propriedade screenAnalyticsEvent com o seguinte atributo:\n ScreenName: nome da tela que irá aparecer.  Segue abaixo um exemplo de evento de ScreenView com a tela marcada:\nBACKEND - BFF ANDROID IOS { \"_beagleType_\": \"beagle:component:screencomponent\", \"child\": { \"_beagleType_\": \"beagle:component:button\", \"text\": \"Test\" }, \"screenAnalyticsEvent\": { \"screenName\": \"ScreenName\" } }  Screen( child = Button(\"test\"), screenAnalyticsEvent = ScreenEvent( screenName = \"ScreenName\" ) )  Screen( child: Button(text: \"Test\"), screenAnalyticsEvent: : .init( screenName: \"ScreenName\" ) )  ","excerpt":" Analytics Como a maioria dos projetos usam alguma forma de …","ref":"/docs-beagle/pt/docs/api/analytics/","title":"Analytics"},{"body":" What is Touchable? Touchable defines clickable areas in your application in widgets that are not clickable by default.\nSee how the structure is represented:\n   Attribute  Type  Required Definition      onPress \u003cb\u003e\u003c/b\u003eAction\u003cb\u003e\u003c/b\u003e ✓ Defines one or more actions to be performed when a child component is clicked.\n\n   click\nAnalytics\nEvent\n \u003cb\u003e\u003c/b\u003eAnalytics\u003cb\u003e\u003c/b\u003e\n\u003cb\u003e\u003c/b\u003eClick\u003cb\u003e\u003c/b\u003e\n  Click event that will be triggered if an analytics service was implemented.   child \u003cb\u003e\u003c/b\u003eServer\u003cb\u003e\u003c/b\u003e\n\u003cb\u003e\u003c/b\u003eDrivenComponent\u003cb\u003e\u003c/b\u003e\n ✓ Defines a widget that will trigger the onPress attribute.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:touchable\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"This is a touchable!\" } ], \"child\": { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/KWwTSWB/1029209-200.png\" }, \"accessibility\": { \"accessibilityLabel\": \"Touchable image\", \"accessible\": true } } }  Touchable(onPress = listOf( Alert(title = \"Image\", message = \"Clicked on Message\")), child = Image(path = ImagePath.Local.justMobile(\"name\")) )  👉 Test this example in the Web Playground ","excerpt":" What is Touchable? Touchable defines clickable areas in your …","ref":"/docs-beagle/docs/api/components/touchable/","title":"Touchable"},{"body":" O ServerDrivenComponent é o pai de todos os componentes do Beagle. Componentes como widgets, formulários e navegação serão implementados por meio do ServerDrivenComponent.\nQualquer componente visual é obrigado a estender de uma classe específica para funcionar no Beagle. Alguns componentes visuais já são implementados pelo Beagle como por exemplo o Button, Text e Image.\nVocê pode ter outros componentes visuais também, e ainda pode criar componentes customizados que devem estender da classe widget de acordo com sua plataforma (Android ou iOS).\nO Beagle possui 14 componentes atualmente divididos em 5 categorias:\nLayout Formulários Lazy UI Touchable  Container List View PageView PageIndicator ScrollView    Validator Simple Form Text Input     Lazy    Button Image Tab Bar Tab View Text Web View    Touchable   ","excerpt":" O ServerDrivenComponent é o pai de todos os componentes do Beagle. …","ref":"/docs-beagle/pt/docs/api/componentes/","title":"Componentes"},{"body":" What is Lazy? The Lazy Component is used when a BFF asynchronous request is made.\nSee how the structure is represented:\n   Attribute Type Required Definition     path String ✓ URL that makes the request.   initialState ServerDrivenComponent ✓ Server-driven component that is showed when there is an asynchronous request being done.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:lazycomponent\", \"path\": \"/listview.json\", \"initialState\": { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Carregando conteúdo, aguarde...\" } }  LazyComponent( path = \"/listview.json\", initialState = Text(\"Carregando conteúdo, aguarde...\") )  👉 Test this component in the Web Playground ","excerpt":" What is Lazy? The Lazy Component is used when a BFF asynchronous …","ref":"/docs-beagle/docs/api/components/lazy/","title":"Lazy"},{"body":" O Beagle possui alguns componentes (UI) já prontos para facilitar o processo de desenvolvimento de uma aplicação, não sendo necessário criar um componente customizado sempre que for utilizar um componente. os Componentes de UI são um grupo de componentes básicos usados para construir as interfaces do usuário ou interfaces móveis com foco no usuário.\nTambém podemos chama-los de Widgets.\nEssa categoria possui 6 widgets:\n","excerpt":" O Beagle possui alguns componentes (UI) já prontos para facilitar o …","ref":"/docs-beagle/pt/docs/api/componentes/ui/","title":"UI"},{"body":" Layout component can be defined with a group of 7 subcomponents: Container, Horizontal, Page View, List View, Scroll View, Stack and Vertical.\nYou will find the description of every Layout attribute:\n","excerpt":" Layout component can be defined with a group of 7 subcomponents: …","ref":"/docs-beagle/docs/api/components/layout/","title":"Layout"},{"body":" O que é? O widget Button é responsável por definir um botão nativo usando informações server driven por meio do Beagle.\nA sua estrutura é representada como mostrado abaixo:\n   Atributos  Tipo  Obrigatório Definição      text String ou\nBinding  ✓ Texto no botão. Título do botão   styleId String ou\nBinding   Este atributo referencia um estilo nativo a ser aplicado no botão. Se não for informado, o estilo padrão de botão da sua aplicação será aplicado ao botão.   onPress List \u003cAction\u003e  Array de ações que esse botão pode disparar quando clicado. É possível definir uma Ação customizada ou qualquer ação já disponível na interface, como por exemplo uma ação que mostra uma mensagem de alerta(Alert). Este atributo é opcional, mas se uma ação for definida aqui ela precisa estar configurada no frontend. Para criar uma ação no frontend veja o exemplo: Criando uma ação customizada    clickAnalyticsEvent ClickEvent   Evento de clique que será disparado caso tenha sido implementado um serviço de analytics. Para saber mais sobre analytics e os eventos suportados, veja o exemplo: Analytics.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Faz um Alert\", \"styleId\" : \"DesignSystem.MeuEstiloDeBotãoNativo\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:alert\", \"message\" : \"Eu sou a mensagem de um Alerta\" } ] }  Button( text = \"Faz um Alert\", styleId = \"DesignSystem.MeuEstiloDeBotãoNativo\", onPress = listOf( Alert( message = \"Eu sou a mensagem de um Alerta\" ) ) )  👉 Teste esse componente no Web Playground ","excerpt":" O que é? O widget Button é responsável por definir um botão nativo …","ref":"/docs-beagle/pt/docs/api/componentes/ui/button/","title":"Button"},{"body":" What is it? Container is a component that contains other components inside it.\nSee how the structure is represented:\n   Attribute Type Required Definition     children List \u003cServerDriven Component\u003e ✓ Defines the component list that it is part of the container.   context ContextData  It is the context in this widget.   onInit List\u003cAction\u003e  It is a parameter that allows you to define a list of actions to be performed when the Widget is displayed.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"@{myContext.value}\" } ], \"context\": { \"id\": \"myContext\", \"value\": \"Hello world!\" } }  Container( children = listOf( Text(text = \"@{myContext.value}\") ), context = ContextData( id = \"myContext\", value = \"Hello World!\" ) )  👉 Test this component in the Web Playground ","excerpt":" What is it? Container is a component that contains other components …","ref":"/docs-beagle/docs/api/components/layout/container/","title":"Container"},{"body":" O que é? O widget de Imagem define uma imagem nativa usando informações server-driven recebidas por meio do Beagle.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     path ImagePath ou Binding ✓ Referência de uma imagem local ou url de uma imagem remota a ser exibida.   mode ImageContentMode  É responsável por controlar como a imagem será controlada internamente.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", { \"_beagleImagePath_\": \"remote\", \"url\": \"/imagePath.png\", \"placeholder\": \"imagePath\" } }, \"mode\": \"CENTER\" }  Image( path = ImagePath.Remote( url = \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", placeholder = ImagePath.Local(mobileId = \"imagePath\", webUrl = \"/imagePath.png\") ), mode = ImageContentMode.CENTER )  👉 Teste esse exemplo no Web Playground ","excerpt":" O que é? O widget de Imagem define uma imagem nativa usando …","ref":"/docs-beagle/pt/docs/api/componentes/ui/image/","title":"Image"},{"body":" What is it? The ListView component is responsible for defining a list of recyclable items natively. These items can be any server driven components. The use of ListView is recommended for situations where there is repetition of components, but with different data.\nFrom version 1.5.0, we started to support the use of context and cell recycling in ListView, with that we provide two ways to build the component. The depreciated version was maintained only to keep backward compatibility, upgrade to the new version of the component if possible for better performance.  See how the structure is represented:\nListView    Atributo Tipo Obrigatório Definição     direction ListDirection  Sets the direction in which list items are displayed.   context ContextData  Defines the context of the component.   onInit List\u003cAction\u003e  List of actions to be performed as soon as the component is displayed.   dataSource Bind\u003cList\u003cAny\u003e\u003e ✓ Expression that points to a list of values used to populate the component.   template ServerDrivenComponent ✓ It represents each cell in the list through a ServerDrivenComponent.   onScrollEnd List\u003cAction\u003e  List of actions taken when the list ends.   scrollEndThreshold Int  Defines the percentage scrolled from the list to trigger onScrollEnd.   iteratorName String  It is the context identifier for each cell.   key String  Points to a unique value present in each item of the dataSource to be used as a suffix in the ids of the template components.    ListDirection It is an ENUM, the values are:\n   Values Definition     VERTICAL When itens are displayed in LINES.   HORIZONTAL When itens are displayed in COLUMNS.    Default value is ListDirection.VERTICAL  Deprecated ListView    Attribute Type Required Descriptioon     children List\u003cServerDrivenComponent\u003e ✓ \nDefines the item list view. They can be configured like a ServerDrivenComponents or like views.    direction \u003cb\u003e\u003c/b\u003eListDirection\u003cb\u003e\u003c/b\u003e  Defines the preview list direction.    How to use it? ListView JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:listView\", \"direction\": \"VERTICAL\", \"dataSource\": [ { \"name\": \"Kelsier\", \"race\": \"Half-skaa\", \"planet\": \"Scadrial\", \"isMistborn\": true, \"age\": 38, \"sex\": \"male\" }, { \"name\": \"Vin\", \"race\": \"Half-skaa\", \"planet\": \"Scadrial\", \"isMistborn\": true, \"age\": 20, \"sex\": \"female\" }, { \"name\": \"TenSoon\", \"race\": \"Kandra\", \"planet\": \"Scadrial\", \"isMistborn\": false, \"age\": 40, \"sex\": \"male\" } ], \"template\": { \"_beagleComponent_\": \"beagle:container\", \"style\": { \"margin\": { \"bottom\": { \"value\": 20, \"type\": \"REAL\" } } }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Name: @{item.name}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Race: @{item.race}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Mistborn: @{item.isMistborn}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Planet: @{item.planet}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"sex: @{item.sex}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"age: @{item.age}\" } ] } }  ListView( dataSource = listOf( Person( name = \"Kelsier\", race = \"Half-skaa\", planet = \"Scadrial\", isMistborn = true, age = 38, sex = Sex.MALE ), Person( name = \"Vin\", race = \"Half-skaa\", planet = \"Scadrial\", isMistborn = true, age = 20, sex = Sex.FEMALE ), Person( name = \"TenSoon\", race = \"Kandra\", planet = \"Scadrial\", isMistborn = false, age = 40, sex = Sex.MALE ), ), template = Container( children = listOf( Text(\"Name: @{item.name}\"), Text(\"Race: @{item.race}\"), Text(\"Mistborn: @{item.isMistborn}\"), Text(\"Planet: @{item.planet}\"), Text(\"sex: @{item.sex}\"), Text(\"age: @{item.age}\"), ) ).applyStyle( Style( margin = EdgeValue(bottom = 20.unitReal()) ) ) )  👉 Test the ListView in the Web Playground​ Deprecated ListView JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:listView\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#FF0000\", \"alignment\": \"CENTER\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#00FF00\", \"alignment\": \"CENTER\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#0000FF\", \"alignment\": \"CENTER\" } ], \"direction\": \"HORIZONTAL\" }  ListView( direction = ListDirection.HORIZONTAL, children = listOf( Text( text = \"Beagle Text list\", textColor = \"#FF0000\", alignment = TextAlignment.CENTER ), Text( text = \"Beagle Text list\", textColor = \"#00FF00\", alignment = TextAlignment.CENTER ), Text( text = \"Beagle Text list\", textColor = \"#0000FF\", alignment = TextAlignment.CENTER ) ) )  👉 Test the Deprecated ListView in the Web Playground​ ","excerpt":" What is it? The ListView component is responsible for defining a list …","ref":"/docs-beagle/docs/api/components/layout/listview/","title":"Listview"},{"body":" É uma classe ENUM responsável por definir como a imagem declarada será visualizada na UI.\nKotlin DSL  enum class ImageContentMode { FIT_XY, FIT_CENTER, CENTER_CROP, CENTER }  Ele pode ser configurado como FIT_XY, FIT_CENTER, CENTER_CROP e CENTER:\n FIT_XY: Considera a escala X e Y de forma que a imagem de origem dê match com as dimensões previstas para visualização no UI. Isso pode alterar a proporção da imagem. FIT_CENTER: Considera a escala computada que irá manter a proporção original da imagem e ainda garantir que ela encaixe inteiramente no espaço destinado no UI. Pelo menos um dos eixos (X ou Y) irá servir. O resultado é centralizado já no local da imagem. CENTER_CROP: Considera a escala uniforme (mantendo a proporção da imagem) de forma que ambas as dimensões (largura e altura) da imagem que será igual ou maior à dimensão correspondente na visualização no UI. CENTER: imagem de centro que pode ser visualizada, mas não redimensionada.  ","excerpt":" É uma classe ENUM responsável por definir como a imagem declarada …","ref":"/docs-beagle/pt/docs/api/componentes/ui/image/imagecontentmode/","title":"Imagecontentmode"},{"body":" What is it? PageView component is a container that present pages that it will be horizontally displayed. They can be any server driven object.\nO Page View refers to its view size on mobile devices (Android or iOS). The page view size is determined by the father that it is in, meaning that, the width and the height will be defined by the component father.\nFor example, a Page View can be declared inside of a Container and the width and the height will define the page view size.\n See how the structure is represented:\n   Attribute Type Required Definition     children List\u003cServerDrivenComponent\u003e ✓ \nDefines the visual components list (server-driven) in the PageView.\n   context ContextData\u003cb\u003e\u003c/b\u003e  It is the context contained by this Widget.   onPageChange List\u003cAction\u003e  Action list that runs when the selected page is altered.   currentPage Int  Identifier where the page is seletected.   showArrow Boolean  This attribute is specific for the web platform. It enables arrows to change pages.    How to use it? On the example below you will see a PageView that contains three pages where each one of them has a Text defined by the Context. Every time there is a change the context page is redefined:\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:pageView\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 1\", \"alignment\":\"CENTER\" }, { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 2\", \"alignment\":\"CENTER\" }, { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 3\", \"alignment\":\"CENTER\" } ], \"onPageChange\":[ { \"_beagleAction_\":\"beagle:setContext\", \"contextId\":\"context\", \"value\":\"@{onPageChange}\" } ], \"currentPage\":\"@{context}\" }, { \"_beagleComponent_\":\"beagle:pageIndicator\", \"selectedColor\":\"#000000\", \"unselectedColor\":\"#888888\", \"numberOfPages\":3, \"currentPage\":\"@{context}\" } ], \"context\":{ \"id\":\"context\", \"value\":0 } }  Container( children = listOf( PageView( children = (1..3).map { Text( text = \"Page $it\", alignment = TextAlignment.CENTER ) }, onPageChange = listOf(SetContext(\"context\", \"@{onPageChange}\")), currentPage = expressionOf(\"@{context}\") ), PageIndicator( numberOfPages = 3, selectedColor = BLACK, unselectedColor = LIGHT_GREY, currentPage = expressionOf(\"@{context}\") ) ), context = ContextData( id = \"context\", value = 0 ) )  👉 Test this component in the Web Playground ","excerpt":" What is it? PageView component is a container that present pages that …","ref":"/docs-beagle/docs/api/components/layout/pageview/","title":"Pageview"},{"body":" O que é? O ImagePath permite que você defina como uma imagem será carregada, podendo ser local ou remote.\nComo usar? ImagePath.Local A sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Definição     webUrl String Caminho absoluto ou relativo da imagem a ser baixada.   mobileId String Identificador da imagem que foi previamente cadastrada nas plataformas mobile.    Irá referenciar uma imagem que já está nos assets locais.\nJSON Kotlin DSL { \"_beagleImagePath_\": \"local\", \"url\": \"/imagemlocal.png\", \"mobileId\": \"imagemlocal\" }  ImagePath.Local( webUrl = \"/imagePath.png\", mobileId = \"imagePath\" )  ImagePath.Remote A sua estrutura é representada como mostrado abaixo:\n   Atributos Tipo Obrigatório Definição     remoteUrl String ✓ Caminho absoluto ou relativo da imagem a ser baixada.   placeholder ImagePath.Local  É possível passar um asset local no aplicativo que será mostrado enquanto a URL remota é carregada.    Irá referenciar uma imagem que esteja hospedada em outro host ou relativo no próprio server.\nJSON Kotlin DSL { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", \"placeholder\": { \"_beagleImagePath_\": \"local\", \"url\": \"/imagemlocal.png\", \"mobileId\": \"imagemlocal\" } }  ImagePath.Remote( remoteUrl = \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\", placeHolder = ImagePath.Local( webUrl = \"/imagePath.png\", mobileId = \"imagePath\" ) )  ","excerpt":" O que é? O ImagePath permite que você defina como uma imagem será …","ref":"/docs-beagle/pt/docs/api/componentes/ui/image/imagepath/","title":"Imagepath"},{"body":" What is it? PageIndicatorComponent is a component that indicates the amount of pages and which one is the current PageView.\n   Attribute Type Required Definition     selectedColor String ✓ Hexadecimal value to represent the color when selected.   unselectedColor String ✓ Hexadecimal value to represent the color when it is not selected.   numberOfPages Int  Indicates the amount of pages.   currentPage Bind\u003cInt\u003e  Indicates the page.    How to use it? An example on how to use PageIndicator can be foun on PageView.\n👉 Test this component in the Web Playground​ ``\n","excerpt":" What is it? PageIndicatorComponent is a component that indicates the …","ref":"/docs-beagle/docs/api/components/layout/pageindicator/","title":"Pageindicator"},{"body":" What is it? Scroll View is a container that shows the preview components by layout scroll.\nSee how the structure is represented:\n   Attribute  Type  Required Definition      children List \u003cServerDriven\u003cb\u003e\u003c/b\u003e\n\u003cb\u003e\u003c/b\u003eComponent\u003e\n ✓ Defines the attributes list to be displayed in the layout view.\n\n    scrollDirection ScrollAxis  Defines the scroll direction on the screen. It can be modify according to the ScrollAxis class. By default, it has the VERTICAL value.   scrollBarEnabled Boolean  Sets if the scroll bar will be displayed or not. This configuration is true by default.   context \u003cb\u003e\u003c/b\u003eContextData\u003cb\u003e\u003c/b\u003e  Sets a context to scroll view.    ScrollAxis It is an ENUM, the values are:\n   Values Definition     VERTICAL Defines the scroll as vertical.   HORIZONTAL Defines the scroll as horizontal.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"style\": { \"flex\": { \"alignItems\": \"CENTER\", \"justifyContent\": \"CENTER\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:scrollView\", \"children\": [ { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\" } }, { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/LCKYdCT/742px-Example-en-svg.png\" } } ] } ] }  ScrollView(scrollDirection = ScrollAxis.VERTICAL, children = listOf( Text(\"Vertical ScrollView\"), Text(\"Vertical ScrollView\"), Text(\"Vertical ScrollView\") ) )  👉 Test this component in the Web Playground​ ","excerpt":" What is it? Scroll View is a container that shows the preview …","ref":"/docs-beagle/docs/api/components/layout/scroll-view/","title":"Scroll View"},{"body":" O que é o Tab Bar? O componente Tab Bar é responsável por definir uma tabela que permite a navegação entre views. Ele exibe tabs correspondentes a diferentes visualizações que podem ser acessadas por meio dela.\nA estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     items TabBarItem ✓ Recebe uma lista de TabBarItems que vão definir as Tabs na tabBar   styleId String  Id do estilo a ser aplicado na TabBar   currentTab Bind\u003cInt\u003e  Número que representa a Tab selecionada.   onTabSelection List\u003cAction\u003e  Lista de ações que são executadas quando um TabBarItem é selecionado. Pode ser utilizado para carregar views de acordo com o TabItem selecionado.    O que é o TabBarItem? Componente corresponde a itens do Tab View e possui a seguinte estrutura:\n   Atributo Tipo Obrigatório Definição     title String  Exibe o texto no item do Tab View. Se ele não for declarado ou se for configurado com o valor nulo, não irá aparecer na tela.   icon Path  Exibe uma imagem local como ícone no item do Tab View. Se ele não for declarado ou for configurado com o valor nulo, não irá aparecer na tela.    Se o título e ícone não forem declarados no Tab Item, o espaço vazio permanecerá. Caso você precise de uma navegação entre visualizadores sem a interface Tab, o recomendado é que você utilize os componentes de navegação.  Como usar? No exemplo a seguir, são utilizados outros componentes para explicar o TabBar: o PageView e o Contexto.\nO Page View é utilizado para renderizar as páginas que se quer exibir de acordo com cada aba, ou seja, ele vai criar a visualização de cada uma delas. É nele que você vai definir os componentes que quer exibir ao clicar em cada aba.\nOs componentes serão renderizados de acordo com a sua posição na lista. Isso significa que, se em nossa lista temos 2 componentes de texto - o TAB 1 e TAB 2 -, o primeiro tem posição ZERO = 0, enquanto que o segundo tem posição UM = 1. O atributo currentTab é quem define qual componente é exibido de acordo com o valor definido nele.\nJá o Contexto é utilizado para guardar o indicador (posição) da aba selecionada e informá-lo ao PageView, que coordena qual elemento irá apresentar.\nExemplo JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:screenComponent\", \"child\": { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:tabBar\", \"items\": [ {\"title\": \"Tab 1\"}, {\"title\": \"Tab 2\"} ], \"styleId\": \"TabBarStyle\", \"onTabSelection\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"contestTabId\", \"value\": \"@{onTabSelection}\" } ] }, { \"_beagleComponent_\": \"beagle:pageView\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Tab 1\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Tab 2\" } ], \"currentPage\": \"@{contestTabid}\" } ], \"context\": { \"id\": \"contestTabid\", \"value\": 0 } } }  Screen( child = Container( context = ContextData(\"contestTabid\", 0), children = listOf( TabBar( onTabSelection = listOf( SetContext( \"contestTabId\", \"@{onTabSelection}\" ) ), items = listOf( TabBarItem(\"Tab 1\"), TabBarItem(\"Tab 2\") ), styleId = \"TabBarStyle\" ), PageView( currentPage = expressionOf(\"@{contestTabid}\"), children = listOf( Text( \"Tab 1\" ), Text( \"Tab 2\" ) ) ) ) ) )     Tab Bar         👉 Teste esse componente no Web Playground Este exemplo não existe no playground, mas você pode copiar e colar o código JSON acima e testa-lo no playground. Esta secção contem mais informações sobre esse exemplo abaixo.  ","excerpt":" O que é o Tab Bar? O componente Tab Bar é responsável por definir uma …","ref":"/docs-beagle/pt/docs/api/componentes/ui/tabbar/","title":"Tabbar"},{"body":" Este componente foi depreciado na versão 1.1.0 do Beagle e será removido em uma versão futura. Utilize o componente TabBar no lugar do Tab View  O que é Tab View? O componente Tab View é responsável pela navegação entre views. Ele exibe tabs correspondentes a diferentes visualizações que podem ser acessadas por meio dela.\nA estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     children List\u003cTabItem\u003e ✓ Uma lista de tab itens disponíveis no componente Tab View. O Tab Item em si não é um widget, mas seu conteúdo é um componente server driven recebido por meio do Beagle.   styleId String  Recebe uma chave que é registrada no Design System de cada plataforma para fazer customização no componente.   context ContextData  Adiciona um contexto para o Tab View.    O que é Tab Item? Componente corresponde a itens do Tab View e possui a seguinte estrutura:\n   Atributo Tipo Obrigatório Definição     title String  Exibe o texto no item do Tab View. Se ele não for declarado ou se for configurado com o valor nulo, não irá aparecer na tela.   icon Path  Exibe uma imagem local como ícone no item do Tab View. Se ele não for declarado ou for configurado com o valor nulo, não irá aparecer na tela.   child Component ✓ Obrigatório. Define qual view será inflada no Tab Item de acordo com o tab clicado. Qualquer componente server-driven pode pode ser um item em uma Tab View.    Se o título e ícone não forem declarados no Tab Item, o espaço vazio permanecerá. Caso você precise de uma navegação entre visualizadores sem a interface Tab, o recomendado é que você utilize os componentes de navegação.  Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:tabview\", \"children\": [ { \"title\": \"Tab 1\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\":\"First Tab Content\" } }, { \"title\": \"Tab 2\", \"child\": { \"_beagleComponent_\": \"beagle:text\", \"text\":\"Second Tab Content\" } } ] } ] }  Screen( child = Container( children = listOf( TabView(children = listOf( TabItem(\"Tab 1\", Image(ImagePath.Remote(\"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\") ) ), TabItem(\"Tab 2\", Image(ImagePath.Remote(\"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\") ) ) ) ) ) ) )     Tab View tela inteira Tab View dividindo tela          👉 Teste esse componente no Web Playground ","excerpt":" Este componente foi depreciado na versão 1.1.0 do Beagle e será …","ref":"/docs-beagle/pt/docs/api/componentes/ui/tabview/","title":"Tabview"},{"body":" form is structured by a group of components that defines how the information will be submitted and validated.\nYou will find below a description of all Form’s attributes in a mobile or web application:\n","excerpt":" form is structured by a group of components that defines how the …","ref":"/docs-beagle/docs/api/components/forms/","title":"Forms"},{"body":" O que é? O componente Text é responsável por definir o texto nativamente usando informações server-driven.\nA estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     text String ou Binding ✓ Define o conteúdo em texto a ser exibido.   styleId String  Referencia o estilo configurado localmente a ser aplicado no texto.   textColor String  Define a cor do texto em hexadecimal.   alignment TextAlignment  Define o alinhamento do conteúdo do texto.    TextAlignment    Atributo Definição     LEFT conteúdo alinhado à esquerda dentro do visualizador de texto.   CENTER conteúdo alinhado no centro dentro do visualizador de texto.   RIGHT conteúdo alinhado à direita dentro do visualizador de texto.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Hello World!\" }  Text(text = \"Hello World!\")  👉 Teste esse componente no Web Playground ","excerpt":" O que é? O componente Text é responsável por definir o texto …","ref":"/docs-beagle/pt/docs/api/componentes/ui/text/","title":"Text"},{"body":" This component is deprecated! It is recomended to use Simple Form.  The component represents a way to build user input and send these values to your backend.\nThe structured is represented below:\n   Attribute Type Required Definition     \nonSubmit\n List \u003cAction\u003e  Array of actions that this button can trigger when a form is sent.   child ServerDrivenComponent  ✓ Defines the visual components list (server-driven).   group String  Only used to forms with multiple pages, which is an identifier to manipulate data.   additionalData Map\u003cString, String\u003e  Values without validation that the user doesn't insert.   shouldStoreFields Boolean  Indicates if must save theadditionalData.    ","excerpt":" This component is deprecated! It is recomended to use Simple Form. …","ref":"/docs-beagle/docs/api/components/forms/form/","title":"Form"},{"body":" O que é? O Input é um componente responsável por exibir uma área de texto editável para o usuário. Esses campos de textos são usados para coletar entradas que um usuário insere utilizando o teclado.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo  Tipo  Obrigatório Definição      value String ou\nBinding\u003cb\u003e\u003c/b\u003e\n  Item referente ao valor de entrada que será digitado na área de texto editável do componente Text Input.   placeholder String ou\n\u003cb\u003e\u003c/b\u003eBinding\u003cb\u003e\u003c/b\u003e\n  Texto que é exibido quando nada foi inserido no campo de texto editável.   disabled Boolean  Propriedade para habilitar ou desabilitar o campo.   readOnly Boolean  Propriedade para determinar se o campo será editável ou somente leitura.   hidden Boolean  Propriedade que determina se o campo será escondido.   type TextInputType ou Binding\u003cb\u003e\u003c/b\u003e  Esse atributo identifica o tipo de texto que iremos receber na área de texto editável. No Android e no iOS, esse campo também atribui o tipo de teclado que será exibido pro usuário.   styleId String  Recebe uma chave que é registrada no Design System de cada plataforma para fazer customização no componente.   onChange List \u003cAction\u003e  Array de ações que esse campo pode disparar quando seu valor for alterado. É possível definir uma ação customizada ou qualquer ação já disponível na interface, como por exemplo uma ação que mostra uma mensagem de alerta(Alert).\n\nEste atributo é opcional, mas se uma ação for definida aqui ela precisa estar configurada no frontend.\n   onBlur List \u003cAction\u003e  Array de ações que esse campo pode disparar quando seu foco é retirado. É possível definir uma ação customizada ou qualquer ação já disponível na interface como, por exemplo, uma ação que mostra uma mensagem de alerta(Alert).\n\nEste atributo é opcional, mas se uma ação for definida aqui ela precisa estar configurada no frontend.\n   onFocus List \u003cAction\u003e  Array de ações que esse campo pode disparar quando é colocado em foco. É possível definir uma ação customizada ou qualquer ação já disponível na interface como, por exemplo, uma ação que mostra uma mensagem de alerta(Alert).\n\nEste atributo é opcional, mas se uma ação for definida aqui ela precisa estar configurada no frontend.\n    TextInputType É um ENUM responsável por definir qual o tipo de entrada de texto.\n   Tipo Definição     DATE Entrada de dados é uma data.   EMAIL Entrada de dados é um email.   PASSWORD Entrada de dados é uma senha.   NUMBER Entrada de dados somente com números.   TEXT Entrada de dados é um texto.    Como usar? Segue abaixo um exemplo de entrada de texto do tipo senha:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:textInput\", \"value\": \"my value\", \"placeholder\": \"user@test.com.br\", \"type\": \"email\", \"onChange\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"Changing input\" } ] }  TextInput( value = \"my value\", placeholder = \"password\", type = TextInputType.PASSWORD, styleId = \"test.input.style\", onChange = listOf( Alert( message = \"Text value changed.\" ) ) )  👉 Teste esse componente no Web Playground O exemplo no link acima é de um formulário que contém um componente do tipo text input. Mas você pode selecionar o código de exemplo acima, copiá-lo e colá-lo no playground e ver como ele funciona.  ","excerpt":" O que é? O Input é um componente responsável por exibir uma área de …","ref":"/docs-beagle/pt/docs/api/componentes/ui/textinput/","title":"Textinput"},{"body":" The validator component is an interface that informs to the Form when to enable the FormSubmit button. It is based on the observability concept, which FormInput will validate the submitted information and then send them to the Validator.\nThere are two ways to use Form Validator:\n Clicking on FormSubmit Calling the notifyObservers method inside the FormInput.  Atenção: Validator ≠FormValidation\nDespite the similar names, it’s important to mention that Validator is different of the FormValidation, the first one authenticates the filled form and the second returns error messages in case of failed information in the form.\n ","excerpt":" The validator component is an interface that informs to the Form when …","ref":"/docs-beagle/docs/api/components/forms/validator/","title":"Validator"},{"body":" O que é? O componente Web View define uma web view nativamente e usa informações server-driven.\nA estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     url String ou Binding ✓ Define a página inicial que o Web View irá carregar. Ele deve ser declarado e não pode ser configurado como valor nulo.    Ao abrir um link não seguro (http): É importante observar que este componente abrirá SOMENTE links seguros do tipo https e NÃO exibirá nenhum link não seguro do tipo http.  Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:webView\", \"url\": \"https://maps.google.com/\" }  WebView(url: \"https://docs.usebeagle.io/\")  👉 Teste esse componente no Web Playground​ ","excerpt":" O que é? O componente Web View define uma web view nativamente e usa …","ref":"/docs-beagle/pt/docs/api/componentes/ui/webview/","title":"Webview"},{"body":" What is it? The simpleForm is responsible for rendering a form on the screen.\nIts structure is represented as shown below:\n   Attribute Type Required Definition     ​onSubmit List \u003cAction\u003e ✓ Action array that this button can trigger when a form is sent.   children List\u003cServerDrivenComponent\u003e ✓ Defines the visual components list (server driven).   context ​ContextData​ ​ Adds a context to the simple form    How to use? When creating a form it is important to understand two steps respectively\n The relationship and update between fields And what happens when the Submit button is pressed.  Updating the fields The TextInput component is the field in which the user or the system will fill in some information, and it is important to know its attributes in order to better use it. Here we will use one of its elements, which is the onChange function.\nFor more information on this component go to the details of TextInput.  OnChange This function is part of the TextInput and it observes the changes made within its field, that is, whenever the value is modified, something is typed, deleted, etc, this function is called and activates a list of other actions to happen whenever the value changes. It is in this list that we add a SetContext action to set the Context value of the form and update the values ​​that are shown in the field.\nCheck our example below on how we implemented a SimpleForm\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:simpleForm\", \"context\":{ \"id\":\"myContext\", \"value\":\"\" }, \"onSubmit\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"Data submited\", \"message\":\"The password is @{myContext}\" } ], \"children\":[ { \"_beagleComponent_\":\"beagle:textInput\", \"value\":\"@{myContext}\", \"placeholder\":\"Type in your password\", \"onChange\":[ { \"_beagleAction_\":\"beagle:setContext\", \"contextId\":\"myContext\", \"value\":\"@{onChange.value}\" } ] }, { \"_beagleComponent_\":\"beagle:button\", \"text\":\"Click to Submit\", \"onPress\":[ { \"_beagleAction_\":\"beagle:submitForm\" } ] } ] }  SimpleForm( context = ContextData(id = \"myContext\", value = \"\"), children = listOf( TextInput( value = \"@{myContext}\", placeholder = \"Type in your password\", onChange = listOf( SetContext( contextId = \"myContext\", value = \"@{onChange.value}\" ) ) ), Button(text = \"Click to Submit\", onPress = listOf(SubmitForm())) ), onSubmit = listOf( Alert( title = \"Data submited\", message = \"The password is \" + \"@{myContext}\" ) ) )  onSubmit It is a function of a simple form that performs a list of actions. It is called when the form is submitted.\nTo submit a form, you must use the SubmitForm action and call it, just implement it in a Button that is part of a simple form, that is, that is in your list of children.\nWhen you click this button, the onSubmit is activated and the list of actions will be performed. It is this list of actions that will define what should happen with the information in this form, if they will be sent to a backend (through the sendRequest action), etc.\n👉 Test this component in the Web Playground ","excerpt":" What is it? The simpleForm is responsible for rendering a form on the …","ref":"/docs-beagle/docs/api/components/forms/simple-form/","title":"Simple Form"},{"body":" O que é? O Touchable é responsável por definir as áreas clicáveis dentro da aplicação em componentes que não são clicáveis nativamente.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo  Tipo  Obrigatório Definição      onPress Action  ✓ Define uma ou mais ações a serem executadas quando um componente child é clicado.   click\nAnalytics\nEvent\n Analytics Click   \nEvento do clique que será disparado caso tenha sido implementado um serviço de analytics.\n   child Server DrivenComponent  ✓ Define o widget que será o gatilho do atributo onPress.       Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:touchable\", \"onPress\": [ { \"_beagleAction_\": \"beagle:alert\", \"message\": \"This is a touchable!\" } ], \"child\": { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/KWwTSWB/1029209-200.png\" }, \"accessibility\": { \"accessibilityLabel\": \"Touchable image\", \"accessible\": true } } }  Touchable(onPress = listOf( Alert(title = \"Image\", message = \"Clicked on Message\")), child = Image(path = ImagePath.Local.justMobile(\"name\")) )  👉 Teste esse componente no Web Playground ","excerpt":" O que é? O Touchable é responsável por definir as áreas clicáveis …","ref":"/docs-beagle/pt/docs/api/componentes/touchable/","title":"Touchable"},{"body":" What is it? Context is a variable of any type, including a map that defines a set of key/value pairs. Through bindings, the value of a context can be accessed by any component or action on your scope.\nThe table below shows the main attributes of the context;\nA tabela abaixo demonstra os principais atributos do contexto:\n   Attribute Type Required Definição     id String ✓ Context identifier   value Any ✓ Context value    The context id can only contain letter, numbers and the character “_” and it must be UNIQUE on the screen.  When to use it? Context can be used when you want to fill values in a different moment from the one you received JSONs components.\nOn the example below, you can see a context with data of a user and it’s showed some information in a Text:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"myData\", \"value\": { \"id\": \"0000\", \"name\": \"User\", \"age\": \"18\" }, }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"value\": \"Name: @{myData.name}\" }, { \"_beagleComponent_\": \"beagle:text\", \"value\": \"Age: @{myData.age}\" } ] }  Container( context = ContextData( id = \"myData\", value = User( id = \"0000\" name = \"User\", age = \"18\" ) ), children = listOf( Text(\"Name: @{myData.name}\"), Text(\"Age: @{myData.age}\") ) )  Notice the context was declared and its values were defined and used to fill the texts, however it is possible to define these values after using a SetContext() method.\nThis way, you can fill the component’s data that weren’t yet in the JSON.\nThe context is only useful if the value is accessed in any JSON part. You will need to use bindings for this to happen.  How to use it? There are two ways to use context: explicit and implicit context. The main difference between them is the scope of the context, it can be defined inside the JSON or the declarative structure you are using.\nContext scope The scope of a context is a component where it and its descendants were defined. It’s impossible to access a declared context in another tree branch.\nA context can be stablished in any Beagle component that implements a ContextComponent, that is a context propriety that can be specified by the following components:\n Container Screen ScrollView PageView TabView Custom Components that implements a ContextComponent  1. Explicit Context When there is a defined scope to the context inside your JSON or your declarative structure.\nSee the example below on how it works:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{myText}\" } ], \"context\" : { \"id\" : \"myText\", \"value\" : \"Hello Beagle\" } }  Container( context = ContextData( id = \"myData\", value = User( id = \"0000\" name = \"User\", age = \"18\" ) ), children = listOf( Text(\"Name: @{myData.name}\"), Text(\"Age: @{myData.age}\") ) )  Notice the context was declared and its values were defined and used to fill the texts, however it is possible to define these values using the SetContext() method later. You can fill the component’s with data that wasn’t in the JSON.\n2. Implicit context When there isn’t a context scope defined inside a JSON or the declarative structure of your screen, but it can be accessed through bindings.\nThat means that this type of context is created only through events.\nBesides that, the scope on this type of context is defined only by an action or a set of action related to the created event in the context.\n In some cases, it’s necessary to access a particular information about an event that triggered an action. An example is the onChange event, that is launched by any component and allows the data input.\nIf the value of an input component changes and the actions to be launched depend on this value, it is fundamental that you have access to the new component value.\nThe other implicit context characteristic is that it always have the same id as the event name created it. If it the onChangeevent, for example, the context scope will have id onChange and the binding will be: { value: newValue }, where newValue is the field you can include a new value to be used.\nCheck out on the following example that used the onBlur event, it works the same way as onChange, but makes a request when the input component lost its focus:\n{ \"_beagleComponent_\": \"beagle:textinput\", \"label\": \"CEP\", \"onBlur\": [ { \"_beagleAction_\": \"beagle:sendRequest\", \"url\": \"https://viacep.com.br/ws/@{onBlur.value}/json\", \"method\": \"GET\" } ] } Besides the onBlur context had never been declared on the example above, you can use it because it was created in an implicit way by the onBlur event.\nThe JSON defines a view where the focus lost on the CEP (zip code) field runs an action to search the address based on the typed value. The request result could be used to define the value for the other fields on an address form.\nYou can check an example of implicit context of Beagle Web on Beagle Playground.  Examples of events that create an implicit context:\n onChange onFocus onBlur onSuccess onError onFinish.  The first three events are part of a beagle:textinputcomponent contract while the last three are part of beagle:sendRequest action.\nBindings Bindings are the string in a special format that identifies a value inside a context. Without it is not possible to create implicit or explicit contexts.\nDuring Beagle’s render process, bindings can be replaced by values referred to them.\nA binding is identified by a prefix @{ and a suffix }. Meaning that everything between the symbols @{ and } identify the context value by which the binding must be replaced when you render a screen.\nSee the example below on how it works:\nJSON kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{myText}\" } ], \"context\" : { \"id\" : \"myText\", \"value\" : \"Hello Beagle\" } }  Container( children = listOf( Text(\"@{myText}\") ), context = ContextData( id = \"myText\", value = \"Hello Beagle\" ) )  To access the “Hello Beagle” text through a binding, it has to specify the context id: @{myText}.\nOn the example above, the context value is a simple string, but you can see on the next topic how to access values in contexts that are maps or arrays.\nTypes of bindings Multi-valued binding (key/value maps) It is the binding type which the context value it will be generally, a key/value of a map.\nIn these cases, bindings must be used to access substructures. As it happens in most of programming languages, Beagle uses points to make this kind of access, as you can see on the context example below:\n To access the CPF, use the @{user.cpf} binding. To access the phone number, use the @{user.phoneNumber.cellphone} binding.  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{user.phoneNumber.cellphone}\" } ], \"context\" : { \"id\" : \"user\", \"value\" : { \"cpf\" : \"014.225.235-12\", \"phoneNumber\" : { \"cellphone\" : \"(34) 98856-8563\", \"telephone\" : \"(34) 3214-5588\" } } } }  No Kotlin é necessario que se crie algumas classes para gerenciar os contextos multivalorados\nContainer( children = listOf( Text(\"@{user.phoneNumber.cellphone}\") ), context = ContextData( id = \"user\", value = User( cpf = \"014.225.235-12\", phoneNumber = PhoneNumber( cellphone = \"(34) 98856-8563\", telephone = \"(34) 3214-5588\" ) ) ) ) data class User(val cpf: String, val phoneNumber:PhoneNumber) data class PhoneNumber(val cellphone:String, val telephone:String)  Binding with vectors (arrays) It is the type of binding which the context value will be generally vectors (arrays).\nIf a vector is used on a context value, to access a specific position, you have to use the [ e ] characters when you’re building the binding.\nSee how on the context example below:\n To access the second film title (“Contact”), use the @{movies.titles[1].title}binding.  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{movies.titles[1].title}\" } ], \"context\" : { \"id\" : \"movies\", \"value\" : { \"genre\" : \"sci-fi\", \"titles\" : [ { \"title\" : \"Inception\", \"year\" : \"2010\", \"rating\" : \"8.8\" }, { \"title\" : \"Contact\", \"year\" : \"1997\", \"rating\" : \"7.4\" } ] } } }  No Kotlin é necessario que se crie algumas classes para gerenciar os contextos multivalorados\nContainer( children = listOf( Text(\"@{movies.titles[1].title}\") ), context = ContextData( id = \"movies\", value = Movie( genre = \"sci-fi\", titles = listOf( Title( title = \"Inception\", year = \"2010\", rating = \"8.8\" ), Title( title = \"Contact\", year = \"1997\", rating = \"7.4\" ) ) ) ) ) class Movie(val genre: String, val titles:List\u003cTitle\u003e) class Title(val title:String, val year:String, val rating:String)  What happens if I attribute a binding to a variable that doesn’t exist? Bindings that refer to a non existent or invalid contexts cannot be updated and it will appear on the screen as they were typed (in case the received attribute is a string).\nFor example, if we use @{client.name} and the \"client\" context is not accessible (declared), this binding will be not replaced by any value. The same would happen if the “client” context doesn’t exist, but has a “name” propriety.\nMultiples bindings in strings It’s possible to use more than one binding in a unique string and event mix statics texts with bindings. See how on the following example:\nExample: \"Hello @{person.name}. Your score is @{score.value}.\"\nAdding a support for bindings in your custom components In each system, the binding must be declared like:\n Android: All the attributes receive an expression that must be declared as Bind. iOS: The attributes that receives a binding must be declared asExpression to have the same Android’s effect. Web: It’s not necessary to deal with bindings in a special way, which means that nothing should be done on your components.  Examples for each operational system:\nAndroid iOS data class MyComponent( val text: Bind\u003cString\u003e ) : WidgetView() { override fun buildView(rootView: RootView): View { val view = MyView(rootView.getContext()) // To make bind works you have to call the observeBindChanges method  // passing a rootView and the attribute that has a bind  observeBindChanges(rootView, text) { view.setText(it) } return view } }  public struct MyComponent: Widget { public var widgetProperties: WidgetProperties public let text: Expression\u003cString\u003e public func toView(renderer: BeagleRenderer) -\u003e UIView { let textView = UITextView() // To make bind works you have to call the observeBindChanges method // passing a rootView and the attribute that has a bind renderer.observe(text, andUpdate: \\.text, in: textView) return textView } }  The way to refer an expression on Kotlin’s DSL must be like this:\nKotlin DSL  MyComponent( text = expressionOf(\"@{myContext.hello}\") )  However, in case you have to pass a hardcoded value, you must use this way:\nKotlin DSL  MyComponent( text = valueOf(\"hello\") )  👉 See some examples in the Playground ","excerpt":" What is it? Context is a variable of any type, including a map that …","ref":"/docs-beagle/docs/api/context/","title":"Context"},{"body":" O que é? O Lazy Component é usado para carregar de forma assíncrona algum componente do BFF.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     path String ✓ A URL que realiza a requisição.   initialState ServerDrivenComponent ✓ Componente server driven que é apresentado enquanto uma requisição assíncrona está sendo feita.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:lazycomponent\", \"path\": \"/listview.json\", \"initialState\": { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Carregando conteúdo, aguarde...\" } }  LazyComponent( path = \"/listview.json\", initialState = Text(\"Carregando conteúdo, aguarde...\") )  👉 Teste esse componente no Web Playground ","excerpt":" O que é? O Lazy Component é usado para carregar de forma assíncrona …","ref":"/docs-beagle/pt/docs/api/componentes/lazy/","title":"Lazy"},{"body":" O componente de Layout pode ser definido a partir de 7 grupos de subcomponentes: Container, Horizontal, Page View, List View, Scroll View, Stack e Vertical.\nAbaixo, você encontra uma descrição completa dos atributos que fazem parte de um Layout dentro de uma aplicação mobile ou web.\n","excerpt":" O componente de Layout pode ser definido a partir de 7 grupos de …","ref":"/docs-beagle/pt/docs/api/componentes/layout/","title":"Layout"},{"body":" What is it? The operations allow you to create application with more complex screens through your backend and with basic operations like addition, equals, etc. This way, the components don’t need this kind of logic inside them.\nHow to use it? The operations can be used when you want to modify the values of a component through logic and operations in a different moment from the one it received the components with the JSON.\nOn Beagle, you have some default operators and you can also create your own.\nSee below all the operators available on Beagle:\n","excerpt":" What is it? The operations allow you to create application with more …","ref":"/docs-beagle/docs/api/context/operations/","title":"Operations"},{"body":" What are they?    Operators Example Action     sum “@{sum(3,3)}” Addition operator for the elements type Int and Double.   subtract “@{subtract(4,3)}” Subtraction operator for the elements type Int and Double.   multiply “@{multiply(3,3)}” Multiplication operator for the elements type Int and Double.   divide “@{divide(3,3)}” Division operator for the elements type Int and Double.    Example See an example below of a counter where two buttons increment and decrement, both with SetContext actions that modifies the context value that has an id counter, altering the value with addition and subtraction operations, increasing or decresing the value of 1 to the text value:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar( title = \"Operations\", showBackButton = true ), child = Container( context = ContextData(\"counter\", 2), children = listOf( Text(expressionOf(\"Sum of 2 + 1 = @{sum(2, 1)}\")), Text(expressionOf(\"Counter: @{counter}\")), Button( text = \"increment\", onPress = listOf( SetContext(\"counter\", \"@{sum(counter, 1)}\")) ), Button( text = \"decrement\", onPress = listOf( SetContext(\"counter\", \"@{subtract(counter, 1)}\")) ) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Sum of 2 + 1 = @{sum(2, 1)}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Counter: @{counter}\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"increment\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"counter\", \"value\" : \"@{sum(counter, 1)}\" } ] }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"decrement\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"counter\", \"value\" : \"@{subtract(counter, 1)}\" } ] } ], \"context\" : { \"id\" : \"counter\", \"value\" : 2 } } }  ","excerpt":" What are they?    Operators Example Action     sum “@{sum(3,3)}” …","ref":"/docs-beagle/docs/api/context/arithmetic-operator/","title":"Arithmetic operator"},{"body":" O que é? O Container é um componente responsável por conter outros componentes dentro de si.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     children List \u003cServerDriven Component\u003e ✓ Define a lista de componentes que fazem parte do container   context ContextData  É o contexto contido por este Widget.   onInit List\u003cAction\u003e  Um parâmetro que te possibilita definir uma lista de ações a serem executadas assim que esse Widget seja exibido.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"@{myContext.value}\" } ], \"context\": { \"id\": \"myContext\", \"value\": \"Hello world!\" } }  Container( children = listOf( Text(text = \"@{myContext.value}\") ), context = ContextData( id = \"myContext\", value = \"Hello World!\" ) )  👉 Teste esse componente no Web Playground​ ","excerpt":" O que é? O Container é um componente responsável por conter outros …","ref":"/docs-beagle/pt/docs/api/componentes/layout/container/","title":"Container"},{"body":" O que é? O componente ListView é responsável por definir uma lista de itens recicláveis nativamente. Esses itens podem ser quaisquer componentes server driven. O uso do ListView é recomendado para situações onde há repetição de componentes, porém com dados diferentes.\nA partir da versão 1.5.0 passamos a suportar o uso de contexto e reciclagem de celulas no ListView, com isso disponibilizamos duas formas de construir o componente. A versão depreciada foi mantida somente para manter retrocompatibilidade, se possível atualize para a nova versão do componente para melhor desempenho.  A sua estrutura é representada como mostrado abaixo:\nListView    Atributo Tipo Obrigatório Definição     direction ListDirection  Define o direcionamento em que os items da lista são exibidos.   context ContextData  Define o contexto do componente.   onInit List\u003cAction\u003e  Lista de ações a serem executadas assim que o componente é exibido.   dataSource Bind\u003cList\u003cAny\u003e\u003e ✓ Expressão que aponta para uma lista de valores usados para popular o componete.   template ServerDrivenComponent ✓ Representa cada celula na lista através de um ServerDrivenComponent.   onScrollEnd List\u003cAction\u003e  Lista de ações executadas quando a lista chega ao fim.   scrollEndThreshold Int  Define a porcentagem rolada da lista para disparar o onScrollEnd.   iteratorName String  É o identificador do contexto de cada célula.   key String  Aponta para um valor único presente em cada item do dataSource para ser usado como um sufixo nos ids dos componentes do template.    ListDirection É um ENUM, cujos valores são:\n   Valor Definição     VERTICAL Quando os items são exibidos em LINHAS.   HORIZONTAL Quando os itens são exibidos em COLUNAS.    Valor default é ListDirection.VERTICAL  ListView Depreciado    Atributo Tipo Obrigatório Definição     children List\u003cServerDrivenComponent\u003e ✓ \nDefine os itens da lista de visualização. Eles podem ser configurados como uma lista de ServerDrivenComponents ou como views.    direction ListDirection   Define o direcionamento da lista de visualização.    Como usar? ListView JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:listView\", \"direction\": \"VERTICAL\", \"dataSource\": [ { \"name\": \"Kelsier\", \"race\": \"Half-skaa\", \"planet\": \"Scadrial\", \"isMistborn\": true, \"age\": 38, \"sex\": \"male\" }, { \"name\": \"Vin\", \"race\": \"Half-skaa\", \"planet\": \"Scadrial\", \"isMistborn\": true, \"age\": 20, \"sex\": \"female\" }, { \"name\": \"TenSoon\", \"race\": \"Kandra\", \"planet\": \"Scadrial\", \"isMistborn\": false, \"age\": 40, \"sex\": \"male\" } ], \"template\": { \"_beagleComponent_\": \"beagle:container\", \"style\": { \"margin\": { \"bottom\": { \"value\": 20, \"type\": \"REAL\" } } }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Name: @{item.name}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Race: @{item.race}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Mistborn: @{item.isMistborn}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Planet: @{item.planet}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"sex: @{item.sex}\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"age: @{item.age}\" } ] } }  ListView( dataSource = listOf( Person( name = \"Kelsier\", race = \"Half-skaa\", planet = \"Scadrial\", isMistborn = true, age = 38, sex = Sex.MALE ), Person( name = \"Vin\", race = \"Half-skaa\", planet = \"Scadrial\", isMistborn = true, age = 20, sex = Sex.FEMALE ), Person( name = \"TenSoon\", race = \"Kandra\", planet = \"Scadrial\", isMistborn = false, age = 40, sex = Sex.MALE ), ), template = Container( children = listOf( Text(\"Name: @{item.name}\"), Text(\"Race: @{item.race}\"), Text(\"Mistborn: @{item.isMistborn}\"), Text(\"Planet: @{item.planet}\"), Text(\"sex: @{item.sex}\"), Text(\"age: @{item.age}\"), ) ).applyStyle( Style( margin = EdgeValue(bottom = 20.unitReal()) ) ) )  👉 Teste o ListView no Web Playground​ ListView Depreciado JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:listView\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#FF0000\", \"alignment\": \"CENTER\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#00FF00\", \"alignment\": \"CENTER\" }, { \"_beagleComponent_\": \"beagle:text\", \"text\": \"Beagle Text list\", \"textColor\": \"#0000FF\", \"alignment\": \"CENTER\" } ], \"direction\": \"HORIZONTAL\" }  ListView( direction = ListDirection.HORIZONTAL, children = listOf( Text( text = \"Beagle Text list\", textColor = \"#FF0000\", alignment = TextAlignment.CENTER ), Text( text = \"Beagle Text list\", textColor = \"#00FF00\", alignment = TextAlignment.CENTER ), Text( text = \"Beagle Text list\", textColor = \"#0000FF\", alignment = TextAlignment.CENTER ) ) )  👉 Teste o ListView depreciado no Web Playground​ ","excerpt":" O que é? O componente ListView é responsável por definir uma lista de …","ref":"/docs-beagle/pt/docs/api/componentes/layout/listview/","title":"Listview"},{"body":" What are they?    Operators Example Action     condition “@{condition()}” Conditional operator that evaluates two elements and verifies which condition is true.   not “@{not()}” negation operator that has as input only one value and its function is invert this value.   and “@{and()}” Operator that receives two inputs and it has a TRUE value, if the two values of the operation inputs are TRUE, if not the result is FALSE.   or “@{or()}” Operator that receives two inputs and it the result it a TRUE value. If only ONE of the two input values are TRUE, if not the result is FALSE.    Example Here is an example of a screen that uses two logical operation condition and or, if the result of the condition or is true, the text of the component text becomes true, if it is false it attibutes the value false to the text:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar(title = \"Operations\", showBackButton = true), child = Container( children = listOf( Text(text = \"The text in green bellow will show if the result of `TRUE OR FALSE\"), Text( expressionOf(\"@{condition(or(true, false), 'true', 'false')}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text in green bellow will show if the result of `TRUE OR FALSE\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(or(true, false), 'true', 'false')}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" What are they?    Operators Example Action     condition …","ref":"/docs-beagle/docs/api/context/logic-operator/","title":"Logic operator"},{"body":" What are they?    Operators Example Action     gt\n(greater)\n \"@{gt(3,4)} Operator that receives two inputs and the result is true if the first value is greater than the second one.   gte\n(greater than or equal to)\n \"@{gte(3,4)}\" Operator that receives two inputs and the result is true if the first value is greater than or equal to the second one.   lt\n(less than)\n @{lt(3,4)}\" Operator that receives two inputs and the result is true if the first value is less than the second one.   lte\n(less then or equal to)\n \"@{lte(3,4)}\" Operator that receives two inputs and the result is true if the first value is less then or equal to the second one.   eq\n(Equal to)\n \"@{eq(4,4)}\" Operator that receives two inputs and the result is true if the two values are equal.    Example Here, the example is a screen that uses the comparison operation It, that verifies if the addition value of the counter is:\n If the result of the condition or is true, the text component Text becomes true; If it is false, it attributes the text the value false;  Kotlin JSON fun screen() = Screen( navigationBar = NavigationBar( title = \"Operations\", showBackButton = true ), child = Container( children = listOf( Text(text = \"The text bellow will show if 4 is below 5 or not\"), Text(expressionOf( \"@{condition(lt(4, 5), 'less then 5', 'greater then 5')}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text bellow will show if 4 is below 5 or not\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(lt(4, 5), 'less then 5', 'greater then 5')}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" What are they?    Operators Example Action     gt\n(greater) …","ref":"/docs-beagle/docs/api/context/comparison-operator/","title":"Comparison operator"},{"body":" O que é? O componente PageView é um container especializado em apresentar páginas que são exibidas na horizontal e podem conter um indicador de páginas. Essas páginas podem ser qualquer objeto server-driven.\nO Page View se refere ao seu tamanho quando visualizado em dispositivos Mobile (Android e iOS). O tamanho dele é determinado pelo elemento pai em que está contido, ou seja, a largura (width) e a altura (height) será definida pelo componente pai.\nPor exemplo, um PageView pode ser declarado dentro de um Container e sua largura e altura são responsáveis por determinar o tamanho do Page View.\n A sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     children List\u003cServerDrivenComponent\u003e ✓ \nDefine a lista de componentes visuais (server-driven) contidos naPageView.\n   context \u003cb\u003e\u003c/b\u003eContextData\u003cb\u003e\u003c/b\u003e  É o contexto contido neste Widget   onPageChange List\u003cAction\u003e  Lista de ação que é executada quando a pagina selecionada é alterada   currentPage Int  Identificador de qual pagina está selecionada   showArrow Boolean  Esse atributo é especifico para plataforma web. Ele habilita setas para mudança de página.    Como usar? No exemplo abaixo segue um PageView contendo três páginas onde cada uma delas tem um Text que é definido por Contexto. Toda vez que há mudança de página o contexto é redefinido.\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:pageView\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 1\", \"alignment\":\"CENTER\" }, { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 2\", \"alignment\":\"CENTER\" }, { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Page 3\", \"alignment\":\"CENTER\" } ], \"onPageChange\":[ { \"_beagleAction_\":\"beagle:setContext\", \"contextId\":\"context\", \"value\":\"@{onPageChange}\" } ], \"currentPage\":\"@{context}\" }, { \"_beagleComponent_\":\"beagle:pageIndicator\", \"selectedColor\":\"#000000\", \"unselectedColor\":\"#888888\", \"numberOfPages\":3, \"currentPage\":\"@{context}\" } ], \"context\":{ \"id\":\"context\", \"value\":0 } }  Container( children = listOf( PageView( children = (1..3).map { Text( text = \"Page $it\", alignment = TextAlignment.CENTER ) }, onPageChange = listOf(SetContext(\"context\", \"@{onPageChange}\")), currentPage = expressionOf(\"@{context}\") ), PageIndicator( numberOfPages = 3, selectedColor = BLACK, unselectedColor = LIGHT_GREY, currentPage = expressionOf(\"@{context}\") ) ), context = ContextData( id = \"context\", value = 0 ) )  👉 Teste esse componente no Web Playground​ ","excerpt":" O que é? O componente PageView é um container especializado em …","ref":"/docs-beagle/pt/docs/api/componentes/layout/pageview/","title":"Pageview"},{"body":" O que é? O PageIndicator é um componente que tem como funcionalidade indicar a quantidade de páginas e qual é a atual do PageView.\n   Atributo Tipo Obrigatório Definição     selectedColor String ✓ Valor em hexadecimal para representar a cor quando selecionado.   unselectedColor String ✓ Valor em hexadecimal para representar a cor quando não selecionado.   numberOfPages Int  Indica a quantidade de paginas.   currentPage Bind\u003cInt\u003e  Indica a página.    Como usar? Um exemplo completo de como usar o PageIndicator está em PageView.\n👉 Teste esse componente no Web Playground​ ","excerpt":" O que é? O PageIndicator é um componente que tem como funcionalidade …","ref":"/docs-beagle/pt/docs/api/componentes/layout/pageindicator/","title":"Pageindicator"},{"body":" What are they?    Operators Example Action     concat “@{concat(“cachorro”, “quente”)}” Operator that concatenates the strings that are as input.   capitalize “@{capitalize(brasil)}” Operator that changes the first string letter into a capital letter.   uppercase “@{uppercase(brasil)}” Operator that changes all letter of a string into uppercases.   lowercase “@{lowecase(BRASIL)}” Operator that changes all letters of a string into lowercases.   substr “@{substr(brasil, 3)}” Operator that returns a substring of a input string. This operation may have 2 or 3 inputs, where the first parameter is the string and the second and third ones are the string limit.    Example This example, a screen has a text with the substring operation, which the sentence is ‘The book is on the table’ and the parameters is 4,11 determine the threshold of this substring, which it will turn the following string ‘book is on':\nKotlin JSON fun screen() = Screen(child = Container( children = listOf( Text(text = \"The text bellow is a substring of `The book is on the table`.\"), Text( expressionOf(\"@{substr('The book is on the table', 4, 11)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\") ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text bellow is a substring of `The book is on the table`.\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{substr('The book is on the table', 4, 11)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" What are they?    Operators Example Action     concat …","ref":"/docs-beagle/docs/api/context/string-manipulation-operator/","title":"String manipulation operator"},{"body":" What are they?    Operadores Exemplo Ação     insert “@{insert(array, 5)}” Operators that receives two inputs, where the first parameter is an array and the second is the element that you want to insert in this array.   remove “@{remove(array, 1)}” Operators that receives two inputs, where the first parameter is an array and the second is the element that you want to remove this array.   removeIndex “@{removeIndex(array, 2)}” Operators that receives two inputs, where the first parameter is an array and the second is the index that you want to remove this array.   contains “@{contains(array, 3)}” Operators that receives two inputs, where the first parameter is an array and the second is the element that you want to verify if it contains in this array.    Example See the example of a screen where the a context was declared with numbersArray id with the values [0, 1, 2, 3, 4], this context is used in the removeIndex operation in the text component text, where it removes the element of index 2.\nKotlin JSON fun screen() = Screen(child = Container( context = ContextData(id = \"numbersArray\", value = arrayOf(0,1,2,3,4)), children = listOf( Text(text = \"Array was [0, 1, 2, 3, 4] and after removing index 2 now is: \"), Text( expressionOf(\"@{removeIndex(numbersArray, 2)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Array was [0, 1, 2, 3, 4] and after removing index 2 now is: \" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{removeIndex(numbersArray, 2)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ], \"context\" : { \"id\" : \"numbersArray\", \"value\" : [ 0, 1, 2, 3, 4 ] } } }  ","excerpt":" What are they?    Operadores Exemplo Ação     insert “@{insert(array, …","ref":"/docs-beagle/docs/api/context/arrays-manipulation-operator/","title":"Arrays manipulation operator"},{"body":" O que é? O componente Scroll View é um container especializado que exibe os componentes em visualização por scroll no layout.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo  Tipo  Obrigatório Definição      children List \u003cServerDriven Component\u003e\n ✓ Define a lista de atributos a ser exibida na visualização do layout. \n    scrollDirection ScrollAxis  Define a direção da rolagem em scroll na tela.\nA direção do scroll pode ser modificada de acordo com a classe ScrollAxis definida logo abaixo. Por default, tem o valor deVERTICAL.\n   scrollBarEnabled Boolean  Determina se a barra de rolagem vai ser exibida ou não. Essa configuração é verdadeira por default.   context ContextData   Dita um contexto para a scroll view.    ScrollAxis É um ENUM, cujos valores são:\n   Valor Definição     VERTICAL Para definir o scroll como vertical.   HORIZONTAL Para definir o scroll como horizontal.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"style\": { \"flex\": { \"alignItems\": \"CENTER\", \"justifyContent\": \"CENTER\" } }, \"children\": [ { \"_beagleComponent_\": \"beagle:scrollView\", \"children\": [ { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/k9tYwtX/selo-do-exemplo-28420393.jpg\" } }, { \"_beagleComponent_\": \"beagle:image\", \"path\": { \"_beagleImagePath_\": \"remote\", \"url\": \"https://i.ibb.co/LCKYdCT/742px-Example-en-svg.png\" } } ] } ] }  ScrollView(scrollDirection = ScrollAxis.VERTICAL, children = listOf( Text(\"Vertical ScrollView\"), Text(\"Vertical ScrollView\"), Text(\"Vertical ScrollView\")))  👉 Teste esse componente no Web Playground​ ","excerpt":" O que é? O componente Scroll View é um container especializado que …","ref":"/docs-beagle/pt/docs/api/componentes/layout/scrollview/","title":"Scrollview"},{"body":" What are they?    Operadores Exemplo Ação     isNull “@{isNull(context)}” Operator that verifies if the parameter is null.   isEmpty “@{isEmpty(\")}” Operator that receives an input and verify if it is empty.   length “@{length(tamanho)}” Operator that receives an input and returns its size.    Example A context with numbersArray id that has [0, 1, 2, 3, 4] as value and the operation length was used in one component Text to get the size of this array, see below:\nKotlin JSON fun screen() = Screen(child = Container( context = ContextData(id = \"numbersArray\", value = arrayOf(0,1,2,3,4)), children = listOf( Text(text = \"Array [0, 1, 2, 3, 4] has size: \"), Text( expressionOf(\"@{length(numbersArray)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Array [0, 1, 2, 3, 4] has size: \" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{length(numbersArray)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ], \"context\" : { \"id\" : \"numbersArray\", \"value\" : [ 0, 1, 2, 3, 4 ] } } }  ","excerpt":" What are they?    Operadores Exemplo Ação     isNull …","ref":"/docs-beagle/docs/api/context/other-operators/","title":"Other operators"},{"body":" O form (Formulário) é estruturado como um grupos de componentes que definem como as informações serão submetidas e validadas.\nAbaixo você encontra uma descrição completa dos atributos que fazem parte de um Formulário dentro de uma aplicação mobile ou web.\n","excerpt":" O form (Formulário) é estruturado como um grupos de componentes que …","ref":"/docs-beagle/pt/docs/api/componentes/formul%C3%A1rios/","title":"Formulários"},{"body":" After you’ve seen it is possible to make addition, subtraction and other operations using context, you can also create your own operation in the platform you want:\niOS  The registration of an operation on iOS is through OperationsProviderprotocol, see below:\npublic protocol OperationsProvider { func register(operationId: String, handler: @escaping OperationHandler) func evaluate(with operation: Operation, in view: UIView) -\u003e DynamicObject } To register your customized operation, you have to do two things:\n Provide an id for this operation; Provide to it an action that it will happen through a closure of the type OperationHandler.  The OperationHandler is a typealias of a code block that returns DynamicObject through a parameter of [DynamicObject] type.\npublic typealias OperationHandler = (_ parameters: [DynamicObject]) -\u003e DynamicObject Now, to register your new operation you have to use BeagleDependencies, where you can access the OperationsProvider, which has the register function.\nlet dependencies = BeagleDependencies() dependencies.operationsProvider.register(operationId: \"isValidCpf\") { parameters in let anyParameters = parameters.map { $0.asAny() } if let intParameters = anyParameters.first as? Int { let stringParameters = String(intParameters) return .bool(stringParameters.isValidCPF) } else if let stringParameters = anyParameters.first as? String { return .bool(stringParameters.isValidCPF) } return nil } Done! Your operation can be used now!\n Example See below an example using the isvalidCpf operation that was created above, where the text component Text will vary according the verification result, if the CPF is valid or not:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar(title = \"Custom operation\", showBackButton = true), child = Container( context = ContextData(\"cpf\", \"00000000000\"), children = listOf( Button(\"CPF atual: @{cpf}\", onPress = listOf( SetContext( contextId = \"cpf\", value = \"42249625000\" ) )), Text(text = \"@{condition(isValidCpf(cpf), 'cpf is valid', 'cpf is not valid')}\") ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Custom operation\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"CPF atual: @{cpf}\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"cpf\", \"value\" : \"42249625000\" } ] }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(isValidCpf(cpf), 'cpf is valid', 'cpf is not valid')}\" } ], \"context\" : { \"id\" : \"cpf\", \"value\" : \"00000000000\" } } }  ","excerpt":" After you’ve seen it is possible to make addition, subtraction and …","ref":"/docs-beagle/docs/api/context/how-to-register-a-new-operation/","title":"How to register a new operation"},{"body":" Esse componente foi depreciado! É recomendado usar o Simple Form.  O componente representa uma maneira de compor entradas do usuário e enviar esses valores ao seu backend.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     \nonSubmit\n List \u003cAction\u003e  Array de ações que esse botão pode disparar quando o formulário é enviado.   child ServerDrivenComponent  ✓ Define a lista de componentes visuais (server-driven).   group String  Usado somente para formulários multi página, o qual é um identificador para manipular os dados.   additionalData Map\u003cString, String\u003e  Valores sem validação que o usuário não insere.   shouldStoreFields Boolean  Indica se deve salvar o additionalData.    ","excerpt":" Esse componente foi depreciado! É recomendado usar o Simple Form.  O …","ref":"/docs-beagle/pt/docs/api/componentes/formul%C3%A1rios/form/","title":"Form"},{"body":" What is it? A Global Context is a variable that can assume as value of any type of variable, like a map defines a subset of key/value or complex JSONs objects that defines object trees.\nIt works exactly like the Context, however in a global scope, meaning that it will exists while the application is still running (even on the background), which allows it to be accessed from any application point, being a component or an action linked to a component or even programmatically.\nHow can you access it? It can be accessed through an expression in a declarative page, for example, \"@{global.user}\" or programmatically from a GlobalContext.get() object\nThis way, it is possible to share information between the native part of the application, the server-driven part and between different server-driven screens.  How to use it? It is important to mention some information to use the Global Context:\n Global context Global ins an object and is type is __ContextData Global context can have as a VALUE, a complex JSON that can contain an object tree in it. It is a Singleton.  By default the global context ID will be always ‘global’.  How to create a Global Context? Global context is created with the application and it is defined internally on Beagle as an object with ContextData type, that it will store any defined information on a global context.\nHow to define a Global Context? A context to be global, it can be defined in two ways:\n From a declarative component (using the SetContextaction) or Programmatically, using the set() function from the GlobalContext object.  1. Using SetContext It is possible to define or modify a global context from the SetContext action. You have to identify a global context using an ID = \"global\" in the contextId property, as you can see below:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\":\"@{global.myValue}\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Open Modal\", \"onPress\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"global\", \"path\": \"myValue\", \"value\": \"Context has changed\" } ] } ] }  Container( children = listOf( Text(text = \"@{global.myValue}\"), Button(text = \"Open Modal\", onPress = listOf( SetContext( contextId = \"global\", path = \"myValue\", value = \"Context has changed\" ) ) ) ) )  When defining a value of any context, it is important to analyse its structure. If any value is passed in the path property, the value it will be defined in the object’s roots, meaning that any other attribution done in the context will overwrite any information without a path on the object’s root.  On the example above, the JSON object created on the context’s root it would be:\n{\"myValue\" : \"Context has changed\"} 2. Using GlobalContext.set() Global context can also be defined through a set method, that can be called from the GlobalContext object.\nFor this, it is used:\nGlobalContext.set(value, path)\n   Parameters Type Required Definition     value Any ✓ It represents an information that can be any kind, for example, other JSONs objects, an array or any other object.   path String  It represents the path that it will contain this information, like the example above, the path used was \"myValue\". The path parameter is not required, and when omitted it will define the value informed in the object’s root, overwriting any other information.    To define a global context, just like the example in this section, use the following command:\nAndroid Web iOS GlobalContext.set(\"Context has changed\", \"myValue\")  On the web global context is one of BeagleService attributes, available by library beagle-angular and beagle-react.\nNa web, o contexto global é um dos atributos do BeagleService, que a lib do beagle-angular e beagle-react disponibilizam.\nAngular:\nTo use the global context in any component of your application, you have to inject BeagleProvider in your components' constructor and use the getBeagleUIService function to have access to beagleService's object, access the globalContext and the globalText function you want. See below the code on how to use the set function:\nimport { BeagleProvider } from '@zup-it/beagle-angular'; constructor(private beagleProvider: BeagleProvider) ... const beagleService = this.beagleProvider.getBeagleUIService() beagleService?.globalContext.set(value, path) React:\nTo use global context in a React application, use the available context by beagle-react through useContext of the React and to have access to beagleService and through it access the globalContext and the function you want. See below the set function being used:\nimport context from '@zup-it/beagle-react/provider' ... const beagleService = useContext(context) beagleService?.globalContext.set(value, path)  In iOS the Global Context is a Beagle Dependencies attribute.\nTo use it in anywhere of your application you must to use the BeagleDependencies instance of your project as the example below:\ndependencies.globalContext.setValue(value: \"Context has changed\", path: \"myValue\") The context value is a DynamicObject, therefore it can take on any kind of value.\n  Recovering a Global Context Global context can be recovered in two ways:\n Using expressions (just like any other context) or get function, called from the GlobalContext object.  1. Using the “@{global}” expression To recover the value assigned to a global context, you have to use the “@{global}” expression.\nThe example on this section, the global context value was assigned using a \"myValue\" path, in order to recover it, you have to use the expression \"@{global.myValue}\" that it will return a “Context has changed” string.\n If you only use the \"@{global}\" expression, the value will return a whole JSON object:  {“myValue” : “Context has changed”}    This expression are observed by the context and are updated when the context changes, however they need to be in a declarative screen.  2. Using a GlobalContext.get() Global context also can be recovered through a get method and it can be called from the GlobalContext object.\nFor this, it is used:\nGlobalContext.get(path)\n   Parameters Type Definition     path String Represents the path that it will contain the information, on the example above, the path used was \"myValue\". The path parameter is optional and if every value is passed, the global context will be returned.    Consider the previous example, to recover a Global context that is in the “myValue” path, use the following command:\nAndroid Web iOS GlobalContext.get(\"myValue\")  The example above you could see all configuration to use set. The config to get is the same, however you have to change the globalContext method that it will be access:\nbeagleService?.globalContext.get(\"myValue\")  As the set method it is necessary to use the BeagleDependencies to call any Global Context method, follow the example below:\ndependencies.globalContext.get(path: \"myValue\")   The same way when using GlobalContext.get() without a path parameter, this method will return a whole JSON object -\u003e {\"myValue\" : \"Context has changed\"}  Removing a Global Context Global context can only be destroyed with the application closing, and even if it is empty, it can be called anywhere in the application, because it ‘‘exists’’ while the application ‘‘exists’’.\nHowever, it can be reseted or it can have parts of its structure (objects inside the JSON object that represents the global context) removed, modifying the object’s structure.\nUsing GlobalContext.clear() Global context can be deleted through clear method that can be called from the GlobalContext object.\nIt is used:\nGlobalContext.clear(path)\n   Parameters Type Definition     path String Optional. Represents the path you want to remove.    1. Removing all Global Context values To remove Global context value as a whole, cleaning it, you have to use the clear command without informing a path. See below:\nAndroid Web iOS GlobalContext.clear()  Remember that in the web the global context access is always made over the BeagleService\nbeagleService?.globalContext.clear()  Remember that in the iOS the global context access is made over the BeagleDependencies\ndependencies.globalContext.clear()  This way, the global context VALUE it will be completely erased and it will have an empty value (\"\"), if called from its GlobalContext.get() function.\n2. Removing a Global Context attribute/property Imagine, for example, a global context that has two properties, like the following ones:\nProperty 1 Property 2  GlobalContext.set(path = \"myValue1\", value = \"My Context Value1\") GlobalContext.set(path = \"myValue2\", value = \"My Context Value2\")   beagleService?.globalContext.set(\"My Context Value1\", \"myValue1\") beagleService?.globalContext.set(\"My Context Value2\", \"myValue1\")  This global context is built by Beagle as a JSON object, like this:\n{ \"myValue1\":\"My Context Value1\", \"myValue2\":\"My Context Value2\" } Using the command:\nAndroid Web iOS GlobalContext.clear(\"myValue1\")  beagleService?.globalContext.clear(\"myValue1\")  dependencies.globalContext.clear(myValue1\")  The property represented by path “myValue1” will be completly removed from the glova context, that it will be:\n{ \"myValue2\":\"My Context Value2\" } ","excerpt":" What is it? A Global Context is a variable that can assume as value …","ref":"/docs-beagle/docs/api/global-context/","title":"Global Context"},{"body":" O componente validator é uma interface que informa ao formulário quando habilitar o botão de FormSubmit. Ele tem como base o conceito de observability, no qual o FormInput irá validar as informações submetidas e, então, enviá-las ao validator.\nExistem duas maneiras de usar o Form Validator:\n Clicando no FormSubmit Chamando pelo método notifyObservers dentro do FormInput.  Atenção: ``Validator ≠ FormValidation.\nApesar dos nomes parecidos, é importante deixar claro que o Validator é diferente do FormValidation. Isso porque o primeiro autentica o formulário preenchido, enquanto que o segundo retorna mensagens de erro em caso de falha nas informações do form.\n ","excerpt":" O componente validator é uma interface que informa ao formulário …","ref":"/docs-beagle/pt/docs/api/componentes/formul%C3%A1rios/validator/","title":"Validator"},{"body":" What are events? Events are anything that can trigger actions on Beagle (Beagle Actions). In the JSON, every key is associated to a Beagle Action that represents an event.\nSee some events example:\n onPress onError onFocus onChange  An event can be part of the component contract or a Beagle action. Abutton, for example, it is a component onPress is an event that it is part of its contract. An action sendRequest, it’s an example of action where the events “onSuccess”, “onError” and “onFinish” are part of the contract.\nHow to use it? See the example with the event onPress button:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click to show message\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Sou um alert\", \"message\" : \"Hello Beagle\" } ] }  Button( text = \"Click to show message\", onPress = listOf( Alert( title = \"I'm an alert\", message = \"Hello Beagle\" ) ) )  The example above, associates the action “beagle:alert” to the event onPress of the beagle:button component. When you bress the button where the title is “Click to show message”, a message will be shown on the screen with the text “Hello World!”.\nEvery event in any component or action can be associated with any Beagle Action. An alert action was used in the previous example, but any other can be used. To make a request when clicking the button, the action “beagle:sendRequest” could be used. For more information about all available actions, access here.\n","excerpt":" What are events? Events are anything that can trigger actions on …","ref":"/docs-beagle/docs/api/events/","title":"Events"},{"body":" O que é? OsimpleForm é responsável por renderizar um formulário em tela.\nA sua estrutura é representada como mostrado abaixo:\n   Atributo Tipo Obrigatório Definição     onSubmit List \u003cAction\u003e ✓ Array de ações que esse botão pode disparar quando um formulário é enviado   children List\u003cServerDrivenComponent\u003e ✓ Define a lista de componentes visuais que compoe o formulário (server-driven)   context ContextData  Adiciona um contexto para o simple form    Como usar? Ao criar um formulário é importante entender dois passos respectivamente\n A relação e atualização entre os campos E o que acontece quando o butão Submit é presionado.  Atualizando os campos O componente TextInput é o campo em que o usuario ou o sistema preencherá com alguma informação, e é importante conhecer seus atributos para melhor utiliza-lo. Aqui utilizaremos um de seus elementos , que é a função onChange.\nPara mais informações sobre esse componente vá até os detalhes do TextInput.  OnChange Essa função é parte do componente Text Input e observa as modificações feitas dentro do seu campo, ou seja, sempre que o valor for modificado, algo for digitado, apagado, etc, essa função é chamada e ativa uma lista de outras ações para acontecer sempre que o valor mudar. É nessa lista que adicionamos uma ação SetContext para definir o valor do Contexto do formulário e atualizar os valores que são mostrados no campo.\nVeja abaixo como implementamos o nosso SimpleForm\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:simpleForm\", \"context\":{ \"id\":\"myContext\", \"value\":\"\" }, \"onSubmit\":[ { \"_beagleAction_\":\"beagle:alert\", \"title\":\"Data submited\", \"message\":\"The password is @{myContext}\" } ], \"children\":[ { \"_beagleComponent_\":\"beagle:textInput\", \"value\":\"@{myContext}\", \"placeholder\":\"Type in your password\", \"onChange\":[ { \"_beagleAction_\":\"beagle:setContext\", \"contextId\":\"myContext\", \"value\":\"@{onChange.value}\" } ] }, { \"_beagleComponent_\":\"beagle:button\", \"text\":\"Click to Submit\", \"onPress\":[ { \"_beagleAction_\":\"beagle:submitForm\" } ] } ] }  SimpleForm( context = ContextData(id = \"myContext\", value = \"\"), children = listOf( TextInput( value = \"@{myContext}\", placeholder = \"Type in your password\", onChange = listOf( SetContext( contextId = \"myContext\", value = \"@{onChange.value}\" ) ) ), Button(text = \"Click to Submit\", onPress = listOf(SubmitForm())) ), onSubmit = listOf( Alert( title = \"Data submited\", message = \"The password is \" + \"@{myContext}\" ) ) )  onSubmit É uma função do SimpleForm que executa uma lista de ações. Ele é cho quando o formuário for submetido\nPara submeter um formulário é preciso utilizar a ação SubmitForm e para chama-la basta somente implementa-la em um Botão que seja parte do SimpleForm, ou seja, que esteja em sua lista de filhos.\nAo clicar nesse botão, o onSubmit é ativados e a lista de ações será executada. É essa lista de ações que definirá o que deve acontecer com as informações so formulario, se serão enviadas para um backend (através da ação sendRequest), etc\n👉 Teste esse componente no Web Playground ","excerpt":" O que é? OsimpleForm é responsável por renderizar um formulário em …","ref":"/docs-beagle/pt/docs/api/componentes/formul%C3%A1rios/simple-form/","title":"Simple Form"},{"body":" What is it? Your screen has attributes and components that can be used and configured. On the table below, we listed the main characteristics from each of these attributes.\n   Attribute Type Required Definition     identifier String  Attribute that globally identifies a screen in your application so you can attributes actions for it.   safe area Safe Area  Specifies a screen’s component position.   navigation bar Navigation Bar  Allows action/navigation’s bar on the screen.   child Server-Driven Component ✓ Define screen’s elements. It can be any visual component that extends toServerDrivenComponent.   style Style  Provide visual customization options to the screen.   screen analytics event Screen Event  Configure analytics elements to your screen.   context ContextData  Screen’s context.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Beagle Screen\", \"showBackButton\" : true, \"navigationBarItems\" : [ { \"_beagleComponent_\" : \"beagle:navigationBarItem\", \"text\" : \"\", \"image\" : { \"_beagleImagePath_\" : \"local\", \"mobileId\" : \"informationImage\" }, \"action\" : { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Screen\", \"message\" : \"Some message\", \"labelOk\" : \"OK\" } } ] }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Some text\" } ] } }  Screen( navigationBar = NavigationBar( title = \"Beagle Screen\", showBackButton = true, navigationBarItems = listOf( NavigationBarItem( text = \"\", image = Local.justMobile(\"informationImage\"), action = Alert( title = \"Screen\", message = \"Some message\", labelOk = \"OK\" ) ) ) ), child = Container( children = listOf( Text(\"Some text\") ) ) )  👉 Test this example in the Web Playground ","excerpt":" What is it? Your screen has attributes and components that can be …","ref":"/docs-beagle/docs/api/screen/","title":"Screen"},{"body":" O que é? O contexto é uma variável de qualquer tipo, incluindo o mapa que define um conjunto de pares de chaves/valores. Por meio de bindings, o valor do contexto pode ser acessado por qualquer componente ou ação do seu escopo.\nA tabela abaixo demonstra os principais atributos do contexto:\n   Atributo Tipo Obrigatoriedade Definição     id String ✓ Identificador do contexto   value Any ✓ Valor do contexto    No caso do contexto id, é importante que ele tenha apenas letras, números e o caractere “_” e deve ser ÚNICO na tela.  Quando usar? De modo geral, o contexto pode ser usado quando você quer preencher valores em um momento diferente daquele em que recebeu os componentes com o JSON.\nNo exemplo abaixo, você pode ver o contexto com dados de um usuário e sendo mostrados algumas dessas informações em um Text :\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"context\": { \"id\": \"myData\", \"value\": { \"id\": \"0000\", \"name\": \"User\", \"age\": \"18\" }, }, \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"value\": \"Name: @{myData.name}\" }, { \"_beagleComponent_\": \"beagle:text\", \"value\": \"Age: @{myData.age}\" } ] }  Container( context = ContextData( id = \"myData\", value = User( id = \"0000\" name = \"User\", age = \"18\" ) ), children = listOf( Text(\"Name: @{myData.name}\"), Text(\"Age: @{myData.age}\") ) )  Perceba que o contexto foi declarado e seus valores foram definidos e usados para preencher os textos, porém é possível definir esses valores depois usando o método SetContext() .\nDessa forma, você pode preencher os componentes com dados que ainda não estavam no JSON.\nO contexto só é útil se o valor for acessado em qualquer parte do JSON. Para isso acontecer, você precisa usar o bindings.  Como usar? Há duas formas para usar contexto: contexto explícito e implícito. A principal diferença entre eles é o escopo do contexto, que pode (ou não) ser definido dentro do JSON ou da estrutura declarativa que estiver usando.\nEscopo do contexto O escopo de um contexto é o componente no qual seus descendentes são definidos. Isso torna possível acessar o contexto declarado em uma outra branch da árvore.\nUm contexto pode ser estabelecido em qualquer componente do Beagle que implementa o ContextComponent, que é a propriedade do context que pode especificar os seguintes componentes:\n Container Screen ScrollView PageView TabView Custom Components, que implementa o ContextComponent  1. Contexto explícito Quando há um escopo definido para o contexto dentro do seu JSON ou da sua estrutura declarativa.\nVeja o exemplo abaixo de como funciona:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{myText}\" } ], \"context\" : { \"id\" : \"myText\", \"value\" : \"Hello Beagle\" } }  Container( context = ContextData( id = \"myData\", value = User( id = \"0000\" name = \"User\", age = \"18\" ) ), children = listOf( Text(\"Name: @{myData.name}\"), Text(\"Age: @{myData.age}\") ) )  Perceba que o contexto foi declarado e seus valores foram definidos e usados para preencher os textos, porém é possível definir depois esses valores usando o método SetContext() . Dessa forma, você pode preencher os componentes com dados que ainda não estavam no JSON.\n2. Contextos implícitos Quando não há um escopo de contexto definido dentro do JSON ou da estrutura declarativa da sua tela, mas que podem ser acessados por bindings.\nIsso significa que esse tipo de contexto é criado por meio de eventos.\nAlém disso, o escopo desse tipo de contexto é definido apenas por uma action ou um conjunto de ações relacionados ao evento criado no contexto.\n Em alguns casos, é necessário acessar uma informação específica sobre um evento que engatilhou uma ação. Um exemplo comum é o onChange event, que é lançado por qualquer componente e permite a entrada de dados.\nCaso mude o valor de uma entrada de um componente e as ações a serem lançadas dependem desse valor, é fundamental que você tenha acesso ao novo valor do componente.\nOutra característica do contexto implícito é que ele sempre possui um id igual ao nome do evento criado. Se, por exemplo, o evento é o onCharge, o escopo do contexto terá id onChange e binding ficará dessa forma:{ value: newValue }, no qual newValue é o campo que você pode incluir um novo valor a ser usado.\nVeja o exemplo abaixo com o evento onBlur , que funciona exatamente como o onChange, mas faz a requisição quando o input do componente perde o foco:\n{ \"_beagleComponent_\": \"beagle:textinput\", \"label\": \"CEP\", \"onBlur\": [ { \"_beagleAction_\": \"beagle:sendRequest\", \"url\": \"https://viacep.com.br/ws/@{onBlur.value}/json\", \"method\": \"GET\" } ] } Apesar do contexto onBlur não ter sido declarado no exemplo acima, você consegue usá-lo porque ele foi criado de uma maneira implícita pelo evento onBlur.\nO que acontece é que o JSON define a view onde o foco se perdeu no campo de CEP e a ação é rodada para procurar o endereço com base no valor digitado. O resultado da requisição pode ser usado para definir o valor de outros campos no formulário de endereço.\nVocê pode conferir um exemplo de uso de contexto implícito no Beagle Web no Beagle Playground.  Exemplos de eventos criados com contexto implícito:\n onChange onFocus onBlur onSuccess onError onFinish  Os três primeiros eventos são parte do contrato do componente beagle:textinput enquanto os três últimos são parte da ação beagle:sendRequest .\nBinding O binding é a string em um formato especial, que identifica o valor dentro de um contexto. Sem ele, não é possível criar contextos, sejam eles implícitos ou explícitos.\nDurante o processo de renderização do Beagle, bindings podem ser substituídos pelos valores que são referenciados a ele.\nUm binding é identificado com o prefixo**@{** e o sufixo **}**. Isso significa que tudo entre esses símbolos serve como uma expressão do contexto, que deve ser substituído quando você renderizar a tela.\nVeja o exemplo abaixo de como funciona:\nJSON kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{myText}\" } ], \"context\" : { \"id\" : \"myText\", \"value\" : \"Hello Beagle\" } }  Container( children = listOf( Text(\"@{myText}\") ), context = ContextData( id = \"myText\", value = \"Hello Beagle\" ) )  Para acessar o texto “Hello Beagle” por meio de bindings, é preciso especificar o id do contexto: @{myText}.\nNo exemplo acima, o valor do contexto é uma simples string, mas você pode ver nos tópicos a seguir como acessar valores em contextos que são mapas ou arrays.\nTipos de Bindings Binding multi-valorados (key/value maps) É o tipo de binding no qual o valor do contexto será, geralmente, uma chave/valor de um map (key/value map).\nNesses casos, os bindings devem ser usados para acessar subestruturas. Como acontece na maior parte de linguagens de programação, o Beagle usa pontos para fazer esse tipo de acesso, como você pode ver no exemplo abaixo:\n Para acessar o CPF, use o binding @{user.cpf} ; Para acessar o número de telefone, use o binding @{user.phoneNumber.cellphone}.  JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{user.phoneNumber.cellphone}\" } ], \"context\" : { \"id\" : \"user\", \"value\" : { \"cpf\" : \"014.225.235-12\", \"phoneNumber\" : { \"cellphone\" : \"(34) 98856-8563\", \"telephone\" : \"(34) 3214-5588\" } } } }  No Kotlin é necessario que se crie algumas classes para gerenciar os contextos multivalorados\nContainer( children = listOf( Text(\"@{user.phoneNumber.cellphone}\") ), context = ContextData( id = \"user\", value = User( cpf = \"014.225.235-12\", phoneNumber = PhoneNumber( cellphone = \"(34) 98856-8563\", telephone = \"(34) 3214-5588\" ) ) ) ) data class User(val cpf: String, val phoneNumber:PhoneNumber) data class PhoneNumber(val cellphone:String, val telephone:String)  Binding com vetores (arrays) É o tipo de binding no qual o valor do contexto será, geralmente, vetores (arrays).\nSe um vetor é usado no valor do contexto para acessar uma posição especifica, você deve usar o caractere [ e ] quando estiver construindo um binding.\nVeja como no exemplo abaixo:\nPara acessar o título do segundo filme (“Contact”), use o binding @{movies.titles[1].title}.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{movies.titles[1].title}\" } ], \"context\" : { \"id\" : \"movies\", \"value\" : { \"genre\" : \"sci-fi\", \"titles\" : [ { \"title\" : \"Inception\", \"year\" : \"2010\", \"rating\" : \"8.8\" }, { \"title\" : \"Contact\", \"year\" : \"1997\", \"rating\" : \"7.4\" } ] } } }  No Kotlin é necessário que se crie algumas classes para gerenciar os contextos multi-valorados\nContainer( children = listOf( Text(\"@{movies.titles[1].title}\") ), context = ContextData( id = \"movies\", value = Movie( genre = \"sci-fi\", titles = listOf( Title( title = \"Inception\", year = \"2010\", rating = \"8.8\" ), Title( title = \"Contact\", year = \"1997\", rating = \"7.4\" ) ) ) ) ) class Movie(val genre: String, val titles:List\u003cTitle\u003e) class Title(val title:String, val year:String, val rating:String)  O que acontece se eu atribuir um binding a uma variável que não existe? Bindings que se referem a contextos não existentes ou inválidos não podem ser atualizados e irão aparecer na tela da mesma forma que a string foi definida literalmente (no caso, se o atributo recebido é uma string).\nPor exemplo, se você usar @{client.name} e o \"client\" o contexto não é acessível (declarado), se o binding não for substituído por nenhum valor. O mesmo aconteceria se o contexto “client” não existisse, mas o tem a propriedade “name”.\nBindings múltiplos em strings É possível usar mais de um binding em uma única string e eventos estáticos misturados com bindings.\nVeja como no exemplo abaixo:\nExemplo: \"Hello @{person.name}. Your score is @{score.value}.\"\nAdicionando suporte para bindings em componentes customizados Em cada sistema, o binding deve ser declarado de uma forma:\n Android: Todos os atributos recebem uma expressão que deve ser declarada como Bind. iOS: Os atributos que recebem um binding devem ser declarados como Expression para fazer o mesmo efeito que no Android. Web: Não é necessário lidar com bindings de uma maneira especial, o que significa que nada deve ser feito em seus componentes.  Exemplos de cada sistema operacional:\nAndroid iOS data class MyComponent( val text: Bind\u003cString\u003e ) : WidgetView() { override fun buildView(rootView: RootView): View { val view = MyView(rootView.getContext()) // To make bind works you have to call the observeBindChanges method  // passing a rootView and the attribute that has a bind  observeBindChanges(rootView, text) { view.setText(it) } return view } }  public struct MyComponent: Widget { public var widgetProperties: WidgetProperties public let text: Expression\u003cString\u003e public func toView(renderer: BeagleRenderer) -\u003e UIView { let textView = UITextView() // To make bind works you have to call the observeBindChanges method // passing a rootView and the attribute that has a bind renderer.observe(text, andUpdate: \\.text, in: textView) return textView } }  A forma de referenciar uma expressão em Kotlin DSL é:\nKotlin DSL  MyComponent( text = expressionOf(\"@{myContext.hello}\") )  No entanto, caso você passe o valor hardcoded, você deve fazer dessa forma:\nKotlin DSL  MyComponent( text = valueOf(\"hello\") )  👉 Veja alguns exemplos no Playground ","excerpt":" O que é? O contexto é uma variável de qualquer tipo, incluindo o mapa …","ref":"/docs-beagle/pt/docs/api/contexto/","title":"Contexto"},{"body":" What is it? Class that defines a navigation bar in the top of the screen and it’s composed by the following attributes:\n   Attribute Type Required Definition     title String ✓ Title for the action/navigation’s bar.   show back button Bool  Enables the return bottom on the action/navigation’s bar. Default is true.   style id String  Allows local customization for the action/navigation’s bar.   navigation bar items Navigation Bar Item  Defines an item’s list for the action/navigation’s bar.   back button accessibility Accessibility  Accessibility’s informations of the backButton.    What is a NavigationBarItem? Class that defines an item for Navigation's bar and and it has the following attributes:\n   Attribute Type Required Definition     text String  Title for the bar’s item.   image Image  Image for the bar’s item.   action Action  Action that can be done when you click on the navigations bar item.   accessibility Accessibility  Accessibiliy’s options for the navigation item.   id String  Component’s identifier.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\":\"beagle:screenComponent\", \"navigationBar\":{ \"title\":\"Beagle Screen\", \"showBackButton\":true, \"navigationBarItems\":[ { \"_beagleComponent_\":\"beagle:navigationBarItem\", \"text\":\"\", \"image\":{ \"_beagleImagePath_\":\"local\", \"mobileId\":\"informationImage\" }, \"action\":{ \"_beagleAction_\":\"beagle:alert\", \"title\":\"Screen\", \"message\":\"Some message\", \"labelOk\":\"OK\" } } ] }, \"child\":{ \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Some text\" } ] } }  Screen( navigationBar = NavigationBar( title = \"Beagle Screen\", navigationBarItems = listOf( NavigationBarItem( text = \"\", image = Local.justMobile(\"informationImage\"), action = Alert( title = \"Screen\", message = \"Some message\", labelOk = \"OK\" ) ) ) ), child = Container( children = listOf( Text(\"Some text\") ) ) )  ","excerpt":" What is it? Class that defines a navigation bar in the top of the …","ref":"/docs-beagle/docs/api/screen/navigation-bar/","title":"Navigation Bar"},{"body":" O que é? As operações permitem que você crie aplicações com telas mais complexas por meio do seu backend com operações básicas como condicionais, soma, igualdade, etc. Dessa forma, os componentes não necessitam de ter esse tipo de lógica dentro deles.\nComo usar? De modo geral, as operações podem ser usadas quando você quer modificar os valores de um componente por meio de lógicas e operações em um momento diferente daquele em que recebeu os componentes com o JSON.\nNo Beagle é disponibilizado alguns operadores padrões e você pode criar suas próprias operações.\nVeja abaixo todos os operadores padrões oferecidos pelo Beagle:\n","excerpt":" O que é? As operações permitem que você crie aplicações com telas …","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/","title":"Operações"},{"body":" This attribute is exclusive for iOS platform.  What is it? Class that helps on your screen’s components area. The Safe Area guarantees that the elements from the screen stay visible to the user.\n   Attribute Type Definition     top Bool Enables a constraint of SafeArea only in top of the screen.   bottom Bool Enables a constraint de_SafeArea_ only in the bottom of the screen.   leading Bool Enables a constraint de_SafeArea_ only in the left side of the screen.   trailing Bool Enables a constraint_SafeArea_ only in the right side of the screen.    How to use it? JSON Kotlin DSL { \"_beagleComponent_\":\"beagle:screenComponent\", \"safeArea\":{ \"top\":true, \"leading\":true, \"bottom\":true, \"trailing\":true }, \"child\":{ \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Some Text\" } ] } }   child = Container( children = listOf( Text(\"Some Text\") ) ), safeArea = SafeArea( top = true, leading = true, trailing = true, bottom = true ) )  ","excerpt":" This attribute is exclusive for iOS platform.  What is it? Class that …","ref":"/docs-beagle/docs/api/screen/safe-area/","title":"Safe Area"},{"body":" Quais são?    Operadores Exemplo Ação     sum “@{sum(3,3)}” Operador de soma para elementos do tipo Int e Double.   subtract “@{subtract(4,3)}” Operador de subtração para elementos do tipo Int e Double.   multiply “@{multiply(3,3)}” Operador de multiplicação para elementos do tipo Int e Double.   divide “@{divide(3,3)}” Operador de divisão para elementos do tipo Int e Double.    Exemplo Veja um exemplo abaixo de um simples contador, onde dois botões increment e decrement, ambos com ações de SetContext que modificam o valor do contexto que possui o id counter, alterando seu valor com operações de soma e de subtração, incrementando e diminuindo o valor de 1 ao valor do texto:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar( title = \"Operations\", showBackButton = true ), child = Container( context = ContextData(\"counter\", 2), children = listOf( Text(expressionOf(\"Sum of 2 + 1 = @{sum(2, 1)}\")), Text(expressionOf(\"Counter: @{counter}\")), Button( text = \"increment\", onPress = listOf( SetContext(\"counter\", \"@{sum(counter, 1)}\")) ), Button( text = \"decrement\", onPress = listOf( SetContext(\"counter\", \"@{subtract(counter, 1)}\")) ) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Sum of 2 + 1 = @{sum(2, 1)}\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Counter: @{counter}\" }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"increment\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"counter\", \"value\" : \"@{sum(counter, 1)}\" } ] }, { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"decrement\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"counter\", \"value\" : \"@{subtract(counter, 1)}\" } ] } ], \"context\" : { \"id\" : \"counter\", \"value\" : 2 } } }  ","excerpt":" Quais são?    Operadores Exemplo Ação     sum “@{sum(3,3)}” Operador …","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-aritm%C3%A9ticos/","title":"Operadores aritméticos"},{"body":" What is it? The Screen Request is an internal Beagle class used to request which screen you want to display. This class is used when you will need to call a Server-Driven page you want to load from an activity or a native fragment on Android.\nAt first, you will only list the URL attribute that referencing the page you want to load from BFF.\nHowever, this class has other attributes, which can be used when transitioning between screens.\n   Attributes Type Required Description     URL String ✓ Defines the endpoint that returns the screen or component you wish to display.   method ScreenMethod ✓ It is an ENUM class that defines which HTTP operation you wish to do. It works as a HTTP REQUEST METHOD and it is set as GET by default.   headers Map\u003cString, String\u003e  It is used when you need to send data via an HTTP header.   body String  It is set default as null and it just needs to be implemented when you need to send a HTTP messages as**body data.**    ScreenMethod It is an ENUM and the values are:\n   Value Definition     GET The GET method requests a representation of a specific resource. Requests using the method GET must return only data.   POST The POST method it is used to submit an entity to a specific resource, frenquetly causing a change in the resource state or colateral effects on the server.   PUT The PUT method replaces all the current representation of the target resources with the data of the request.   DELETE The DELETE method removes a specific resource.   HEAD The HEAD method request an answer the same way the GET method does, however without a response body.   PATCH The PATCH method is used to apply partial modifications in a resource.    How to use it? To start a new Activity, you have to use the startActivity() method from an Activity or a Fragment creating a ServerDrivenIntent passing through a ScreenRequest with the BFF’s address of the screen, like the example below:\nstartActivity( newServerDrivenIntent\u003cServerDrivenActivity\u003e( ScreenRequest(\"URL_WITH_SCREEN_ENDPOINT\") ) ) ","excerpt":" What is it? The Screen Request is an internal Beagle class used to …","ref":"/docs-beagle/docs/api/screen-request/","title":"Screen Request"},{"body":" Quais são?    Operadores Exemplo Ação     condition “@{condition()}” Operador de condição que avalia dois elementos e verifica qual é a condição verdadeira.   not “@{not()}” Operador de negação que tem como entrada apenas um valor, e sua função é simplesmente inverter esse valor.   and “@{and()}” Operador que recebe duas entradas e resulta em um valor VERDADEIRO se os dois valores de entrada da operação forem VERDADEIROS, caso contrário o resultado é FALSO.   or “@{or()}” Operador que recebe duas entradas E resulta em um valor VERDADEIRO se ao menos UM dos dois valores de entrada da operação for VERDADEIRO, caso contrário o resultado é FALSO.    Exemplo Aqui temos o exemplo de uma tela que utiliza duas operações lógicas, condition e or, onde caso o resultado da condição do or for verdadeira o texto do componente Text se torna true, caso falso ele atribui ao texto o valor de false.\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar(title = \"Operations\", showBackButton = true), child = Container( children = listOf( Text(text = \"The text in green bellow will show if the result of `TRUE OR FALSE\"), Text( expressionOf(\"@{condition(or(true, false), 'true', 'false')}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text in green bellow will show if the result of `TRUE OR FALSE\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(or(true, false), 'true', 'false')}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" Quais são?    Operadores Exemplo Ação     condition “@{condition()}” …","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-l%C3%B3gicos/","title":"Operadores lógicos"},{"body":" What is it? A Widget is an abstract class that allows a visual component to be referenced on Beagle. When a visual component extends from a widget, it gets 3 attributes that enables some them, with its functions in the viewed elements.\nIt is important to remember that, by default, these structures have null value.  abstract class Widget : StyleComponent, AccessibilityComponent, IdentifierComponent { override var id: String? = null override var style: Style? = null override var accessibility: Accessibility? = null } We list below all the attributes a widget can receive. But, if you want an use example and how to create a widget, see our section creating a component. \nWhich are the attributes? Widget’s attributes The main attributes of this class are:\n   Attribute Definition     id  string parameter that identifies the visual component listed by a widget.   \nstyle  This attribute is defined by a Style class that is configured to define a series of visual properties.    data class Style ( val backgroundColor: String? = null, val cornerRadius: CornerRadius? = null, val size: Size? = null, val margin: EdgeValue? = null, val padding: EdgeValue? = null, val position: EdgeValue? = null, val flex: Flex? = null, val positionType: PositionType? = null, val display: Display? = null) Style attributes The main attributes are:\n   Attribute  Description     backgroundColor  It defines with a string parameter the background color of a visual component. It is important that the color is listed with hexadecimal format, starting with #. For example: white color in a background \"FFFFFF\".   cornerRadius  Defines with a double value the rouding edge of this component.   size  Defines a size of a component with a whole value. This value must be followed by a .unitPercent() notation to define a percentage size related to the application's screen, or using the .unitReal() notation to define a size in pixels. A 80.unitPercent() value defines that a component will have a relative size of 80% of a screen. And 80.unitReal() defines a 80 pixels size.\n\n   margin  It determines the margin that will affect the spacing around the element, it will help them move according the internal limits of its father and brothers elements.\nThe margin element contributes to the total size of its father, for example, if the father element is automatically sized.\n   padding  Defines internal spaces of the component, it behaves like 'internal margin' of the element. For example, a container has two visuals elements that defines a padding value, so that internal elements aren't glued to the internal margins.   position  Attribute that adds a padding to a position. For more details about how it works, check our documentation about position attributes in component's layout.     flex  Flex attribute positions the elements on a screen. For more details about it, check our documentation aboutFlex.    positionType  \u003cb\u003e\u003c/b\u003ePosition Type attribute establishes a relation with the element's positioning and its brothers.   display  Attribute that defines if the element linked to this widget will be positioned by Flex.      Accessibility attributes The main attributes are:\n   Attribute Description     accessible Enable a boolean value with accessibility information.   accessibilityLabel Defines with a string message for accessibility.    How to use it? On the example below, we used a Container to show the widgets attributes. The class defines a visual component that must extend the widget class.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Sou um texto Server-Driven\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Sou outro texto Server-Driven\" } ], \"id\" : \"SouUmWidget\", \"style\" : { \"backgroundColor\" : \"#ff8100\", \"cornerRadius\" : { \"radius\" : 25.0 }, \"size\" : { \"width\" : { \"value\" : 70.0, \"type\" : \"PERCENT\" }, \"height\" : { \"value\" : 80.0, \"type\" : \"REAL\" } }, \"margin\" : { \"all\" : { \"value\" : 20.0, \"type\" : \"REAL\" } }, \"padding\" : { \"all\" : { \"value\" : 15.0, \"type\" : \"REAL\" } }, \"position\" : { \"left\" : { \"value\" : 0.0, \"type\" : \"REAL\" } }, \"flex\" : { \"flexDirection\" : \"ROW\" }, \"positionType\" : \"RELATIVE\", \"display\" : \"FLEX\" }, \"accessibility\" : { \"accessible\" : true, \"accessibilityLabel\" : \"Sou acessível\" } }  Container( listOf( Text(\"Sou um texto Server-Driven\"), Text(\"Sou outro texto Server-Driven\") ) ).applyStyle( Style(backgroundColor = \"#ff8100\", cornerRadius = CornerRadius(25.0), size = Size(width = 70.unitPercent(), height = 80.unitReal()), margin = EdgeValue(all = 20.unitReal()), padding = EdgeValue(all = 15.unitReal()), position = EdgeValue(0.unitReal()), flex = Flex(FlexDirection.ROW), positionType = PositionType.RELATIVE, display = Display.FLEX) ).applyAccessibility(accessibility = Accessibility( accessible = true, accessibilityLabel = \"Sou acessível\") ).setId(\"SouUmWidget\")  👇 Test this component in the Web Playground {% embed url=“https://beagle-playground.netlify.app/#/demo/default-components/container.json” %}}\n","excerpt":" What is it? A Widget is an abstract class that allows a visual …","ref":"/docs-beagle/docs/api/widget/","title":"Widget"},{"body":" Quais são?    Operadores Exemplo Ação     gt\n(Maior)\n \"@{gt(3,4)} Operador que recebe duas entradas e resulta em verdadeiro se o primeiro valor for maior que o segundo.   gte\n(Maior ou Igual)\n \"@{gte(3,4)}\" Operador que recebe duas entradas e resulta em verdadeiro se o primeiro valor for maior ou igual ao segundo.   lt\n(Menor)\n @{lt(3,4)}\" Operador que recebe duas entradas e resulta em verdadeiro se o primeiro valor for menor que o segundo.   lte\n(Menor ou igual)\n \"@{lte(3,4)}\" Operador que recebe duas entradas e resulta em verdadeiro se o primeiro valor for menor ou igual ao segundo.   eq\n(Igual)\n \"@{eq(4,4)}\" Operador que recebe duas entradas e resulta em verdadeiro se o os dois valores são iguais.    Exemplo Aqui, o exemplo é de uma tela que utiliza a operação de comparação lt, que verifica se o valor da soma de counter e:\n Se o resultado da condição do or for verdadeira, o texto do componente Text se torna true; Caso falso ele atribui ao texto o valor de false.  Kotlin JSON fun screen() = Screen( navigationBar = NavigationBar( title = \"Operations\", showBackButton = true ), child = Container( children = listOf( Text(text = \"The text bellow will show if 4 is below 5 or not\"), Text(expressionOf( \"@{condition(lt(4, 5), 'less then 5', 'greater then 5')}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Operations\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text bellow will show if 4 is below 5 or not\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(lt(4, 5), 'less then 5', 'greater then 5')}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" Quais são?    Operadores Exemplo Ação     gt\n(Maior)\n \"@{gt(3,4)} …","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-de-compara%C3%A7%C3%A3o/","title":"Operadores de comparação"},{"body":" Quais são?    Operadores Exemplo Ação     concat “@{concat(“cachorro”, “quente”)}” Operador que concatena as strings que tiver como entrada.   capitalize “@{capitalize(brasil)}” Operador que transforma a primeira letra da string em uma letra maiúscula.   uppercase “@{uppercase(brasil)}” Operador que transforma a todas as letras de uma string em letras maiúsculas.   lowercase “@{lowecase(BRASIL)}” Operador que transforma a todas as letras de uma string em letras minúsculas.   substr “@{substr(brasil, 3)}” Operador que retorna uma substring da string de entrada. Essa operação pode ter 2 ou 3 entradas, onde o primeiro parâmetro é a string e o segundo e terceiro parâmetro são os limitadores da string.    Exemplo Nesse exemplo, uma tela possui um texto com uma operação de substring, no qual sua frase é ‘The book is on the table’ e os parâmetros 4, 11 ditam o limite dessa substring, a tornando a seguinte string ‘book is on’:\nKotlin JSON fun screen() = Screen(child = Container( children = listOf( Text(text = \"The text bellow is a substring of `The book is on the table`.\"), Text( expressionOf(\"@{substr('The book is on the table', 4, 11)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\") ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"The text bellow is a substring of `The book is on the table`.\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{substr('The book is on the table', 4, 11)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ] } }  ","excerpt":" Quais são?    Operadores Exemplo Ação     concat …","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-para-manipula%C3%A7%C3%A3o-de-string/","title":"Operadores para manipulação de string"},{"body":" Quais são?    Operadores Exemplo Ação     insert “@{insert(array, 5)}” Operador que recebe duas entradas onde o primeiro parâmetro é um array e o segundo é o elemento que deseja inserir nesse array.   remove “@{remove(array, 1)}” Operador que recebe duas entradas onde o primeiro parâmetro é um array e o segundo é o elemento que deseja remover desse array.   removeIndex “@{removeIndex(array, 2)}” Operador que recebe duas entradas onde o primeiro parâmetro é um array e o segundo é o index do elemento que deseja remover desse array.   contains “@{contains(array, 3)}” Operador que recebe duas entradas onde o primeiro parâmetro é um array e o segundo é o elemento que deseja verificar se contém no array.    Exemplo Veja o exemplo de uma tela no qual foi declarado um contexto com id numbersArray com o valor de [0, 1, 2, 3, 4], esse contexto é usado na operação de removeIndexno texto do component Text, onde ele remove o elemento de index 2.\nKotlin JSON fun screen() = Screen(child = Container( context = ContextData(id = \"numbersArray\", value = arrayOf(0,1,2,3,4)), children = listOf( Text(text = \"Array was [0, 1, 2, 3, 4] and after removing index 2 now is: \"), Text( expressionOf(\"@{removeIndex(numbersArray, 2)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Array was [0, 1, 2, 3, 4] and after removing index 2 now is: \" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{removeIndex(numbersArray, 2)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ], \"context\" : { \"id\" : \"numbersArray\", \"value\" : [ 0, 1, 2, 3, 4 ] } } }  ","excerpt":" Quais são?    Operadores Exemplo Ação     insert “@{insert(array, …","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/operadores-para-manipula%C3%A7%C3%A3o-de-arrays/","title":"Operadores para manipulação de arrays"},{"body":" Quais são?    Operadores Exemplo Ação     isNull “@{isNull(context)}” Operador que verifica se o paramêtro é nulo.   isEmpty “@{isEmpty(\")}” Operador que recebe uma entrada e verifica se ela é vazia.   length “@{length(tamanho)}” Operador que recebe uma entrada e retorna o seu tamanho.    Exemplo Um contexto com id numbersArray que possui como valor [0, 1, 2, 3, 4] e a operação length foi utilizada em um componente Text para pegar o tamanho desse array, veja abaixo:\nKotlin JSON fun screen() = Screen(child = Container( context = ContextData(id = \"numbersArray\", value = arrayOf(0,1,2,3,4)), children = listOf( Text(text = \"Array [0, 1, 2, 3, 4] has size: \"), Text( expressionOf(\"@{length(numbersArray)}\") ).applyStyle(Style(backgroundColor = \"#00FF00\")) ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Array [0, 1, 2, 3, 4] has size: \" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{length(numbersArray)}\", \"style\" : { \"backgroundColor\" : \"#00FF00\" } } ], \"context\" : { \"id\" : \"numbersArray\", \"value\" : [ 0, 1, 2, 3, 4 ] } } }  ","excerpt":" Quais são?    Operadores Exemplo Ação     isNull “@{isNull(context)}” …","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/outros-operadores/","title":"Outros operadores"},{"body":" Depois que você viu que é possível realizarOperações do tipo soma, subtração, etc, utilizando o contexto, você também pode criar a sua própria operação na plataforma que você quiser:\niOS  O registro de uma operação no iOS é feito através de um protocolo chamado OperationsProvider, veja abaixo:\npublic protocol OperationsProvider { func register(operationId: String, handler: @escaping OperationHandler) func evaluate(with operation: Operation, in view: UIView) -\u003e DynamicObject } Para registrar sua operação customizada, você deve fazer duas coisas:\n Prover um id para essa operação; Prover a ela a ação que irá acontecer por meio de uma closure do tipo OperationHandler.  O OperationHandler é um typealias de um bloco de código que retorna DynamicObject por meio de parâmetros do tipo [DynamicObject].\npublic typealias OperationHandler = (_ parameters: [DynamicObject]) -\u003e DynamicObject Agora, para registrar a sua nova operação basta utilizar o BeagleDependencies, onde nele você acessa o OperationsProvider, no qual tem a função de registro.\nlet dependencies = BeagleDependencies() dependencies.operationsProvider.register(operationId: \"isValidCpf\") { parameters in let anyParameters = parameters.map { $0.asAny() } if let intParameters = anyParameters.first as? Int { let stringParameters = String(intParameters) return .bool(stringParameters.isValidCPF) } else if let stringParameters = anyParameters.first as? String { return .bool(stringParameters.isValidCPF) } return nil } Pronto! Sua operação já pode ser utilizada!\n Exemplo Veja abaixo o exemplo utilizando a operação isValidCpf que foi criada acima, onde o texto do componente Text varia de acordo com o resultado da verificação se o CPF é válido ou não:\nKotlin JSON fun screen() = Screen( navigationBar = NavigationBar(title = \"Custom operation\", showBackButton = true), child = Container( context = ContextData(\"cpf\", \"00000000000\"), children = listOf( Button(\"CPF atual: @{cpf}\", onPress = listOf( SetContext( contextId = \"cpf\", value = \"42249625000\" ) )), Text(text = \"@{condition(isValidCpf(cpf), 'cpf is valid', 'cpf is not valid')}\") ) ) )  { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Custom operation\", \"showBackButton\" : true }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"CPF atual: @{cpf}\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:setContext\", \"contextId\" : \"cpf\", \"value\" : \"42249625000\" } ] }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"@{condition(isValidCpf(cpf), 'cpf is valid', 'cpf is not valid')}\" } ], \"context\" : { \"id\" : \"cpf\", \"value\" : \"00000000000\" } } }  ","excerpt":" Depois que você viu que é possível realizarOperações do tipo soma, …","ref":"/docs-beagle/pt/docs/api/contexto/opera%C3%A7%C3%B5es/como-registrar-uma-nova-opera%C3%A7%C3%A3o/","title":"Como registrar uma nova operação"},{"body":" O que é? O Contexto Global é uma variável que pode assumir como valor qualquer tipo de variável, como um mapa definindo um conjunto de pares chave/valor ou objetos JSONs complexos que definem árvores de objetos.\nEle funciona exatamente como o Contexto, no entanto, com um escopo global, ou seja, ele existirá enquanto a aplicação estiver rodando (mesmo em background), o que o permite ser acessado a partir de qualquer ponto da aplicação, seja esse ponto um componente ou ação vinculada a um componente ou mesmo programaticamente.\nComo acessar? Ele pode ser acessado a partir de uma expressão em uma página declarativa, como por exemplo \"@{global.user}\" ou programaticamente, a partir de um objeto GlobalContext.get().\nDesta forma, é possível compartilhar informações entre a parte nativa da aplicação, parte server-driven e também entre diferentes telas server-driven.  Como utilizar? Para utilizar o Contexto Global é importante ressaltar algumas informações importantes:\n O Contexto Global é um Objeto do tipo ContextData. O Contexto Global pode ter como VALUE um Objeto JSON complexo, que pode conter uma árvore de objetos em si mesmo. É um Singleton.  Por default o ID de um contexto global será sempre “global”.  Como criar um Contexto Global? O Contexto Global é criado juntamente com a aplicação. É definido internamente no Beagle como um objeto do tipo ContextData que armazenará qualquer informação definida no contexto global.\nComo definir um Contexto Global? Um contexto que seja global pode ser definido de duas formas:\n A partir de um componente declarativo (utilizando a AçãoSetContext) ou Programaticamente, utilizando a função set() a partir do objeto GlobalContext  1. Usando o SetContext É possível definir ou modificar um contexto global a partir da Ação SetContext Para tal, basta identificar o contexto global utilizando a ID = \"global\" na propriedade contextId, como mostrado no exemplo abaixo:\nJSON Kotlin DSL { \"_beagleComponent_\": \"beagle:container\", \"children\": [ { \"_beagleComponent_\": \"beagle:text\", \"text\":\"@{global.myValue}\" }, { \"_beagleComponent_\": \"beagle:button\", \"text\": \"Open Modal\", \"onPress\": [ { \"_beagleAction_\": \"beagle:setContext\", \"contextId\": \"global\", \"path\": \"myValue\", \"value\": \"Context has changed\" } ] } ] }  Container( children = listOf( Text(text = \"@{global.myValue}\"), Button(text = \"Open Modal\", onPress = listOf( SetContext( contextId = \"global\", path = \"myValue\", value = \"Context has changed\" ) ) ) ) )  Ao definir o valor (value) de um contexto qualquer, é importante analisar sua estrutura. Se nenhum valor for passado na propriedade path, o valor será definido na raiz desse objeto, ou seja, qualquer outra atribuição que seja feita ao contexto vai sobrescrever qualquer informação sem um path na raiz do objeto.  No exemplo acima, o objeto JSON criado na raiz do contexto seria:\n{\"myValue\" : \"Context has changed\"} 2. Usando o GlobalContext.set() O Contexto Global também pode ser definido através de um método set que pode ser chamado a partir do objeto GlobalContext.\nPara isso é usado:\nGlobalContext.set(value, path)\n   Parâmetro Tipo Obrigatório Definição     value Any ✓ Representa a informação em si, que pode ser de qualquer tipo, como por exemplo, outros objetos JSONs, um array ou outro objeto qualquer.   path String  Representa o caminho designado que conterá essa informação, no exemplo acima, o path utilizado foi \"myValue\". O parâmetro path não é obrigatório, e quando for omitido, definirá o valor informado na raiz do objeto, sobrescrevendo qualquer outra informação.    Para definir um contexto global como o do exemplo dessa seção, utilize o comando abaixo:\nAndroid Web iOS GlobalContext.set(\"Context has changed\", \"myValue\")  Na web, o contexto global é um dos atributos do BeagleService, que a lib do beagle-angular e beagle-react disponibilizam.\nAngular:\nPara utilizar o contexto global em qualquer componente da sua aplicação você precisará injetar o BeagleProvider no construtor do seu componente, utilizar a função getBeagleUIService para ter acesso ao objeto do beagleService, acessar o globalContext e a função do globalContext desejada. Abaixo o código exemplificando como utilizar a função de set.\nimport { BeagleProvider } from '@zup-it/beagle-angular'; constructor(private beagleProvider: BeagleProvider) ... const beagleService = this.beagleProvider.getBeagleUIService() beagleService?.globalContext.set(value, path) React:\nPara utilizar o contexto global em uma aplicação React, utilize o context disponibilizado pelo beagle-react através do useContext do próprio react para ter acesso ao beagleService e através desse beagleService, acesse o globalContext e a função desejada, no exemplo abaixo, a função de set é utilizada.\nimport context from '@zup-it/beagle-react/provider' ... const beagleService = useContext(context) beagleService?.globalContext.set(value, path)  No iOS o Contexto Global é um dos atributos do Beagle Dependencies .\nPara utilizar o contexto global em qualquer componente da sua aplicação você precisará chamar o BeagleDependencies do seu projeto como no exemplo abaixo:\ndependencies.globalContext.setValue(value: \"Context has changed\", path: \"myValue\") O valor do contexto é um DynamicObject, portanto ele pode assumir qualquer tipo de valor.\n  O contexto global pode ser recuperado de duas formas:\n Usando expressões (assim como qualquer contexto) ou Função get chamada a partir do Objeto GlobalContext.  1. Usando a expressão “@{global}” Para recuperar o valor atribuído a um contexto global basta utilizar a expressão “@{global}”.\nNo exemplo utilizado nessa seção, atribuímos um valor ao contexto global utilizando o path \"myValue\" , dessa forma, para recuperá-lo basta usar a expressão \"@{global.myValue}\" o que retornará a string “Context has changed”.\n Caso utilize somente a expressão \"@{global}\" , o valor retornado será o objeto JSON inteiro:  {“myValue” : “Context has changed”}    Essas expressões são observadas pelo contexto e são atualizadas conforme o contexto muda, no entanto elas precisam estar em uma tela declarativa.  2. Usando o GlobalContext.get() O Contexto Global também pode ser recuperado através de um método get que pode ser chamado a partir do objeto GlobalContext.\nPara isso é usado:\nGlobalContext.get(path)\n   Parâmetro Tipo Obrigatório Definição     path String  Representa o caminho designado que conterá essa informação, no exemplo acima, o path utilizada foi \"myValue\". O parâmetro path é opcional e caso não seja passado todo o valor do contexto global será retornado.    Considerando o exemplo anterior, para recuperar o valor do Contexto Global que está no path “myValue”, utilize o comando:\nAndroid Web iOS GlobalContext.get(\"myValue\")  Acima foram mostradas todas as configs para utilização do set. A config para o get é a mesma, porém mudando apenas o método do globalContext que será acessado:\nbeagleService?.globalContext.get(\"myValue\")  Assim como no método set será necessário chamar as dependências do Beagle para utilizar o contexto global como no exemplo abaixo:\ndependencies.globalContext.get(path: \"myValue\")   Da mesma forma, ao utilizar o GlobalContext.get() sem nenhum parâmetro como path, esse método retornará o objeto JSON inteiro -\u003e {\"myValue\" : \"Context has changed\"}  Removendo um Contexto Global O contexto global só é destruído com o encerramento da aplicação, e mesmo se estiver vazio, pode ser chamado de qualquer lugar da aplicação, pois “existe” enquanto a aplicação “existir”.\nNo entanto, ele pode ser apagado (reset) ou ter partes de sua estrutura (Objetos dentro do objeto JSON que representa o contexto global) removidas, modificando a estrutura do objeto.\nUsando o GlobalContext.clear() O Contexto Global pode ser apagado através do método clear que pode ser chamado a partir do objeto GlobalContext.\nPara isso é usado:\nGlobalContext.clear(path)\n   Parâmetro Tipo Obrigatório Definição     path String  Opcional. Representa o caminho que se deseja remover.    1. Removendo todos os valores do Contexto Global Para remover os valores de um Contexto Global por completo, “limpando-o”, devemos utilizar o comando clear sem informar um path. Veja abaixo:\nAndroid Web iOS GlobalContext.clear()  Lembre-se que na web o acesso ao contexto global sempre é feito atráves do beagleService:\nbeagleService?.globalContext.clear()  Lembre-se que no iOS o acesso ao contexto global é feito através do BeagleDependencies\ndependencies.globalContext.clear()  Dessa forma, o VALUE do Contexto Global será apagado totalmente e terá um valor vazio (\"\") caso chamado a partir de sua função GlobalContext.get()\n2. Removendo um atributo/propriedade do Contexto Global Por exemplo, imagine um contexto global que tenha duas propriedades definidas a seguir\nPropriedade 1 Propriedade 2  GlobalContext.set(path = \"myValue1\", value = \"My Context Value1\") GlobalContext.set(path = \"myValue2\", value = \"My Context Value2\")   beagleService?.globalContext.set(\"My Context Value1\", \"myValue1\") beagleService?.globalContext.set(\"My Context Value2\", \"myValue1\")  Esse Contexto Global é construído pelo Beagle como o objeto JSON a seguir:\n{ \"myValue1\":\"My Context Value1\", \"myValue2\":\"My Context Value2\" } Ao utilizar o comando:\nAndroid Web iOS GlobalContext.clear(myValue1\")  beagleService?.globalContext.clear(\"myValue1\")  dependencies.globalContext.clear(myValue1\")  A propriedade representada pelo path “myValue1” será completamente removida contexto global, que será:\n{ \"myValue2\":\"My Context Value2\" } ","excerpt":" O que é? O Contexto Global é uma variável que pode assumir como valor …","ref":"/docs-beagle/pt/docs/api/contexto-global/","title":"Contexto Global"},{"body":" O que são? Eventos são tudo que podem disparar ações do Beagle (Beagle Actions). No JSON, toda chave que é associada a uma Beagle Action representa um evento.\nVeja alguns exemplos de eventos:\n onPress onError onFocus onChange  Um evento pode ser parte do contrato de um componente ou de uma Beagle Action. Um botão, por exemplo, é um componente e “onPress” é um evento que faz parte do seu contrato. A ação sendRequest, é um exemplo de ação onde os eventos “onSuccess”, “onError” e “onFinish” são parte do contrato.\nComo usar? Veja o exemplo com o evento “onPress” do botão:\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:button\", \"text\" : \"Click to show message\", \"onPress\" : [ { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Sou um alert\", \"message\" : \"Hello Beagle\" } ] }  Button( text = \"Click to show message\", onPress = listOf( Alert( title = \"I'm an alert\", message = \"Hello Beagle\" ) ) )  No exemplo acima, associa-se a ação “beagle:alert” ao evento “onPress” do componente “beagle:button”. Ou seja, ao pressionar o botão cujo título é “click to show message”, uma mensagem de alerta será exibida na tela com o texto “Hello World!”.\nTodo evento em qualquer componente ou ação pode ser associado a qualquer Beagle Action. Foi utilizada a ação de alerta no exemplo anterior, mas qualquer outra poderia ser utilizada. Para fazer uma requisição ao clicar no botão, a ação “beagle:sendRequest” poderia ter sido usada. Para saber mais sobre a relação com todas a ações disponíveis, acesse a documentação sobre ações.\n","excerpt":" O que são? Eventos são tudo que podem disparar ações do Beagle …","ref":"/docs-beagle/pt/docs/api/eventos/","title":"Eventos"},{"body":" O que é? A sua tela possui atributos e componentes que podem ser usados e configurados. Na tabela abaixo, listamos as principais características para cada um destes atributos.\n   Atributo Tipo Obrigatório Definição     identifier String  Atributo que identifica a tela globalmente na sua aplicação, de modo que seja possível atribuir ações a ela.   safe area Safe Area  Especifica o posicionamento dos componentes na tela.   navigation bar Navigation Bar  Permite configurar a barra de ações/navegação na tela.   child Server Driven Component ✓ Define os elementos na tela. Pode ser qualquer componente visual que estenda de ServerDrivenComponent.   style Style  Fornece opções de customização visual para a Screen.   screen analytics event Screen Event  Configura elementos de análise(Analytics) na sua tela.   context ContextData  Contexto da tela.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:screenComponent\", \"navigationBar\" : { \"title\" : \"Beagle Screen\", \"showBackButton\" : true, \"navigationBarItems\" : [ { \"_beagleComponent_\" : \"beagle:navigationBarItem\", \"text\" : \"\", \"image\" : { \"_beagleImagePath_\" : \"local\", \"mobileId\" : \"informationImage\" }, \"action\" : { \"_beagleAction_\" : \"beagle:alert\", \"title\" : \"Screen\", \"message\" : \"Some message\", \"labelOk\" : \"OK\" } } ] }, \"child\" : { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"Some text\" } ] } }  Screen( navigationBar = NavigationBar( title = \"Beagle Screen\", showBackButton = true, navigationBarItems = listOf( NavigationBarItem( text = \"\", image = Local.justMobile(\"informationImage\"), action = Alert( title = \"Screen\", message = \"Some message\", labelOk = \"OK\" ) ) ) ), child = Container( children = listOf( Text(\"Some text\") ) ) )  👉 Teste esse exemplo no Playground ","excerpt":" O que é? A sua tela possui atributos e componentes que podem ser …","ref":"/docs-beagle/pt/docs/api/screen/","title":"Screen"},{"body":" O que é a NavigationBar? Classe que define a barra superior com função de navegação. É composta pelos seguintes atributos:\n   Atributo Tipo Obrigatório Definição     title String ✓ Título para a barra de ações/navegação.   showBackButton Boolean  Habilita o botão de voltar na barra de ações/ navegação. Default é true.   styleId String  Permite a customização local da barra de ações/navegação.   navigationBarItems List\u003cNavigationBarItem\u003e  Define uma lista de itens da barra de ação/navegação.   backButtonAccessibility Accessibility  Informações de acessibilidade do backButton.    O que é a NavigationBarItem? Classe que define o item da NavigationBar que é composto por:\n   Atributo Tipo Obrigatório Definição     text String ✓ Título do item da barra.   image Image  Imagem do item da barra.   action Action ✓ Ação que deve ser realizada ao clicar no item da barra de navegação.   accessibility Accessibility  Opções de acessibilidade para o navigation item.   id String  Identificador do componente.    Como usar? Para usar uma NavigationBar é necessário declarar dentro de uma Screen. Segue um exemplo abaixo:\nJSON Kotlin DSL { \"_beagleComponent_\":\"beagle:screenComponent\", \"navigationBar\":{ \"title\":\"Beagle Screen\", \"showBackButton\":true, \"navigationBarItems\":[ { \"_beagleComponent_\":\"beagle:navigationBarItem\", \"text\":\"\", \"image\":{ \"_beagleImagePath_\":\"local\", \"mobileId\":\"informationImage\" }, \"action\":{ \"_beagleAction_\":\"beagle:alert\", \"title\":\"Screen\", \"message\":\"Some message\", \"labelOk\":\"OK\" } } ] }, \"child\":{ \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Some text\" } ] } }   Screen( navigationBar = NavigationBar( title = \"Beagle Screen\", navigationBarItems = listOf( NavigationBarItem( text = \"\", image = Local.justMobile(\"informationImage\"), action = Alert( title = \"Screen\", message = \"Some message\", labelOk = \"OK\" ) ) ) ), child = Container( children = listOf( Text(\"Some text\") ) ) )  ","excerpt":" O que é a NavigationBar? Classe que define a barra superior com …","ref":"/docs-beagle/pt/docs/api/screen/navigation-bar/","title":"Navigation Bar"},{"body":" Esse atributo é exclusivo da plataforma iOS.  O que é? Classe que auxilia o posicionamento dos componentes na área da tela. Safe Area garante que os elementos que compõem sua tela estejam visíveis para o usuário.\n   Atributo Tipo Obrigatório Definição     top Boolean  Habilita a constraint de SafeArea apenas no topo da tela.   bottom Boolean  Habilita a constraint de_SafeArea_ apenas na parte de baixo da tela.   leading Boolean  Habilita a constraint de_SafeArea_ apenas à esquerda da tela.   trailing Boolean  Habilita a constraint_SafeArea_ apenas à direita da tela.    Como usar? JSON Kotlin DSL { \"_beagleComponent_\":\"beagle:screenComponent\", \"safeArea\":{ \"top\":true, \"leading\":true, \"bottom\":true, \"trailing\":true }, \"child\":{ \"_beagleComponent_\":\"beagle:container\", \"children\":[ { \"_beagleComponent_\":\"beagle:text\", \"text\":\"Some Text\" } ] } }  Screen( child = Container( children = listOf( Text(\"Some Text\") ) ), safeArea = SafeArea( top = true, leading = true, trailing = true, bottom = true ) )  ","excerpt":" Esse atributo é exclusivo da plataforma iOS.  O que é? Classe que …","ref":"/docs-beagle/pt/docs/api/screen/safe-area/","title":"Safe Area"},{"body":" O que é? A Screen Request é uma classe interna do Beagle utilizada para solicitar qual tela você deseja exibir. Esta classe é utilizada quando se deseja chamar uma tela Server-Driven a partir de uma activity ou fragment nativo no Android.\nA princípio, você listará apenas o atributo URL referente à página que deseja carregar vinda do BFF.\nNo entanto, essa classe possui outros atributos, que podem ser utilizados na transição entre telas.\n   Atributo Tipo Obrigatório Descrição     URL String ✓ Define o endpoint que retorna a página ou componente visual desejado   method ScreenMethod ✓ É um ENUM que define qual operação você deseja fazer. Ele funciona como um método HTTP request, mas que está configurado como GET, por padrão   headers Map\u003cString, String\u003e  É utilizado somente quando você deseja enviar informações nos campos de cabeçalho HTTP   body String  É definido por padrão como null e só precisa ser implementado caso seja necessário enviar uma mensagem HTTP como body data.    ScreenMethod É um ENUM, cujo os valores são:\n   Valor Definição     GET O método GET solicita a representação de um recurso específico. Requisições utilizando o método GET devem retornar apenas dados.   POST O método POST é utilizado para submeter uma entidade a um recurso específico, frequentemente causando uma mudança no estado do recurso ou efeitos colaterais no servidor.   PUT O método PUT substitui todas as atuais representações do recurso de destino pela carga de dados da requisição.   DELETE O método DELETE remove um recurso específico.   HEAD O método HEAD solicita uma resposta de forma idêntica ao método GET, porém sem conter o corpo da resposta.   PATCH O método PATCH é utilizado para aplicar modificações parciais em um recurso.    Como usar? Para iniciar uma nova Activity basta usar o método startActivity() a partir de uma Activity ou um Fragment criando um ServerDrivenIntent passando o ScreenRequest com o endereço do BFF da tela como no exemplo abaixo:\nstartActivity( newServerDrivenIntent\u003cServerDrivenActivity\u003e( ScreenRequest(\"URL_WITH_SCREEN_ENDPOINT\") ) ) ","excerpt":" O que é? A Screen Request é uma classe interna do Beagle utilizada …","ref":"/docs-beagle/pt/docs/api/screen-request/","title":"Screen Request"},{"body":" O que é? O Widget é uma classe abstrata que permite que um componente visual seja referenciado no Beagle. Quando um componente visual se estende do widget, ele herda 3 atributos que habilitam algum atributos e funcionalidades nos elementos visualizados.\nÉ importante lembrar que, por default, essas estruturas são colocadas como nulas.  abstract class Widget : StyleComponent, AccessibilityComponent, IdentifierComponent { override var id: String? = null override var style: Style? = null override var accessibility: Accessibility? = null } Abaixo listamos todos os atributos que um widget pode receber. Mas se quiser um exemplo de uso e como criar um widget, veja a seção posicionamento de componentes.\nQuais seus atributos? Atributos do Widget Os principais atributos desta classe são:\n   Atributo Tipo Obrigatório Definição     id  String  identifica o componente visual listado pelo widget.   \nstyle  Style  define uma série de propriedades visuais.   accessibility  Accessibility  define o conteúdo textual para uso de leitor de telas.    Atributos do Style Os principais atributos são:\n   Atributo  Tipo Obrigatório Definição     backgroundColor  String  Define a cor de fundo de um componente visual. Para isso, é importante que a cor seja listada em formato hexadecimal, necessariamente começando com #. Por exemplo: a cor branca em um background seria \"#FFFFFF   cornerRadius  CornerRadius  Define o arredondamento da borda desse componente   size  Size  Define o tamanho do componente com um valor inteiro . Este valor deve ser seguido da notação .unitPercent() para definir um tamanho percentual em relação a tela da aplicação, ou usando a notação .unitReal() para definir um tamanho pontual em pixels. Um valor 80.unitPercent() define que o componente terá um tamanho relativo a 80% da tela. Já 80.unitReal()define o tamanho de 80 pixels.    margin  EdgeValue  Determina a margem que afeta o espaçamento ao redor de um elemento, contribuindo para que ele se desloque de acordo com os limites internos do elemento pai e de seus irmãos.\nA margem de um elemento contribui para o tamanho total de seu pai se, por exemplo, o elemento pai for dimensionado automaticamente.\n   padding  EdgeValue  Define espaços internos no componente, ele se comporta como uma espécie de \"margem interna\" do elemento. Por exemplo, um container que tenha dois elementos visuais define um valor para padding para que os elementos internos não fiquem \"colados\" nas margens internas.   position  EdgeValue  Adiciona padding a uma posição. Para mais detalhes sobre seu funcionamento verifique nossa documentação sobre o atributo posição  em um layout de componentes.   flex  Flex   Responsável por posicionar elementos na tela. Para mais detalhes verifique nossa documentação sobre o Flex.    positionType  PositionType  Responsável por estabelecer a relação de posicionamento entre este elemento e seus irmãos.   display  Display  Define se o elemento vinculado a esse widget será posicionado pelo Flex.    Atributos do Accessibility Os principais atributos são:\n   Atributos Tipo Obrigatório Definição     accessible Boolean  Habilita informações para acessibilidade   accessibilityLabel String  Define uma mensagem para acessibilidade    Como usar? No exemplo abaixo, utilizamos um Container para exemplificar os atributos de um widget. A classe que define um componente visual deve estender da classe widget.\nJSON Kotlin DSL { \"_beagleComponent_\" : \"beagle:container\", \"children\" : [ { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"I'am a Server-Driven text\" }, { \"_beagleComponent_\" : \"beagle:text\", \"text\" : \"I'am another a Server-Driven text\" } ], \"id\" : \"WidgetID\", \"style\" : { \"backgroundColor\" : \"#ff8100\", \"cornerRadius\" : { \"radius\" : 25.0 }, \"size\" : { \"width\" : { \"value\" : 70.0, \"type\" : \"PERCENT\" }, \"height\" : { \"value\" : 80.0, \"type\" : \"REAL\" } }, \"margin\" : { \"all\" : { \"value\" : 20.0, \"type\" : \"REAL\" } }, \"padding\" : { \"all\" : { \"value\" : 15.0, \"type\" : \"REAL\" } }, \"position\" : { \"left\" : { \"value\" : 0.0, \"type\" : \"REAL\" } }, \"flex\" : { \"flexDirection\" : \"ROW\" }, \"positionType\" : \"RELATIVE\", \"display\" : \"FLEX\" }, \"accessibility\" : { \"accessible\" : true, \"accessibilityLabel\" : \"I have acessibility\" } }  Container( listOf( Text(\"I'am a Server-Driven text\"), Text(\"I'am another Server-Driven text\") ) ).applyStyle( Style(backgroundColor = \"#ff8100\", cornerRadius = CornerRadius(25.0), size = Size(width = 70.unitPercent(), height = 80.unitReal()), margin = EdgeValue(all = 20.unitReal()), padding = EdgeValue(all = 15.unitReal()), position = EdgeValue(0.unitReal()), flex = Flex(FlexDirection.ROW), positionType = PositionType.RELATIVE, display = Display.FLEX) ).applyAccessibility(accessibility = Accessibility( accessible = true, accessibilityLabel = \"I have acessibility\") ).setId(\"WidgetID\")  👇 Teste esse componente no Web Playground {% embed url=“https://beagle-playground.netlify.app/#/demo/default-components/container.json” %}}\n","excerpt":" O que é? O Widget é uma classe abstrata que permite que um componente …","ref":"/docs-beagle/pt/docs/api/widget/","title":"Widget"},{"body":" O que é o Beagle? O Beagle é um Framework open source de desenvolvimento cross-platform pautado no paradigma de implementação de um Server-Driver UI nativamente no iOS e Android. Você pode facilmente mudar o layout e DATAda sua aplicação mudando apenas o código da tela no backend.\nComo o Beagle funciona? O desenvolvedor declara telas no backend e expõe endpoints que representam essas telas. No celular ou na web, esses endpoints são chamados usando o Beagle para renderizar os componentes na tela.\nBeagle funciona como uma “ponte” entre o front e o backend possibilitando que componentes de design da aplicação sejam parametrizado ao backend, com possibilidade de aplicação nativa.\nA arquitetura do meu aplicativo mudará se eu usar o Beagle? Não, o Beagle é agnóstico em relação a arquitetura e não interfere na arquitetura do projeto em que é utilizado.\nPor que usar o Beagle e não o React Native ou Flutter? A solução do Beagle é diferente de outras tecnologias. É uma ferramenta para facilitar o desenvolvimento, tem o conceito de UI orientada a servidor e entrega contínua. O Beagle permite que você manipule, através do backend, componentes nativos de sua aplicação, modifique os layout e a exibição desses componentes.\nÉ possível realizar testes em telas server driven? Sim! Testes unitários como testes instrumentados funcionam da mesma forma com o Beagle.\nPosso usar o Beagle em um aplicativo que já possui vários recursos desenvolvidos? Sim! Se a sua aplicação já tiver componentes desenvolvidos em um design system você poderá utilizá-los no Beagle. Para tal, basta somente que eles estejam definidos de maneira componentizada e ai serão facilmente registrados no Beagle.\nUm aplicativo que usa o Beagle precisa ser 100% Server Driven? Não, a aplicação pode utilizar uma tela Server Driven ​​em apenas alguns fluxos do aplicativo. Você pode continuar em um fluxo Server Driven ou voltar à tela nativa normalmente.\nPreciso usar o Beagle em todo o aplicativo? Não, a sua aplicação continua a mesma e ela pode ser utilizada nativamente mesmo com o Beagle registrado nela. Você pode usar o Beagle onde e quando quiser!\nMeu aplicativo funcionará offline? Depende. Toda aplicação Server Driven ao requisitar um fluxo do servidor precisa estar conectada a internet no momento da requisição para obter uma resposta do backend. Os fluxos Server Driven não podem ser resolvidos sem uma conexão. Mas a sua aplicação não é 100% Server Driven, a parte dela que não precisa coletar informações online funcionará normalmente. E pode até ser configurada para chamar outras telas caso esteja offline.\nE se a internet cair no meio do fluxo da aplicação? A maneira de lidar com casos de desconexão é criar telas declarativas locais para fallback.\nTerei problemas para fazer o upload do aplicativo com o Beagle na App Store ou na Play Store? Não! De maneira alguma. Todos os componentes utilizados estarão definidos na aplicação quando o upload para a loja for realizado. Embora o Beagle ofereça dinamismo ao lidar com as atualizações, essa qualidade está atrelada a manipulação do backend e não oferecemos nada na configuração do frontend que seja volúvel o suficiente para justificar algum tipo de bloqueio pela Apple ou Google ao atualizar um aplicativo na loja. Uma das principais propostas do Beagle é exatamente minimizar a necessidade de deploys na loja.\nTerei problemas de performance com o Beagle? Não, muito pelo contrário! Nós fizemos um benchmark de renderização com outras estratégias nativas - como Auto Layout (IOS) e o Constraint Layout (Android) - e o Beagle, usando o mecanismo Yoga Layout para posicionar elementos na tela, teve a melhor resposta.\nMinha aplicação não ficará mais lenta com os tempos de resposta do backend? Não, pois o Beagle usa o mecanismo de cache para armazenar as telas adjacentes à tela atual. Isso permite otimizar as chamadas para o backend e, portanto, não precisa solicitar novamente ao backend no momento do clique do usuário.\nQual a versão mais atual do Beagle? A versão mais atual do Beagle:undefined\nO Beagle é gratuito? Sim! Por ser um framework de desenvolvimento open source, o Beagle é totalmente gratuito.\nPosso criar um BFF em um linguagem diferente que não seja JVM? É possível criar um BFF em uma linguagem diferente. Porém, por enquanto não temos libs prontas para auxiliar neste processo. Por isso, é necessário que o programador crie algum mecanismo para que os contratos do Beagle sejam respeitados.\nQuais vantagens de usar o Beagle? Uma das principais vantagens do Beagle é facilitar o desenvolvimento a partir do paradigma BFF.\nIsso significa que o Beagle te permite modificar os layouts das telas da sua aplicação, os fluxos entre telas e a navegação na sua aplicação. Tudo isso é feito a partir de páginas criadas declarativamente no seu BFF que, a partir de uma biblioteca de componentes definidas no frontend da sua aplicação, auxilia na alteração da interface.\nCom isso, você pode:\n Decidir qual componente visual deve ser apresentado: quais textos, legendas ou qualquer outra informação visual que deva ser exibida, centralizada e abstraída no servidor.  Isso evita a replicação em cada plataforma frontend que consome essa API. O servidor aplica essa lógica de negócios e usa seus resultados para montar a resposta da API JSON representando-o.\n Fazer testes A/B para mudar a ordem em que os componentes são apresentados.  Posso usar o Beagle desenvolver aplicativos para Android, iOS ou Web? Sim! Por ser um framework cross-platform, Beagle te auxilia a desenvolver aplicações nestas três plataformas utilizando o conceito de Server-Driven UI, o que torna possível que um mesmo BFF seja utilizado para as 3 aplicações.\nVocê pode ver mais sobre como criar projetos no Beagle para as 3 plataformas em:\n Beagle for Android  Beagle for iOS Beagle for Web  Posso fazer testes unitários e instrumentados em telas Server-Driven? Sim! Testes unitários e instrumentais são realizados normalmente quando usamos o Beagle. A estrutura do Beagle não interfere em como os testes são realizados.\nComo fazer testes unitários usando Beagle? Testes unitários têm o objetivo de aferir a funcionalidade do código, em sua menor fração. Os testes em aplicações que utilizam o Beagle são feitos da mesma forma que em aplicações que não o utilizem. Isso significa que o Beagle não interfere de maneira alguma na realização dos testes.\nComo fazer testes instrumentados? Testes instrumentados são feitos em aplicações usando Beagle da mesma forma que em outras aplicações que não utilizam. No entanto, é importante salientar que, muitas vezes, um componente server-driven pode não conter um ID que geralmente a identifica em um teste instrumentado.\nPensando nisso, adicionamos ao elemento WIDGET (que referencia um componente) um atributo ID para que seja possível identificá-lo programaticamente.\n","excerpt":" O que é o Beagle? O Beagle é um Framework open source de …","ref":"/docs-beagle/pt/docs/faq/","title":"FAQ"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/release-notes/","title":"Release Notes"},{"body":"","excerpt":"","ref":"/docs-beagle/","title":"Beagle"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/","title":"Beagle"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/","title":"Documentation"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/","title":"Documentação"},{"body":"","excerpt":"","ref":"/docs-beagle/pt/docs/search/","title":"Resultado da Pesquisa"},{"body":"","excerpt":"","ref":"/docs-beagle/docs/search/","title":"Search Results"}]